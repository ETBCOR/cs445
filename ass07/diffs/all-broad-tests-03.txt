====================================
FILE: aamain2.c-
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 aamain2.c-
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 aamain2.c-.f21
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 aamain2.c-.f22
-rw-------. 1 corg7983 domain_users   71 Nov 17 15:35 aamain2.expected
-rw-------. 1 corg7983 domain_users   20 Nov 17 15:35 aamain2.in
-rw-------. 1 corg7983 domain_users  629 Nov 22 12:27 aamain2.mem
-rw-------. 1 corg7983 domain_users    0 Nov 17 15:35 aamain2.mem.diffs
-rw-------. 1 corg7983 domain_users 1470 Nov 17 15:35 aamain2.mem.f21
-rw-------. 1 corg7983 domain_users  167 Nov 22 12:27 aamain2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 aamain2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 aamain2.tm.diffs
-rw-------. 1 corg7983 domain_users 4834 Nov 17 15:35 aamain2.tm.f21
TM CODE COMPARISON
aamain2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  aamain2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,666(6)	Load integer constant 
												   >	 42:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 43:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 47:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 48:    LDC  3,1(6)	Load Boolean constant 
												   >	 49:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 50:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-36(7)	CALL outputb
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 54:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 55:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-24(7)	CALL outnl
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL input
												   >	 59:     ST  1,-2(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end input
												   >	 60:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-62(7)	CALL input
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL inputb
												   >	 64:     ST  1,-2(1)	Store fp in ghost frame for inputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end inputb
												   >	 65:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 66:    LDA  3,1(7)	Return address in ac 
												   >	 67:    JMP  7,-56(7)	CALL inputb
												   >	 68:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputb
												   >	* TOFF set: -2
												   >	* RETURN
												   >	 69:     LD  3,-1(1)	Load return address 
												   >	 70:     LD  1,0(1)	Adjust fp 
												   >	 71:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 72:    LDC  2,0(6)	Set return value to 0 
												   >	 73:     LD  3,-1(1)	Load return address 
												   >	 74:     LD  1,0(1)	Adjust fp 
												   >	 75:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,75(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 76:    LDA  1,0(0)	set first frame at end of globals 
												   >	 77:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-41(7)	Jump to main 
												   >	 80:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
aamain2.mem aamain2.mem.f21 differ: byte 7, line 1
aamain2 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Const 666 of type int [line: 3]							.   .   .   Child: 0  Const 666 of type int [line: 3]
.   .   Sibling: 1  Call: outputb of type void [line: 4]						.   .   Sibling: 1  Call: outputb of type void [line: 4]
.   .   .   Child: 0  Const true of type bool [line: 4]							.   .   .   Child: 0  Const true of type bool [line: 4]
.   .   Sibling: 2  Call: outnl of type void [line: 5]							.   .   Sibling: 2  Call: outnl of type void [line: 5]
.   .   Sibling: 3  Call: input of type int [line: 6]							.   .   Sibling: 3  Call: input of type int [line: 6]
.   .   Sibling: 4  Call: inputb of type bool [line: 7]							.   .   Sibling: 4  Call: inputb of type bool [line: 7]
.   .   Sibling: 5  Return [line: 9]									.   .   Sibling: 5  Return [line: 9]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
aamain2.out ztmp23114.txt differ: byte 1, line 1
aamain2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/aamain2.tm
Number of errors: 0										   |	666 T
------------------------------------								   |	entered: 496
Loading file: aamain2.tm									   |	entered: T
ERROR: TM Command 4 unknown.									   <
ERROR: TM Command T unknown.									   <
Bye.													Bye.
====================================
FILE: array0.c-
-rw-------. 1 corg7983 domain_users   525 Nov 17 15:35 array0.c-
-rw-------. 1 corg7983 domain_users   527 Nov 17 15:35 array0.c-.f21
-rw-------. 1 corg7983 domain_users   525 Nov 17 15:35 array0.c-.f22
-rw-------. 1 corg7983 domain_users    88 Nov 17 15:35 array0.expected
-rw-------. 1 corg7983 domain_users  5492 Nov 22 12:27 array0.mem
-rw-------. 1 corg7983 domain_users   238 Nov 17 15:35 array0.mem.diffs
-rw-------. 1 corg7983 domain_users  6335 Nov 17 15:35 array0.mem.f21
-rw-------. 1 corg7983 domain_users   108 Nov 22 12:27 array0.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 array0.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 array0.tm.diffs
-rw-------. 1 corg7983 domain_users 15056 Nov 17 15:35 array0.tm.f21
TM CODE COMPARISON
array0 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  array0.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION show
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load address of base of array z
												   >	 42:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 43:     LD  3,-3(1)	Load variable n
												   >	* TOFF inc: -6
												   >	 44:     LD  4,-6(1)	Pop left into ac1 
												   >	 45:    SUB  3,4,3	compute location from index 
												   >	 46:     LD  3,0(3)	Load array element 
												   >	 47:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 48:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 49:    LDA  3,1(7)	Return address in ac 
												   >	 50:    JMP  7,-45(7)	CALL output
												   >	 51:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* RETURN
												   >	 52:     LD  3,-2(1)	Load address of base of array z
												   >	 53:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 54:     LD  3,-3(1)	Load variable n
												   >	* TOFF inc: -4
												   >	 55:     LD  4,-4(1)	Pop left into ac1 
												   >	 56:    SUB  3,4,3	compute location from index 
												   >	 57:     LD  3,0(3)	Load array element 
												   >	 58:    LDA  2,0(3)	Copy result to return register 
												   >	 59:     LD  3,-1(1)	Load return address 
												   >	 60:     LD  1,0(1)	Adjust fp 
												   >	 61:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 62:    LDC  2,0(6)	Set return value to 0 
												   >	 63:     LD  3,-1(1)	Load return address 
												   >	 64:     LD  1,0(1)	Adjust fp 
												   >	 65:    JMP  7,0(3)	Return 
												   >	* END FUNCTION show
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 66:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	 67:    LDC  3,4(6)	load size of array a
												   >	 68:     ST  3,-2(1)	save size of array a
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 69:    LDC  3,1(6)	Load integer constant 
												   >	 70:     ST  3,-7(1)	Push index 
												   >	* TOFF dec: -8
												   >	 71:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 72:     LD  4,-7(1)	Pop index 
												   >	 73:    LDA  5,-1(0)	Load address of base of array g
												   >	 74:    SUB  5,5,4	Compute offset of value 
												   >	 75:     ST  3,0(5)	Store variable g
												   >	* EXPRESSION
												   >	 76:    LDC  3,1(6)	Load integer constant 
												   >	 77:     ST  3,-7(1)	Push index 
												   >	* TOFF dec: -8
												   >	 78:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 79:     LD  4,-7(1)	Pop index 
												   >	 80:    LDA  5,-3(1)	Load address of base of array a
												   >	 81:    SUB  5,5,4	Compute offset of value 
												   >	 82:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	 83:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 84:    LDA  3,-3(1)	Load address of base of array a
												   >	 85:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 86:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	 87:     LD  4,-9(1)	Pop left into ac1 
												   >	 88:    SUB  3,4,3	compute location from index 
												   >	 89:     LD  3,0(3)	Load array element 
												   >	 90:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 91:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 92:    LDA  3,1(7)	Return address in ac 
												   >	 93:    JMP  7,-88(7)	CALL output
												   >	 94:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	 95:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 96:    LDA  3,-1(0)	Load address of base of array g
												   >	 97:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 98:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	 99:     LD  4,-9(1)	Pop left into ac1 
												   >	100:    SUB  3,4,3	compute location from index 
												   >	101:     LD  3,0(3)	Load array element 
												   >	102:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	103:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	104:    LDA  3,1(7)	Return address in ac 
												   >	105:    JMP  7,-100(7)	CALL output
												   >	106:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	107:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	108:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-77(7)	CALL outnl
												   >	111:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL show
												   >	112:     ST  1,-7(1)	Store fp in ghost frame for show
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	113:    LDA  3,-3(1)	Load address of base of array a
												   >	114:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	115:    LDC  3,1(6)	Load integer constant 
												   >	116:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end show
												   >	117:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	118:    LDA  3,1(7)	Return address in ac 
												   >	119:    JMP  7,-81(7)	CALL show
												   >	120:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end show
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL show
												   >	121:     ST  1,-7(1)	Store fp in ghost frame for show
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	122:    LDA  3,-1(0)	Load address of base of array g
												   >	123:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	124:    LDC  3,1(6)	Load integer constant 
												   >	125:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end show
												   >	126:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-90(7)	CALL show
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end show
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	130:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	131:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	132:    LDA  3,1(7)	Return address in ac 
												   >	133:    JMP  7,-100(7)	CALL outnl
												   >	134:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	135:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	* CALL show
												   >	136:     ST  1,-9(1)	Store fp in ghost frame for show
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	137:    LDA  3,-3(1)	Load address of base of array a
												   >	138:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	139:    LDC  3,1(6)	Load integer constant 
												   >	140:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end show
												   >	141:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	142:    LDA  3,1(7)	Return address in ac 
												   >	143:    JMP  7,-105(7)	CALL show
												   >	144:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end show
												   >	* TOFF set: -9
												   >	145:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	146:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	147:    LDA  3,1(7)	Return address in ac 
												   >	148:    JMP  7,-143(7)	CALL output
												   >	149:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	150:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	* CALL show
												   >	151:     ST  1,-9(1)	Store fp in ghost frame for show
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	152:    LDA  3,-1(0)	Load address of base of array g
												   >	153:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	154:    LDC  3,1(6)	Load integer constant 
												   >	155:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end show
												   >	156:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	157:    LDA  3,1(7)	Return address in ac 
												   >	158:    JMP  7,-120(7)	CALL show
												   >	159:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end show
												   >	* TOFF set: -9
												   >	160:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	161:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	162:    LDA  3,1(7)	Return address in ac 
												   >	163:    JMP  7,-158(7)	CALL output
												   >	164:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	165:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	166:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	167:    LDA  3,1(7)	Return address in ac 
												   >	168:    JMP  7,-135(7)	CALL outnl
												   >	169:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	170:    LDC  3,1(6)	Load integer constant 
												   >	171:     ST  3,-7(1)	Push index 
												   >	* TOFF dec: -8
												   >	172:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	173:     LD  4,-7(1)	Pop index 
												   >	174:    LDA  5,-1(0)	Load address of base of array g
												   >	175:    SUB  5,5,4	Compute offset of value 
												   >	176:     LD  4,0(5)	load lhs variable g
												   >	177:    ADD  3,4,3	op += 
												   >	178:     ST  3,0(5)	Store variable g
												   >	* EXPRESSION
												   >	179:    LDC  3,1(6)	Load integer constant 
												   >	180:     ST  3,-7(1)	Push index 
												   >	* TOFF dec: -8
												   >	181:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	182:     LD  4,-7(1)	Pop index 
												   >	183:    LDA  5,-3(1)	Load address of base of array a
												   >	184:    SUB  5,5,4	Compute offset of value 
												   >	185:     LD  4,0(5)	load lhs variable a
												   >	186:    ADD  3,4,3	op += 
												   >	187:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	188:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	189:    LDA  3,-3(1)	Load address of base of array a
												   >	190:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	191:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	192:     LD  4,-9(1)	Pop left into ac1 
												   >	193:    SUB  3,4,3	compute location from index 
												   >	194:     LD  3,0(3)	Load array element 
												   >	195:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	196:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	197:    LDA  3,1(7)	Return address in ac 
												   >	198:    JMP  7,-193(7)	CALL output
												   >	199:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	200:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	201:    LDA  3,-1(0)	Load address of base of array g
												   >	202:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	203:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	204:     LD  4,-9(1)	Pop left into ac1 
												   >	205:    SUB  3,4,3	compute location from index 
												   >	206:     LD  3,0(3)	Load array element 
												   >	207:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	208:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-205(7)	CALL output
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	212:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	213:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	214:    LDA  3,1(7)	Return address in ac 
												   >	215:    JMP  7,-182(7)	CALL outnl
												   >	216:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	217:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	218:    LDC  3,1(6)	Load integer constant 
												   >	219:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	220:    LDC  3,100(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	221:     LD  4,-9(1)	Pop index 
												   >	222:    LDA  5,-3(1)	Load address of base of array a
												   >	223:    SUB  5,5,4	Compute offset of value 
												   >	224:     LD  4,0(5)	load lhs variable a
												   >	225:    ADD  3,4,3	op += 
												   >	226:     ST  3,0(5)	Store variable a
												   >	227:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	228:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	229:    LDA  3,1(7)	Return address in ac 
												   >	230:    JMP  7,-225(7)	CALL output
												   >	231:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	232:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	233:    LDC  3,1(6)	Load integer constant 
												   >	234:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	235:    LDC  3,100(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	236:     LD  4,-9(1)	Pop index 
												   >	237:    LDA  5,-1(0)	Load address of base of array g
												   >	238:    SUB  5,5,4	Compute offset of value 
												   >	239:     LD  4,0(5)	load lhs variable g
												   >	240:    ADD  3,4,3	op += 
												   >	241:     ST  3,0(5)	Store variable g
												   >	242:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	243:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	244:    LDA  3,1(7)	Return address in ac 
												   >	245:    JMP  7,-240(7)	CALL output
												   >	246:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	247:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	248:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	249:    LDA  3,1(7)	Return address in ac 
												   >	250:    JMP  7,-217(7)	CALL outnl
												   >	251:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	252:    LDC  2,0(6)	Set return value to 0 
												   >	253:     LD  3,-1(1)	Load return address 
												   >	254:     LD  1,0(1)	Adjust fp 
												   >	255:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,255(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	256:    LDA  1,-5(0)	set first frame at end of globals 
												   >	257:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	258:    LDC  3,4(6)	load size of array g
												   >	259:     ST  3,0(0)	save size of array g
												   >	* END INIT GLOBALS AND STATICS
												   >	260:    LDA  3,1(7)	Return address in ac 
												   >	261:    JMP  7,-196(7)	Jump to main 
												   >	262:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
array0.mem array0.mem.f21 differ: byte 1, line 1
array0 (MEM DIFF)
Var: g of array of type int [mem: Global loc: -1 size: 5] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: show returns type int [mem: Global loc: 0 size: -4] [line: 2]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of array of type int [mem: Global loc: -1 size: 5] [line: 1]
												   >	Sibling: 8  Func: show returns type int [mem: Global loc: 0 size: -4] [line: 2]
.   Child: 0  Parm: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 2]			.   Child: 0  Parm: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Sibling: 1  Parm: n of type int [mem: Parameter loc: -3 size: 1] [line: 2]				.   Sibling: 1  Parm: n of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]
.   .   Child: 1  Call: output of type void [line: 4]							.   .   Child: 1  Call: output of type void [line: 4]
.   .   .   Child: 0  Op: [ of type int [line: 4]							.   .   .   Child: 0  Op: [ of type int [line: 4]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -3 size: 1] [line: 4]			.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -3 size: 1] [line: 4]
.   .   Sibling: 1  Return [line: 5]									.   .   Sibling: 1  Return [line: 5]
.   .   .   Child: 0  Op: [ of type int [line: 5]							.   .   .   Child: 0  Op: [ of type int [line: 5]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -3 size: 1] [line: 5]			.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -3 size: 1] [line: 5]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 8]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 8]
.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 9]						.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 9]
.   .   Child: 0  Var: a of array of type int [mem: Local loc: -3 size: 5] [line: 10]			.   .   Child: 0  Var: a of array of type int [mem: Local loc: -3 size: 5] [line: 10]
.   .   Child: 1  Assign: = of type int [line: 12]						   |	.   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   Child: 0  Op: [ of type int [line: 12]							.   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 12]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 12]
.   .   .   .   Child: 1  Const 1 of type int [line: 12]						.   .   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   .   Child: 1  Const 666 of type int [line: 12]							.   .   .   Child: 1  Const 666 of type int [line: 12]
.   .   Sibling: 1  Assign: = of type int [line: 13]						   |	.   .   Sibling: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 13]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 13]
.   .   .   .   Child: 1  Const 1 of type int [line: 13]						.   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   .   Child: 1  Const 777 of type int [line: 13]							.   .   .   Child: 1  Const 777 of type int [line: 13]
.   .   Sibling: 2  Call: output of type void [line: 15]						.   .   Sibling: 2  Call: output of type void [line: 15]
.   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 15]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 15]
.   .   .   .   Child: 1  Const 1 of type int [line: 15]						.   .   .   .   Child: 1  Const 1 of type int [line: 15]
.   .   Sibling: 3  Call: output of type void [line: 16]						.   .   Sibling: 3  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 16]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 16]
.   .   .   .   Child: 1  Const 1 of type int [line: 16]						.   .   .   .   Child: 1  Const 1 of type int [line: 16]
.   .   Sibling: 4  Call: outnl of type void [line: 17]							.   .   Sibling: 4  Call: outnl of type void [line: 17]
.   .   Sibling: 5  Call: show of type int [line: 19]							.   .   Sibling: 5  Call: show of type int [line: 19]
.   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 19]		.   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 19]
.   .   .   Sibling: 1  Const 1 of type int [line: 19]							.   .   .   Sibling: 1  Const 1 of type int [line: 19]
.   .   Sibling: 6  Call: show of type int [line: 20]							.   .   Sibling: 6  Call: show of type int [line: 20]
.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 20]		.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 20]
.   .   .   Sibling: 1  Const 1 of type int [line: 20]							.   .   .   Sibling: 1  Const 1 of type int [line: 20]
.   .   Sibling: 7  Call: outnl of type void [line: 21]							.   .   Sibling: 7  Call: outnl of type void [line: 21]
.   .   Sibling: 8  Call: output of type void [line: 23]						.   .   Sibling: 8  Call: output of type void [line: 23]
.   .   .   Child: 0  Call: show of type int [line: 23]							.   .   .   Child: 0  Call: show of type int [line: 23]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 23]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 23]
.   .   .   .   Sibling: 1  Const 1 of type int [line: 23]						.   .   .   .   Sibling: 1  Const 1 of type int [line: 23]
.   .   Sibling: 9  Call: output of type void [line: 24]						.   .   Sibling: 9  Call: output of type void [line: 24]
.   .   .   Child: 0  Call: show of type int [line: 24]							.   .   .   Child: 0  Call: show of type int [line: 24]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 24]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 24]
.   .   .   .   Sibling: 1  Const 1 of type int [line: 24]						.   .   .   .   Sibling: 1  Const 1 of type int [line: 24]
.   .   Sibling: 10  Call: outnl of type void [line: 25]						.   .   Sibling: 10  Call: outnl of type void [line: 25]
.   .   Sibling: 11  Assign: += of type int [line: 27]							.   .   Sibling: 11  Assign: += of type int [line: 27]
.   .   .   Child: 0  Op: [ of type int [line: 27]							.   .   .   Child: 0  Op: [ of type int [line: 27]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 27]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 27]
.   .   .   .   Child: 1  Const 1 of type int [line: 27]						.   .   .   .   Child: 1  Const 1 of type int [line: 27]
.   .   .   Child: 1  Const 4 of type int [line: 27]							.   .   .   Child: 1  Const 4 of type int [line: 27]
.   .   Sibling: 12  Assign: += of type int [line: 28]							.   .   Sibling: 12  Assign: += of type int [line: 28]
.   .   .   Child: 0  Op: [ of type int [line: 28]							.   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 28]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 28]
.   .   .   .   Child: 1  Const 1 of type int [line: 28]						.   .   .   .   Child: 1  Const 1 of type int [line: 28]
.   .   .   Child: 1  Const 3 of type int [line: 28]							.   .   .   Child: 1  Const 3 of type int [line: 28]
.   .   Sibling: 13  Call: output of type void [line: 30]						.   .   Sibling: 13  Call: output of type void [line: 30]
.   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 30]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 30]
.   .   .   .   Child: 1  Const 1 of type int [line: 30]						.   .   .   .   Child: 1  Const 1 of type int [line: 30]
.   .   Sibling: 14  Call: output of type void [line: 31]						.   .   Sibling: 14  Call: output of type void [line: 31]
.   .   .   Child: 0  Op: [ of type int [line: 31]							.   .   .   Child: 0  Op: [ of type int [line: 31]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 31]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 31]
.   .   .   .   Child: 1  Const 1 of type int [line: 31]						.   .   .   .   Child: 1  Const 1 of type int [line: 31]
.   .   Sibling: 15  Call: outnl of type void [line: 32]						.   .   Sibling: 15  Call: outnl of type void [line: 32]
.   .   Sibling: 16  Call: output of type void [line: 34]						.   .   Sibling: 16  Call: output of type void [line: 34]
.   .   .   Child: 0  Assign: += of type int [line: 34]							.   .   .   Child: 0  Assign: += of type int [line: 34]
.   .   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 34]	.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -3 size: 5] [line: 34]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 34]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 34]
.   .   .   .   Child: 1  Const 100 of type int [line: 34]						.   .   .   .   Child: 1  Const 100 of type int [line: 34]
.   .   Sibling: 17  Call: output of type void [line: 35]						.   .   Sibling: 17  Call: output of type void [line: 35]
.   .   .   Child: 0  Assign: += of type int [line: 35]							.   .   .   Child: 0  Assign: += of type int [line: 35]
.   .   .   .   Child: 0  Op: [ of type int [line: 35]							.   .   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 35	.   .   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 5] [line: 35
.   .   .   .   .   Child: 1  Const 1 of type int [line: 35]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 35]
.   .   .   .   Child: 1  Const 100 of type int [line: 35]						.   .   .   .   Child: 1  Const 100 of type int [line: 35]
.   .   Sibling: 18  Call: outnl of type void [line: 36]						.   .   Sibling: 18  Call: outnl of type void [line: 36]
Offset for end of global space: -5									Offset for end of global space: -5
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
array0.out ztmp23114.txt differ: byte 1, line 1
array0 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/array0.tm
Number of errors: 0										   |	777 666
------------------------------------								   |	777 666
Loading file: array0.tm										   |	777 777 666 666
												   >	780 670
												   >	880 770
Bye.													Bye.
====================================
FILE: array1.c-
-rw-------. 1 corg7983 domain_users  209 Nov 17 15:35 array1.c-
-rw-------. 1 corg7983 domain_users  212 Nov 17 15:35 array1.c-.f21
-rw-------. 1 corg7983 domain_users  209 Nov 17 15:35 array1.c-.f22
-rw-------. 1 corg7983 domain_users   96 Nov 17 15:35 array1.expected
-rw-------. 1 corg7983 domain_users 2516 Nov 22 12:27 array1.mem
-rw-------. 1 corg7983 domain_users  355 Nov 17 15:35 array1.mem.diffs
-rw-------. 1 corg7983 domain_users 3360 Nov 17 15:35 array1.mem.f21
-rw-------. 1 corg7983 domain_users  160 Nov 22 12:27 array1.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 array1.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 array1.tm.diffs
-rw-------. 1 corg7983 domain_users 6361 Nov 17 15:35 array1.tm.f21
TM CODE COMPARISON
array1 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  array1.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION ford
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -27
												   >	 40:    LDC  3,22(6)	load size of array z
												   >	 41:     ST  3,-4(1)	save size of array z
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:     LD  3,-2(1)	Load address of base of array x
												   >	 43:     LD  3,1(3)	Load array size 
												   >	* EXPRESSION
												   >	 44:    LDC  3,11(6)	Load integer constant 
												   >	 45:     ST  3,-27(1)	Push index 
												   >	* TOFF dec: -28
												   >	 46:     LD  3,-2(1)	Load address of base of array x
												   >	 47:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	 48:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	 49:     LD  4,-28(1)	Pop left into ac1 
												   >	 50:    SUB  3,4,3	compute location from index 
												   >	 51:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -27
												   >	 52:     LD  4,-27(1)	Pop index 
												   >	 53:    LDA  5,-5(1)	Load address of base of array z
												   >	 54:    SUB  5,5,4	Compute offset of value 
												   >	 55:     ST  3,0(5)	Store variable z
												   >	* EXPRESSION
												   >	 56:    LDC  3,3(6)	Load integer constant 
												   >	 57:     ST  3,-27(1)	Push index 
												   >	* TOFF dec: -28
												   >	 58:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -27
												   >	 59:     LD  4,-27(1)	Pop index 
												   >	 60:     LD  5,-2(1)	Load address of base of array x
												   >	 61:    SUB  5,5,4	Compute offset of value 
												   >	 62:     ST  3,0(5)	Store variable x
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 63:    LDC  2,0(6)	Set return value to 0 
												   >	 64:     LD  3,-1(1)	Load return address 
												   >	 65:     LD  1,0(1)	Adjust fp 
												   >	 66:    JMP  7,0(3)	Return 
												   >	* END FUNCTION ford
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 67:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -36
												   >	 68:    LDC  3,33(6)	load size of array y
												   >	 69:     ST  3,-2(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 70:    LDC  3,3(6)	Load integer constant 
												   >	 71:     ST  3,-36(1)	Push index 
												   >	* TOFF dec: -37
												   >	 72:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -36
												   >	 73:     LD  4,-36(1)	Pop index 
												   >	 74:    LDA  5,-3(1)	Load address of base of array y
												   >	 75:    SUB  5,5,4	Compute offset of value 
												   >	 76:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL ford
												   >	 77:     ST  1,-36(1)	Store fp in ghost frame for ford
												   >	* TOFF dec: -37
												   >	* TOFF dec: -38
												   >	* Param 1
												   >	 78:    LDA  3,-3(1)	Load address of base of array y
												   >	 79:     ST  3,-38(1)	Push parameter 
												   >	* TOFF dec: -39
												   >	* Param 2
												   >	 80:    LDA  3,-3(1)	Load address of base of array y
												   >	 81:     ST  3,-39(1)	Push parameter 
												   >	* TOFF dec: -40
												   >	* Param end ford
												   >	 82:    LDA  1,-36(1)	Ghost frame becomes new active frame 
												   >	 83:    LDA  3,1(7)	Return address in ac 
												   >	 84:    JMP  7,-46(7)	CALL ford
												   >	 85:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ford
												   >	* TOFF set: -36
												   >	* EXPRESSION
												   >	* CALL output
												   >	 86:     ST  1,-36(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -37
												   >	* TOFF dec: -38
												   >	* Param 1
												   >	 87:    LDA  3,-3(1)	Load address of base of array y
												   >	 88:     ST  3,-38(1)	Push left side 
												   >	* TOFF dec: -39
												   >	 89:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -38
												   >	 90:     LD  4,-38(1)	Pop left into ac1 
												   >	 91:    SUB  3,4,3	compute location from index 
												   >	 92:     LD  3,0(3)	Load array element 
												   >	 93:     ST  3,-38(1)	Push parameter 
												   >	* TOFF dec: -39
												   >	* Param end output
												   >	 94:    LDA  1,-36(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-91(7)	CALL output
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -36
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 98:     ST  1,-36(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -37
												   >	* TOFF dec: -38
												   >	* Param end outnl
												   >	 99:    LDA  1,-36(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-68(7)	CALL outnl
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -36
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	103:    LDC  2,0(6)	Set return value to 0 
												   >	104:     LD  3,-1(1)	Load return address 
												   >	105:     LD  1,0(1)	Adjust fp 
												   >	106:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,106(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	107:    LDA  1,0(0)	set first frame at end of globals 
												   >	108:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-44(7)	Jump to main 
												   >	111:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
array1.mem array1.mem.f21 differ: byte 59, line 2
array1 (MEM DIFF)
WARNING(1): The parameter 'y' seems not to be used.							WARNING(1): The parameter 'y' seems not to be used.
Func: ford returns type void [mem: Global loc: 0 size: -4] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: ford returns type void [mem: Global loc: 0 size: -4] [line: 1]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Sibling: 1  Parm: y of array of type int [mem: Parameter loc: -3 size: 1] [line: 1]			.   Sibling: 1  Parm: y of array of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -27] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -27] [line: 2]
.   .   Child: 0  Var: z of array of type int [mem: Local loc: -5 size: 23] [line: 3]			.   .   Child: 0  Var: z of array of type int [mem: Local loc: -5 size: 23] [line: 3]
.   .   Child: 1  Op: sizeof of type int [line: 5]							.   .   Child: 1  Op: sizeof of type int [line: 5]
.   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Assign: = of type int [line: 6]						   |	.   .   Sibling: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -5 size: 23] [line: 6]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -5 size: 23] [line: 6]
.   .   .   .   Child: 1  Const 11 of type int [line: 6]						.   .   .   .   Child: 1  Const 11 of type int [line: 6]
.   .   .   Child: 1  Op: [ of type int [line: 6]							.   .   .   Child: 1  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 3 of type int [line: 6]							.   .   .   .   Child: 1  Const 3 of type int [line: 6]
.   .   Sibling: 2  Assign: = of type int [line: 7]						   |	.   .   Sibling: 2  Assign: := of type int [line: 7]
.   .   .   Child: 0  Op: [ of type int [line: 7]							.   .   .   Child: 0  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 3 of type int [line: 7]							.   .   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   .   Child: 1  Const 777 of type int [line: 7]							.   .   .   Child: 1  Const 777 of type int [line: 7]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 10]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -36] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -36] [line: 11]
.   .   Child: 0  Var: y of array of type int [mem: Local loc: -3 size: 34] [line: 12]			.   .   Child: 0  Var: y of array of type int [mem: Local loc: -3 size: 34] [line: 12]
.   .   Child: 1  Assign: = of type int [line: 14]						   |	.   .   Child: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 14]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 14]
.   .   .   .   Child: 1  Const 3 of type int [line: 14]						.   .   .   .   Child: 1  Const 3 of type int [line: 14]
.   .   .   Child: 1  Const 666 of type int [line: 14]							.   .   .   Child: 1  Const 666 of type int [line: 14]
.   .   Sibling: 1  Call: ford of type void [line: 15]							.   .   Sibling: 1  Call: ford of type void [line: 15]
.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 15]		.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 15]
.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 15]		.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 15]
.   .   Sibling: 2  Call: output of type void [line: 16]						.   .   Sibling: 2  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 16]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 34] [line: 16]
.   .   .   .   Child: 1  Const 3 of type int [line: 16]						.   .   .   .   Child: 1  Const 3 of type int [line: 16]
.   .   Sibling: 3  Call: outnl of type void [line: 17]							.   .   Sibling: 3  Call: outnl of type void [line: 17]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
array1.out ztmp23114.txt differ: byte 53, line 2
array1 (Output DIFF)
WARNING(1): The parameter 'y' seems not to be used.							WARNING(1): The parameter 'y' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/array1.tm
Number of errors: 0										   |	777
------------------------------------								   <
Loading file: array1.tm										   <
Bye.													Bye.
====================================
FILE: array2.c-
-rw-------. 1 corg7983 domain_users  195 Nov 17 15:35 array2.c-
-rw-------. 1 corg7983 domain_users  198 Nov 17 15:35 array2.c-.f21
-rw-------. 1 corg7983 domain_users  195 Nov 17 15:35 array2.c-.f22
-rw-------. 1 corg7983 domain_users   48 Nov 17 15:35 array2.expected
-rw-------. 1 corg7983 domain_users 2271 Nov 22 12:27 array2.mem
-rw-------. 1 corg7983 domain_users  351 Nov 17 15:35 array2.mem.diffs
-rw-------. 1 corg7983 domain_users 3115 Nov 17 15:35 array2.mem.f21
-rw-------. 1 corg7983 domain_users  108 Nov 22 12:27 array2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 array2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 array2.tm.diffs
-rw-------. 1 corg7983 domain_users 6198 Nov 17 15:35 array2.tm.f21
TM CODE COMPARISON
array2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  array2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION ford
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-2(1)	Load address of base of array x
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    SUB  3,4,3	compute location from index 
												   >	 45:     LD  3,0(3)	Load array element 
												   >	 46:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 47:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 48:     LD  3,-3(1)	Load variable y
												   >	 49:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 50:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-47(7)	CALL output
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 54:    LDC  3,3(6)	Load integer constant 
												   >	 55:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	 56:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 57:     LD  4,-4(1)	Pop index 
												   >	 58:     LD  5,-2(1)	Load address of base of array x
												   >	 59:    SUB  5,5,4	Compute offset of value 
												   >	 60:     ST  3,0(5)	Store variable x
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 61:    LDC  2,0(6)	Set return value to 0 
												   >	 62:     LD  3,-1(1)	Load return address 
												   >	 63:     LD  1,0(1)	Adjust fp 
												   >	 64:    JMP  7,0(3)	Return 
												   >	* END FUNCTION ford
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 65:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	 66:    LDC  3,5(6)	load size of array y
												   >	 67:     ST  3,-2(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 68:    LDC  3,3(6)	Load integer constant 
												   >	 69:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	 70:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 71:     LD  4,-8(1)	Pop index 
												   >	 72:    LDA  5,-3(1)	Load address of base of array y
												   >	 73:    SUB  5,5,4	Compute offset of value 
												   >	 74:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL ford
												   >	 75:     ST  1,-8(1)	Store fp in ghost frame for ford
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	 76:    LDA  3,-3(1)	Load address of base of array y
												   >	 77:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end ford
												   >	 78:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-42(7)	CALL ford
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ford
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	 82:    LDA  3,-3(1)	Load address of base of array y
												   >	 83:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 84:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 85:     LD  4,-8(1)	Pop left into ac1 
												   >	 86:    SUB  3,4,3	compute location from index 
												   >	 87:     LD  3,0(3)	Load array element 
												   >	* EXPRESSION
												   >	* CALL output
												   >	 88:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	 89:    LDA  3,-3(1)	Load address of base of array y
												   >	 90:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 91:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	 92:     LD  4,-10(1)	Pop left into ac1 
												   >	 93:    SUB  3,4,3	compute location from index 
												   >	 94:     LD  3,0(3)	Load array element 
												   >	 95:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	 96:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 97:    LDA  3,1(7)	Return address in ac 
												   >	 98:    JMP  7,-93(7)	CALL output
												   >	 99:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	100:    LDC  2,0(6)	Set return value to 0 
												   >	101:     LD  3,-1(1)	Load return address 
												   >	102:     LD  1,0(1)	Adjust fp 
												   >	103:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,103(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	104:    LDA  1,0(0)	set first frame at end of globals 
												   >	105:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	106:    LDA  3,1(7)	Return address in ac 
												   >	107:    JMP  7,-43(7)	Jump to main 
												   >	108:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
array2.mem array2.mem.f21 differ: byte 7, line 1
array2 (MEM DIFF)
Func: ford returns type void [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: ford returns type void [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]
.   .   Child: 0  Var: y of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Child: 0  Var: y of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 4]						   |	.   .   Child: 1  Assign: := of type int [line: 4]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   .   Child: 1  Op: [ of type int [line: 4]							.   .   .   Child: 1  Op: [ of type int [line: 4]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   .   .   Child: 1  Const 3 of type int [line: 4]							.   .   .   .   Child: 1  Const 3 of type int [line: 4]
.   .   Sibling: 1  Call: output of type void [line: 5]							.   .   Sibling: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Sibling: 2  Assign: = of type int [line: 6]						   |	.   .   Sibling: 2  Assign: := of type int [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 3 of type int [line: 6]							.   .   .   .   Child: 1  Const 3 of type int [line: 6]
.   .   .   Child: 1  Const 777 of type int [line: 6]							.   .   .   Child: 1  Const 777 of type int [line: 6]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 9]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 9]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 10]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 10]
.   .   Child: 0  Var: y of array of type int [mem: Local loc: -3 size: 6] [line: 11]			.   .   Child: 0  Var: y of array of type int [mem: Local loc: -3 size: 6] [line: 11]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 13]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 13]
.   .   .   .   Child: 1  Const 3 of type int [line: 13]						.   .   .   .   Child: 1  Const 3 of type int [line: 13]
.   .   .   Child: 1  Const 666 of type int [line: 13]							.   .   .   Child: 1  Const 666 of type int [line: 13]
.   .   Sibling: 1  Call: ford of type void [line: 14]							.   .   Sibling: 1  Call: ford of type void [line: 14]
.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 14]		.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 14]
.   .   Sibling: 2  Op: [ of type int [line: 15]							.   .   Sibling: 2  Op: [ of type int [line: 15]
.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 15]		.   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 15]
.   .   .   Child: 1  Const 3 of type int [line: 15]							.   .   .   Child: 1  Const 3 of type int [line: 15]
.   .   Sibling: 3  Call: output of type void [line: 16]						.   .   Sibling: 3  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 16]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -3 size: 6] [line: 16]
.   .   .   .   Child: 1  Const 3 of type int [line: 16]						.   .   .   .   Child: 1  Const 3 of type int [line: 16]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
array2.out ztmp23114.txt differ: byte 1, line 1
array2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/array2.tm
Number of errors: 0										   |	666 777
------------------------------------								   <
Loading file: array2.tm										   <
Bye.													Bye.
====================================
FILE: array.c-
-rw-------. 1 corg7983 domain_users   703 Nov 17 15:35 array.c-
-rw-------. 1 corg7983 domain_users   715 Nov 17 15:35 array.c-.f21
-rw-------. 1 corg7983 domain_users   703 Nov 17 15:35 array.c-.f22
-rw-------. 1 corg7983 domain_users    75 Nov 17 15:35 array.expected
-rw-------. 1 corg7983 domain_users  8936 Nov 22 12:27 array.mem
-rw-------. 1 corg7983 domain_users  1464 Nov 17 15:35 array.mem.diffs
-rw-------. 1 corg7983 domain_users  9789 Nov 17 15:35 array.mem.f21
-rw-------. 1 corg7983 domain_users   107 Nov 22 12:27 array.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 array.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 array.tm.diffs
-rw-------. 1 corg7983 domain_users 19086 Nov 17 15:35 array.tm.f21
TM CODE COMPARISON
array (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  array.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION get
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load address of base of array x
												   >	 42:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 43:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 44:     LD  4,-6(1)	Pop left into ac1 
												   >	 45:    SUB  3,4,3	compute location from index 
												   >	 46:     LD  3,0(3)	Load array element 
												   >	 47:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 48:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 49:    LDA  3,1(7)	Return address in ac 
												   >	 50:    JMP  7,-45(7)	CALL output
												   >	 51:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 52:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 53:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 54:    LDA  3,1(7)	Return address in ac 
												   >	 55:    JMP  7,-22(7)	CALL outnl
												   >	 56:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 57:    LDC  3,1(6)	Load integer constant 
												   >	 58:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	 59:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 60:     LD  4,-4(1)	Pop index 
												   >	 61:     LD  5,-2(1)	Load address of base of array x
												   >	 62:    SUB  5,5,4	Compute offset of value 
												   >	 63:     ST  3,0(5)	Store variable x
												   >	* RETURN
												   >	 64:     LD  3,-2(1)	Load address of base of array x
												   >	 65:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 66:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -4
												   >	 67:     LD  4,-4(1)	Pop left into ac1 
												   >	 68:    SUB  3,4,3	compute location from index 
												   >	 69:     LD  3,0(3)	Load array element 
												   >	 70:    LDA  2,0(3)	Copy result to return register 
												   >	 71:     LD  3,-1(1)	Load return address 
												   >	 72:     LD  1,0(1)	Adjust fp 
												   >	 73:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 74:    LDC  2,0(6)	Set return value to 0 
												   >	 75:     LD  3,-1(1)	Load return address 
												   >	 76:     LD  1,0(1)	Adjust fp 
												   >	 77:    JMP  7,0(3)	Return 
												   >	* END FUNCTION get
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 78:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	 79:    LDC  3,5(6)	load size of array x
												   >	 80:     ST  3,-2(1)	save size of array x
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 81:    LDC  3,2(6)	Load integer constant 
												   >	 82:     ST  3,-8(1)	Store variable dog
												   >	* EXPRESSION
												   >	 83:    LDC  3,0(6)	Load integer constant 
												   >	 84:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	 85:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	 86:     LD  4,-9(1)	Pop index 
												   >	 87:    LDA  5,-3(1)	Load address of base of array x
												   >	 88:    SUB  5,5,4	Compute offset of value 
												   >	 89:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 90:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	 91:    LDA  3,-3(1)	Load address of base of array x
												   >	 92:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 93:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	 94:     LD  4,-11(1)	Pop left into ac1 
												   >	 95:    SUB  3,4,3	compute location from index 
												   >	 96:     LD  3,0(3)	Load array element 
												   >	 97:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	 98:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-95(7)	CALL output
												   >	101:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	102:    LDC  3,1(6)	Load integer constant 
												   >	103:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	104:    LDA  3,-3(1)	Load address of base of array x
												   >	105:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	106:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	107:     LD  4,-10(1)	Pop left into ac1 
												   >	108:    SUB  3,4,3	compute location from index 
												   >	109:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -9
												   >	110:     LD  4,-9(1)	Pop index 
												   >	111:    LDA  5,-3(1)	Load address of base of array x
												   >	112:    SUB  5,5,4	Compute offset of value 
												   >	113:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	114:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	115:    LDA  3,-3(1)	Load address of base of array x
												   >	116:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	117:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	118:     LD  4,-11(1)	Pop left into ac1 
												   >	119:    SUB  3,4,3	compute location from index 
												   >	120:     LD  3,0(3)	Load array element 
												   >	121:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	122:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	123:    LDA  3,1(7)	Return address in ac 
												   >	124:    JMP  7,-119(7)	CALL output
												   >	125:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	126:    LDC  3,2(6)	Load integer constant 
												   >	127:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	128:    LDA  3,-3(1)	Load address of base of array x
												   >	129:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	130:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	131:     LD  4,-10(1)	Pop left into ac1 
												   >	132:    SUB  3,4,3	compute location from index 
												   >	133:     LD  3,0(3)	Load array element 
												   >	134:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	135:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	136:     LD  4,-10(1)	Pop left into ac1 
												   >	137:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -9
												   >	138:     LD  4,-9(1)	Pop index 
												   >	139:    LDA  5,-3(1)	Load address of base of array x
												   >	140:    SUB  5,5,4	Compute offset of value 
												   >	141:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	142:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	143:    LDA  3,-3(1)	Load address of base of array x
												   >	144:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	145:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	146:     LD  4,-11(1)	Pop left into ac1 
												   >	147:    SUB  3,4,3	compute location from index 
												   >	148:     LD  3,0(3)	Load array element 
												   >	149:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	150:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-147(7)	CALL output
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	154:     LD  3,-8(1)	Load variable dog
												   >	155:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	156:     LD  3,-8(1)	Load variable dog
												   >	* TOFF inc: -9
												   >	157:     LD  4,-9(1)	Pop left into ac1 
												   >	158:    ADD  3,4,3	Op + 
												   >	159:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	160:    LDC  3,496(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	161:     LD  4,-9(1)	Pop index 
												   >	162:    LDA  5,-3(1)	Load address of base of array x
												   >	163:    SUB  5,5,4	Compute offset of value 
												   >	164:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	165:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	166:    LDA  3,-3(1)	Load address of base of array x
												   >	167:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	168:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	169:     LD  4,-11(1)	Pop left into ac1 
												   >	170:    SUB  3,4,3	compute location from index 
												   >	171:     LD  3,0(3)	Load array element 
												   >	172:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	173:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-170(7)	CALL output
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	177:     ST  1,-9(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param end outnl
												   >	178:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	179:    LDA  3,1(7)	Return address in ac 
												   >	180:    JMP  7,-147(7)	CALL outnl
												   >	181:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	182:    LDC  3,2(6)	Load integer constant 
												   >	183:     ST  3,-8(1)	Store variable dog
												   >	* EXPRESSION
												   >	184:    LDC  3,0(6)	Load integer constant 
												   >	185:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	186:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	187:     LD  4,-9(1)	Pop index 
												   >	188:    LDA  5,-1(0)	Load address of base of array y
												   >	189:    SUB  5,5,4	Compute offset of value 
												   >	190:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	191:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	192:    LDA  3,-1(0)	Load address of base of array y
												   >	193:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	194:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	195:     LD  4,-11(1)	Pop left into ac1 
												   >	196:    SUB  3,4,3	compute location from index 
												   >	197:     LD  3,0(3)	Load array element 
												   >	198:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	199:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-196(7)	CALL output
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	203:    LDC  3,1(6)	Load integer constant 
												   >	204:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	205:    LDA  3,-1(0)	Load address of base of array y
												   >	206:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	207:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	208:     LD  4,-10(1)	Pop left into ac1 
												   >	209:    SUB  3,4,3	compute location from index 
												   >	210:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -9
												   >	211:     LD  4,-9(1)	Pop index 
												   >	212:    LDA  5,-1(0)	Load address of base of array y
												   >	213:    SUB  5,5,4	Compute offset of value 
												   >	214:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	215:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	216:    LDA  3,-1(0)	Load address of base of array y
												   >	217:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	218:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	219:     LD  4,-11(1)	Pop left into ac1 
												   >	220:    SUB  3,4,3	compute location from index 
												   >	221:     LD  3,0(3)	Load array element 
												   >	222:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	223:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	224:    LDA  3,1(7)	Return address in ac 
												   >	225:    JMP  7,-220(7)	CALL output
												   >	226:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	227:    LDC  3,2(6)	Load integer constant 
												   >	228:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	229:    LDA  3,-1(0)	Load address of base of array y
												   >	230:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	231:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	232:     LD  4,-10(1)	Pop left into ac1 
												   >	233:    SUB  3,4,3	compute location from index 
												   >	234:     LD  3,0(3)	Load array element 
												   >	235:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	236:    LDC  3,311(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	237:     LD  4,-10(1)	Pop left into ac1 
												   >	238:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -9
												   >	239:     LD  4,-9(1)	Pop index 
												   >	240:    LDA  5,-1(0)	Load address of base of array y
												   >	241:    SUB  5,5,4	Compute offset of value 
												   >	242:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	243:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	244:    LDA  3,-1(0)	Load address of base of array y
												   >	245:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	246:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	247:     LD  4,-11(1)	Pop left into ac1 
												   >	248:    SUB  3,4,3	compute location from index 
												   >	249:     LD  3,0(3)	Load array element 
												   >	250:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	251:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	252:    LDA  3,1(7)	Return address in ac 
												   >	253:    JMP  7,-248(7)	CALL output
												   >	254:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	255:     LD  3,-8(1)	Load variable dog
												   >	256:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	257:     LD  3,-8(1)	Load variable dog
												   >	* TOFF inc: -9
												   >	258:     LD  4,-9(1)	Pop left into ac1 
												   >	259:    ADD  3,4,3	Op + 
												   >	260:     ST  3,-9(1)	Push index 
												   >	* TOFF dec: -10
												   >	261:    LDC  3,496(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	262:     LD  4,-9(1)	Pop index 
												   >	263:    LDA  5,-1(0)	Load address of base of array y
												   >	264:    SUB  5,5,4	Compute offset of value 
												   >	265:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	266:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	267:    LDA  3,-1(0)	Load address of base of array y
												   >	268:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	269:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	270:     LD  4,-11(1)	Pop left into ac1 
												   >	271:    SUB  3,4,3	compute location from index 
												   >	272:     LD  3,0(3)	Load array element 
												   >	273:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	274:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	275:    LDA  3,1(7)	Return address in ac 
												   >	276:    JMP  7,-271(7)	CALL output
												   >	277:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	278:     ST  1,-9(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param end outnl
												   >	279:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	280:    LDA  3,1(7)	Return address in ac 
												   >	281:    JMP  7,-248(7)	CALL outnl
												   >	282:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL get
												   >	283:     ST  1,-9(1)	Store fp in ghost frame for get
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	284:    LDA  3,-1(0)	Load address of base of array y
												   >	285:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	286:    LDC  3,2(6)	Load integer constant 
												   >	287:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end get
												   >	288:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	289:    LDA  3,1(7)	Return address in ac 
												   >	290:    JMP  7,-252(7)	CALL get
												   >	291:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end get
												   >	* TOFF set: -9
												   >	292:     ST  3,-8(1)	Store variable dog
												   >	* EXPRESSION
												   >	* CALL output
												   >	293:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	294:     LD  3,-8(1)	Load variable dog
												   >	295:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	296:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	297:    LDA  3,1(7)	Return address in ac 
												   >	298:    JMP  7,-293(7)	CALL output
												   >	299:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL output
												   >	300:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	* CALL get
												   >	301:     ST  1,-11(1)	Store fp in ghost frame for get
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	302:    LDA  3,-1(0)	Load address of base of array y
												   >	303:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param 2
												   >	304:    LDC  3,2(6)	Load integer constant 
												   >	305:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end get
												   >	306:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	307:    LDA  3,1(7)	Return address in ac 
												   >	308:    JMP  7,-270(7)	CALL get
												   >	309:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end get
												   >	* TOFF set: -11
												   >	310:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	311:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	312:    LDA  3,1(7)	Return address in ac 
												   >	313:    JMP  7,-308(7)	CALL output
												   >	314:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL output
												   >	315:     ST  1,-9(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	316:    LDA  3,-3(1)	Load address of base of array x
												   >	317:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	318:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	319:     LD  4,-11(1)	Pop left into ac1 
												   >	320:    SUB  3,4,3	compute location from index 
												   >	321:     LD  3,0(3)	Load array element 
												   >	322:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end output
												   >	323:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	324:    LDA  3,1(7)	Return address in ac 
												   >	325:    JMP  7,-320(7)	CALL output
												   >	326:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	327:     ST  1,-9(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param end outnl
												   >	328:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	329:    LDA  3,1(7)	Return address in ac 
												   >	330:    JMP  7,-297(7)	CALL outnl
												   >	331:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -9
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	332:    LDC  2,0(6)	Set return value to 0 
												   >	333:     LD  3,-1(1)	Load return address 
												   >	334:     LD  1,0(1)	Adjust fp 
												   >	335:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,335(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	336:    LDA  1,-6(0)	set first frame at end of globals 
												   >	337:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	338:    LDC  3,5(6)	load size of array y
												   >	339:     ST  3,0(0)	save size of array y
												   >	* END INIT GLOBALS AND STATICS
												   >	340:    LDA  3,1(7)	Return address in ac 
												   >	341:    JMP  7,-264(7)	Jump to main 
												   >	342:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
array.mem array.mem.f21 differ: byte 1, line 1
array (MEM DIFF)
Var: y of array of type int [mem: Global loc: -1 size: 6] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: get returns type int [mem: Global loc: 0 size: -4] [line: 3]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: y of array of type int [mem: Global loc: -1 size: 6] [line: 1]
												   >	Sibling: 8  Func: get returns type int [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: i of type int [mem: Parameter loc: -3 size: 1] [line: 3]				.   Sibling: 1  Parm: i of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 1  Call: output of type void [line: 5]							.   .   Child: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Op: [ of type int [line: 5]							.   .   .   Child: 0  Op: [ of type int [line: 5]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   .   Child: 1  Const 0 of type int [line: 5]							.   .   .   .   Child: 1  Const 0 of type int [line: 5]
.   .   Sibling: 1  Call: outnl of type void [line: 6]							.   .   Sibling: 1  Call: outnl of type void [line: 6]
.   .   Sibling: 2  Assign: = of type int [line: 7]						   |	.   .   Sibling: 2  Assign: := of type int [line: 7]
.   .   .   Child: 0  Op: [ of type int [line: 7]							.   .   .   Child: 0  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 1 of type int [line: 7]							.   .   .   .   Child: 1  Const 1 of type int [line: 7]
.   .   .   Child: 1  Const 666 of type int [line: 7]							.   .   .   Child: 1  Const 666 of type int [line: 7]
.   .   Sibling: 3  Return [line: 8]									.   .   Sibling: 3  Return [line: 8]
.   .   .   Child: 0  Op: [ of type int [line: 8]							.   .   .   Child: 0  Op: [ of type int [line: 8]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 8]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 12]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 6] [line: 13]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 6] [line: 13]
.   .   Sibling: 1  Var: dog of type int [mem: Local loc: -8 size: 1] [line: 14]			.   .   Sibling: 1  Var: dog of type int [mem: Local loc: -8 size: 1] [line: 14]
.   .   Child: 1  Assign: = of type int [line: 16]						   |	.   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 16]			.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 16]
.   .   .   Child: 1  Const 2 of type int [line: 16]							.   .   .   Child: 1  Const 2 of type int [line: 16]
.   .   Sibling: 1  Assign: = of type int [line: 17]						   |	.   .   Sibling: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Op: [ of type int [line: 17]							.   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 17]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 17]
.   .   .   .   Child: 1  Const 0 of type int [line: 17]						.   .   .   .   Child: 1  Const 0 of type int [line: 17]
.   .   .   Child: 1  Const 3 of type int [line: 17]							.   .   .   Child: 1  Const 3 of type int [line: 17]
.   .   Sibling: 2  Call: output of type void [line: 18]						.   .   Sibling: 2  Call: output of type void [line: 18]
.   .   .   Child: 0  Op: [ of type int [line: 18]							.   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 18]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 18]
.   .   .   .   Child: 1  Const 0 of type int [line: 18]						.   .   .   .   Child: 1  Const 0 of type int [line: 18]
.   .   Sibling: 3  Assign: = of type int [line: 19]						   |	.   .   Sibling: 3  Assign: := of type int [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 19]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 19]
.   .   .   .   Child: 1  Const 1 of type int [line: 19]						.   .   .   .   Child: 1  Const 1 of type int [line: 19]
.   .   .   Child: 1  Op: [ of type int [line: 19]							.   .   .   Child: 1  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 19]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 19]
.   .   .   .   Child: 1  Const 0 of type int [line: 19]						.   .   .   .   Child: 1  Const 0 of type int [line: 19]
.   .   Sibling: 4  Call: output of type void [line: 20]						.   .   Sibling: 4  Call: output of type void [line: 20]
.   .   .   Child: 0  Op: [ of type int [line: 20]							.   .   .   Child: 0  Op: [ of type int [line: 20]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 20]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 20]
.   .   .   .   Child: 1  Const 1 of type int [line: 20]						.   .   .   .   Child: 1  Const 1 of type int [line: 20]
.   .   Sibling: 5  Assign: = of type int [line: 21]						   |	.   .   Sibling: 5  Assign: := of type int [line: 21]
.   .   .   Child: 0  Op: [ of type int [line: 21]							.   .   .   Child: 0  Op: [ of type int [line: 21]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 21]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 21]
.   .   .   .   Child: 1  Const 2 of type int [line: 21]						.   .   .   .   Child: 1  Const 2 of type int [line: 21]
.   .   .   Child: 1  Op: + of type int [line: 21]							.   .   .   Child: 1  Op: + of type int [line: 21]
.   .   .   .   Child: 0  Op: [ of type int [line: 21]							.   .   .   .   Child: 0  Op: [ of type int [line: 21]
.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 21]	.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 21]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 21]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 21]
.   .   .   .   Child: 1  Const 1 of type int [line: 21]						.   .   .   .   Child: 1  Const 1 of type int [line: 21]
.   .   Sibling: 6  Call: output of type void [line: 22]						.   .   Sibling: 6  Call: output of type void [line: 22]
.   .   .   Child: 0  Op: [ of type int [line: 22]							.   .   .   Child: 0  Op: [ of type int [line: 22]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 22]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 22]
.   .   .   .   Child: 1  Const 2 of type int [line: 22]						.   .   .   .   Child: 1  Const 2 of type int [line: 22]
.   .   Sibling: 7  Assign: = of type int [line: 23]						   |	.   .   Sibling: 7  Assign: := of type int [line: 23]
.   .   .   Child: 0  Op: [ of type int [line: 23]							.   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 23]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 23]
.   .   .   .   Child: 1  Op: + of type int [line: 23]							.   .   .   .   Child: 1  Op: + of type int [line: 23]
.   .   .   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 23]		.   .   .   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 23]
.   .   .   .   .   Child: 1  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 23]		.   .   .   .   .   Child: 1  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 23]
.   .   .   Child: 1  Const 496 of type int [line: 23]							.   .   .   Child: 1  Const 496 of type int [line: 23]
.   .   Sibling: 8  Call: output of type void [line: 24]						.   .   Sibling: 8  Call: output of type void [line: 24]
.   .   .   Child: 0  Op: [ of type int [line: 24]							.   .   .   Child: 0  Op: [ of type int [line: 24]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 24]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 24]
.   .   .   .   Child: 1  Const 4 of type int [line: 24]						.   .   .   .   Child: 1  Const 4 of type int [line: 24]
.   .   Sibling: 9  Call: outnl of type void [line: 25]							.   .   Sibling: 9  Call: outnl of type void [line: 25]
.   .   Sibling: 10  Assign: = of type int [line: 27]						   |	.   .   Sibling: 10  Assign: := of type int [line: 27]
.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 27]			.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 27]
.   .   .   Child: 1  Const 2 of type int [line: 27]							.   .   .   Child: 1  Const 2 of type int [line: 27]
.   .   Sibling: 11  Assign: = of type int [line: 28]						   |	.   .   Sibling: 11  Assign: := of type int [line: 28]
.   .   .   Child: 0  Op: [ of type int [line: 28]							.   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 28]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 28]
.   .   .   .   Child: 1  Const 0 of type int [line: 28]						.   .   .   .   Child: 1  Const 0 of type int [line: 28]
.   .   .   Child: 1  Const 3 of type int [line: 28]							.   .   .   Child: 1  Const 3 of type int [line: 28]
.   .   Sibling: 12  Call: output of type void [line: 29]						.   .   Sibling: 12  Call: output of type void [line: 29]
.   .   .   Child: 0  Op: [ of type int [line: 29]							.   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 29]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 29]
.   .   .   .   Child: 1  Const 0 of type int [line: 29]						.   .   .   .   Child: 1  Const 0 of type int [line: 29]
.   .   Sibling: 13  Assign: = of type int [line: 30]						   |	.   .   Sibling: 13  Assign: := of type int [line: 30]
.   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 30]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 30]
.   .   .   .   Child: 1  Const 1 of type int [line: 30]						.   .   .   .   Child: 1  Const 1 of type int [line: 30]
.   .   .   Child: 1  Op: [ of type int [line: 30]							.   .   .   Child: 1  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 30]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 30]
.   .   .   .   Child: 1  Const 0 of type int [line: 30]						.   .   .   .   Child: 1  Const 0 of type int [line: 30]
.   .   Sibling: 14  Call: output of type void [line: 31]						.   .   Sibling: 14  Call: output of type void [line: 31]
.   .   .   Child: 0  Op: [ of type int [line: 31]							.   .   .   Child: 0  Op: [ of type int [line: 31]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 31]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 31]
.   .   .   .   Child: 1  Const 1 of type int [line: 31]						.   .   .   .   Child: 1  Const 1 of type int [line: 31]
.   .   Sibling: 15  Assign: = of type int [line: 32]						   |	.   .   Sibling: 15  Assign: := of type int [line: 32]
.   .   .   Child: 0  Op: [ of type int [line: 32]							.   .   .   Child: 0  Op: [ of type int [line: 32]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 32]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 32]
.   .   .   .   Child: 1  Const 2 of type int [line: 32]						.   .   .   .   Child: 1  Const 2 of type int [line: 32]
.   .   .   Child: 1  Op: + of type int [line: 32]							.   .   .   Child: 1  Op: + of type int [line: 32]
.   .   .   .   Child: 0  Op: [ of type int [line: 32]							.   .   .   .   Child: 0  Op: [ of type int [line: 32]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 32	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 32
.   .   .   .   .   Child: 1  Const 1 of type int [line: 32]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 32]
.   .   .   .   Child: 1  Const 311 of type int [line: 32]						.   .   .   .   Child: 1  Const 311 of type int [line: 32]
.   .   Sibling: 16  Call: output of type void [line: 33]						.   .   Sibling: 16  Call: output of type void [line: 33]
.   .   .   Child: 0  Op: [ of type int [line: 33]							.   .   .   Child: 0  Op: [ of type int [line: 33]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 33]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 33]
.   .   .   .   Child: 1  Const 2 of type int [line: 33]						.   .   .   .   Child: 1  Const 2 of type int [line: 33]
.   .   Sibling: 17  Assign: = of type int [line: 34]						   |	.   .   Sibling: 17  Assign: := of type int [line: 34]
.   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 34]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 34]
.   .   .   .   Child: 1  Op: + of type int [line: 34]							.   .   .   .   Child: 1  Op: + of type int [line: 34]
.   .   .   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 34]		.   .   .   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 34]
.   .   .   .   .   Child: 1  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 34]		.   .   .   .   .   Child: 1  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 34]
.   .   .   Child: 1  Const 496 of type int [line: 34]							.   .   .   Child: 1  Const 496 of type int [line: 34]
.   .   Sibling: 18  Call: output of type void [line: 35]						.   .   Sibling: 18  Call: output of type void [line: 35]
.   .   .   Child: 0  Op: [ of type int [line: 35]							.   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 35]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 35]
.   .   .   .   Child: 1  Const 4 of type int [line: 35]						.   .   .   .   Child: 1  Const 4 of type int [line: 35]
.   .   Sibling: 19  Call: outnl of type void [line: 36]						.   .   Sibling: 19  Call: outnl of type void [line: 36]
.   .   Sibling: 20  Assign: = of type int [line: 38]						   |	.   .   Sibling: 20  Assign: := of type int [line: 38]
.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 38]			.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 38]
.   .   .   Child: 1  Call: get of type int [line: 38]							.   .   .   Child: 1  Call: get of type int [line: 38]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 38]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 38]
.   .   .   .   Sibling: 1  Const 2 of type int [line: 38]						.   .   .   .   Sibling: 1  Const 2 of type int [line: 38]
.   .   Sibling: 21  Call: output of type void [line: 39]						.   .   Sibling: 21  Call: output of type void [line: 39]
.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 39]			.   .   .   Child: 0  Id: dog of type int [mem: Local loc: -8 size: 1] [line: 39]
.   .   Sibling: 22  Call: output of type void [line: 40]						.   .   Sibling: 22  Call: output of type void [line: 40]
.   .   .   Child: 0  Call: get of type int [line: 40]							.   .   .   Child: 0  Call: get of type int [line: 40]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 40]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 6] [line: 40]
.   .   .   .   Sibling: 1  Const 2 of type int [line: 40]						.   .   .   .   Sibling: 1  Const 2 of type int [line: 40]
.   .   Sibling: 23  Call: output of type void [line: 41]						.   .   Sibling: 23  Call: output of type void [line: 41]
.   .   .   Child: 0  Op: [ of type int [line: 41]							.   .   .   Child: 0  Op: [ of type int [line: 41]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 41]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 6] [line: 41]
.   .   .   .   Child: 1  Const 1 of type int [line: 41]						.   .   .   .   Child: 1  Const 1 of type int [line: 41]
.   .   Sibling: 24  Call: outnl of type void [line: 42]						.   .   Sibling: 24  Call: outnl of type void [line: 42]
Offset for end of global space: -6									Offset for end of global space: -6
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
array.out ztmp23114.txt differ: byte 1, line 1
array (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/array.tm
Number of errors: 0										   |	3 3 4 496
------------------------------------								   |	3 3 314 496
Loading file: array.tm										   |	3
												   >	314 3
												   >	314 3
Bye.													Bye.
====================================
FILE: arraysize.c-
-rw-------. 1 corg7983 domain_users   487 Nov 17 15:35 arraysize.c-
-rw-------. 1 corg7983 domain_users   490 Nov 17 15:35 arraysize.c-.f21
-rw-------. 1 corg7983 domain_users   487 Nov 17 15:35 arraysize.c-.f22
-rw-------. 1 corg7983 domain_users   205 Nov 17 15:35 arraysize.expected
-rw-------. 1 corg7983 domain_users  5288 Nov 22 12:27 arraysize.mem
-rw-------. 1 corg7983 domain_users   355 Nov 17 15:35 arraysize.mem.diffs
-rw-------. 1 corg7983 domain_users  6133 Nov 17 15:35 arraysize.mem.f21
-rw-------. 1 corg7983 domain_users   215 Nov 22 12:27 arraysize.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 arraysize.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 arraysize.tm.diffs
-rw-------. 1 corg7983 domain_users 13860 Nov 17 15:35 arraysize.tm.f21
TM CODE COMPARISON
arraysize (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  arraysize.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION ford
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -18
												   >	 40:    LDC  3,13(6)	load size of array y
												   >	 41:     ST  3,-4(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:    LDC  3,0(6)	Load integer constant 
												   >	 43:     ST  3,-18(1)	Push index 
												   >	* TOFF dec: -19
												   >	 44:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	 45:     LD  4,-18(1)	Pop index 
												   >	 46:    LDA  5,-5(1)	Load address of base of array y
												   >	 47:    SUB  5,5,4	Compute offset of value 
												   >	 48:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	 49:    LDC  3,0(6)	Load integer constant 
												   >	 50:     ST  3,-18(1)	Push index 
												   >	* TOFF dec: -19
												   >	 51:    LDC  3,888(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	 52:     LD  4,-18(1)	Pop index 
												   >	 53:    LDA  5,-1(0)	Load address of base of array g
												   >	 54:    SUB  5,5,4	Compute offset of value 
												   >	 55:     ST  3,0(5)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	 56:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 57:     LD  3,-2(1)	Load address of base of array x
												   >	 58:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 59:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	 60:     LD  4,-20(1)	Pop left into ac1 
												   >	 61:    SUB  3,4,3	compute location from index 
												   >	 62:     LD  3,0(3)	Load array element 
												   >	 63:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 64:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 65:    LDA  3,1(7)	Return address in ac 
												   >	 66:    JMP  7,-61(7)	CALL output
												   >	 67:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 68:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 69:     LD  3,-2(1)	Load address of base of array x
												   >	 70:     LD  3,1(3)	Load array size 
												   >	 71:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 72:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-69(7)	CALL output
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 76:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 77:    LDA  3,-1(0)	Load address of base of array g
												   >	 78:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 79:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	 80:     LD  4,-20(1)	Pop left into ac1 
												   >	 81:    SUB  3,4,3	compute location from index 
												   >	 82:     LD  3,0(3)	Load array element 
												   >	 83:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 84:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 85:    LDA  3,1(7)	Return address in ac 
												   >	 86:    JMP  7,-81(7)	CALL output
												   >	 87:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 88:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 89:    LDA  3,-1(0)	Load address of base of array g
												   >	 90:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 91:    LDC  3,1(6)	Load integer constant 
												   >	 92:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -20
												   >	 93:     LD  4,-20(1)	Pop left into ac1 
												   >	 94:    SUB  3,4,3	compute location from index 
												   >	 95:     LD  3,0(3)	Load array element 
												   >	 96:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 97:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 98:    LDA  3,1(7)	Return address in ac 
												   >	 99:    JMP  7,-94(7)	CALL output
												   >	100:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	101:     ST  1,-18(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param end outnl
												   >	102:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	103:    LDA  3,1(7)	Return address in ac 
												   >	104:    JMP  7,-71(7)	CALL outnl
												   >	105:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	106:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	107:    LDA  3,-5(1)	Load address of base of array y
												   >	108:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	109:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	110:     LD  4,-20(1)	Pop left into ac1 
												   >	111:    SUB  3,4,3	compute location from index 
												   >	112:     LD  3,0(3)	Load array element 
												   >	113:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	114:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-111(7)	CALL output
												   >	117:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	118:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	119:    LDA  3,-5(1)	Load address of base of array y
												   >	120:     LD  3,1(3)	Load array size 
												   >	121:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	122:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	123:    LDA  3,1(7)	Return address in ac 
												   >	124:    JMP  7,-119(7)	CALL output
												   >	125:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	126:     ST  1,-18(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param end outnl
												   >	127:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	128:    LDA  3,1(7)	Return address in ac 
												   >	129:    JMP  7,-96(7)	CALL outnl
												   >	130:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -18
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	131:    LDC  2,0(6)	Set return value to 0 
												   >	132:     LD  3,-1(1)	Load return address 
												   >	133:     LD  1,0(1)	Adjust fp 
												   >	134:    JMP  7,0(3)	Return 
												   >	* END FUNCTION ford
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	135:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	136:    LDC  3,11(6)	load size of array m
												   >	137:     ST  3,-2(1)	save size of array m
												   >	* Compound Body
												   >	* EXPRESSION
												   >	138:    LDC  3,0(6)	Load integer constant 
												   >	139:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	140:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	141:     LD  4,-14(1)	Pop index 
												   >	142:    LDA  5,-3(1)	Load address of base of array m
												   >	143:    SUB  5,5,4	Compute offset of value 
												   >	144:     ST  3,0(5)	Store variable m
												   >	* EXPRESSION
												   >	* CALL output
												   >	145:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	146:    LDA  3,-3(1)	Load address of base of array m
												   >	147:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	148:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	149:     LD  4,-16(1)	Pop left into ac1 
												   >	150:    SUB  3,4,3	compute location from index 
												   >	151:     LD  3,0(3)	Load array element 
												   >	152:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	153:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	154:    LDA  3,1(7)	Return address in ac 
												   >	155:    JMP  7,-150(7)	CALL output
												   >	156:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	157:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	158:    LDA  3,-3(1)	Load address of base of array m
												   >	159:     LD  3,1(3)	Load array size 
												   >	160:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	161:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	162:    LDA  3,1(7)	Return address in ac 
												   >	163:    JMP  7,-158(7)	CALL output
												   >	164:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	165:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	166:    LDA  3,-1(0)	Load address of base of array g
												   >	167:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	168:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	169:     LD  4,-16(1)	Pop left into ac1 
												   >	170:    SUB  3,4,3	compute location from index 
												   >	171:     LD  3,0(3)	Load array element 
												   >	172:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	173:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-170(7)	CALL output
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	177:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	178:    LDA  3,-1(0)	Load address of base of array g
												   >	179:     LD  3,1(3)	Load array size 
												   >	180:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	181:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	182:    LDA  3,1(7)	Return address in ac 
												   >	183:    JMP  7,-178(7)	CALL output
												   >	184:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	185:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	186:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	187:    LDA  3,1(7)	Return address in ac 
												   >	188:    JMP  7,-155(7)	CALL outnl
												   >	189:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL ford
												   >	190:     ST  1,-14(1)	Store fp in ghost frame for ford
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	191:    LDA  3,-3(1)	Load address of base of array m
												   >	192:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end ford
												   >	193:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	194:    LDA  3,1(7)	Return address in ac 
												   >	195:    JMP  7,-157(7)	CALL ford
												   >	196:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ford
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL ford
												   >	197:     ST  1,-14(1)	Store fp in ghost frame for ford
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	198:    LDA  3,-1(0)	Load address of base of array g
												   >	199:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end ford
												   >	200:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	201:    LDA  3,1(7)	Return address in ac 
												   >	202:    JMP  7,-164(7)	CALL ford
												   >	203:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ford
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	204:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	205:    LDA  3,-3(1)	Load address of base of array m
												   >	206:     LD  3,1(3)	Load array size 
												   >	207:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	208:    LDA  3,-1(0)	Load address of base of array g
												   >	209:     LD  3,1(3)	Load array size 
												   >	* TOFF inc: -16
												   >	210:     LD  4,-16(1)	Pop left into ac1 
												   >	211:    MUL  3,4,3	Op * 
												   >	212:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	213:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	214:    LDA  3,1(7)	Return address in ac 
												   >	215:    JMP  7,-210(7)	CALL output
												   >	216:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	217:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	218:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	219:    LDA  3,1(7)	Return address in ac 
												   >	220:    JMP  7,-187(7)	CALL outnl
												   >	221:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	222:    LDC  2,0(6)	Set return value to 0 
												   >	223:     LD  3,-1(1)	Load return address 
												   >	224:     LD  1,0(1)	Adjust fp 
												   >	225:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,225(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	226:    LDA  1,-37(0)	set first frame at end of globals 
												   >	227:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	228:    LDC  3,12(6)	load size of array g
												   >	229:     ST  3,0(0)	save size of array g
												   >	230:    LDC  3,23(6)	load size of array h
												   >	231:     ST  3,-13(0)	save size of array h
												   >	* END INIT GLOBALS AND STATICS
												   >	232:    LDA  3,1(7)	Return address in ac 
												   >	233:    JMP  7,-99(7)	Jump to main 
												   >	234:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
arraysize.mem arraysize.mem.f21 differ: byte 105, line 3
arraysize (MEM DIFF)
WARNING(12): The variable 'i' seems not to be used.							WARNING(12): The variable 'i' seems not to be used.
WARNING(25): The variable 'h' seems not to be used.							WARNING(25): The variable 'h' seems not to be used.
Var: g of array of type int [mem: Global loc: -1 size: 13] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: ford returns type void [mem: Global loc: 0 size: -3] [line: 10]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of array of type int [mem: Global loc: -1 size: 13] [line: 1]
												   >	Sibling: 8  Func: ford returns type void [mem: Global loc: 0 size: -3] [line: 10]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -18] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -18] [line: 11]
.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 12]				.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -5 size: 14] [line: 12]		.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -5 size: 14] [line: 12]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 13]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 13]
.   .   .   .   Child: 1  Const 0 of type int [line: 13]						.   .   .   .   Child: 1  Const 0 of type int [line: 13]
.   .   .   Child: 1  Const 666 of type int [line: 13]							.   .   .   Child: 1  Const 666 of type int [line: 13]
.   .   Sibling: 1  Assign: = of type int [line: 14]						   |	.   .   Sibling: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 14]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 14]
.   .   .   .   Child: 1  Const 0 of type int [line: 14]						.   .   .   .   Child: 1  Const 0 of type int [line: 14]
.   .   .   Child: 1  Const 888 of type int [line: 14]							.   .   .   Child: 1  Const 888 of type int [line: 14]
.   .   Sibling: 2  Call: output of type void [line: 15]						.   .   Sibling: 2  Call: output of type void [line: 15]
.   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 15]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 0 of type int [line: 15]						.   .   .   .   Child: 1  Const 0 of type int [line: 15]
.   .   Sibling: 3  Call: output of type void [line: 16]						.   .   Sibling: 3  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: sizeof of type int [line: 16]							.   .   .   Child: 0  Op: sizeof of type int [line: 16]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 16]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 16]
.   .   Sibling: 4  Call: output of type void [line: 17]						.   .   Sibling: 4  Call: output of type void [line: 17]
.   .   .   Child: 0  Op: [ of type int [line: 17]							.   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 17]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 17]
.   .   .   .   Child: 1  Const 0 of type int [line: 17]						.   .   .   .   Child: 1  Const 0 of type int [line: 17]
.   .   Sibling: 5  Call: output of type void [line: 18]						.   .   Sibling: 5  Call: output of type void [line: 18]
.   .   .   Child: 0  Op: [ of type int [line: 18]							.   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 18]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 18]
.   .   .   .   Child: 1  Op: chsign of type int [line: 18]						.   .   .   .   Child: 1  Op: chsign of type int [line: 18]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 18]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 18]
.   .   Sibling: 6  Call: outnl of type void [line: 19]							.   .   Sibling: 6  Call: outnl of type void [line: 19]
.   .   Sibling: 7  Call: output of type void [line: 20]						.   .   Sibling: 7  Call: output of type void [line: 20]
.   .   .   Child: 0  Op: [ of type int [line: 20]							.   .   .   Child: 0  Op: [ of type int [line: 20]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 20]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 20]
.   .   .   .   Child: 1  Const 0 of type int [line: 20]						.   .   .   .   Child: 1  Const 0 of type int [line: 20]
.   .   Sibling: 8  Call: output of type void [line: 21]						.   .   Sibling: 8  Call: output of type void [line: 21]
.   .   .   Child: 0  Op: sizeof of type int [line: 21]							.   .   .   Child: 0  Op: sizeof of type int [line: 21]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 21]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -5 size: 14] [line: 21]
.   .   Sibling: 9  Call: outnl of type void [line: 22]							.   .   Sibling: 9  Call: outnl of type void [line: 22]
Sibling: 2  Var: h of array of type bool [mem: Global loc: -14 size: 24] [line: 25]		   |	Sibling: 9  Var: h of array of type bool [mem: Global loc: -14 size: 24] [line: 25]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 27]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 27]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 28]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 28]
.   .   Child: 0  Var: m of array of type int [mem: Local loc: -3 size: 12] [line: 29]			.   .   Child: 0  Var: m of array of type int [mem: Local loc: -3 size: 12] [line: 29]
.   .   Child: 1  Assign: = of type int [line: 31]						   |	.   .   Child: 1  Assign: := of type int [line: 31]
.   .   .   Child: 0  Op: [ of type int [line: 31]							.   .   .   Child: 0  Op: [ of type int [line: 31]
.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 31]		.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 31]
.   .   .   .   Child: 1  Const 0 of type int [line: 31]						.   .   .   .   Child: 1  Const 0 of type int [line: 31]
.   .   .   Child: 1  Const 777 of type int [line: 31]							.   .   .   Child: 1  Const 777 of type int [line: 31]
.   .   Sibling: 1  Call: output of type void [line: 32]						.   .   Sibling: 1  Call: output of type void [line: 32]
.   .   .   Child: 0  Op: [ of type int [line: 32]							.   .   .   Child: 0  Op: [ of type int [line: 32]
.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 32]		.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 32]
.   .   .   .   Child: 1  Const 0 of type int [line: 32]						.   .   .   .   Child: 1  Const 0 of type int [line: 32]
.   .   Sibling: 2  Call: output of type void [line: 33]						.   .   Sibling: 2  Call: output of type void [line: 33]
.   .   .   Child: 0  Op: sizeof of type int [line: 33]							.   .   .   Child: 0  Op: sizeof of type int [line: 33]
.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 33]		.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 33]
.   .   Sibling: 3  Call: output of type void [line: 34]						.   .   Sibling: 3  Call: output of type void [line: 34]
.   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 34]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 34]
.   .   .   .   Child: 1  Const 0 of type int [line: 34]						.   .   .   .   Child: 1  Const 0 of type int [line: 34]
.   .   Sibling: 4  Call: output of type void [line: 35]						.   .   Sibling: 4  Call: output of type void [line: 35]
.   .   .   Child: 0  Op: sizeof of type int [line: 35]							.   .   .   Child: 0  Op: sizeof of type int [line: 35]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 35]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 35]
.   .   Sibling: 5  Call: outnl of type void [line: 36]							.   .   Sibling: 5  Call: outnl of type void [line: 36]
.   .   Sibling: 6  Call: ford of type void [line: 38]							.   .   Sibling: 6  Call: ford of type void [line: 38]
.   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 38]		.   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 38]
.   .   Sibling: 7  Call: ford of type void [line: 39]							.   .   Sibling: 7  Call: ford of type void [line: 39]
.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 39]		.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 39]
.   .   Sibling: 8  Call: output of type void [line: 41]						.   .   Sibling: 8  Call: output of type void [line: 41]
.   .   .   Child: 0  Op: * of type int [line: 41]							.   .   .   Child: 0  Op: * of type int [line: 41]
.   .   .   .   Child: 0  Op: sizeof of type int [line: 41]						.   .   .   .   Child: 0  Op: sizeof of type int [line: 41]
.   .   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 41	.   .   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 41
.   .   .   .   Child: 1  Op: sizeof of type int [line: 41]						.   .   .   .   Child: 1  Op: sizeof of type int [line: 41]
.   .   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 4	.   .   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 4
.   .   Sibling: 9  Call: outnl of type void [line: 42]							.   .   Sibling: 9  Call: outnl of type void [line: 42]
Offset for end of global space: -37									Offset for end of global space: -37
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
arraysize.out ztmp23114.txt differ: byte 105, line 3
arraysize (Output DIFF)
WARNING(12): The variable 'i' seems not to be used.							WARNING(12): The variable 'i' seems not to be used.
WARNING(25): The variable 'h' seems not to be used.							WARNING(25): The variable 'h' seems not to be used.
Number of warnings: 2										   |	Loading file: BroadTests/arraysize.tm
Number of errors: 0										   |	777 11 0 12
------------------------------------								   |	777 11 888 12
Loading file: arraysize.tm									   |	666 13
												   >	888 12 888 12
												   >	666 13
												   >	132
Bye.													Bye.
====================================
FILE: assign1.c-
-rw-------. 1 corg7983 domain_users   499 Nov 17 15:35 assign1.c-
-rw-------. 1 corg7983 domain_users   511 Nov 17 15:35 assign1.c-.f21
-rw-------. 1 corg7983 domain_users   499 Nov 17 15:35 assign1.c-.f22
-rw-------. 1 corg7983 domain_users    77 Nov 17 15:35 assign1.expected
-rw-------. 1 corg7983 domain_users  5144 Nov 22 12:27 assign1.mem
-rw-------. 1 corg7983 domain_users  1472 Nov 17 15:35 assign1.mem.diffs
-rw-------. 1 corg7983 domain_users  5999 Nov 17 15:35 assign1.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign1.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign1.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign1.tm.diffs
-rw-------. 1 corg7983 domain_users 10729 Nov 17 15:35 assign1.tm.f21
TM CODE COMPARISON
assign1 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign1.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,111(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 42:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 43:     LD  3,-2(1)	Load variable x
												   >	 44:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 45:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 46:    LDA  3,1(7)	Return address in ac 
												   >	 47:    JMP  7,-42(7)	CALL output
												   >	 48:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 49:    LDC  3,222(6)	Load integer constant 
												   >	 50:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 51:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 52:     LD  3,-3(1)	Load variable y
												   >	 53:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 54:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 55:    LDA  3,1(7)	Return address in ac 
												   >	 56:    JMP  7,-51(7)	CALL output
												   >	 57:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 58:    LDC  3,1(6)	Load Boolean constant 
												   >	 59:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 60:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 61:     LD  3,-4(1)	Load variable a
												   >	 62:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	 63:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 64:    LDA  3,1(7)	Return address in ac 
												   >	 65:    JMP  7,-49(7)	CALL outputb
												   >	 66:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 67:    LDC  3,0(6)	Load Boolean constant 
												   >	 68:     ST  3,-5(1)	Store variable b
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 69:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 70:     LD  3,-5(1)	Load variable b
												   >	 71:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	 72:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-58(7)	CALL outputb
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 76:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	 77:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-46(7)	CALL outnl
												   >	 80:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 81:    LDC  3,333(6)	Load integer constant 
												   >	 82:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	 83:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 84:     LD  3,0(0)	Load variable gx
												   >	 85:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 86:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-83(7)	CALL output
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 90:    LDC  3,444(6)	Load integer constant 
												   >	 91:     ST  3,-1(0)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	 92:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 93:     LD  3,-1(0)	Load variable gy
												   >	 94:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 95:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 96:    LDA  3,1(7)	Return address in ac 
												   >	 97:    JMP  7,-92(7)	CALL output
												   >	 98:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 99:    LDC  3,0(6)	Load Boolean constant 
												   >	100:     ST  3,-2(0)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	101:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	102:     LD  3,-2(0)	Load variable ga
												   >	103:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	104:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	105:    LDA  3,1(7)	Return address in ac 
												   >	106:    JMP  7,-90(7)	CALL outputb
												   >	107:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	108:    LDC  3,1(6)	Load Boolean constant 
												   >	109:     ST  3,-3(0)	Store variable gb
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	110:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	111:     LD  3,-3(0)	Load variable gb
												   >	112:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	113:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-99(7)	CALL outputb
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	117:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	118:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	119:    LDA  3,1(7)	Return address in ac 
												   >	120:    JMP  7,-87(7)	CALL outnl
												   >	121:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	122:     LD  3,-3(1)	Load variable y
												   >	123:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	124:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	125:     LD  3,-2(1)	Load variable x
												   >	126:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	127:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	128:    LDA  3,1(7)	Return address in ac 
												   >	129:    JMP  7,-124(7)	CALL output
												   >	130:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	131:     LD  3,-5(1)	Load variable b
												   >	132:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	133:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	134:     LD  3,-4(1)	Load variable a
												   >	135:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	136:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	137:    LDA  3,1(7)	Return address in ac 
												   >	138:    JMP  7,-122(7)	CALL outputb
												   >	139:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	140:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	141:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	142:    LDA  3,1(7)	Return address in ac 
												   >	143:    JMP  7,-110(7)	CALL outnl
												   >	144:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	145:     LD  3,-1(0)	Load variable gy
												   >	146:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	147:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	148:     LD  3,0(0)	Load variable gx
												   >	149:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	150:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-147(7)	CALL output
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	154:     LD  3,-3(0)	Load variable gb
												   >	155:     ST  3,-2(0)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	156:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	157:     LD  3,-2(0)	Load variable ga
												   >	158:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	159:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-145(7)	CALL outputb
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	163:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	164:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	165:    LDA  3,1(7)	Return address in ac 
												   >	166:    JMP  7,-133(7)	CALL outnl
												   >	167:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* RETURN
												   >	168:     LD  3,-1(1)	Load return address 
												   >	169:     LD  1,0(1)	Adjust fp 
												   >	170:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	171:    LDC  2,0(6)	Set return value to 0 
												   >	172:     LD  3,-1(1)	Load return address 
												   >	173:     LD  1,0(1)	Adjust fp 
												   >	174:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,174(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	175:    LDA  1,-4(0)	set first frame at end of globals 
												   >	176:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	177:    LDA  3,1(7)	Return address in ac 
												   >	178:    JMP  7,-140(7)	Jump to main 
												   >	179:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign1.mem assign1.mem.f21 differ: byte 1, line 1
assign1 (MEM DIFF)
Var: gx of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: gy of type int [mem: Global loc: -1 size: 1] [line: 1]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: ga of type bool [mem: Global loc: -2 size: 1] [line: 2]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Var: gb of type bool [mem: Global loc: -3 size: 1] [line: 2]			   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]		   |	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: gx of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: gy of type int [mem: Global loc: -1 size: 1] [line: 1]
												   >	Sibling: 9  Var: ga of type bool [mem: Global loc: -2 size: 1] [line: 2]
												   >	Sibling: 10  Var: gb of type bool [mem: Global loc: -3 size: 1] [line: 2]
												   >	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 5]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 6]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   Sibling: 2  Var: a of type bool [mem: Local loc: -4 size: 1] [line: 7]				.   .   Sibling: 2  Var: a of type bool [mem: Local loc: -4 size: 1] [line: 7]
.   .   Sibling: 3  Var: b of type bool [mem: Local loc: -5 size: 1] [line: 7]				.   .   Sibling: 3  Var: b of type bool [mem: Local loc: -5 size: 1] [line: 7]
.   .   Child: 1  Assign: = of type int [line: 9]						   |	.   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   Child: 1  Const 111 of type int [line: 9]							.   .   .   Child: 1  Const 111 of type int [line: 9]
.   .   Sibling: 1  Call: output of type void [line: 10]						.   .   Sibling: 1  Call: output of type void [line: 10]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   Sibling: 2  Assign: = of type int [line: 11]						   |	.   .   Sibling: 2  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   Child: 1  Const 222 of type int [line: 11]							.   .   .   Child: 1  Const 222 of type int [line: 11]
.   .   Sibling: 3  Call: output of type void [line: 12]						.   .   Sibling: 3  Call: output of type void [line: 12]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   Sibling: 4  Assign: = of type bool [line: 13]						   |	.   .   Sibling: 4  Assign: := of type bool [line: 13]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 13]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   Child: 1  Const true of type bool [line: 13]						.   .   .   Child: 1  Const true of type bool [line: 13]
.   .   Sibling: 5  Call: outputb of type void [line: 14]						.   .   Sibling: 5  Call: outputb of type void [line: 14]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 14]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 14]
.   .   Sibling: 6  Assign: = of type bool [line: 15]						   |	.   .   Sibling: 6  Assign: := of type bool [line: 15]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 15]			.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 15]
.   .   .   Child: 1  Const false of type bool [line: 15]						.   .   .   Child: 1  Const false of type bool [line: 15]
.   .   Sibling: 7  Call: outputb of type void [line: 16]						.   .   Sibling: 7  Call: outputb of type void [line: 16]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 16]			.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 16]
.   .   Sibling: 8  Call: outnl of type void [line: 17]							.   .   Sibling: 8  Call: outnl of type void [line: 17]
.   .   Sibling: 9  Assign: = of type int [line: 19]						   |	.   .   Sibling: 9  Assign: := of type int [line: 19]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 19]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 19]
.   .   .   Child: 1  Const 333 of type int [line: 19]							.   .   .   Child: 1  Const 333 of type int [line: 19]
.   .   Sibling: 10  Call: output of type void [line: 20]						.   .   Sibling: 10  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 20]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 20]
.   .   Sibling: 11  Assign: = of type int [line: 21]						   |	.   .   Sibling: 11  Assign: := of type int [line: 21]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 21]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 21]
.   .   .   Child: 1  Const 444 of type int [line: 21]							.   .   .   Child: 1  Const 444 of type int [line: 21]
.   .   Sibling: 12  Call: output of type void [line: 22]						.   .   Sibling: 12  Call: output of type void [line: 22]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 22]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 22]
.   .   Sibling: 13  Assign: = of type bool [line: 23]						   |	.   .   Sibling: 13  Assign: := of type bool [line: 23]
.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 23]			.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 23]
.   .   .   Child: 1  Const false of type bool [line: 23]						.   .   .   Child: 1  Const false of type bool [line: 23]
.   .   Sibling: 14  Call: outputb of type void [line: 24]						.   .   Sibling: 14  Call: outputb of type void [line: 24]
.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 24]			.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 24]
.   .   Sibling: 15  Assign: = of type bool [line: 25]						   |	.   .   Sibling: 15  Assign: := of type bool [line: 25]
.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 25]			.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 25]
.   .   .   Child: 1  Const true of type bool [line: 25]						.   .   .   Child: 1  Const true of type bool [line: 25]
.   .   Sibling: 16  Call: outputb of type void [line: 26]						.   .   Sibling: 16  Call: outputb of type void [line: 26]
.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 26]			.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 26]
.   .   Sibling: 17  Call: outnl of type void [line: 27]						.   .   Sibling: 17  Call: outnl of type void [line: 27]
.   .   Sibling: 18  Assign: = of type int [line: 29]						   |	.   .   Sibling: 18  Assign: := of type int [line: 29]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 29]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 29]
.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 29]				.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 29]
.   .   Sibling: 19  Call: output of type void [line: 30]						.   .   Sibling: 19  Call: output of type void [line: 30]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 30]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 30]
.   .   Sibling: 20  Assign: = of type bool [line: 31]						   |	.   .   Sibling: 20  Assign: := of type bool [line: 31]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 31]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 31]
.   .   .   Child: 1  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 31]			.   .   .   Child: 1  Id: b of type bool [mem: Local loc: -5 size: 1] [line: 31]
.   .   Sibling: 21  Call: outputb of type void [line: 32]						.   .   Sibling: 21  Call: outputb of type void [line: 32]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 32]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -4 size: 1] [line: 32]
.   .   Sibling: 22  Call: outnl of type void [line: 33]						.   .   Sibling: 22  Call: outnl of type void [line: 33]
.   .   Sibling: 23  Assign: = of type int [line: 35]						   |	.   .   Sibling: 23  Assign: := of type int [line: 35]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 35]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 35]
.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 35]			.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 35]
.   .   Sibling: 24  Call: output of type void [line: 36]						.   .   Sibling: 24  Call: output of type void [line: 36]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 36]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 36]
.   .   Sibling: 25  Assign: = of type bool [line: 37]						   |	.   .   Sibling: 25  Assign: := of type bool [line: 37]
.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 37]			.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 37]
.   .   .   Child: 1  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 37]			.   .   .   Child: 1  Id: gb of type bool [mem: Global loc: -3 size: 1] [line: 37]
.   .   Sibling: 26  Call: outputb of type void [line: 38]						.   .   Sibling: 26  Call: outputb of type void [line: 38]
.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 38]			.   .   .   Child: 0  Id: ga of type bool [mem: Global loc: -2 size: 1] [line: 38]
.   .   Sibling: 27  Call: outnl of type void [line: 39]						.   .   Sibling: 27  Call: outnl of type void [line: 39]
.   .   Sibling: 28  Return [line: 41]									.   .   Sibling: 28  Return [line: 41]
Offset for end of global space: -4									Offset for end of global space: -4
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign1.out ztmp23114.txt differ: byte 1, line 1
assign1 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign1.tm
Number of errors: 0										   |	111 222 T F
------------------------------------								   |	333 444 F T
Loading file: assign1.tm									   |	222 F
												   >	444 T
Bye.													Bye.
====================================
FILE: assign2.c-
-rw-------. 1 corg7983 domain_users   607 Nov 17 15:35 assign2.c-
-rw-------. 1 corg7983 domain_users   619 Nov 17 15:35 assign2.c-.f21
-rw-------. 1 corg7983 domain_users   607 Nov 17 15:35 assign2.c-.f22
-rw-------. 1 corg7983 domain_users    77 Nov 17 15:35 assign2.expected
-rw-------. 1 corg7983 domain_users  8645 Nov 22 12:27 assign2.mem
-rw-------. 1 corg7983 domain_users  1478 Nov 17 15:35 assign2.mem.diffs
-rw-------. 1 corg7983 domain_users  9500 Nov 17 15:35 assign2.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign2.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign2.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign2.tm.diffs
-rw-------. 1 corg7983 domain_users 18528 Nov 17 15:35 assign2.tm.f21
TM CODE COMPARISON
assign2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -32
												   >	 40:    LDC  3,8(6)	load size of array x
												   >	 41:     ST  3,-2(1)	save size of array x
												   >	 42:    LDC  3,7(6)	load size of array y
												   >	 43:     ST  3,-11(1)	save size of array y
												   >	 44:    LDC  3,6(6)	load size of array a
												   >	 45:     ST  3,-19(1)	save size of array a
												   >	 46:    LDC  3,5(6)	load size of array b
												   >	 47:     ST  3,-26(1)	save size of array b
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 48:    LDC  3,5(6)	Load integer constant 
												   >	 49:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	 50:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -32
												   >	 51:     LD  4,-32(1)	Pop index 
												   >	 52:    LDA  5,-3(1)	Load address of base of array x
												   >	 53:    SUB  5,5,4	Compute offset of value 
												   >	 54:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 55:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	 56:    LDA  3,-3(1)	Load address of base of array x
												   >	 57:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	 58:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	 59:     LD  4,-34(1)	Pop left into ac1 
												   >	 60:    SUB  3,4,3	compute location from index 
												   >	 61:     LD  3,0(3)	Load array element 
												   >	 62:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	 63:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	 64:    LDA  3,1(7)	Return address in ac 
												   >	 65:    JMP  7,-60(7)	CALL output
												   >	 66:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	 67:    LDC  3,4(6)	Load integer constant 
												   >	 68:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	 69:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -32
												   >	 70:     LD  4,-32(1)	Pop index 
												   >	 71:    LDA  5,-12(1)	Load address of base of array y
												   >	 72:    SUB  5,5,4	Compute offset of value 
												   >	 73:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 74:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	 75:    LDA  3,-12(1)	Load address of base of array y
												   >	 76:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	 77:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	 78:     LD  4,-34(1)	Pop left into ac1 
												   >	 79:    SUB  3,4,3	compute location from index 
												   >	 80:     LD  3,0(3)	Load array element 
												   >	 81:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	 82:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	 83:    LDA  3,1(7)	Return address in ac 
												   >	 84:    JMP  7,-79(7)	CALL output
												   >	 85:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	 86:    LDC  3,3(6)	Load integer constant 
												   >	 87:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	 88:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -32
												   >	 89:     LD  4,-32(1)	Pop index 
												   >	 90:    LDA  5,-20(1)	Load address of base of array a
												   >	 91:    SUB  5,5,4	Compute offset of value 
												   >	 92:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 93:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	 94:    LDA  3,-20(1)	Load address of base of array a
												   >	 95:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	 96:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	 97:     LD  4,-34(1)	Pop left into ac1 
												   >	 98:    SUB  3,4,3	compute location from index 
												   >	 99:     LD  3,0(3)	Load array element 
												   >	100:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	101:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	102:    LDA  3,1(7)	Return address in ac 
												   >	103:    JMP  7,-87(7)	CALL outputb
												   >	104:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	105:    LDC  3,2(6)	Load integer constant 
												   >	106:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	107:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -32
												   >	108:     LD  4,-32(1)	Pop index 
												   >	109:    LDA  5,-27(1)	Load address of base of array b
												   >	110:    SUB  5,5,4	Compute offset of value 
												   >	111:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	112:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	113:    LDA  3,-27(1)	Load address of base of array b
												   >	114:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	115:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	116:     LD  4,-34(1)	Pop left into ac1 
												   >	117:    SUB  3,4,3	compute location from index 
												   >	118:     LD  3,0(3)	Load array element 
												   >	119:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	120:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	121:    LDA  3,1(7)	Return address in ac 
												   >	122:    JMP  7,-106(7)	CALL outputb
												   >	123:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	124:     ST  1,-32(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param end outnl
												   >	125:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-94(7)	CALL outnl
												   >	128:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	129:    LDC  3,5(6)	Load integer constant 
												   >	130:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	131:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -32
												   >	132:     LD  4,-32(1)	Pop index 
												   >	133:    LDA  5,-1(0)	Load address of base of array gx
												   >	134:    SUB  5,5,4	Compute offset of value 
												   >	135:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	136:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	137:    LDA  3,-1(0)	Load address of base of array gx
												   >	138:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	139:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	140:     LD  4,-34(1)	Pop left into ac1 
												   >	141:    SUB  3,4,3	compute location from index 
												   >	142:     LD  3,0(3)	Load array element 
												   >	143:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	144:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	145:    LDA  3,1(7)	Return address in ac 
												   >	146:    JMP  7,-141(7)	CALL output
												   >	147:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	148:    LDC  3,4(6)	Load integer constant 
												   >	149:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	150:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -32
												   >	151:     LD  4,-32(1)	Pop index 
												   >	152:    LDA  5,-9(0)	Load address of base of array gy
												   >	153:    SUB  5,5,4	Compute offset of value 
												   >	154:     ST  3,0(5)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	155:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	156:    LDA  3,-9(0)	Load address of base of array gy
												   >	157:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	158:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	159:     LD  4,-34(1)	Pop left into ac1 
												   >	160:    SUB  3,4,3	compute location from index 
												   >	161:     LD  3,0(3)	Load array element 
												   >	162:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	163:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	164:    LDA  3,1(7)	Return address in ac 
												   >	165:    JMP  7,-160(7)	CALL output
												   >	166:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	167:    LDC  3,3(6)	Load integer constant 
												   >	168:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	169:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -32
												   >	170:     LD  4,-32(1)	Pop index 
												   >	171:    LDA  5,-16(0)	Load address of base of array ga
												   >	172:    SUB  5,5,4	Compute offset of value 
												   >	173:     ST  3,0(5)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	174:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	175:    LDA  3,-16(0)	Load address of base of array ga
												   >	176:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	177:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	178:     LD  4,-34(1)	Pop left into ac1 
												   >	179:    SUB  3,4,3	compute location from index 
												   >	180:     LD  3,0(3)	Load array element 
												   >	181:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	182:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	183:    LDA  3,1(7)	Return address in ac 
												   >	184:    JMP  7,-168(7)	CALL outputb
												   >	185:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	186:    LDC  3,2(6)	Load integer constant 
												   >	187:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	188:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -32
												   >	189:     LD  4,-32(1)	Pop index 
												   >	190:    LDA  5,-22(0)	Load address of base of array gb
												   >	191:    SUB  5,5,4	Compute offset of value 
												   >	192:     ST  3,0(5)	Store variable gb
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	193:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	194:    LDA  3,-22(0)	Load address of base of array gb
												   >	195:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	196:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	197:     LD  4,-34(1)	Pop left into ac1 
												   >	198:    SUB  3,4,3	compute location from index 
												   >	199:     LD  3,0(3)	Load array element 
												   >	200:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	201:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	202:    LDA  3,1(7)	Return address in ac 
												   >	203:    JMP  7,-187(7)	CALL outputb
												   >	204:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	205:     ST  1,-32(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param end outnl
												   >	206:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	207:    LDA  3,1(7)	Return address in ac 
												   >	208:    JMP  7,-175(7)	CALL outnl
												   >	209:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	210:    LDC  3,5(6)	Load integer constant 
												   >	211:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	212:    LDA  3,-12(1)	Load address of base of array y
												   >	213:     ST  3,-33(1)	Push left side 
												   >	* TOFF dec: -34
												   >	214:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -33
												   >	215:     LD  4,-33(1)	Pop left into ac1 
												   >	216:    SUB  3,4,3	compute location from index 
												   >	217:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -32
												   >	218:     LD  4,-32(1)	Pop index 
												   >	219:    LDA  5,-3(1)	Load address of base of array x
												   >	220:    SUB  5,5,4	Compute offset of value 
												   >	221:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	222:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	223:    LDA  3,-3(1)	Load address of base of array x
												   >	224:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	225:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	226:     LD  4,-34(1)	Pop left into ac1 
												   >	227:    SUB  3,4,3	compute location from index 
												   >	228:     LD  3,0(3)	Load array element 
												   >	229:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	230:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	231:    LDA  3,1(7)	Return address in ac 
												   >	232:    JMP  7,-227(7)	CALL output
												   >	233:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	234:    LDC  3,3(6)	Load integer constant 
												   >	235:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	236:    LDA  3,-27(1)	Load address of base of array b
												   >	237:     ST  3,-33(1)	Push left side 
												   >	* TOFF dec: -34
												   >	238:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -33
												   >	239:     LD  4,-33(1)	Pop left into ac1 
												   >	240:    SUB  3,4,3	compute location from index 
												   >	241:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -32
												   >	242:     LD  4,-32(1)	Pop index 
												   >	243:    LDA  5,-20(1)	Load address of base of array a
												   >	244:    SUB  5,5,4	Compute offset of value 
												   >	245:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	246:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	247:    LDA  3,-20(1)	Load address of base of array a
												   >	248:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	249:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	250:     LD  4,-34(1)	Pop left into ac1 
												   >	251:    SUB  3,4,3	compute location from index 
												   >	252:     LD  3,0(3)	Load array element 
												   >	253:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	254:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	255:    LDA  3,1(7)	Return address in ac 
												   >	256:    JMP  7,-240(7)	CALL outputb
												   >	257:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	258:     ST  1,-32(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param end outnl
												   >	259:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	260:    LDA  3,1(7)	Return address in ac 
												   >	261:    JMP  7,-228(7)	CALL outnl
												   >	262:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	263:    LDC  3,5(6)	Load integer constant 
												   >	264:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	265:    LDA  3,-9(0)	Load address of base of array gy
												   >	266:     ST  3,-33(1)	Push left side 
												   >	* TOFF dec: -34
												   >	267:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -33
												   >	268:     LD  4,-33(1)	Pop left into ac1 
												   >	269:    SUB  3,4,3	compute location from index 
												   >	270:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -32
												   >	271:     LD  4,-32(1)	Pop index 
												   >	272:    LDA  5,-1(0)	Load address of base of array gx
												   >	273:    SUB  5,5,4	Compute offset of value 
												   >	274:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	275:     ST  1,-32(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	276:    LDA  3,-1(0)	Load address of base of array gx
												   >	277:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	278:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	279:     LD  4,-34(1)	Pop left into ac1 
												   >	280:    SUB  3,4,3	compute location from index 
												   >	281:     LD  3,0(3)	Load array element 
												   >	282:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end output
												   >	283:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	284:    LDA  3,1(7)	Return address in ac 
												   >	285:    JMP  7,-280(7)	CALL output
												   >	286:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	287:    LDC  3,3(6)	Load integer constant 
												   >	288:     ST  3,-32(1)	Push index 
												   >	* TOFF dec: -33
												   >	289:    LDA  3,-22(0)	Load address of base of array gb
												   >	290:     ST  3,-33(1)	Push left side 
												   >	* TOFF dec: -34
												   >	291:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -33
												   >	292:     LD  4,-33(1)	Pop left into ac1 
												   >	293:    SUB  3,4,3	compute location from index 
												   >	294:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -32
												   >	295:     LD  4,-32(1)	Pop index 
												   >	296:    LDA  5,-16(0)	Load address of base of array ga
												   >	297:    SUB  5,5,4	Compute offset of value 
												   >	298:     ST  3,0(5)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	299:     ST  1,-32(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	300:    LDA  3,-16(0)	Load address of base of array ga
												   >	301:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	302:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	303:     LD  4,-34(1)	Pop left into ac1 
												   >	304:    SUB  3,4,3	compute location from index 
												   >	305:     LD  3,0(3)	Load array element 
												   >	306:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end outputb
												   >	307:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	308:    LDA  3,1(7)	Return address in ac 
												   >	309:    JMP  7,-293(7)	CALL outputb
												   >	310:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -32
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	311:     ST  1,-32(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param end outnl
												   >	312:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	313:    LDA  3,1(7)	Return address in ac 
												   >	314:    JMP  7,-281(7)	CALL outnl
												   >	315:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -32
												   >	* RETURN
												   >	316:     LD  3,-1(1)	Load return address 
												   >	317:     LD  1,0(1)	Adjust fp 
												   >	318:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	319:    LDC  2,0(6)	Set return value to 0 
												   >	320:     LD  3,-1(1)	Load return address 
												   >	321:     LD  1,0(1)	Adjust fp 
												   >	322:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,322(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	323:    LDA  1,-26(0)	set first frame at end of globals 
												   >	324:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	325:    LDC  3,5(6)	load size of array ga
												   >	326:     ST  3,-15(0)	save size of array ga
												   >	327:    LDC  3,4(6)	load size of array gb
												   >	328:     ST  3,-21(0)	save size of array gb
												   >	329:    LDC  3,7(6)	load size of array gx
												   >	330:     ST  3,0(0)	save size of array gx
												   >	331:    LDC  3,6(6)	load size of array gy
												   >	332:     ST  3,-8(0)	save size of array gy
												   >	* END INIT GLOBALS AND STATICS
												   >	333:    LDA  3,1(7)	Return address in ac 
												   >	334:    JMP  7,-296(7)	Jump to main 
												   >	335:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign2.mem assign2.mem.f21 differ: byte 1, line 1
assign2 (MEM DIFF)
Var: gx of array of type int [mem: Global loc: -1 size: 8] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: gy of array of type int [mem: Global loc: -9 size: 7] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 2]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Var: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 2]		   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]		   |	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: gx of array of type int [mem: Global loc: -1 size: 8] [line: 1]
												   >	Sibling: 8  Var: gy of array of type int [mem: Global loc: -9 size: 7] [line: 1]
												   >	Sibling: 9  Var: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 2]
												   >	Sibling: 10  Var: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 2]
												   >	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -32] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -32] [line: 5]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 9] [line: 6]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 9] [line: 6]
.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -12 size: 8] [line: 6]			.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -12 size: 8] [line: 6]
.   .   Sibling: 2  Var: a of array of type bool [mem: Local loc: -20 size: 7] [line: 7]		.   .   Sibling: 2  Var: a of array of type bool [mem: Local loc: -20 size: 7] [line: 7]
.   .   Sibling: 3  Var: b of array of type bool [mem: Local loc: -27 size: 6] [line: 7]		.   .   Sibling: 3  Var: b of array of type bool [mem: Local loc: -27 size: 6] [line: 7]
.   .   Child: 1  Assign: = of type int [line: 9]						   |	.   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 9]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 9]
.   .   .   .   Child: 1  Const 5 of type int [line: 9]							.   .   .   .   Child: 1  Const 5 of type int [line: 9]
.   .   .   Child: 1  Const 111 of type int [line: 9]							.   .   .   Child: 1  Const 111 of type int [line: 9]
.   .   Sibling: 1  Call: output of type void [line: 10]						.   .   Sibling: 1  Call: output of type void [line: 10]
.   .   .   Child: 0  Op: [ of type int [line: 10]							.   .   .   Child: 0  Op: [ of type int [line: 10]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 10]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 10]
.   .   .   .   Child: 1  Const 5 of type int [line: 10]						.   .   .   .   Child: 1  Const 5 of type int [line: 10]
.   .   Sibling: 2  Assign: = of type int [line: 11]						   |	.   .   Sibling: 2  Assign: := of type int [line: 11]
.   .   .   Child: 0  Op: [ of type int [line: 11]							.   .   .   Child: 0  Op: [ of type int [line: 11]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 11]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 11]
.   .   .   .   Child: 1  Const 4 of type int [line: 11]						.   .   .   .   Child: 1  Const 4 of type int [line: 11]
.   .   .   Child: 1  Const 222 of type int [line: 11]							.   .   .   Child: 1  Const 222 of type int [line: 11]
.   .   Sibling: 3  Call: output of type void [line: 12]						.   .   Sibling: 3  Call: output of type void [line: 12]
.   .   .   Child: 0  Op: [ of type int [line: 12]							.   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 12]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 12]
.   .   .   .   Child: 1  Const 4 of type int [line: 12]						.   .   .   .   Child: 1  Const 4 of type int [line: 12]
.   .   Sibling: 4  Assign: = of type bool [line: 13]						   |	.   .   Sibling: 4  Assign: := of type bool [line: 13]
.   .   .   Child: 0  Op: [ of type bool [line: 13]							.   .   .   Child: 0  Op: [ of type bool [line: 13]
.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 13]		.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 13]
.   .   .   .   Child: 1  Const 3 of type int [line: 13]						.   .   .   .   Child: 1  Const 3 of type int [line: 13]
.   .   .   Child: 1  Const true of type bool [line: 13]						.   .   .   Child: 1  Const true of type bool [line: 13]
.   .   Sibling: 5  Call: outputb of type void [line: 14]						.   .   Sibling: 5  Call: outputb of type void [line: 14]
.   .   .   Child: 0  Op: [ of type bool [line: 14]							.   .   .   Child: 0  Op: [ of type bool [line: 14]
.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 14]		.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 14]
.   .   .   .   Child: 1  Const 3 of type int [line: 14]						.   .   .   .   Child: 1  Const 3 of type int [line: 14]
.   .   Sibling: 6  Assign: = of type bool [line: 15]						   |	.   .   Sibling: 6  Assign: := of type bool [line: 15]
.   .   .   Child: 0  Op: [ of type bool [line: 15]							.   .   .   Child: 0  Op: [ of type bool [line: 15]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 15]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 15]
.   .   .   .   Child: 1  Const 2 of type int [line: 15]						.   .   .   .   Child: 1  Const 2 of type int [line: 15]
.   .   .   Child: 1  Const false of type bool [line: 15]						.   .   .   Child: 1  Const false of type bool [line: 15]
.   .   Sibling: 7  Call: outputb of type void [line: 16]						.   .   Sibling: 7  Call: outputb of type void [line: 16]
.   .   .   Child: 0  Op: [ of type bool [line: 16]							.   .   .   Child: 0  Op: [ of type bool [line: 16]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 16]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 16]
.   .   .   .   Child: 1  Const 2 of type int [line: 16]						.   .   .   .   Child: 1  Const 2 of type int [line: 16]
.   .   Sibling: 8  Call: outnl of type void [line: 17]							.   .   Sibling: 8  Call: outnl of type void [line: 17]
.   .   Sibling: 9  Assign: = of type int [line: 19]						   |	.   .   Sibling: 9  Assign: := of type int [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 19]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 19]
.   .   .   .   Child: 1  Const 5 of type int [line: 19]						.   .   .   .   Child: 1  Const 5 of type int [line: 19]
.   .   .   Child: 1  Const 333 of type int [line: 19]							.   .   .   Child: 1  Const 333 of type int [line: 19]
.   .   Sibling: 10  Call: output of type void [line: 20]						.   .   Sibling: 10  Call: output of type void [line: 20]
.   .   .   Child: 0  Op: [ of type int [line: 20]							.   .   .   Child: 0  Op: [ of type int [line: 20]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 20]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 20]
.   .   .   .   Child: 1  Const 5 of type int [line: 20]						.   .   .   .   Child: 1  Const 5 of type int [line: 20]
.   .   Sibling: 11  Assign: = of type int [line: 21]						   |	.   .   Sibling: 11  Assign: := of type int [line: 21]
.   .   .   Child: 0  Op: [ of type int [line: 21]							.   .   .   Child: 0  Op: [ of type int [line: 21]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 21]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 21]
.   .   .   .   Child: 1  Const 4 of type int [line: 21]						.   .   .   .   Child: 1  Const 4 of type int [line: 21]
.   .   .   Child: 1  Const 444 of type int [line: 21]							.   .   .   Child: 1  Const 444 of type int [line: 21]
.   .   Sibling: 12  Call: output of type void [line: 22]						.   .   Sibling: 12  Call: output of type void [line: 22]
.   .   .   Child: 0  Op: [ of type int [line: 22]							.   .   .   Child: 0  Op: [ of type int [line: 22]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 22]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 22]
.   .   .   .   Child: 1  Const 4 of type int [line: 22]						.   .   .   .   Child: 1  Const 4 of type int [line: 22]
.   .   Sibling: 13  Assign: = of type bool [line: 23]						   |	.   .   Sibling: 13  Assign: := of type bool [line: 23]
.   .   .   Child: 0  Op: [ of type bool [line: 23]							.   .   .   Child: 0  Op: [ of type bool [line: 23]
.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 23]	.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 23]
.   .   .   .   Child: 1  Const 3 of type int [line: 23]						.   .   .   .   Child: 1  Const 3 of type int [line: 23]
.   .   .   Child: 1  Const false of type bool [line: 23]						.   .   .   Child: 1  Const false of type bool [line: 23]
.   .   Sibling: 14  Call: outputb of type void [line: 24]						.   .   Sibling: 14  Call: outputb of type void [line: 24]
.   .   .   Child: 0  Op: [ of type bool [line: 24]							.   .   .   Child: 0  Op: [ of type bool [line: 24]
.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 24]	.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 24]
.   .   .   .   Child: 1  Const 3 of type int [line: 24]						.   .   .   .   Child: 1  Const 3 of type int [line: 24]
.   .   Sibling: 15  Assign: = of type bool [line: 25]						   |	.   .   Sibling: 15  Assign: := of type bool [line: 25]
.   .   .   Child: 0  Op: [ of type bool [line: 25]							.   .   .   Child: 0  Op: [ of type bool [line: 25]
.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 25]	.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 25]
.   .   .   .   Child: 1  Const 2 of type int [line: 25]						.   .   .   .   Child: 1  Const 2 of type int [line: 25]
.   .   .   Child: 1  Const true of type bool [line: 25]						.   .   .   Child: 1  Const true of type bool [line: 25]
.   .   Sibling: 16  Call: outputb of type void [line: 26]						.   .   Sibling: 16  Call: outputb of type void [line: 26]
.   .   .   Child: 0  Op: [ of type bool [line: 26]							.   .   .   Child: 0  Op: [ of type bool [line: 26]
.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 26]	.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 26]
.   .   .   .   Child: 1  Const 2 of type int [line: 26]						.   .   .   .   Child: 1  Const 2 of type int [line: 26]
.   .   Sibling: 17  Call: outnl of type void [line: 27]						.   .   Sibling: 17  Call: outnl of type void [line: 27]
.   .   Sibling: 18  Assign: = of type int [line: 29]						   |	.   .   Sibling: 18  Assign: := of type int [line: 29]
.   .   .   Child: 0  Op: [ of type int [line: 29]							.   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 29]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 29]
.   .   .   .   Child: 1  Const 5 of type int [line: 29]						.   .   .   .   Child: 1  Const 5 of type int [line: 29]
.   .   .   Child: 1  Op: [ of type int [line: 29]							.   .   .   Child: 1  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 29]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 29]
.   .   .   .   Child: 1  Const 4 of type int [line: 29]						.   .   .   .   Child: 1  Const 4 of type int [line: 29]
.   .   Sibling: 19  Call: output of type void [line: 30]						.   .   Sibling: 19  Call: output of type void [line: 30]
.   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 30]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 30]
.   .   .   .   Child: 1  Const 5 of type int [line: 30]						.   .   .   .   Child: 1  Const 5 of type int [line: 30]
.   .   Sibling: 20  Assign: = of type bool [line: 31]						   |	.   .   Sibling: 20  Assign: := of type bool [line: 31]
.   .   .   Child: 0  Op: [ of type bool [line: 31]							.   .   .   Child: 0  Op: [ of type bool [line: 31]
.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 31]		.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 31]
.   .   .   .   Child: 1  Const 3 of type int [line: 31]						.   .   .   .   Child: 1  Const 3 of type int [line: 31]
.   .   .   Child: 1  Op: [ of type bool [line: 31]							.   .   .   Child: 1  Op: [ of type bool [line: 31]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 31]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -27 size: 6] [line: 31]
.   .   .   .   Child: 1  Const 2 of type int [line: 31]						.   .   .   .   Child: 1  Const 2 of type int [line: 31]
.   .   Sibling: 21  Call: outputb of type void [line: 32]						.   .   Sibling: 21  Call: outputb of type void [line: 32]
.   .   .   Child: 0  Op: [ of type bool [line: 32]							.   .   .   Child: 0  Op: [ of type bool [line: 32]
.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 32]		.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -20 size: 7] [line: 32]
.   .   .   .   Child: 1  Const 3 of type int [line: 32]						.   .   .   .   Child: 1  Const 3 of type int [line: 32]
.   .   Sibling: 22  Call: outnl of type void [line: 33]						.   .   Sibling: 22  Call: outnl of type void [line: 33]
.   .   Sibling: 23  Assign: = of type int [line: 35]						   |	.   .   Sibling: 23  Assign: := of type int [line: 35]
.   .   .   Child: 0  Op: [ of type int [line: 35]							.   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 35]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 35]
.   .   .   .   Child: 1  Const 5 of type int [line: 35]						.   .   .   .   Child: 1  Const 5 of type int [line: 35]
.   .   .   Child: 1  Op: [ of type int [line: 35]							.   .   .   Child: 1  Op: [ of type int [line: 35]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 35]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 35]
.   .   .   .   Child: 1  Const 4 of type int [line: 35]						.   .   .   .   Child: 1  Const 4 of type int [line: 35]
.   .   Sibling: 24  Call: output of type void [line: 36]						.   .   Sibling: 24  Call: output of type void [line: 36]
.   .   .   Child: 0  Op: [ of type int [line: 36]							.   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 36]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 36]
.   .   .   .   Child: 1  Const 5 of type int [line: 36]						.   .   .   .   Child: 1  Const 5 of type int [line: 36]
.   .   Sibling: 25  Assign: = of type bool [line: 37]						   |	.   .   Sibling: 25  Assign: := of type bool [line: 37]
.   .   .   Child: 0  Op: [ of type bool [line: 37]							.   .   .   Child: 0  Op: [ of type bool [line: 37]
.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 37]	.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 37]
.   .   .   .   Child: 1  Const 3 of type int [line: 37]						.   .   .   .   Child: 1  Const 3 of type int [line: 37]
.   .   .   Child: 1  Op: [ of type bool [line: 37]							.   .   .   Child: 1  Op: [ of type bool [line: 37]
.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 37]	.   .   .   .   Child: 0  Id: gb of array of type bool [mem: Global loc: -22 size: 5] [line: 37]
.   .   .   .   Child: 1  Const 2 of type int [line: 37]						.   .   .   .   Child: 1  Const 2 of type int [line: 37]
.   .   Sibling: 26  Call: outputb of type void [line: 38]						.   .   Sibling: 26  Call: outputb of type void [line: 38]
.   .   .   Child: 0  Op: [ of type bool [line: 38]							.   .   .   Child: 0  Op: [ of type bool [line: 38]
.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 38]	.   .   .   .   Child: 0  Id: ga of array of type bool [mem: Global loc: -16 size: 6] [line: 38]
.   .   .   .   Child: 1  Const 3 of type int [line: 38]						.   .   .   .   Child: 1  Const 3 of type int [line: 38]
.   .   Sibling: 27  Call: outnl of type void [line: 39]						.   .   Sibling: 27  Call: outnl of type void [line: 39]
.   .   Sibling: 28  Return [line: 41]									.   .   Sibling: 28  Return [line: 41]
Offset for end of global space: -26									Offset for end of global space: -26
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign2.out ztmp23114.txt differ: byte 1, line 1
assign2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign2.tm
Number of errors: 0										   |	111 222 T F
------------------------------------								   |	333 444 F T
Loading file: assign2.tm									   |	222 F
												   >	444 T
Bye.													Bye.
====================================
FILE: assign3.c-
-rw-------. 1 corg7983 domain_users   628 Nov 17 15:35 assign3.c-
-rw-------. 1 corg7983 domain_users   628 Nov 17 15:35 assign3.c-.f21
-rw-------. 1 corg7983 domain_users   628 Nov 17 15:35 assign3.c-.f22
-rw-------. 1 corg7983 domain_users    85 Nov 17 15:35 assign3.expected
-rw-------. 1 corg7983 domain_users  8471 Nov 22 12:27 assign3.mem
-rw-------. 1 corg7983 domain_users     0 Nov 17 15:35 assign3.mem.diffs
-rw-------. 1 corg7983 domain_users  9312 Nov 17 15:35 assign3.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign3.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign3.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign3.tm.diffs
-rw-------. 1 corg7983 domain_users 20330 Nov 17 15:35 assign3.tm.f21
TM CODE COMPARISON
assign3 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign3.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -19
												   >	 40:    LDC  3,8(6)	load size of array x
												   >	 41:     ST  3,-2(1)	save size of array x
												   >	 42:    LDC  3,7(6)	load size of array y
												   >	 43:     ST  3,-11(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 44:    LDC  3,5(6)	Load integer constant 
												   >	 45:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	 46:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	 47:     LD  4,-19(1)	Pop index 
												   >	 48:    LDA  5,-3(1)	Load address of base of array x
												   >	 49:    SUB  5,5,4	Compute offset of value 
												   >	 50:     LD  4,0(5)	load lhs variable x
												   >	 51:    ADD  3,4,3	op += 
												   >	 52:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 53:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	 54:    LDA  3,-3(1)	Load address of base of array x
												   >	 55:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	 56:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	 57:     LD  4,-21(1)	Pop left into ac1 
												   >	 58:    SUB  3,4,3	compute location from index 
												   >	 59:     LD  3,0(3)	Load array element 
												   >	 60:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	 61:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	 62:    LDA  3,1(7)	Return address in ac 
												   >	 63:    JMP  7,-58(7)	CALL output
												   >	 64:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	 65:    LDC  3,4(6)	Load integer constant 
												   >	 66:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	 67:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	 68:     LD  4,-19(1)	Pop index 
												   >	 69:    LDA  5,-12(1)	Load address of base of array y
												   >	 70:    SUB  5,5,4	Compute offset of value 
												   >	 71:     LD  4,0(5)	load lhs variable y
												   >	 72:    ADD  3,4,3	op += 
												   >	 73:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 74:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	 75:    LDA  3,-12(1)	Load address of base of array y
												   >	 76:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	 77:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	 78:     LD  4,-21(1)	Pop left into ac1 
												   >	 79:    SUB  3,4,3	compute location from index 
												   >	 80:     LD  3,0(3)	Load array element 
												   >	 81:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	 82:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	 83:    LDA  3,1(7)	Return address in ac 
												   >	 84:    JMP  7,-79(7)	CALL output
												   >	 85:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 86:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	 87:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-56(7)	CALL outnl
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	 91:    LDC  3,5(6)	Load integer constant 
												   >	 92:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	 93:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	 94:     LD  4,-19(1)	Pop index 
												   >	 95:    LDA  5,-1(0)	Load address of base of array gx
												   >	 96:    SUB  5,5,4	Compute offset of value 
												   >	 97:     LD  4,0(5)	load lhs variable gx
												   >	 98:    ADD  3,4,3	op += 
												   >	 99:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	100:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	101:    LDA  3,-1(0)	Load address of base of array gx
												   >	102:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	103:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	104:     LD  4,-21(1)	Pop left into ac1 
												   >	105:    SUB  3,4,3	compute location from index 
												   >	106:     LD  3,0(3)	Load array element 
												   >	107:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	108:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-105(7)	CALL output
												   >	111:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	112:    LDC  3,4(6)	Load integer constant 
												   >	113:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	114:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	115:     LD  4,-19(1)	Pop index 
												   >	116:    LDA  5,-9(0)	Load address of base of array gy
												   >	117:    SUB  5,5,4	Compute offset of value 
												   >	118:     LD  4,0(5)	load lhs variable gy
												   >	119:    ADD  3,4,3	op += 
												   >	120:     ST  3,0(5)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	121:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	122:    LDA  3,-9(0)	Load address of base of array gy
												   >	123:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	124:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	125:     LD  4,-21(1)	Pop left into ac1 
												   >	126:    SUB  3,4,3	compute location from index 
												   >	127:     LD  3,0(3)	Load array element 
												   >	128:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	129:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	130:    LDA  3,1(7)	Return address in ac 
												   >	131:    JMP  7,-126(7)	CALL output
												   >	132:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	133:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	134:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	135:    LDA  3,1(7)	Return address in ac 
												   >	136:    JMP  7,-103(7)	CALL outnl
												   >	137:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	138:    LDC  3,5(6)	Load integer constant 
												   >	139:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	140:    LDA  3,-12(1)	Load address of base of array y
												   >	141:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	142:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	143:     LD  4,-20(1)	Pop left into ac1 
												   >	144:    SUB  3,4,3	compute location from index 
												   >	145:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -19
												   >	146:     LD  4,-19(1)	Pop index 
												   >	147:    LDA  5,-3(1)	Load address of base of array x
												   >	148:    SUB  5,5,4	Compute offset of value 
												   >	149:     LD  4,0(5)	load lhs variable x
												   >	150:    ADD  3,4,3	op += 
												   >	151:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	152:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	153:    LDA  3,-3(1)	Load address of base of array x
												   >	154:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	155:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	156:     LD  4,-21(1)	Pop left into ac1 
												   >	157:    SUB  3,4,3	compute location from index 
												   >	158:     LD  3,0(3)	Load array element 
												   >	159:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	160:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	161:    LDA  3,1(7)	Return address in ac 
												   >	162:    JMP  7,-157(7)	CALL output
												   >	163:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	164:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	165:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-134(7)	CALL outnl
												   >	168:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	169:    LDC  3,5(6)	Load integer constant 
												   >	170:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	171:    LDA  3,-9(0)	Load address of base of array gy
												   >	172:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	173:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	174:     LD  4,-20(1)	Pop left into ac1 
												   >	175:    SUB  3,4,3	compute location from index 
												   >	176:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -19
												   >	177:     LD  4,-19(1)	Pop index 
												   >	178:    LDA  5,-1(0)	Load address of base of array gx
												   >	179:    SUB  5,5,4	Compute offset of value 
												   >	180:     LD  4,0(5)	load lhs variable gx
												   >	181:    ADD  3,4,3	op += 
												   >	182:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	183:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	184:    LDA  3,-1(0)	Load address of base of array gx
												   >	185:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	186:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	187:     LD  4,-21(1)	Pop left into ac1 
												   >	188:    SUB  3,4,3	compute location from index 
												   >	189:     LD  3,0(3)	Load array element 
												   >	190:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	191:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	192:    LDA  3,1(7)	Return address in ac 
												   >	193:    JMP  7,-188(7)	CALL output
												   >	194:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	195:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	196:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	197:    LDA  3,1(7)	Return address in ac 
												   >	198:    JMP  7,-165(7)	CALL outnl
												   >	199:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	200:    LDC  3,5(6)	Load integer constant 
												   >	201:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	202:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	203:     LD  4,-19(1)	Pop index 
												   >	204:    LDA  5,-3(1)	Load address of base of array x
												   >	205:    SUB  5,5,4	Compute offset of value 
												   >	206:     LD  4,0(5)	load lhs variable x
												   >	207:    SUB  3,4,3	op -= 
												   >	208:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	209:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	210:    LDA  3,-3(1)	Load address of base of array x
												   >	211:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	212:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	213:     LD  4,-21(1)	Pop left into ac1 
												   >	214:    SUB  3,4,3	compute location from index 
												   >	215:     LD  3,0(3)	Load array element 
												   >	216:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	217:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	218:    LDA  3,1(7)	Return address in ac 
												   >	219:    JMP  7,-214(7)	CALL output
												   >	220:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	221:    LDC  3,4(6)	Load integer constant 
												   >	222:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	223:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	224:     LD  4,-19(1)	Pop index 
												   >	225:    LDA  5,-12(1)	Load address of base of array y
												   >	226:    SUB  5,5,4	Compute offset of value 
												   >	227:     LD  4,0(5)	load lhs variable y
												   >	228:    SUB  3,4,3	op -= 
												   >	229:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	230:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	231:    LDA  3,-12(1)	Load address of base of array y
												   >	232:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	233:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	234:     LD  4,-21(1)	Pop left into ac1 
												   >	235:    SUB  3,4,3	compute location from index 
												   >	236:     LD  3,0(3)	Load array element 
												   >	237:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	238:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	239:    LDA  3,1(7)	Return address in ac 
												   >	240:    JMP  7,-235(7)	CALL output
												   >	241:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	242:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	243:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	244:    LDA  3,1(7)	Return address in ac 
												   >	245:    JMP  7,-212(7)	CALL outnl
												   >	246:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	247:    LDC  3,5(6)	Load integer constant 
												   >	248:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	249:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	250:     LD  4,-19(1)	Pop index 
												   >	251:    LDA  5,-1(0)	Load address of base of array gx
												   >	252:    SUB  5,5,4	Compute offset of value 
												   >	253:     LD  4,0(5)	load lhs variable gx
												   >	254:    SUB  3,4,3	op -= 
												   >	255:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	256:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	257:    LDA  3,-1(0)	Load address of base of array gx
												   >	258:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	259:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	260:     LD  4,-21(1)	Pop left into ac1 
												   >	261:    SUB  3,4,3	compute location from index 
												   >	262:     LD  3,0(3)	Load array element 
												   >	263:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	264:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	265:    LDA  3,1(7)	Return address in ac 
												   >	266:    JMP  7,-261(7)	CALL output
												   >	267:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	268:    LDC  3,4(6)	Load integer constant 
												   >	269:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	270:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	271:     LD  4,-19(1)	Pop index 
												   >	272:    LDA  5,-9(0)	Load address of base of array gy
												   >	273:    SUB  5,5,4	Compute offset of value 
												   >	274:     LD  4,0(5)	load lhs variable gy
												   >	275:    SUB  3,4,3	op -= 
												   >	276:     ST  3,0(5)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	277:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	278:    LDA  3,-9(0)	Load address of base of array gy
												   >	279:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	280:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	281:     LD  4,-21(1)	Pop left into ac1 
												   >	282:    SUB  3,4,3	compute location from index 
												   >	283:     LD  3,0(3)	Load array element 
												   >	284:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	285:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	286:    LDA  3,1(7)	Return address in ac 
												   >	287:    JMP  7,-282(7)	CALL output
												   >	288:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	289:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	290:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	291:    LDA  3,1(7)	Return address in ac 
												   >	292:    JMP  7,-259(7)	CALL outnl
												   >	293:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	294:    LDC  3,5(6)	Load integer constant 
												   >	295:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	296:    LDA  3,-12(1)	Load address of base of array y
												   >	297:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	298:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	299:     LD  4,-20(1)	Pop left into ac1 
												   >	300:    SUB  3,4,3	compute location from index 
												   >	301:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -19
												   >	302:     LD  4,-19(1)	Pop index 
												   >	303:    LDA  5,-3(1)	Load address of base of array x
												   >	304:    SUB  5,5,4	Compute offset of value 
												   >	305:     LD  4,0(5)	load lhs variable x
												   >	306:    SUB  3,4,3	op -= 
												   >	307:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	308:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	309:    LDA  3,-3(1)	Load address of base of array x
												   >	310:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	311:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	312:     LD  4,-21(1)	Pop left into ac1 
												   >	313:    SUB  3,4,3	compute location from index 
												   >	314:     LD  3,0(3)	Load array element 
												   >	315:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	316:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	317:    LDA  3,1(7)	Return address in ac 
												   >	318:    JMP  7,-313(7)	CALL output
												   >	319:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	320:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	321:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	322:    LDA  3,1(7)	Return address in ac 
												   >	323:    JMP  7,-290(7)	CALL outnl
												   >	324:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	325:    LDC  3,5(6)	Load integer constant 
												   >	326:     ST  3,-19(1)	Push index 
												   >	* TOFF dec: -20
												   >	327:    LDA  3,-9(0)	Load address of base of array gy
												   >	328:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	329:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	330:     LD  4,-20(1)	Pop left into ac1 
												   >	331:    SUB  3,4,3	compute location from index 
												   >	332:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -19
												   >	333:     LD  4,-19(1)	Pop index 
												   >	334:    LDA  5,-1(0)	Load address of base of array gx
												   >	335:    SUB  5,5,4	Compute offset of value 
												   >	336:     LD  4,0(5)	load lhs variable gx
												   >	337:    SUB  3,4,3	op -= 
												   >	338:     ST  3,0(5)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	339:     ST  1,-19(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param 1
												   >	340:    LDA  3,-1(0)	Load address of base of array gx
												   >	341:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	342:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	343:     LD  4,-21(1)	Pop left into ac1 
												   >	344:    SUB  3,4,3	compute location from index 
												   >	345:     LD  3,0(3)	Load array element 
												   >	346:     ST  3,-21(1)	Push parameter 
												   >	* TOFF dec: -22
												   >	* Param end output
												   >	347:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	348:    LDA  3,1(7)	Return address in ac 
												   >	349:    JMP  7,-344(7)	CALL output
												   >	350:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -19
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	351:     ST  1,-19(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -20
												   >	* TOFF dec: -21
												   >	* Param end outnl
												   >	352:    LDA  1,-19(1)	Ghost frame becomes new active frame 
												   >	353:    LDA  3,1(7)	Return address in ac 
												   >	354:    JMP  7,-321(7)	CALL outnl
												   >	355:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -19
												   >	* RETURN
												   >	356:     LD  3,-1(1)	Load return address 
												   >	357:     LD  1,0(1)	Adjust fp 
												   >	358:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	359:    LDC  2,0(6)	Set return value to 0 
												   >	360:     LD  3,-1(1)	Load return address 
												   >	361:     LD  1,0(1)	Adjust fp 
												   >	362:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,362(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	363:    LDA  1,-15(0)	set first frame at end of globals 
												   >	364:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	365:    LDC  3,7(6)	load size of array gx
												   >	366:     ST  3,0(0)	save size of array gx
												   >	367:    LDC  3,6(6)	load size of array gy
												   >	368:     ST  3,-8(0)	save size of array gy
												   >	* END INIT GLOBALS AND STATICS
												   >	369:    LDA  3,1(7)	Return address in ac 
												   >	370:    JMP  7,-332(7)	Jump to main 
												   >	371:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign3.mem assign3.mem.f21 differ: byte 1, line 1
assign3 (MEM DIFF)
Var: gx of array of type int [mem: Global loc: -1 size: 8] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: gy of array of type int [mem: Global loc: -9 size: 7] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: gx of array of type int [mem: Global loc: -1 size: 8] [line: 1]
												   >	Sibling: 8  Var: gy of array of type int [mem: Global loc: -9 size: 7] [line: 1]
												   >	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -19] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -19] [line: 4]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 9] [line: 5]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 9] [line: 5]
.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -12 size: 8] [line: 5]			.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -12 size: 8] [line: 5]
.   .   Child: 1  Assign: += of type int [line: 7]							.   .   Child: 1  Assign: += of type int [line: 7]
.   .   .   Child: 0  Op: [ of type int [line: 7]							.   .   .   Child: 0  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 7]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 7]
.   .   .   .   Child: 1  Const 5 of type int [line: 7]							.   .   .   .   Child: 1  Const 5 of type int [line: 7]
.   .   .   Child: 1  Const 111 of type int [line: 7]							.   .   .   Child: 1  Const 111 of type int [line: 7]
.   .   Sibling: 1  Call: output of type void [line: 8]							.   .   Sibling: 1  Call: output of type void [line: 8]
.   .   .   Child: 0  Op: [ of type int [line: 8]							.   .   .   Child: 0  Op: [ of type int [line: 8]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 8]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 8]
.   .   .   .   Child: 1  Const 5 of type int [line: 8]							.   .   .   .   Child: 1  Const 5 of type int [line: 8]
.   .   Sibling: 2  Assign: += of type int [line: 9]							.   .   Sibling: 2  Assign: += of type int [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 9]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 9]
.   .   .   .   Child: 1  Const 4 of type int [line: 9]							.   .   .   .   Child: 1  Const 4 of type int [line: 9]
.   .   .   Child: 1  Const 222 of type int [line: 9]							.   .   .   Child: 1  Const 222 of type int [line: 9]
.   .   Sibling: 3  Call: output of type void [line: 10]						.   .   Sibling: 3  Call: output of type void [line: 10]
.   .   .   Child: 0  Op: [ of type int [line: 10]							.   .   .   Child: 0  Op: [ of type int [line: 10]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 10]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 10]
.   .   .   .   Child: 1  Const 4 of type int [line: 10]						.   .   .   .   Child: 1  Const 4 of type int [line: 10]
.   .   Sibling: 4  Call: outnl of type void [line: 11]							.   .   Sibling: 4  Call: outnl of type void [line: 11]
.   .   Sibling: 5  Assign: += of type int [line: 13]							.   .   Sibling: 5  Assign: += of type int [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 13]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 13]
.   .   .   .   Child: 1  Const 5 of type int [line: 13]						.   .   .   .   Child: 1  Const 5 of type int [line: 13]
.   .   .   Child: 1  Const 333 of type int [line: 13]							.   .   .   Child: 1  Const 333 of type int [line: 13]
.   .   Sibling: 6  Call: output of type void [line: 14]						.   .   Sibling: 6  Call: output of type void [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 14]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 14]
.   .   .   .   Child: 1  Const 5 of type int [line: 14]						.   .   .   .   Child: 1  Const 5 of type int [line: 14]
.   .   Sibling: 7  Assign: += of type int [line: 15]							.   .   Sibling: 7  Assign: += of type int [line: 15]
.   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 15]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 15]
.   .   .   .   Child: 1  Const 4 of type int [line: 15]						.   .   .   .   Child: 1  Const 4 of type int [line: 15]
.   .   .   Child: 1  Const 444 of type int [line: 15]							.   .   .   Child: 1  Const 444 of type int [line: 15]
.   .   Sibling: 8  Call: output of type void [line: 16]						.   .   Sibling: 8  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 16]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 16]
.   .   .   .   Child: 1  Const 4 of type int [line: 16]						.   .   .   .   Child: 1  Const 4 of type int [line: 16]
.   .   Sibling: 9  Call: outnl of type void [line: 17]							.   .   Sibling: 9  Call: outnl of type void [line: 17]
.   .   Sibling: 10  Assign: += of type int [line: 19]							.   .   Sibling: 10  Assign: += of type int [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 19]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 19]
.   .   .   .   Child: 1  Const 5 of type int [line: 19]						.   .   .   .   Child: 1  Const 5 of type int [line: 19]
.   .   .   Child: 1  Op: [ of type int [line: 19]							.   .   .   Child: 1  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 19]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 19]
.   .   .   .   Child: 1  Const 4 of type int [line: 19]						.   .   .   .   Child: 1  Const 4 of type int [line: 19]
.   .   Sibling: 11  Call: output of type void [line: 20]						.   .   Sibling: 11  Call: output of type void [line: 20]
.   .   .   Child: 0  Op: [ of type int [line: 20]							.   .   .   Child: 0  Op: [ of type int [line: 20]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 20]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 20]
.   .   .   .   Child: 1  Const 5 of type int [line: 20]						.   .   .   .   Child: 1  Const 5 of type int [line: 20]
.   .   Sibling: 12  Call: outnl of type void [line: 21]						.   .   Sibling: 12  Call: outnl of type void [line: 21]
.   .   Sibling: 13  Assign: += of type int [line: 23]							.   .   Sibling: 13  Assign: += of type int [line: 23]
.   .   .   Child: 0  Op: [ of type int [line: 23]							.   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 23]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 23]
.   .   .   .   Child: 1  Const 5 of type int [line: 23]						.   .   .   .   Child: 1  Const 5 of type int [line: 23]
.   .   .   Child: 1  Op: [ of type int [line: 23]							.   .   .   Child: 1  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 23]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 23]
.   .   .   .   Child: 1  Const 4 of type int [line: 23]						.   .   .   .   Child: 1  Const 4 of type int [line: 23]
.   .   Sibling: 14  Call: output of type void [line: 24]						.   .   Sibling: 14  Call: output of type void [line: 24]
.   .   .   Child: 0  Op: [ of type int [line: 24]							.   .   .   Child: 0  Op: [ of type int [line: 24]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 24]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 24]
.   .   .   .   Child: 1  Const 5 of type int [line: 24]						.   .   .   .   Child: 1  Const 5 of type int [line: 24]
.   .   Sibling: 15  Call: outnl of type void [line: 25]						.   .   Sibling: 15  Call: outnl of type void [line: 25]
.   .   Sibling: 16  Assign: -= of type int [line: 27]							.   .   Sibling: 16  Assign: -= of type int [line: 27]
.   .   .   Child: 0  Op: [ of type int [line: 27]							.   .   .   Child: 0  Op: [ of type int [line: 27]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 27]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 27]
.   .   .   .   Child: 1  Const 5 of type int [line: 27]						.   .   .   .   Child: 1  Const 5 of type int [line: 27]
.   .   .   Child: 1  Const 111 of type int [line: 27]							.   .   .   Child: 1  Const 111 of type int [line: 27]
.   .   Sibling: 17  Call: output of type void [line: 28]						.   .   Sibling: 17  Call: output of type void [line: 28]
.   .   .   Child: 0  Op: [ of type int [line: 28]							.   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 28]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 28]
.   .   .   .   Child: 1  Const 5 of type int [line: 28]						.   .   .   .   Child: 1  Const 5 of type int [line: 28]
.   .   Sibling: 18  Assign: -= of type int [line: 29]							.   .   Sibling: 18  Assign: -= of type int [line: 29]
.   .   .   Child: 0  Op: [ of type int [line: 29]							.   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 29]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 29]
.   .   .   .   Child: 1  Const 4 of type int [line: 29]						.   .   .   .   Child: 1  Const 4 of type int [line: 29]
.   .   .   Child: 1  Const 222 of type int [line: 29]							.   .   .   Child: 1  Const 222 of type int [line: 29]
.   .   Sibling: 19  Call: output of type void [line: 30]						.   .   Sibling: 19  Call: output of type void [line: 30]
.   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 30]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 30]
.   .   .   .   Child: 1  Const 4 of type int [line: 30]						.   .   .   .   Child: 1  Const 4 of type int [line: 30]
.   .   Sibling: 20  Call: outnl of type void [line: 31]						.   .   Sibling: 20  Call: outnl of type void [line: 31]
.   .   Sibling: 21  Assign: -= of type int [line: 33]							.   .   Sibling: 21  Assign: -= of type int [line: 33]
.   .   .   Child: 0  Op: [ of type int [line: 33]							.   .   .   Child: 0  Op: [ of type int [line: 33]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 33]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 33]
.   .   .   .   Child: 1  Const 5 of type int [line: 33]						.   .   .   .   Child: 1  Const 5 of type int [line: 33]
.   .   .   Child: 1  Const 333 of type int [line: 33]							.   .   .   Child: 1  Const 333 of type int [line: 33]
.   .   Sibling: 22  Call: output of type void [line: 34]						.   .   Sibling: 22  Call: output of type void [line: 34]
.   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 34]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 34]
.   .   .   .   Child: 1  Const 5 of type int [line: 34]						.   .   .   .   Child: 1  Const 5 of type int [line: 34]
.   .   Sibling: 23  Assign: -= of type int [line: 35]							.   .   Sibling: 23  Assign: -= of type int [line: 35]
.   .   .   Child: 0  Op: [ of type int [line: 35]							.   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 35]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 35]
.   .   .   .   Child: 1  Const 4 of type int [line: 35]						.   .   .   .   Child: 1  Const 4 of type int [line: 35]
.   .   .   Child: 1  Const 444 of type int [line: 35]							.   .   .   Child: 1  Const 444 of type int [line: 35]
.   .   Sibling: 24  Call: output of type void [line: 36]						.   .   Sibling: 24  Call: output of type void [line: 36]
.   .   .   Child: 0  Op: [ of type int [line: 36]							.   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 36]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 36]
.   .   .   .   Child: 1  Const 4 of type int [line: 36]						.   .   .   .   Child: 1  Const 4 of type int [line: 36]
.   .   Sibling: 25  Call: outnl of type void [line: 37]						.   .   Sibling: 25  Call: outnl of type void [line: 37]
.   .   Sibling: 26  Assign: -= of type int [line: 39]							.   .   Sibling: 26  Assign: -= of type int [line: 39]
.   .   .   Child: 0  Op: [ of type int [line: 39]							.   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 39]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 39]
.   .   .   .   Child: 1  Const 5 of type int [line: 39]						.   .   .   .   Child: 1  Const 5 of type int [line: 39]
.   .   .   Child: 1  Op: [ of type int [line: 39]							.   .   .   Child: 1  Op: [ of type int [line: 39]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 39]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -12 size: 8] [line: 39]
.   .   .   .   Child: 1  Const 4 of type int [line: 39]						.   .   .   .   Child: 1  Const 4 of type int [line: 39]
.   .   Sibling: 27  Call: output of type void [line: 40]						.   .   Sibling: 27  Call: output of type void [line: 40]
.   .   .   Child: 0  Op: [ of type int [line: 40]							.   .   .   Child: 0  Op: [ of type int [line: 40]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 40]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 9] [line: 40]
.   .   .   .   Child: 1  Const 5 of type int [line: 40]						.   .   .   .   Child: 1  Const 5 of type int [line: 40]
.   .   Sibling: 28  Call: outnl of type void [line: 41]						.   .   Sibling: 28  Call: outnl of type void [line: 41]
.   .   Sibling: 29  Assign: -= of type int [line: 43]							.   .   Sibling: 29  Assign: -= of type int [line: 43]
.   .   .   Child: 0  Op: [ of type int [line: 43]							.   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 43]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 43]
.   .   .   .   Child: 1  Const 5 of type int [line: 43]						.   .   .   .   Child: 1  Const 5 of type int [line: 43]
.   .   .   Child: 1  Op: [ of type int [line: 43]							.   .   .   Child: 1  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 43]		.   .   .   .   Child: 0  Id: gy of array of type int [mem: Global loc: -9 size: 7] [line: 43]
.   .   .   .   Child: 1  Const 4 of type int [line: 43]						.   .   .   .   Child: 1  Const 4 of type int [line: 43]
.   .   Sibling: 30  Call: output of type void [line: 44]						.   .   Sibling: 30  Call: output of type void [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 44]		.   .   .   .   Child: 0  Id: gx of array of type int [mem: Global loc: -1 size: 8] [line: 44]
.   .   .   .   Child: 1  Const 5 of type int [line: 44]						.   .   .   .   Child: 1  Const 5 of type int [line: 44]
.   .   Sibling: 31  Call: outnl of type void [line: 45]						.   .   Sibling: 31  Call: outnl of type void [line: 45]
.   .   Sibling: 32  Return [line: 47]									.   .   Sibling: 32  Return [line: 47]
Offset for end of global space: -15									Offset for end of global space: -15
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign3.out ztmp23114.txt differ: byte 1, line 1
assign3 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign3.tm
Number of errors: 0										   |	111 222
------------------------------------								   |	333 444
Loading file: assign3.tm									   |	333
												   >	777
												   >	222 0
												   >	444 0
												   >	222
												   >	444
Bye.													Bye.
====================================
FILE: assign4.c-
-rw-------. 1 corg7983 domain_users   532 Nov 17 15:35 assign4.c-
-rw-------. 1 corg7983 domain_users   532 Nov 17 15:35 assign4.c-.f21
-rw-------. 1 corg7983 domain_users   532 Nov 17 15:35 assign4.c-.f22
-rw-------. 1 corg7983 domain_users    85 Nov 17 15:35 assign4.expected
-rw-------. 1 corg7983 domain_users  5035 Nov 22 12:27 assign4.mem
-rw-------. 1 corg7983 domain_users     0 Nov 17 15:35 assign4.mem.diffs
-rw-------. 1 corg7983 domain_users  5876 Nov 17 15:35 assign4.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign4.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign4.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign4.tm.diffs
-rw-------. 1 corg7983 domain_users 12866 Nov 17 15:35 assign4.tm.f21
TM CODE COMPARISON
assign4 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign4.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,111(6)	Load integer constant 
												   >	 41:     LD  4,-2(1)	load lhs variable x
												   >	 42:    ADD  3,4,3	op += 
												   >	 43:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 44:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 45:     LD  3,-2(1)	Load variable x
												   >	 46:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 47:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-44(7)	CALL output
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 51:    LDC  3,222(6)	Load integer constant 
												   >	 52:     LD  4,-3(1)	load lhs variable y
												   >	 53:    ADD  3,4,3	op += 
												   >	 54:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 55:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 56:     LD  3,-3(1)	Load variable y
												   >	 57:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 58:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-55(7)	CALL output
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 62:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 63:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 64:    LDA  3,1(7)	Return address in ac 
												   >	 65:    JMP  7,-32(7)	CALL outnl
												   >	 66:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 67:    LDC  3,333(6)	Load integer constant 
												   >	 68:     LD  4,0(0)	load lhs variable gx
												   >	 69:    ADD  3,4,3	op += 
												   >	 70:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	 71:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 72:     LD  3,0(0)	Load variable gx
												   >	 73:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 74:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-71(7)	CALL output
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 78:    LDC  3,444(6)	Load integer constant 
												   >	 79:     LD  4,-1(0)	load lhs variable gy
												   >	 80:    ADD  3,4,3	op += 
												   >	 81:     ST  3,-1(0)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	 82:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 83:     LD  3,-1(0)	Load variable gy
												   >	 84:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 85:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-82(7)	CALL output
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 89:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 90:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-59(7)	CALL outnl
												   >	 93:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 94:     LD  3,-3(1)	Load variable y
												   >	 95:     LD  4,-2(1)	load lhs variable x
												   >	 96:    ADD  3,4,3	op += 
												   >	 97:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 98:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 99:     LD  3,-2(1)	Load variable x
												   >	100:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	101:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	102:    LDA  3,1(7)	Return address in ac 
												   >	103:    JMP  7,-98(7)	CALL output
												   >	104:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	105:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	106:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-75(7)	CALL outnl
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	110:     LD  3,-1(0)	Load variable gy
												   >	111:     LD  4,0(0)	load lhs variable gx
												   >	112:    ADD  3,4,3	op += 
												   >	113:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	114:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	115:     LD  3,0(0)	Load variable gx
												   >	116:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	117:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	118:    LDA  3,1(7)	Return address in ac 
												   >	119:    JMP  7,-114(7)	CALL output
												   >	120:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	121:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	122:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	123:    LDA  3,1(7)	Return address in ac 
												   >	124:    JMP  7,-91(7)	CALL outnl
												   >	125:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	126:    LDC  3,111(6)	Load integer constant 
												   >	127:     LD  4,-2(1)	load lhs variable x
												   >	128:    SUB  3,4,3	op -= 
												   >	129:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	130:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	131:     LD  3,-2(1)	Load variable x
												   >	132:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	133:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	134:    LDA  3,1(7)	Return address in ac 
												   >	135:    JMP  7,-130(7)	CALL output
												   >	136:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	137:    LDC  3,222(6)	Load integer constant 
												   >	138:     LD  4,-3(1)	load lhs variable y
												   >	139:    SUB  3,4,3	op -= 
												   >	140:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	141:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	142:     LD  3,-3(1)	Load variable y
												   >	143:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	144:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	145:    LDA  3,1(7)	Return address in ac 
												   >	146:    JMP  7,-141(7)	CALL output
												   >	147:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	148:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	149:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	150:    LDA  3,1(7)	Return address in ac 
												   >	151:    JMP  7,-118(7)	CALL outnl
												   >	152:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	153:    LDC  3,333(6)	Load integer constant 
												   >	154:     LD  4,0(0)	load lhs variable gx
												   >	155:    SUB  3,4,3	op -= 
												   >	156:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	157:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	158:     LD  3,0(0)	Load variable gx
												   >	159:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	160:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	161:    LDA  3,1(7)	Return address in ac 
												   >	162:    JMP  7,-157(7)	CALL output
												   >	163:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	164:    LDC  3,444(6)	Load integer constant 
												   >	165:     LD  4,-1(0)	load lhs variable gy
												   >	166:    SUB  3,4,3	op -= 
												   >	167:     ST  3,-1(0)	Store variable gy
												   >	* EXPRESSION
												   >	* CALL output
												   >	168:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	169:     LD  3,-1(0)	Load variable gy
												   >	170:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	171:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	172:    LDA  3,1(7)	Return address in ac 
												   >	173:    JMP  7,-168(7)	CALL output
												   >	174:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	175:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	176:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	177:    LDA  3,1(7)	Return address in ac 
												   >	178:    JMP  7,-145(7)	CALL outnl
												   >	179:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	180:     LD  3,-3(1)	Load variable y
												   >	181:     LD  4,-2(1)	load lhs variable x
												   >	182:    SUB  3,4,3	op -= 
												   >	183:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	184:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	185:     LD  3,-2(1)	Load variable x
												   >	186:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	187:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-184(7)	CALL output
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	191:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	192:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	193:    LDA  3,1(7)	Return address in ac 
												   >	194:    JMP  7,-161(7)	CALL outnl
												   >	195:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	196:     LD  3,-1(0)	Load variable gy
												   >	197:     LD  4,0(0)	load lhs variable gx
												   >	198:    SUB  3,4,3	op -= 
												   >	199:     ST  3,0(0)	Store variable gx
												   >	* EXPRESSION
												   >	* CALL output
												   >	200:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	201:     LD  3,0(0)	Load variable gx
												   >	202:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	203:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	204:    LDA  3,1(7)	Return address in ac 
												   >	205:    JMP  7,-200(7)	CALL output
												   >	206:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	207:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	208:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-177(7)	CALL outnl
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* RETURN
												   >	212:     LD  3,-1(1)	Load return address 
												   >	213:     LD  1,0(1)	Adjust fp 
												   >	214:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	215:    LDC  2,0(6)	Set return value to 0 
												   >	216:     LD  3,-1(1)	Load return address 
												   >	217:     LD  1,0(1)	Adjust fp 
												   >	218:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,218(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	219:    LDA  1,-2(0)	set first frame at end of globals 
												   >	220:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	221:    LDA  3,1(7)	Return address in ac 
												   >	222:    JMP  7,-184(7)	Jump to main 
												   >	223:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign4.mem assign4.mem.f21 differ: byte 1, line 1
assign4 (MEM DIFF)
Var: gx of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: gy of type int [mem: Global loc: -1 size: 1] [line: 1]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: gx of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: gy of type int [mem: Global loc: -1 size: 1] [line: 1]
												   >	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Child: 1  Assign: += of type int [line: 7]							.   .   Child: 1  Assign: += of type int [line: 7]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Const 111 of type int [line: 7]							.   .   .   Child: 1  Const 111 of type int [line: 7]
.   .   Sibling: 1  Call: output of type void [line: 8]							.   .   Sibling: 1  Call: output of type void [line: 8]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   Sibling: 2  Assign: += of type int [line: 9]							.   .   Sibling: 2  Assign: += of type int [line: 9]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   Child: 1  Const 222 of type int [line: 9]							.   .   .   Child: 1  Const 222 of type int [line: 9]
.   .   Sibling: 3  Call: output of type void [line: 10]						.   .   Sibling: 3  Call: output of type void [line: 10]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   Sibling: 4  Call: outnl of type void [line: 11]							.   .   Sibling: 4  Call: outnl of type void [line: 11]
.   .   Sibling: 5  Assign: += of type int [line: 13]							.   .   Sibling: 5  Assign: += of type int [line: 13]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 13]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 13]
.   .   .   Child: 1  Const 333 of type int [line: 13]							.   .   .   Child: 1  Const 333 of type int [line: 13]
.   .   Sibling: 6  Call: output of type void [line: 14]						.   .   Sibling: 6  Call: output of type void [line: 14]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 14]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 14]
.   .   Sibling: 7  Assign: += of type int [line: 15]							.   .   Sibling: 7  Assign: += of type int [line: 15]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 15]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 15]
.   .   .   Child: 1  Const 444 of type int [line: 15]							.   .   .   Child: 1  Const 444 of type int [line: 15]
.   .   Sibling: 8  Call: output of type void [line: 16]						.   .   Sibling: 8  Call: output of type void [line: 16]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 16]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 16]
.   .   Sibling: 9  Call: outnl of type void [line: 17]							.   .   Sibling: 9  Call: outnl of type void [line: 17]
.   .   Sibling: 10  Assign: += of type int [line: 19]							.   .   Sibling: 10  Assign: += of type int [line: 19]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 19]				.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   Sibling: 11  Call: output of type void [line: 20]						.   .   Sibling: 11  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]
.   .   Sibling: 12  Call: outnl of type void [line: 21]						.   .   Sibling: 12  Call: outnl of type void [line: 21]
.   .   Sibling: 13  Assign: += of type int [line: 23]							.   .   Sibling: 13  Assign: += of type int [line: 23]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 23]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 23]
.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 23]			.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 23]
.   .   Sibling: 14  Call: output of type void [line: 24]						.   .   Sibling: 14  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 24]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 24]
.   .   Sibling: 15  Call: outnl of type void [line: 25]						.   .   Sibling: 15  Call: outnl of type void [line: 25]
.   .   Sibling: 16  Assign: -= of type int [line: 27]							.   .   Sibling: 16  Assign: -= of type int [line: 27]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 27]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 27]
.   .   .   Child: 1  Const 111 of type int [line: 27]							.   .   .   Child: 1  Const 111 of type int [line: 27]
.   .   Sibling: 17  Call: output of type void [line: 28]						.   .   Sibling: 17  Call: output of type void [line: 28]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 28]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 28]
.   .   Sibling: 18  Assign: -= of type int [line: 29]							.   .   Sibling: 18  Assign: -= of type int [line: 29]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 29]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 29]
.   .   .   Child: 1  Const 222 of type int [line: 29]							.   .   .   Child: 1  Const 222 of type int [line: 29]
.   .   Sibling: 19  Call: output of type void [line: 30]						.   .   Sibling: 19  Call: output of type void [line: 30]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 30]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 30]
.   .   Sibling: 20  Call: outnl of type void [line: 31]						.   .   Sibling: 20  Call: outnl of type void [line: 31]
.   .   Sibling: 21  Assign: -= of type int [line: 33]							.   .   Sibling: 21  Assign: -= of type int [line: 33]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 33]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 33]
.   .   .   Child: 1  Const 333 of type int [line: 33]							.   .   .   Child: 1  Const 333 of type int [line: 33]
.   .   Sibling: 22  Call: output of type void [line: 34]						.   .   Sibling: 22  Call: output of type void [line: 34]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 34]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 34]
.   .   Sibling: 23  Assign: -= of type int [line: 35]							.   .   Sibling: 23  Assign: -= of type int [line: 35]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 35]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 35]
.   .   .   Child: 1  Const 444 of type int [line: 35]							.   .   .   Child: 1  Const 444 of type int [line: 35]
.   .   Sibling: 24  Call: output of type void [line: 36]						.   .   Sibling: 24  Call: output of type void [line: 36]
.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 36]			.   .   .   Child: 0  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 36]
.   .   Sibling: 25  Call: outnl of type void [line: 37]						.   .   Sibling: 25  Call: outnl of type void [line: 37]
.   .   Sibling: 26  Assign: -= of type int [line: 39]							.   .   Sibling: 26  Assign: -= of type int [line: 39]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 39]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 39]
.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 39]				.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 39]
.   .   Sibling: 27  Call: output of type void [line: 40]						.   .   Sibling: 27  Call: output of type void [line: 40]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 40]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 40]
.   .   Sibling: 28  Call: outnl of type void [line: 41]						.   .   Sibling: 28  Call: outnl of type void [line: 41]
.   .   Sibling: 29  Assign: -= of type int [line: 43]							.   .   Sibling: 29  Assign: -= of type int [line: 43]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 43]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 43]
.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 43]			.   .   .   Child: 1  Id: gy of type int [mem: Global loc: -1 size: 1] [line: 43]
.   .   Sibling: 30  Call: output of type void [line: 44]						.   .   Sibling: 30  Call: output of type void [line: 44]
.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 44]			.   .   .   Child: 0  Id: gx of type int [mem: Global loc: 0 size: 1] [line: 44]
.   .   Sibling: 31  Call: outnl of type void [line: 45]						.   .   Sibling: 31  Call: outnl of type void [line: 45]
.   .   Sibling: 32  Return [line: 47]									.   .   Sibling: 32  Return [line: 47]
Offset for end of global space: -2									Offset for end of global space: -2
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign4.out ztmp23114.txt differ: byte 1, line 1
assign4 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign4.tm
Number of errors: 0										   |	111 222
------------------------------------								   |	333 444
Loading file: assign4.tm									   |	333
												   >	777
												   >	222 0
												   >	444 0
												   >	222
												   >	444
Bye.													Bye.
====================================
FILE: assign5.c-
-rw-------. 1 corg7983 domain_users   578 Nov 17 15:35 assign5.c-
-rw-------. 1 corg7983 domain_users   589 Nov 17 15:35 assign5.c-.f21
-rw-------. 1 corg7983 domain_users   578 Nov 17 15:35 assign5.c-.f22
-rw-------. 1 corg7983 domain_users   137 Nov 17 15:35 assign5.expected
-rw-------. 1 corg7983 domain_users  7643 Nov 22 12:27 assign5.mem
-rw-------. 1 corg7983 domain_users  1339 Nov 17 15:35 assign5.mem.diffs
-rw-------. 1 corg7983 domain_users  8495 Nov 17 15:35 assign5.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign5.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign5.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign5.tm.diffs
-rw-------. 1 corg7983 domain_users 18082 Nov 17 15:35 assign5.tm.f21
TM CODE COMPARISON
assign5 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign5.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,333(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 42:    LDC  3,444(6)	Load integer constant 
												   >	 43:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	 44:    LDC  3,666(6)	Load integer constant 
												   >	 45:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	 46:     LD  3,-4(1)	Load variable z
												   >	 47:     ST  3,-3(1)	Store variable y
												   >	 48:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 49:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 50:     LD  3,-2(1)	Load variable x
												   >	 51:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 52:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 53:    LDA  3,1(7)	Return address in ac 
												   >	 54:    JMP  7,-49(7)	CALL output
												   >	 55:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 56:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 57:     LD  3,-3(1)	Load variable y
												   >	 58:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 59:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 60:    LDA  3,1(7)	Return address in ac 
												   >	 61:    JMP  7,-56(7)	CALL output
												   >	 62:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 63:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 64:     LD  3,-4(1)	Load variable z
												   >	 65:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 66:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-63(7)	CALL output
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 70:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	 71:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 72:    LDA  3,1(7)	Return address in ac 
												   >	 73:    JMP  7,-40(7)	CALL outnl
												   >	 74:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 75:     LD  3,-4(1)	Load variable z
												   >	 76:     ST  3,-3(1)	Store variable y
												   >	 77:     LD  4,-2(1)	load lhs variable x
												   >	 78:    ADD  3,4,3	op += 
												   >	 79:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 80:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 81:     LD  3,-2(1)	Load variable x
												   >	 82:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 83:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-80(7)	CALL output
												   >	 86:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 87:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 88:     LD  3,-3(1)	Load variable y
												   >	 89:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 90:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-87(7)	CALL output
												   >	 93:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 94:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 95:     LD  3,-4(1)	Load variable z
												   >	 96:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 97:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 98:    LDA  3,1(7)	Return address in ac 
												   >	 99:    JMP  7,-94(7)	CALL output
												   >	100:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	101:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	102:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	103:    LDA  3,1(7)	Return address in ac 
												   >	104:    JMP  7,-71(7)	CALL outnl
												   >	105:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	106:     LD  3,-4(1)	Load variable z
												   >	107:     LD  4,-3(1)	load lhs variable y
												   >	108:    ADD  3,4,3	op += 
												   >	109:     ST  3,-3(1)	Store variable y
												   >	110:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	111:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	112:     LD  3,-2(1)	Load variable x
												   >	113:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	114:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-111(7)	CALL output
												   >	117:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	118:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	119:     LD  3,-3(1)	Load variable y
												   >	120:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	121:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	122:    LDA  3,1(7)	Return address in ac 
												   >	123:    JMP  7,-118(7)	CALL output
												   >	124:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	125:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	126:     LD  3,-4(1)	Load variable z
												   >	127:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	128:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	129:    LDA  3,1(7)	Return address in ac 
												   >	130:    JMP  7,-125(7)	CALL output
												   >	131:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	132:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	133:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	134:    LDA  3,1(7)	Return address in ac 
												   >	135:    JMP  7,-102(7)	CALL outnl
												   >	136:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	137:     LD  3,-4(1)	Load variable z
												   >	138:     LD  4,-3(1)	load lhs variable y
												   >	139:    ADD  3,4,3	op += 
												   >	140:     ST  3,-3(1)	Store variable y
												   >	141:     LD  4,-2(1)	load lhs variable x
												   >	142:    ADD  3,4,3	op += 
												   >	143:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	144:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	145:     LD  3,-2(1)	Load variable x
												   >	146:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	147:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	148:    LDA  3,1(7)	Return address in ac 
												   >	149:    JMP  7,-144(7)	CALL output
												   >	150:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	151:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	152:     LD  3,-3(1)	Load variable y
												   >	153:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	154:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-151(7)	CALL output
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	158:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	159:     LD  3,-4(1)	Load variable z
												   >	160:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	161:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	162:    LDA  3,1(7)	Return address in ac 
												   >	163:    JMP  7,-158(7)	CALL output
												   >	164:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	165:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	166:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	167:    LDA  3,1(7)	Return address in ac 
												   >	168:    JMP  7,-135(7)	CALL outnl
												   >	169:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	170:     LD  3,-4(1)	Load variable z
												   >	171:     ST  3,-3(1)	Store variable y
												   >	172:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	173:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	174:     LD  3,-2(1)	Load variable x
												   >	175:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	176:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	177:    LDA  3,1(7)	Return address in ac 
												   >	178:    JMP  7,-173(7)	CALL output
												   >	179:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	180:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	181:     LD  3,-3(1)	Load variable y
												   >	182:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	183:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	184:    LDA  3,1(7)	Return address in ac 
												   >	185:    JMP  7,-180(7)	CALL output
												   >	186:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	187:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	188:     LD  3,-4(1)	Load variable z
												   >	189:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	190:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	191:    LDA  3,1(7)	Return address in ac 
												   >	192:    JMP  7,-187(7)	CALL output
												   >	193:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	194:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	195:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	196:    LDA  3,1(7)	Return address in ac 
												   >	197:    JMP  7,-164(7)	CALL outnl
												   >	198:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	199:     LD  3,-4(1)	Load variable z
												   >	200:     ST  3,-3(1)	Store variable y
												   >	201:     LD  4,-2(1)	load lhs variable x
												   >	202:    SUB  3,4,3	op -= 
												   >	203:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	204:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	205:     LD  3,-2(1)	Load variable x
												   >	206:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	207:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	208:    LDA  3,1(7)	Return address in ac 
												   >	209:    JMP  7,-204(7)	CALL output
												   >	210:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	211:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	212:     LD  3,-3(1)	Load variable y
												   >	213:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	214:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	215:    LDA  3,1(7)	Return address in ac 
												   >	216:    JMP  7,-211(7)	CALL output
												   >	217:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	218:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	219:     LD  3,-4(1)	Load variable z
												   >	220:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	221:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-218(7)	CALL output
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	225:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	226:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	227:    LDA  3,1(7)	Return address in ac 
												   >	228:    JMP  7,-195(7)	CALL outnl
												   >	229:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	230:     LD  3,-4(1)	Load variable z
												   >	231:     LD  4,-3(1)	load lhs variable y
												   >	232:    SUB  3,4,3	op -= 
												   >	233:     ST  3,-3(1)	Store variable y
												   >	234:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	235:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	236:     LD  3,-2(1)	Load variable x
												   >	237:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	238:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	239:    LDA  3,1(7)	Return address in ac 
												   >	240:    JMP  7,-235(7)	CALL output
												   >	241:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	242:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	243:     LD  3,-3(1)	Load variable y
												   >	244:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	245:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	246:    LDA  3,1(7)	Return address in ac 
												   >	247:    JMP  7,-242(7)	CALL output
												   >	248:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	249:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	250:     LD  3,-4(1)	Load variable z
												   >	251:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	252:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	253:    LDA  3,1(7)	Return address in ac 
												   >	254:    JMP  7,-249(7)	CALL output
												   >	255:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	256:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	257:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	258:    LDA  3,1(7)	Return address in ac 
												   >	259:    JMP  7,-226(7)	CALL outnl
												   >	260:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	261:     LD  3,-4(1)	Load variable z
												   >	262:     LD  4,-3(1)	load lhs variable y
												   >	263:    SUB  3,4,3	op -= 
												   >	264:     ST  3,-3(1)	Store variable y
												   >	265:     LD  4,-2(1)	load lhs variable x
												   >	266:    SUB  3,4,3	op -= 
												   >	267:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	268:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	269:     LD  3,-2(1)	Load variable x
												   >	270:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	271:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	272:    LDA  3,1(7)	Return address in ac 
												   >	273:    JMP  7,-268(7)	CALL output
												   >	274:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	275:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	276:     LD  3,-3(1)	Load variable y
												   >	277:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	278:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	279:    LDA  3,1(7)	Return address in ac 
												   >	280:    JMP  7,-275(7)	CALL output
												   >	281:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	282:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	283:     LD  3,-4(1)	Load variable z
												   >	284:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	285:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	286:    LDA  3,1(7)	Return address in ac 
												   >	287:    JMP  7,-282(7)	CALL output
												   >	288:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	289:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	290:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	291:    LDA  3,1(7)	Return address in ac 
												   >	292:    JMP  7,-259(7)	CALL outnl
												   >	293:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* RETURN
												   >	294:     LD  3,-1(1)	Load return address 
												   >	295:     LD  1,0(1)	Adjust fp 
												   >	296:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	297:    LDC  2,0(6)	Set return value to 0 
												   >	298:     LD  3,-1(1)	Load return address 
												   >	299:     LD  1,0(1)	Adjust fp 
												   >	300:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,300(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	301:    LDA  1,0(0)	set first frame at end of globals 
												   >	302:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	303:    LDA  3,1(7)	Return address in ac 
												   >	304:    JMP  7,-266(7)	Jump to main 
												   >	305:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign5.mem assign5.mem.f21 differ: byte 7, line 1
assign5 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 3]				.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 4]						   |	.   .   Child: 1  Assign: := of type int [line: 4]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 4]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 4]
.   .   .   Child: 1  Const 333 of type int [line: 4]							.   .   .   Child: 1  Const 333 of type int [line: 4]
.   .   Sibling: 1  Assign: = of type int [line: 5]						   |	.   .   Sibling: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   .   Child: 1  Const 444 of type int [line: 5]							.   .   .   Child: 1  Const 444 of type int [line: 5]
.   .   Sibling: 2  Assign: = of type int [line: 6]						   |	.   .   Sibling: 2  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   .   Child: 1  Const 666 of type int [line: 6]							.   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 3  Assign: = of type int [line: 8]						   |	.   .   Sibling: 3  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   Sibling: 4  Call: output of type void [line: 9]							.   .   Sibling: 4  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   Sibling: 5  Call: output of type void [line: 9]							.   .   Sibling: 5  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 6  Call: output of type void [line: 9]							.   .   Sibling: 6  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 9]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Sibling: 7  Call: outnl of type void [line: 9]							.   .   Sibling: 7  Call: outnl of type void [line: 9]
.   .   Sibling: 8  Assign: += of type int [line: 10]							.   .   Sibling: 8  Assign: += of type int [line: 10]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   Child: 1  Assign: = of type int [line: 10]						   |	.   .   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 10]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   Sibling: 9  Call: output of type void [line: 11]						.   .   Sibling: 9  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   Sibling: 10  Call: output of type void [line: 11]						.   .   Sibling: 10  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   Sibling: 11  Call: output of type void [line: 11]						.   .   Sibling: 11  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 11]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   Sibling: 12  Call: outnl of type void [line: 11]						.   .   Sibling: 12  Call: outnl of type void [line: 11]
.   .   Sibling: 13  Assign: = of type int [line: 12]						   |	.   .   Sibling: 13  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 12]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   Child: 1  Assign: += of type int [line: 12]							.   .   .   Child: 1  Assign: += of type int [line: 12]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 12]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 12]
.   .   Sibling: 14  Call: output of type void [line: 13]						.   .   Sibling: 14  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   Sibling: 15  Call: output of type void [line: 13]						.   .   Sibling: 15  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 13]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 13]
.   .   Sibling: 16  Call: output of type void [line: 13]						.   .   Sibling: 16  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 13]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   Sibling: 17  Call: outnl of type void [line: 13]						.   .   Sibling: 17  Call: outnl of type void [line: 13]
.   .   Sibling: 18  Assign: += of type int [line: 14]							.   .   Sibling: 18  Assign: += of type int [line: 14]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 14]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   .   Child: 1  Assign: += of type int [line: 14]							.   .   .   Child: 1  Assign: += of type int [line: 14]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 14]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 14]
.   .   Sibling: 19  Call: output of type void [line: 15]						.   .   Sibling: 19  Call: output of type void [line: 15]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]
.   .   Sibling: 20  Call: output of type void [line: 15]						.   .   Sibling: 20  Call: output of type void [line: 15]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   Sibling: 21  Call: output of type void [line: 15]						.   .   Sibling: 21  Call: output of type void [line: 15]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 15]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 15]
.   .   Sibling: 22  Call: outnl of type void [line: 15]						.   .   Sibling: 22  Call: outnl of type void [line: 15]
.   .   Sibling: 23  Assign: = of type int [line: 17]						   |	.   .   Sibling: 23  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 17]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 17]
.   .   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 17]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 17]
.   .   Sibling: 24  Call: output of type void [line: 18]						.   .   Sibling: 24  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 25  Call: output of type void [line: 18]						.   .   Sibling: 25  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   Sibling: 26  Call: output of type void [line: 18]						.   .   Sibling: 26  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 18]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   Sibling: 27  Call: outnl of type void [line: 18]						.   .   Sibling: 27  Call: outnl of type void [line: 18]
.   .   Sibling: 28  Assign: -= of type int [line: 19]							.   .   Sibling: 28  Assign: -= of type int [line: 19]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   .   Child: 1  Assign: = of type int [line: 19]						   |	.   .   .   Child: 1  Assign: := of type int [line: 19]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 19]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 19]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 19]
.   .   Sibling: 29  Call: output of type void [line: 20]						.   .   Sibling: 29  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]
.   .   Sibling: 30  Call: output of type void [line: 20]						.   .   Sibling: 30  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 20]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 20]
.   .   Sibling: 31  Call: output of type void [line: 20]						.   .   Sibling: 31  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 20]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 20]
.   .   Sibling: 32  Call: outnl of type void [line: 20]						.   .   Sibling: 32  Call: outnl of type void [line: 20]
.   .   Sibling: 33  Assign: = of type int [line: 21]						   |	.   .   Sibling: 33  Assign: := of type int [line: 21]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 21]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   .   Child: 1  Assign: -= of type int [line: 21]							.   .   .   Child: 1  Assign: -= of type int [line: 21]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 21]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 21]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 21]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 21]
.   .   Sibling: 34  Call: output of type void [line: 22]						.   .   Sibling: 34  Call: output of type void [line: 22]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 22]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 22]
.   .   Sibling: 35  Call: output of type void [line: 22]						.   .   Sibling: 35  Call: output of type void [line: 22]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 22]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   Sibling: 36  Call: output of type void [line: 22]						.   .   Sibling: 36  Call: output of type void [line: 22]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 22]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 22]
.   .   Sibling: 37  Call: outnl of type void [line: 22]						.   .   Sibling: 37  Call: outnl of type void [line: 22]
.   .   Sibling: 38  Assign: -= of type int [line: 23]							.   .   Sibling: 38  Assign: -= of type int [line: 23]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 23]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 23]
.   .   .   Child: 1  Assign: -= of type int [line: 23]							.   .   .   Child: 1  Assign: -= of type int [line: 23]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 23]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 23]			.   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -4 size: 1] [line: 23]
.   .   Sibling: 39  Call: output of type void [line: 24]						.   .   Sibling: 39  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 24]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 24]
.   .   Sibling: 40  Call: output of type void [line: 24]						.   .   Sibling: 40  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 24]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   Sibling: 41  Call: output of type void [line: 24]						.   .   Sibling: 41  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 24]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 24]
.   .   Sibling: 42  Call: outnl of type void [line: 24]						.   .   Sibling: 42  Call: outnl of type void [line: 24]
.   .   Sibling: 43  Return [line: 26]									.   .   Sibling: 43  Return [line: 26]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign5.out ztmp23114.txt differ: byte 1, line 1
assign5 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign5.tm
Number of errors: 0										   |	666 666 666
------------------------------------								   |	1332 666 666
Loading file: assign5.tm									   |	1332 1332 666
												   >	3330 1998 666
												   >	666 666 666
												   >	0 666 666
												   >	0 0 666
												   >	666 -666 666
Bye.													Bye.
====================================
FILE: assign6.c-
-rw-------. 1 corg7983 domain_users  1609 Nov 17 15:35 assign6.c-
-rw-------. 1 corg7983 domain_users  1627 Nov 17 15:35 assign6.c-.f21
-rw-------. 1 corg7983 domain_users  1609 Nov 17 15:35 assign6.c-.f22
-rw-------. 1 corg7983 domain_users   173 Nov 17 15:35 assign6.expected
-rw-------. 1 corg7983 domain_users 19152 Nov 22 12:27 assign6.mem
-rw-------. 1 corg7983 domain_users  2226 Nov 17 15:35 assign6.mem.diffs
-rw-------. 1 corg7983 domain_users 20012 Nov 17 15:35 assign6.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 assign6.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 assign6.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 assign6.tm.diffs
-rw-------. 1 corg7983 domain_users 37409 Nov 17 15:35 assign6.tm.f21
TM CODE COMPARISON
assign6 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  assign6.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -17
												   >	 40:    LDC  3,10(6)	load size of array b
												   >	 41:     ST  3,-5(1)	save size of array b
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:    LDC  3,777(6)	Load integer constant 
												   >	 43:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	 44:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 45:     LD  3,-4(1)	Load variable a
												   >	 46:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	 47:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-44(7)	CALL output
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	 51:    LDC  3,666(6)	Load integer constant 
												   >	 52:     LD  4,-4(1)	load lhs variable a
												   >	 53:    ADD  3,4,3	op += 
												   >	 54:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	 55:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 56:     LD  3,-4(1)	Load variable a
												   >	 57:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	 58:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-55(7)	CALL output
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	 62:    LDC  3,666(6)	Load integer constant 
												   >	 63:     LD  4,-4(1)	load lhs variable a
												   >	 64:    SUB  3,4,3	op -= 
												   >	 65:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	 66:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 67:     LD  3,-4(1)	Load variable a
												   >	 68:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	 69:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-66(7)	CALL output
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 73:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	 74:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-43(7)	CALL outnl
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	 78:    LDC  3,777(6)	Load integer constant 
												   >	 79:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	 80:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 81:     LD  3,0(0)	Load variable g
												   >	 82:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	 83:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-80(7)	CALL output
												   >	 86:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	 87:    LDC  3,666(6)	Load integer constant 
												   >	 88:     LD  4,0(0)	load lhs variable g
												   >	 89:    ADD  3,4,3	op += 
												   >	 90:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	 91:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 92:     LD  3,0(0)	Load variable g
												   >	 93:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	 94:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-91(7)	CALL output
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	 98:    LDC  3,666(6)	Load integer constant 
												   >	 99:     LD  4,0(0)	load lhs variable g
												   >	100:    SUB  3,4,3	op -= 
												   >	101:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	102:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	103:     LD  3,0(0)	Load variable g
												   >	104:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	105:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	106:    LDA  3,1(7)	Return address in ac 
												   >	107:    JMP  7,-102(7)	CALL output
												   >	108:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	109:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	110:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	111:    LDA  3,1(7)	Return address in ac 
												   >	112:    JMP  7,-79(7)	CALL outnl
												   >	113:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	114:    LDC  3,777(6)	Load integer constant 
												   >	115:     ST  3,-2(1)	Store variable p
												   >	* EXPRESSION
												   >	* CALL output
												   >	116:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	117:     LD  3,-2(1)	Load variable p
												   >	118:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	119:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-116(7)	CALL output
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	123:    LDC  3,666(6)	Load integer constant 
												   >	124:     LD  4,-2(1)	load lhs variable p
												   >	125:    ADD  3,4,3	op += 
												   >	126:     ST  3,-2(1)	Store variable p
												   >	* EXPRESSION
												   >	* CALL output
												   >	127:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	128:     LD  3,-2(1)	Load variable p
												   >	129:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	130:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-127(7)	CALL output
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	134:    LDC  3,666(6)	Load integer constant 
												   >	135:     LD  4,-2(1)	load lhs variable p
												   >	136:    SUB  3,4,3	op -= 
												   >	137:     ST  3,-2(1)	Store variable p
												   >	* EXPRESSION
												   >	* CALL output
												   >	138:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	139:     LD  3,-2(1)	Load variable p
												   >	140:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	141:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	142:    LDA  3,1(7)	Return address in ac 
												   >	143:    JMP  7,-138(7)	CALL output
												   >	144:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	145:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	146:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	147:    LDA  3,1(7)	Return address in ac 
												   >	148:    JMP  7,-115(7)	CALL outnl
												   >	149:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	150:    LDC  3,1(6)	Load integer constant 
												   >	151:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	152:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	153:     LD  4,-17(1)	Pop index 
												   >	154:    LDA  5,-6(1)	Load address of base of array b
												   >	155:    SUB  5,5,4	Compute offset of value 
												   >	156:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	157:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	158:    LDA  3,-6(1)	Load address of base of array b
												   >	159:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	160:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	161:     LD  4,-19(1)	Pop left into ac1 
												   >	162:    SUB  3,4,3	compute location from index 
												   >	163:     LD  3,0(3)	Load array element 
												   >	164:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	165:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-162(7)	CALL output
												   >	168:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	169:    LDC  3,1(6)	Load integer constant 
												   >	170:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	171:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	172:     LD  4,-17(1)	Pop index 
												   >	173:    LDA  5,-6(1)	Load address of base of array b
												   >	174:    SUB  5,5,4	Compute offset of value 
												   >	175:     LD  4,0(5)	load lhs variable b
												   >	176:    ADD  3,4,3	op += 
												   >	177:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	178:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	179:    LDA  3,-6(1)	Load address of base of array b
												   >	180:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	181:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	182:     LD  4,-19(1)	Pop left into ac1 
												   >	183:    SUB  3,4,3	compute location from index 
												   >	184:     LD  3,0(3)	Load array element 
												   >	185:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	186:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	187:    LDA  3,1(7)	Return address in ac 
												   >	188:    JMP  7,-183(7)	CALL output
												   >	189:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	190:    LDC  3,1(6)	Load integer constant 
												   >	191:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	192:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	193:     LD  4,-17(1)	Pop index 
												   >	194:    LDA  5,-6(1)	Load address of base of array b
												   >	195:    SUB  5,5,4	Compute offset of value 
												   >	196:     LD  4,0(5)	load lhs variable b
												   >	197:    SUB  3,4,3	op -= 
												   >	198:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	199:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	200:    LDA  3,-6(1)	Load address of base of array b
												   >	201:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	202:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	203:     LD  4,-19(1)	Pop left into ac1 
												   >	204:    SUB  3,4,3	compute location from index 
												   >	205:     LD  3,0(3)	Load array element 
												   >	206:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	207:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	208:    LDA  3,1(7)	Return address in ac 
												   >	209:    JMP  7,-204(7)	CALL output
												   >	210:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	211:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	212:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	213:    LDA  3,1(7)	Return address in ac 
												   >	214:    JMP  7,-181(7)	CALL outnl
												   >	215:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	216:    LDC  3,1(6)	Load integer constant 
												   >	217:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	218:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	219:     LD  4,-17(1)	Pop index 
												   >	220:    LDA  5,-2(0)	Load address of base of array h
												   >	221:    SUB  5,5,4	Compute offset of value 
												   >	222:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	* CALL output
												   >	223:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	224:    LDA  3,-2(0)	Load address of base of array h
												   >	225:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	226:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	227:     LD  4,-19(1)	Pop left into ac1 
												   >	228:    SUB  3,4,3	compute location from index 
												   >	229:     LD  3,0(3)	Load array element 
												   >	230:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	231:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	232:    LDA  3,1(7)	Return address in ac 
												   >	233:    JMP  7,-228(7)	CALL output
												   >	234:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	235:    LDC  3,1(6)	Load integer constant 
												   >	236:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	237:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	238:     LD  4,-17(1)	Pop index 
												   >	239:    LDA  5,-2(0)	Load address of base of array h
												   >	240:    SUB  5,5,4	Compute offset of value 
												   >	241:     LD  4,0(5)	load lhs variable h
												   >	242:    ADD  3,4,3	op += 
												   >	243:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	* CALL output
												   >	244:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	245:    LDA  3,-2(0)	Load address of base of array h
												   >	246:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	247:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	248:     LD  4,-19(1)	Pop left into ac1 
												   >	249:    SUB  3,4,3	compute location from index 
												   >	250:     LD  3,0(3)	Load array element 
												   >	251:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	252:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	253:    LDA  3,1(7)	Return address in ac 
												   >	254:    JMP  7,-249(7)	CALL output
												   >	255:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	256:    LDC  3,1(6)	Load integer constant 
												   >	257:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	258:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	259:     LD  4,-17(1)	Pop index 
												   >	260:    LDA  5,-2(0)	Load address of base of array h
												   >	261:    SUB  5,5,4	Compute offset of value 
												   >	262:     LD  4,0(5)	load lhs variable h
												   >	263:    SUB  3,4,3	op -= 
												   >	264:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	* CALL output
												   >	265:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	266:    LDA  3,-2(0)	Load address of base of array h
												   >	267:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	268:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	269:     LD  4,-19(1)	Pop left into ac1 
												   >	270:    SUB  3,4,3	compute location from index 
												   >	271:     LD  3,0(3)	Load array element 
												   >	272:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	273:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	274:    LDA  3,1(7)	Return address in ac 
												   >	275:    JMP  7,-270(7)	CALL output
												   >	276:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	277:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	278:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	279:    LDA  3,1(7)	Return address in ac 
												   >	280:    JMP  7,-247(7)	CALL outnl
												   >	281:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	282:    LDC  3,1(6)	Load integer constant 
												   >	283:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	284:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	285:     LD  4,-17(1)	Pop index 
												   >	286:     LD  5,-3(1)	Load address of base of array q
												   >	287:    SUB  5,5,4	Compute offset of value 
												   >	288:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	289:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	290:     LD  3,-3(1)	Load address of base of array q
												   >	291:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	292:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	293:     LD  4,-19(1)	Pop left into ac1 
												   >	294:    SUB  3,4,3	compute location from index 
												   >	295:     LD  3,0(3)	Load array element 
												   >	296:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	297:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	298:    LDA  3,1(7)	Return address in ac 
												   >	299:    JMP  7,-294(7)	CALL output
												   >	300:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	301:    LDC  3,1(6)	Load integer constant 
												   >	302:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	303:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	304:     LD  4,-17(1)	Pop index 
												   >	305:     LD  5,-3(1)	Load address of base of array q
												   >	306:    SUB  5,5,4	Compute offset of value 
												   >	307:     LD  4,0(5)	load lhs variable q
												   >	308:    ADD  3,4,3	op += 
												   >	309:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	310:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	311:     LD  3,-3(1)	Load address of base of array q
												   >	312:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	313:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	314:     LD  4,-19(1)	Pop left into ac1 
												   >	315:    SUB  3,4,3	compute location from index 
												   >	316:     LD  3,0(3)	Load array element 
												   >	317:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	318:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	319:    LDA  3,1(7)	Return address in ac 
												   >	320:    JMP  7,-315(7)	CALL output
												   >	321:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	322:    LDC  3,1(6)	Load integer constant 
												   >	323:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	324:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	325:     LD  4,-17(1)	Pop index 
												   >	326:     LD  5,-3(1)	Load address of base of array q
												   >	327:    SUB  5,5,4	Compute offset of value 
												   >	328:     LD  4,0(5)	load lhs variable q
												   >	329:    SUB  3,4,3	op -= 
												   >	330:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	331:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	332:     LD  3,-3(1)	Load address of base of array q
												   >	333:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	334:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	335:     LD  4,-19(1)	Pop left into ac1 
												   >	336:    SUB  3,4,3	compute location from index 
												   >	337:     LD  3,0(3)	Load array element 
												   >	338:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	339:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	340:    LDA  3,1(7)	Return address in ac 
												   >	341:    JMP  7,-336(7)	CALL output
												   >	342:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	343:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	344:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	345:    LDA  3,1(7)	Return address in ac 
												   >	346:    JMP  7,-313(7)	CALL outnl
												   >	347:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	348:    LDC  3,1(6)	Load integer constant 
												   >	349:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	350:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	351:     LD  4,-17(1)	Pop index 
												   >	352:    LDA  5,-6(1)	Load address of base of array b
												   >	353:    SUB  5,5,4	Compute offset of value 
												   >	354:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	355:    LDA  3,-6(1)	Load address of base of array b
												   >	356:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	357:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	358:     LD  4,-17(1)	Pop left into ac1 
												   >	359:    SUB  3,4,3	compute location from index 
												   >	360:     LD  3,0(3)	Load array element 
												   >	361:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	362:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	363:     LD  4,-17(1)	Pop left into ac1 
												   >	364:    ADD  3,4,3	Op + 
												   >	365:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	366:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	367:     LD  4,-17(1)	Pop index 
												   >	368:     LD  5,-3(1)	Load address of base of array q
												   >	369:    SUB  5,5,4	Compute offset of value 
												   >	370:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	371:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	372:     LD  3,-3(1)	Load address of base of array q
												   >	373:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	374:    LDA  3,-6(1)	Load address of base of array b
												   >	375:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	376:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	377:     LD  4,-20(1)	Pop left into ac1 
												   >	378:    SUB  3,4,3	compute location from index 
												   >	379:     LD  3,0(3)	Load array element 
												   >	380:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	381:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	382:     LD  4,-20(1)	Pop left into ac1 
												   >	383:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -19
												   >	384:     LD  4,-19(1)	Pop left into ac1 
												   >	385:    SUB  3,4,3	compute location from index 
												   >	386:     LD  3,0(3)	Load array element 
												   >	387:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	388:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	389:    LDA  3,1(7)	Return address in ac 
												   >	390:    JMP  7,-385(7)	CALL output
												   >	391:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	392:    LDA  3,-6(1)	Load address of base of array b
												   >	393:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	394:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	395:     LD  4,-17(1)	Pop left into ac1 
												   >	396:    SUB  3,4,3	compute location from index 
												   >	397:     LD  3,0(3)	Load array element 
												   >	398:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	399:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	400:     LD  4,-17(1)	Pop left into ac1 
												   >	401:    ADD  3,4,3	Op + 
												   >	402:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	403:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	404:     LD  4,-17(1)	Pop index 
												   >	405:     LD  5,-3(1)	Load address of base of array q
												   >	406:    SUB  5,5,4	Compute offset of value 
												   >	407:     LD  4,0(5)	load lhs variable q
												   >	408:    ADD  3,4,3	op += 
												   >	409:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	410:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	411:     LD  3,-3(1)	Load address of base of array q
												   >	412:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	413:    LDA  3,-6(1)	Load address of base of array b
												   >	414:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	415:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	416:     LD  4,-20(1)	Pop left into ac1 
												   >	417:    SUB  3,4,3	compute location from index 
												   >	418:     LD  3,0(3)	Load array element 
												   >	419:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	420:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	421:     LD  4,-20(1)	Pop left into ac1 
												   >	422:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -19
												   >	423:     LD  4,-19(1)	Pop left into ac1 
												   >	424:    SUB  3,4,3	compute location from index 
												   >	425:     LD  3,0(3)	Load array element 
												   >	426:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	427:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	428:    LDA  3,1(7)	Return address in ac 
												   >	429:    JMP  7,-424(7)	CALL output
												   >	430:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	431:    LDA  3,-6(1)	Load address of base of array b
												   >	432:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	433:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	434:     LD  4,-17(1)	Pop left into ac1 
												   >	435:    SUB  3,4,3	compute location from index 
												   >	436:     LD  3,0(3)	Load array element 
												   >	437:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	438:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	439:     LD  4,-17(1)	Pop left into ac1 
												   >	440:    ADD  3,4,3	Op + 
												   >	441:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	442:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -17
												   >	443:     LD  4,-17(1)	Pop index 
												   >	444:     LD  5,-3(1)	Load address of base of array q
												   >	445:    SUB  5,5,4	Compute offset of value 
												   >	446:     LD  4,0(5)	load lhs variable q
												   >	447:    SUB  3,4,3	op -= 
												   >	448:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	* CALL output
												   >	449:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	450:     LD  3,-3(1)	Load address of base of array q
												   >	451:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	452:    LDA  3,-6(1)	Load address of base of array b
												   >	453:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	454:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	455:     LD  4,-20(1)	Pop left into ac1 
												   >	456:    SUB  3,4,3	compute location from index 
												   >	457:     LD  3,0(3)	Load array element 
												   >	458:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	459:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	460:     LD  4,-20(1)	Pop left into ac1 
												   >	461:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -19
												   >	462:     LD  4,-19(1)	Pop left into ac1 
												   >	463:    SUB  3,4,3	compute location from index 
												   >	464:     LD  3,0(3)	Load array element 
												   >	465:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	466:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	467:    LDA  3,1(7)	Return address in ac 
												   >	468:    JMP  7,-463(7)	CALL output
												   >	469:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	470:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	471:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	472:    LDA  3,1(7)	Return address in ac 
												   >	473:    JMP  7,-440(7)	CALL outnl
												   >	474:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	475:    LDC  3,777(6)	Load integer constant 
												   >	476:     ST  3,-4(1)	Store variable a
												   >	477:     ST  3,-16(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	478:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	479:     LD  3,-16(1)	Load variable x
												   >	480:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	481:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	482:    LDA  3,1(7)	Return address in ac 
												   >	483:    JMP  7,-478(7)	CALL output
												   >	484:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	485:    LDC  3,666(6)	Load integer constant 
												   >	486:     LD  4,-4(1)	load lhs variable a
												   >	487:    ADD  3,4,3	op += 
												   >	488:     ST  3,-4(1)	Store variable a
												   >	489:     ST  3,-16(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	490:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	491:     LD  3,-16(1)	Load variable x
												   >	492:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	493:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	494:    LDA  3,1(7)	Return address in ac 
												   >	495:    JMP  7,-490(7)	CALL output
												   >	496:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	497:    LDC  3,666(6)	Load integer constant 
												   >	498:     LD  4,-4(1)	load lhs variable a
												   >	499:    SUB  3,4,3	op -= 
												   >	500:     ST  3,-4(1)	Store variable a
												   >	501:     ST  3,-16(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	502:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	503:     LD  3,-16(1)	Load variable x
												   >	504:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	505:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	506:    LDA  3,1(7)	Return address in ac 
												   >	507:    JMP  7,-502(7)	CALL output
												   >	508:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	509:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	510:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	511:    LDA  3,1(7)	Return address in ac 
												   >	512:    JMP  7,-479(7)	CALL outnl
												   >	513:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	514:    LDC  3,1(6)	Load integer constant 
												   >	515:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	516:    LDC  3,2(6)	Load integer constant 
												   >	517:     ST  3,-18(1)	Push index 
												   >	* TOFF dec: -19
												   >	518:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	519:     LD  4,-18(1)	Pop index 
												   >	520:    LDA  5,-6(1)	Load address of base of array b
												   >	521:    SUB  5,5,4	Compute offset of value 
												   >	522:     ST  3,0(5)	Store variable b
												   >	* TOFF inc: -17
												   >	523:     LD  4,-17(1)	Pop index 
												   >	524:    LDA  5,-6(1)	Load address of base of array b
												   >	525:    SUB  5,5,4	Compute offset of value 
												   >	526:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	527:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	528:    LDA  3,-6(1)	Load address of base of array b
												   >	529:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	530:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	531:     LD  4,-19(1)	Pop left into ac1 
												   >	532:    SUB  3,4,3	compute location from index 
												   >	533:     LD  3,0(3)	Load array element 
												   >	534:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	535:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	536:    LDA  3,1(7)	Return address in ac 
												   >	537:    JMP  7,-532(7)	CALL output
												   >	538:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	539:    LDC  3,1(6)	Load integer constant 
												   >	540:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	541:    LDC  3,2(6)	Load integer constant 
												   >	542:     ST  3,-18(1)	Push index 
												   >	* TOFF dec: -19
												   >	543:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	544:     LD  4,-18(1)	Pop index 
												   >	545:    LDA  5,-6(1)	Load address of base of array b
												   >	546:    SUB  5,5,4	Compute offset of value 
												   >	547:     LD  4,0(5)	load lhs variable b
												   >	548:    ADD  3,4,3	op += 
												   >	549:     ST  3,0(5)	Store variable b
												   >	* TOFF inc: -17
												   >	550:     LD  4,-17(1)	Pop index 
												   >	551:    LDA  5,-6(1)	Load address of base of array b
												   >	552:    SUB  5,5,4	Compute offset of value 
												   >	553:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	554:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	555:    LDA  3,-6(1)	Load address of base of array b
												   >	556:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	557:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	558:     LD  4,-19(1)	Pop left into ac1 
												   >	559:    SUB  3,4,3	compute location from index 
												   >	560:     LD  3,0(3)	Load array element 
												   >	561:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	562:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	563:    LDA  3,1(7)	Return address in ac 
												   >	564:    JMP  7,-559(7)	CALL output
												   >	565:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	566:    LDC  3,1(6)	Load integer constant 
												   >	567:     ST  3,-17(1)	Push index 
												   >	* TOFF dec: -18
												   >	568:    LDC  3,2(6)	Load integer constant 
												   >	569:     ST  3,-18(1)	Push index 
												   >	* TOFF dec: -19
												   >	570:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	571:     LD  4,-18(1)	Pop index 
												   >	572:    LDA  5,-6(1)	Load address of base of array b
												   >	573:    SUB  5,5,4	Compute offset of value 
												   >	574:     LD  4,0(5)	load lhs variable b
												   >	575:    SUB  3,4,3	op -= 
												   >	576:     ST  3,0(5)	Store variable b
												   >	* TOFF inc: -17
												   >	577:     LD  4,-17(1)	Pop index 
												   >	578:    LDA  5,-6(1)	Load address of base of array b
												   >	579:    SUB  5,5,4	Compute offset of value 
												   >	580:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	581:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	582:    LDA  3,-6(1)	Load address of base of array b
												   >	583:     ST  3,-19(1)	Push left side 
												   >	* TOFF dec: -20
												   >	584:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -19
												   >	585:     LD  4,-19(1)	Pop left into ac1 
												   >	586:    SUB  3,4,3	compute location from index 
												   >	587:     LD  3,0(3)	Load array element 
												   >	588:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	589:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	590:    LDA  3,1(7)	Return address in ac 
												   >	591:    JMP  7,-586(7)	CALL output
												   >	592:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	593:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	594:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	595:    LDA  3,1(7)	Return address in ac 
												   >	596:    JMP  7,-563(7)	CALL outnl
												   >	597:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	598:     LD  3,-4(1)	Load variable a
												   >	599:     ST  3,-17(1)	Push left side 
												   >	* TOFF dec: -18
												   >	600:     LD  3,-16(1)	Load variable x
												   >	* TOFF inc: -17
												   >	601:     LD  4,-17(1)	Pop left into ac1 
												   >	602:    MUL  3,4,3	Op * 
												   >	603:     LD  4,-4(1)	load lhs variable a
												   >	604:    ADD  3,4,3	op += 
												   >	605:     ST  3,-4(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	606:     ST  1,-17(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	607:     LD  3,-4(1)	Load variable a
												   >	608:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param end output
												   >	609:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	610:    LDA  3,1(7)	Return address in ac 
												   >	611:    JMP  7,-606(7)	CALL output
												   >	612:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -17
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	613:     ST  1,-17(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param end outnl
												   >	614:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	615:    LDA  3,1(7)	Return address in ac 
												   >	616:    JMP  7,-583(7)	CALL outnl
												   >	617:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -17
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	618:    LDC  2,0(6)	Set return value to 0 
												   >	619:     LD  3,-1(1)	Load return address 
												   >	620:     LD  1,0(1)	Adjust fp 
												   >	621:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	622:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -24
												   >	623:    LDC  3,20(6)	load size of array qq
												   >	624:     ST  3,-3(1)	save size of array qq
												   >	* Compound Body
												   >	* EXPRESSION
												   >	625:    LDC  3,888(6)	Load integer constant 
												   >	626:     ST  3,-2(1)	Store variable pp
												   >	* EXPRESSION
												   >	627:    LDC  3,1(6)	Load integer constant 
												   >	628:     ST  3,-24(1)	Push index 
												   >	* TOFF dec: -25
												   >	629:    LDC  3,999(6)	Load integer constant 
												   >	* TOFF inc: -24
												   >	630:     LD  4,-24(1)	Pop index 
												   >	631:    LDA  5,-4(1)	Load address of base of array qq
												   >	632:    SUB  5,5,4	Compute offset of value 
												   >	633:     ST  3,0(5)	Store variable qq
												   >	* EXPRESSION
												   >	* CALL dog
												   >	634:     ST  1,-24(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -25
												   >	* TOFF dec: -26
												   >	* Param 1
												   >	635:     LD  3,-2(1)	Load variable pp
												   >	636:     ST  3,-26(1)	Push parameter 
												   >	* TOFF dec: -27
												   >	* Param 2
												   >	637:    LDA  3,-4(1)	Load address of base of array qq
												   >	638:     ST  3,-27(1)	Push parameter 
												   >	* TOFF dec: -28
												   >	* Param end dog
												   >	639:    LDA  1,-24(1)	Ghost frame becomes new active frame 
												   >	640:    LDA  3,1(7)	Return address in ac 
												   >	641:    JMP  7,-603(7)	CALL dog
												   >	642:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -24
												   >	* EXPRESSION
												   >	* CALL output
												   >	643:     ST  1,-24(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -25
												   >	* TOFF dec: -26
												   >	* Param 1
												   >	644:     LD  3,-2(1)	Load variable pp
												   >	645:     ST  3,-26(1)	Push parameter 
												   >	* TOFF dec: -27
												   >	* Param end output
												   >	646:    LDA  1,-24(1)	Ghost frame becomes new active frame 
												   >	647:    LDA  3,1(7)	Return address in ac 
												   >	648:    JMP  7,-643(7)	CALL output
												   >	649:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -24
												   >	* EXPRESSION
												   >	* CALL output
												   >	650:     ST  1,-24(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -25
												   >	* TOFF dec: -26
												   >	* Param 1
												   >	651:    LDA  3,-4(1)	Load address of base of array qq
												   >	652:     ST  3,-26(1)	Push left side 
												   >	* TOFF dec: -27
												   >	653:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -26
												   >	654:     LD  4,-26(1)	Pop left into ac1 
												   >	655:    SUB  3,4,3	compute location from index 
												   >	656:     LD  3,0(3)	Load array element 
												   >	657:     ST  3,-26(1)	Push parameter 
												   >	* TOFF dec: -27
												   >	* Param end output
												   >	658:    LDA  1,-24(1)	Ghost frame becomes new active frame 
												   >	659:    LDA  3,1(7)	Return address in ac 
												   >	660:    JMP  7,-655(7)	CALL output
												   >	661:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -24
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	662:     ST  1,-24(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -25
												   >	* TOFF dec: -26
												   >	* Param end outnl
												   >	663:    LDA  1,-24(1)	Ghost frame becomes new active frame 
												   >	664:    LDA  3,1(7)	Return address in ac 
												   >	665:    JMP  7,-632(7)	CALL outnl
												   >	666:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -24
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	667:    LDC  2,0(6)	Set return value to 0 
												   >	668:     LD  3,-1(1)	Load return address 
												   >	669:     LD  1,0(1)	Adjust fp 
												   >	670:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,670(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	671:    LDA  1,-12(0)	set first frame at end of globals 
												   >	672:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	673:    LDC  3,10(6)	load size of array h
												   >	674:     ST  3,-1(0)	save size of array h
												   >	* END INIT GLOBALS AND STATICS
												   >	675:    LDA  3,1(7)	Return address in ac 
												   >	676:    JMP  7,-55(7)	Jump to main 
												   >	677:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
assign6.mem assign6.mem.f21 differ: byte 1, line 1
assign6 (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: h of array of type int [mem: Global loc: -2 size: 11] [line: 2]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: h of array of type int [mem: Global loc: -2 size: 11] [line: 2]
												   >	Sibling: 9  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: p of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: p of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]			.   Sibling: 1  Parm: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -17] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -17] [line: 4]
.   .   Child: 0  Var: a of type int [mem: Local loc: -4 size: 1] [line: 5]				.   .   Child: 0  Var: a of type int [mem: Local loc: -4 size: 1] [line: 5]
.   .   Sibling: 1  Var: b of array of type int [mem: Local loc: -6 size: 11] [line: 5]			.   .   Sibling: 1  Var: b of array of type int [mem: Local loc: -6 size: 11] [line: 5]
.   .   Sibling: 2  Var: x of type int [mem: Local loc: -16 size: 1] [line: 6]				.   .   Sibling: 2  Var: x of type int [mem: Local loc: -16 size: 1] [line: 6]
.   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 8]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 1  Const 777 of type int [line: 8]							.   .   .   Child: 1  Const 777 of type int [line: 8]
.   .   Sibling: 1  Call: output of type void [line: 9]							.   .   Sibling: 1  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 9]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Sibling: 2  Assign: += of type int [line: 10]							.   .   Sibling: 2  Assign: += of type int [line: 10]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 10]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   Child: 1  Const 666 of type int [line: 10]							.   .   .   Child: 1  Const 666 of type int [line: 10]
.   .   Sibling: 3  Call: output of type void [line: 11]						.   .   Sibling: 3  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 11]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   Sibling: 4  Assign: -= of type int [line: 12]							.   .   Sibling: 4  Assign: -= of type int [line: 12]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 12]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 12]
.   .   .   Child: 1  Const 666 of type int [line: 12]							.   .   .   Child: 1  Const 666 of type int [line: 12]
.   .   Sibling: 5  Call: output of type void [line: 13]						.   .   Sibling: 5  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 13]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   Sibling: 6  Call: outnl of type void [line: 14]							.   .   Sibling: 6  Call: outnl of type void [line: 14]
.   .   Sibling: 7  Assign: = of type int [line: 16]						   |	.   .   Sibling: 7  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 16]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 16]
.   .   .   Child: 1  Const 777 of type int [line: 16]							.   .   .   Child: 1  Const 777 of type int [line: 16]
.   .   Sibling: 8  Call: output of type void [line: 17]						.   .   Sibling: 8  Call: output of type void [line: 17]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]
.   .   Sibling: 9  Assign: += of type int [line: 18]							.   .   Sibling: 9  Assign: += of type int [line: 18]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]
.   .   .   Child: 1  Const 666 of type int [line: 18]							.   .   .   Child: 1  Const 666 of type int [line: 18]
.   .   Sibling: 10  Call: output of type void [line: 19]						.   .   Sibling: 10  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]
.   .   Sibling: 11  Assign: -= of type int [line: 20]							.   .   Sibling: 11  Assign: -= of type int [line: 20]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]
.   .   .   Child: 1  Const 666 of type int [line: 20]							.   .   .   Child: 1  Const 666 of type int [line: 20]
.   .   Sibling: 12  Call: output of type void [line: 21]						.   .   Sibling: 12  Call: output of type void [line: 21]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 21]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 21]
.   .   Sibling: 13  Call: outnl of type void [line: 22]						.   .   Sibling: 13  Call: outnl of type void [line: 22]
.   .   Sibling: 14  Assign: = of type int [line: 24]						   |	.   .   Sibling: 14  Assign: := of type int [line: 24]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 24]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 24]
.   .   .   Child: 1  Const 777 of type int [line: 24]							.   .   .   Child: 1  Const 777 of type int [line: 24]
.   .   Sibling: 15  Call: output of type void [line: 25]						.   .   Sibling: 15  Call: output of type void [line: 25]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 25]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 25]
.   .   Sibling: 16  Assign: += of type int [line: 26]							.   .   Sibling: 16  Assign: += of type int [line: 26]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 26]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 26]
.   .   .   Child: 1  Const 666 of type int [line: 26]							.   .   .   Child: 1  Const 666 of type int [line: 26]
.   .   Sibling: 17  Call: output of type void [line: 27]						.   .   Sibling: 17  Call: output of type void [line: 27]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 27]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 27]
.   .   Sibling: 18  Assign: -= of type int [line: 28]							.   .   Sibling: 18  Assign: -= of type int [line: 28]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 28]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 28]
.   .   .   Child: 1  Const 666 of type int [line: 28]							.   .   .   Child: 1  Const 666 of type int [line: 28]
.   .   Sibling: 19  Call: output of type void [line: 29]						.   .   Sibling: 19  Call: output of type void [line: 29]
.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 29]			.   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -2 size: 1] [line: 29]
.   .   Sibling: 20  Call: outnl of type void [line: 30]						.   .   Sibling: 20  Call: outnl of type void [line: 30]
.   .   Sibling: 21  Assign: = of type int [line: 32]						   |	.   .   Sibling: 21  Assign: := of type int [line: 32]
.   .   .   Child: 0  Op: [ of type int [line: 32]							.   .   .   Child: 0  Op: [ of type int [line: 32]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 32]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 32]
.   .   .   .   Child: 1  Const 1 of type int [line: 32]						.   .   .   .   Child: 1  Const 1 of type int [line: 32]
.   .   .   Child: 1  Const 777 of type int [line: 32]							.   .   .   Child: 1  Const 777 of type int [line: 32]
.   .   Sibling: 22  Call: output of type void [line: 33]						.   .   Sibling: 22  Call: output of type void [line: 33]
.   .   .   Child: 0  Op: [ of type int [line: 33]							.   .   .   Child: 0  Op: [ of type int [line: 33]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 33]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 33]
.   .   .   .   Child: 1  Const 1 of type int [line: 33]						.   .   .   .   Child: 1  Const 1 of type int [line: 33]
.   .   Sibling: 23  Assign: += of type int [line: 34]							.   .   Sibling: 23  Assign: += of type int [line: 34]
.   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 34]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 34]
.   .   .   .   Child: 1  Const 1 of type int [line: 34]						.   .   .   .   Child: 1  Const 1 of type int [line: 34]
.   .   .   Child: 1  Const 666 of type int [line: 34]							.   .   .   Child: 1  Const 666 of type int [line: 34]
.   .   Sibling: 24  Call: output of type void [line: 35]						.   .   Sibling: 24  Call: output of type void [line: 35]
.   .   .   Child: 0  Op: [ of type int [line: 35]							.   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 35]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 35]
.   .   .   .   Child: 1  Const 1 of type int [line: 35]						.   .   .   .   Child: 1  Const 1 of type int [line: 35]
.   .   Sibling: 25  Assign: -= of type int [line: 36]							.   .   Sibling: 25  Assign: -= of type int [line: 36]
.   .   .   Child: 0  Op: [ of type int [line: 36]							.   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 36]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 36]
.   .   .   .   Child: 1  Const 1 of type int [line: 36]						.   .   .   .   Child: 1  Const 1 of type int [line: 36]
.   .   .   Child: 1  Const 666 of type int [line: 36]							.   .   .   Child: 1  Const 666 of type int [line: 36]
.   .   Sibling: 26  Call: output of type void [line: 37]						.   .   Sibling: 26  Call: output of type void [line: 37]
.   .   .   Child: 0  Op: [ of type int [line: 37]							.   .   .   Child: 0  Op: [ of type int [line: 37]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 37]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 37]
.   .   .   .   Child: 1  Const 1 of type int [line: 37]						.   .   .   .   Child: 1  Const 1 of type int [line: 37]
.   .   Sibling: 27  Call: outnl of type void [line: 38]						.   .   Sibling: 27  Call: outnl of type void [line: 38]
.   .   Sibling: 28  Assign: = of type int [line: 40]						   |	.   .   Sibling: 28  Assign: := of type int [line: 40]
.   .   .   Child: 0  Op: [ of type int [line: 40]							.   .   .   Child: 0  Op: [ of type int [line: 40]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 40]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 40]
.   .   .   .   Child: 1  Const 1 of type int [line: 40]						.   .   .   .   Child: 1  Const 1 of type int [line: 40]
.   .   .   Child: 1  Const 777 of type int [line: 40]							.   .   .   Child: 1  Const 777 of type int [line: 40]
.   .   Sibling: 29  Call: output of type void [line: 41]						.   .   Sibling: 29  Call: output of type void [line: 41]
.   .   .   Child: 0  Op: [ of type int [line: 41]							.   .   .   Child: 0  Op: [ of type int [line: 41]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 41]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 41]
.   .   .   .   Child: 1  Const 1 of type int [line: 41]						.   .   .   .   Child: 1  Const 1 of type int [line: 41]
.   .   Sibling: 30  Assign: += of type int [line: 42]							.   .   Sibling: 30  Assign: += of type int [line: 42]
.   .   .   Child: 0  Op: [ of type int [line: 42]							.   .   .   Child: 0  Op: [ of type int [line: 42]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 42]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 42]
.   .   .   .   Child: 1  Const 1 of type int [line: 42]						.   .   .   .   Child: 1  Const 1 of type int [line: 42]
.   .   .   Child: 1  Const 666 of type int [line: 42]							.   .   .   Child: 1  Const 666 of type int [line: 42]
.   .   Sibling: 31  Call: output of type void [line: 43]						.   .   Sibling: 31  Call: output of type void [line: 43]
.   .   .   Child: 0  Op: [ of type int [line: 43]							.   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 43]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 43]
.   .   .   .   Child: 1  Const 1 of type int [line: 43]						.   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   Sibling: 32  Assign: -= of type int [line: 44]							.   .   Sibling: 32  Assign: -= of type int [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 44]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 44]
.   .   .   .   Child: 1  Const 1 of type int [line: 44]						.   .   .   .   Child: 1  Const 1 of type int [line: 44]
.   .   .   Child: 1  Const 666 of type int [line: 44]							.   .   .   Child: 1  Const 666 of type int [line: 44]
.   .   Sibling: 33  Call: output of type void [line: 45]						.   .   Sibling: 33  Call: output of type void [line: 45]
.   .   .   Child: 0  Op: [ of type int [line: 45]							.   .   .   Child: 0  Op: [ of type int [line: 45]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 45]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 45]
.   .   .   .   Child: 1  Const 1 of type int [line: 45]						.   .   .   .   Child: 1  Const 1 of type int [line: 45]
.   .   Sibling: 34  Call: outnl of type void [line: 46]						.   .   Sibling: 34  Call: outnl of type void [line: 46]
.   .   Sibling: 35  Assign: = of type int [line: 48]						   |	.   .   Sibling: 35  Assign: := of type int [line: 48]
.   .   .   Child: 0  Op: [ of type int [line: 48]							.   .   .   Child: 0  Op: [ of type int [line: 48]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 48]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 48]
.   .   .   .   Child: 1  Const 1 of type int [line: 48]						.   .   .   .   Child: 1  Const 1 of type int [line: 48]
.   .   .   Child: 1  Const 777 of type int [line: 48]							.   .   .   Child: 1  Const 777 of type int [line: 48]
.   .   Sibling: 36  Call: output of type void [line: 49]						.   .   Sibling: 36  Call: output of type void [line: 49]
.   .   .   Child: 0  Op: [ of type int [line: 49]							.   .   .   Child: 0  Op: [ of type int [line: 49]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 49]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 49]
.   .   .   .   Child: 1  Const 1 of type int [line: 49]						.   .   .   .   Child: 1  Const 1 of type int [line: 49]
.   .   Sibling: 37  Assign: += of type int [line: 50]							.   .   Sibling: 37  Assign: += of type int [line: 50]
.   .   .   Child: 0  Op: [ of type int [line: 50]							.   .   .   Child: 0  Op: [ of type int [line: 50]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 50]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 50]
.   .   .   .   Child: 1  Const 1 of type int [line: 50]						.   .   .   .   Child: 1  Const 1 of type int [line: 50]
.   .   .   Child: 1  Const 666 of type int [line: 50]							.   .   .   Child: 1  Const 666 of type int [line: 50]
.   .   Sibling: 38  Call: output of type void [line: 51]						.   .   Sibling: 38  Call: output of type void [line: 51]
.   .   .   Child: 0  Op: [ of type int [line: 51]							.   .   .   Child: 0  Op: [ of type int [line: 51]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 51]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 51]
.   .   .   .   Child: 1  Const 1 of type int [line: 51]						.   .   .   .   Child: 1  Const 1 of type int [line: 51]
.   .   Sibling: 39  Assign: -= of type int [line: 52]							.   .   Sibling: 39  Assign: -= of type int [line: 52]
.   .   .   Child: 0  Op: [ of type int [line: 52]							.   .   .   Child: 0  Op: [ of type int [line: 52]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 52]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 52]
.   .   .   .   Child: 1  Const 1 of type int [line: 52]						.   .   .   .   Child: 1  Const 1 of type int [line: 52]
.   .   .   Child: 1  Const 666 of type int [line: 52]							.   .   .   Child: 1  Const 666 of type int [line: 52]
.   .   Sibling: 40  Call: output of type void [line: 53]						.   .   Sibling: 40  Call: output of type void [line: 53]
.   .   .   Child: 0  Op: [ of type int [line: 53]							.   .   .   Child: 0  Op: [ of type int [line: 53]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 53]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 53]
.   .   .   .   Child: 1  Const 1 of type int [line: 53]						.   .   .   .   Child: 1  Const 1 of type int [line: 53]
.   .   Sibling: 41  Call: outnl of type void [line: 54]						.   .   Sibling: 41  Call: outnl of type void [line: 54]
.   .   Sibling: 42  Assign: = of type int [line: 56]						   |	.   .   Sibling: 42  Assign: := of type int [line: 56]
.   .   .   Child: 0  Op: [ of type int [line: 56]							.   .   .   Child: 0  Op: [ of type int [line: 56]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 56]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 56]
.   .   .   .   Child: 1  Const 1 of type int [line: 56]						.   .   .   .   Child: 1  Const 1 of type int [line: 56]
.   .   .   Child: 1  Const 3 of type int [line: 56]							.   .   .   Child: 1  Const 3 of type int [line: 56]
.   .   Sibling: 43  Assign: = of type int [line: 57]						   |	.   .   Sibling: 43  Assign: := of type int [line: 57]
.   .   .   Child: 0  Op: [ of type int [line: 57]							.   .   .   Child: 0  Op: [ of type int [line: 57]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 57]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 57]
.   .   .   .   Child: 1  Op: + of type int [line: 57]							.   .   .   .   Child: 1  Op: + of type int [line: 57]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 57]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 57]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 57]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 57]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 57]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 57]
.   .   .   Child: 1  Const 777 of type int [line: 57]							.   .   .   Child: 1  Const 777 of type int [line: 57]
.   .   Sibling: 44  Call: output of type void [line: 58]						.   .   Sibling: 44  Call: output of type void [line: 58]
.   .   .   Child: 0  Op: [ of type int [line: 58]							.   .   .   Child: 0  Op: [ of type int [line: 58]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 58]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 58]
.   .   .   .   Child: 1  Op: + of type int [line: 58]							.   .   .   .   Child: 1  Op: + of type int [line: 58]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 58]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 58]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 58]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 58]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 58]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 58]
.   .   Sibling: 45  Assign: += of type int [line: 59]							.   .   Sibling: 45  Assign: += of type int [line: 59]
.   .   .   Child: 0  Op: [ of type int [line: 59]							.   .   .   Child: 0  Op: [ of type int [line: 59]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 59]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 59]
.   .   .   .   Child: 1  Op: + of type int [line: 59]							.   .   .   .   Child: 1  Op: + of type int [line: 59]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 59]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 59]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 59]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 59]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 59]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 59]
.   .   .   Child: 1  Const 666 of type int [line: 59]							.   .   .   Child: 1  Const 666 of type int [line: 59]
.   .   Sibling: 46  Call: output of type void [line: 60]						.   .   Sibling: 46  Call: output of type void [line: 60]
.   .   .   Child: 0  Op: [ of type int [line: 60]							.   .   .   Child: 0  Op: [ of type int [line: 60]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 60]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 60]
.   .   .   .   Child: 1  Op: + of type int [line: 60]							.   .   .   .   Child: 1  Op: + of type int [line: 60]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 60]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 60]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 60]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 60]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 60]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 60]
.   .   Sibling: 47  Assign: -= of type int [line: 61]							.   .   Sibling: 47  Assign: -= of type int [line: 61]
.   .   .   Child: 0  Op: [ of type int [line: 61]							.   .   .   Child: 0  Op: [ of type int [line: 61]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 61]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 61]
.   .   .   .   Child: 1  Op: + of type int [line: 61]							.   .   .   .   Child: 1  Op: + of type int [line: 61]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 61]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 61]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 61]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 61]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 61]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 61]
.   .   .   Child: 1  Const 666 of type int [line: 61]							.   .   .   Child: 1  Const 666 of type int [line: 61]
.   .   Sibling: 48  Call: output of type void [line: 62]						.   .   Sibling: 48  Call: output of type void [line: 62]
.   .   .   Child: 0  Op: [ of type int [line: 62]							.   .   .   Child: 0  Op: [ of type int [line: 62]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 62]	.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -3 size: 1] [line: 62]
.   .   .   .   Child: 1  Op: + of type int [line: 62]							.   .   .   .   Child: 1  Op: + of type int [line: 62]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 62]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 62]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 62]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 62]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 62]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 62]
.   .   Sibling: 49  Call: outnl of type void [line: 63]						.   .   Sibling: 49  Call: outnl of type void [line: 63]
.   .   Sibling: 50  Assign: = of type int [line: 65]						   |	.   .   Sibling: 50  Assign: := of type int [line: 65]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 65]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 65]
.   .   .   Child: 1  Assign: = of type int [line: 65]						   |	.   .   .   Child: 1  Assign: := of type int [line: 65]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 65]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 65]
.   .   .   .   Child: 1  Const 777 of type int [line: 65]						.   .   .   .   Child: 1  Const 777 of type int [line: 65]
.   .   Sibling: 51  Call: output of type void [line: 66]						.   .   Sibling: 51  Call: output of type void [line: 66]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 66]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 66]
.   .   Sibling: 52  Assign: = of type int [line: 67]						   |	.   .   Sibling: 52  Assign: := of type int [line: 67]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 67]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 67]
.   .   .   Child: 1  Assign: += of type int [line: 67]							.   .   .   Child: 1  Assign: += of type int [line: 67]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 67]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 67]
.   .   .   .   Child: 1  Const 666 of type int [line: 67]						.   .   .   .   Child: 1  Const 666 of type int [line: 67]
.   .   Sibling: 53  Call: output of type void [line: 68]						.   .   Sibling: 53  Call: output of type void [line: 68]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 68]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 68]
.   .   Sibling: 54  Assign: = of type int [line: 69]						   |	.   .   Sibling: 54  Assign: := of type int [line: 69]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 69]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 69]
.   .   .   Child: 1  Assign: -= of type int [line: 69]							.   .   .   Child: 1  Assign: -= of type int [line: 69]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 69]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 69]
.   .   .   .   Child: 1  Const 666 of type int [line: 69]						.   .   .   .   Child: 1  Const 666 of type int [line: 69]
.   .   Sibling: 55  Call: output of type void [line: 70]						.   .   Sibling: 55  Call: output of type void [line: 70]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 70]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -16 size: 1] [line: 70]
.   .   Sibling: 56  Call: outnl of type void [line: 71]						.   .   Sibling: 56  Call: outnl of type void [line: 71]
.   .   Sibling: 57  Assign: = of type int [line: 73]						   |	.   .   Sibling: 57  Assign: := of type int [line: 73]
.   .   .   Child: 0  Op: [ of type int [line: 73]							.   .   .   Child: 0  Op: [ of type int [line: 73]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 73]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 73]
.   .   .   .   Child: 1  Const 1 of type int [line: 73]						.   .   .   .   Child: 1  Const 1 of type int [line: 73]
.   .   .   Child: 1  Assign: = of type int [line: 73]						   |	.   .   .   Child: 1  Assign: := of type int [line: 73]
.   .   .   .   Child: 0  Op: [ of type int [line: 73]							.   .   .   .   Child: 0  Op: [ of type int [line: 73]
.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 73	.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 73
.   .   .   .   .   Child: 1  Const 2 of type int [line: 73]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 73]
.   .   .   .   Child: 1  Const 777 of type int [line: 73]						.   .   .   .   Child: 1  Const 777 of type int [line: 73]
.   .   Sibling: 58  Call: output of type void [line: 74]						.   .   Sibling: 58  Call: output of type void [line: 74]
.   .   .   Child: 0  Op: [ of type int [line: 74]							.   .   .   Child: 0  Op: [ of type int [line: 74]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 74]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 74]
.   .   .   .   Child: 1  Const 1 of type int [line: 74]						.   .   .   .   Child: 1  Const 1 of type int [line: 74]
.   .   Sibling: 59  Assign: = of type int [line: 75]						   |	.   .   Sibling: 59  Assign: := of type int [line: 75]
.   .   .   Child: 0  Op: [ of type int [line: 75]							.   .   .   Child: 0  Op: [ of type int [line: 75]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 75]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 75]
.   .   .   .   Child: 1  Const 1 of type int [line: 75]						.   .   .   .   Child: 1  Const 1 of type int [line: 75]
.   .   .   Child: 1  Assign: += of type int [line: 75]							.   .   .   Child: 1  Assign: += of type int [line: 75]
.   .   .   .   Child: 0  Op: [ of type int [line: 75]							.   .   .   .   Child: 0  Op: [ of type int [line: 75]
.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 75	.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 75
.   .   .   .   .   Child: 1  Const 2 of type int [line: 75]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 75]
.   .   .   .   Child: 1  Const 666 of type int [line: 75]						.   .   .   .   Child: 1  Const 666 of type int [line: 75]
.   .   Sibling: 60  Call: output of type void [line: 76]						.   .   Sibling: 60  Call: output of type void [line: 76]
.   .   .   Child: 0  Op: [ of type int [line: 76]							.   .   .   Child: 0  Op: [ of type int [line: 76]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 76]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 76]
.   .   .   .   Child: 1  Const 1 of type int [line: 76]						.   .   .   .   Child: 1  Const 1 of type int [line: 76]
.   .   Sibling: 61  Assign: = of type int [line: 77]						   |	.   .   Sibling: 61  Assign: := of type int [line: 77]
.   .   .   Child: 0  Op: [ of type int [line: 77]							.   .   .   Child: 0  Op: [ of type int [line: 77]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 77]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 77]
.   .   .   .   Child: 1  Const 1 of type int [line: 77]						.   .   .   .   Child: 1  Const 1 of type int [line: 77]
.   .   .   Child: 1  Assign: -= of type int [line: 77]							.   .   .   Child: 1  Assign: -= of type int [line: 77]
.   .   .   .   Child: 0  Op: [ of type int [line: 77]							.   .   .   .   Child: 0  Op: [ of type int [line: 77]
.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 77	.   .   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 77
.   .   .   .   .   Child: 1  Const 2 of type int [line: 77]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 77]
.   .   .   .   Child: 1  Const 666 of type int [line: 77]						.   .   .   .   Child: 1  Const 666 of type int [line: 77]
.   .   Sibling: 62  Call: output of type void [line: 78]						.   .   Sibling: 62  Call: output of type void [line: 78]
.   .   .   Child: 0  Op: [ of type int [line: 78]							.   .   .   Child: 0  Op: [ of type int [line: 78]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 78]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Local loc: -6 size: 11] [line: 78]
.   .   .   .   Child: 1  Const 1 of type int [line: 78]						.   .   .   .   Child: 1  Const 1 of type int [line: 78]
.   .   Sibling: 63  Call: outnl of type void [line: 79]						.   .   Sibling: 63  Call: outnl of type void [line: 79]
.   .   Sibling: 64  Assign: += of type int [line: 81]							.   .   Sibling: 64  Assign: += of type int [line: 81]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 81]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 81]
.   .   .   Child: 1  Op: * of type int [line: 81]							.   .   .   Child: 1  Op: * of type int [line: 81]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 81]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 81]
.   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -16 size: 1] [line: 81]			.   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -16 size: 1] [line: 81]
.   .   Sibling: 65  Call: output of type void [line: 82]						.   .   Sibling: 65  Call: output of type void [line: 82]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 82]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -4 size: 1] [line: 82]
.   .   Sibling: 66  Call: outnl of type void [line: 83]						.   .   Sibling: 66  Call: outnl of type void [line: 83]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 86]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 86]
.   Child: 1  Compound [mem: None loc: 0 size: -24] [line: 87]						.   Child: 1  Compound [mem: None loc: 0 size: -24] [line: 87]
.   .   Child: 0  Var: pp of type int [mem: Local loc: -2 size: 1] [line: 88]				.   .   Child: 0  Var: pp of type int [mem: Local loc: -2 size: 1] [line: 88]
.   .   Sibling: 1  Var: qq of array of type int [mem: Local loc: -4 size: 21] [line: 88]		.   .   Sibling: 1  Var: qq of array of type int [mem: Local loc: -4 size: 21] [line: 88]
.   .   Child: 1  Assign: = of type int [line: 89]						   |	.   .   Child: 1  Assign: := of type int [line: 89]
.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 89]			.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 89]
.   .   .   Child: 1  Const 888 of type int [line: 89]							.   .   .   Child: 1  Const 888 of type int [line: 89]
.   .   Sibling: 1  Assign: = of type int [line: 90]						   |	.   .   Sibling: 1  Assign: := of type int [line: 90]
.   .   .   Child: 0  Op: [ of type int [line: 90]							.   .   .   Child: 0  Op: [ of type int [line: 90]
.   .   .   .   Child: 0  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 90]		.   .   .   .   Child: 0  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 90]
.   .   .   .   Child: 1  Const 1 of type int [line: 90]						.   .   .   .   Child: 1  Const 1 of type int [line: 90]
.   .   .   Child: 1  Const 999 of type int [line: 90]							.   .   .   Child: 1  Const 999 of type int [line: 90]
.   .   Sibling: 2  Call: dog of type void [line: 91]							.   .   Sibling: 2  Call: dog of type void [line: 91]
.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 91]			.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 91]
.   .   .   Sibling: 1  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 91]		.   .   .   Sibling: 1  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 91]
.   .   Sibling: 3  Call: output of type void [line: 92]						.   .   Sibling: 3  Call: output of type void [line: 92]
.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 92]			.   .   .   Child: 0  Id: pp of type int [mem: Local loc: -2 size: 1] [line: 92]
.   .   Sibling: 4  Call: output of type void [line: 93]						.   .   Sibling: 4  Call: output of type void [line: 93]
.   .   .   Child: 0  Op: [ of type int [line: 93]							.   .   .   Child: 0  Op: [ of type int [line: 93]
.   .   .   .   Child: 0  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 93]		.   .   .   .   Child: 0  Id: qq of array of type int [mem: Local loc: -4 size: 21] [line: 93]
.   .   .   .   Child: 1  Const 1 of type int [line: 93]						.   .   .   .   Child: 1  Const 1 of type int [line: 93]
.   .   Sibling: 5  Call: outnl of type void [line: 94]							.   .   Sibling: 5  Call: outnl of type void [line: 94]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
assign6.out ztmp23114.txt differ: byte 1, line 1
assign6 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/assign6.tm
Number of errors: 0										   |	777 1443 777
------------------------------------								   |	777 1443 777
Loading file: assign6.tm									   |	777 1443 777
												   >	777 1443 777
												   >	777 1443 777
												   >	777 1443 777
												   >	777 1443 777
												   >	777 1443 777
												   >	777 1443 777
												   >	604506
												   >	888 777
Bye.													Bye.
====================================
FILE: break2.c-
-rw-------. 1 corg7983 domain_users  318 Nov 17 15:35 break2.c-
-rw-------. 1 corg7983 domain_users  320 Nov 17 15:35 break2.c-.f21
-rw-------. 1 corg7983 domain_users  318 Nov 17 15:35 break2.c-.f22
-rw-------. 1 corg7983 domain_users   64 Nov 17 15:35 break2.expected
-rw-------. 1 corg7983 domain_users 2855 Nov 22 12:27 break2.mem
-rw-------. 1 corg7983 domain_users  246 Nov 17 15:35 break2.mem.diffs
-rw-------. 1 corg7983 domain_users 3698 Nov 17 15:35 break2.mem.f21
-rw-------. 1 corg7983 domain_users  108 Nov 22 12:27 break2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 break2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 break2.tm.diffs
-rw-------. 1 corg7983 domain_users 6241 Nov 17 15:35 break2.tm.f21
TM CODE COMPARISON
break2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  break2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-2(1)	Load variable i
												   >	 43:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 44:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 45:     LD  4,-3(1)	Pop left into ac1 
												   >	 46:    TLT  3,4,3	Op < 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 49:    LDC  3,0(6)	Load integer constant 
												   >	 50:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	 51:     LD  3,-3(1)	Load variable j
												   >	 52:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 53:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 54:     LD  4,-4(1)	Pop left into ac1 
												   >	 55:    TLE  3,4,3	Op <= 
												   >	 56:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 58:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 59:     LD  3,-2(1)	Load variable i
												   >	 60:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 61:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 62:    LDA  3,1(7)	Return address in ac 
												   >	 63:    JMP  7,-58(7)	CALL output
												   >	 64:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 65:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 66:     LD  3,-3(1)	Load variable j
												   >	 67:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 68:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 69:    LDA  3,1(7)	Return address in ac 
												   >	 70:    JMP  7,-65(7)	CALL output
												   >	 71:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 72:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 73:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 74:    LDA  3,1(7)	Return address in ac 
												   >	 75:    JMP  7,-42(7)	CALL outnl
												   >	 76:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* IF
												   >	 77:     LD  3,-2(1)	Load variable i
												   >	 78:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 79:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 80:     LD  4,-4(1)	Pop left into ac1 
												   >	 81:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* BREAK
												   >	 83:    JMP  7,-27(7)	break 
												   >	 82:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 84:     LD  3,-3(1)	load lhs variable j
												   >	 85:    LDA  3,1(3)	increment value of j
												   >	 86:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	 87:    JMP  7,-37(7)	go to beginning of loop 
												   >	 57:    JMP  7,30(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	 88:     LD  3,-3(1)	Load variable j
												   >	 89:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 90:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 91:     LD  4,-4(1)	Pop left into ac1 
												   >	 92:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* BREAK
												   >	 94:    JMP  7,-47(7)	break 
												   >	 93:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 95:     LD  3,-2(1)	load lhs variable i
												   >	 96:    LDA  3,1(3)	increment value of i
												   >	 97:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 98:    JMP  7,-57(7)	go to beginning of loop 
												   >	 48:    JMP  7,50(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 99:    LDC  3,0(6)	Load integer constant 
												   >	100:    LDA  2,0(3)	Copy result to return register 
												   >	101:     LD  3,-1(1)	Load return address 
												   >	102:     LD  1,0(1)	Adjust fp 
												   >	103:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	104:    LDC  2,0(6)	Set return value to 0 
												   >	105:     LD  3,-1(1)	Load return address 
												   >	106:     LD  1,0(1)	Adjust fp 
												   >	107:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,107(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	108:    LDA  1,0(0)	set first frame at end of globals 
												   >	109:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-73(7)	Jump to main 
												   >	112:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
break2.mem break2.mem.f21 differ: byte 7, line 1
break2 (MEM DIFF)
Func: main returns type int [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Const 0 of type int [line: 5]							.   .   .   Child: 1  Const 0 of type int [line: 5]
.   .   Sibling: 1  While [line: 6]									.   .   Sibling: 1  While [line: 6]
.   .   .   Child: 0  Op: < of type bool [line: 6]							.   .   .   Child: 0  Op: < of type bool [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 10 of type int [line: 6]						.   .   .   .   Child: 1  Const 10 of type int [line: 6]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]
.   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   .   Child: 1  Assign: = of type int [line: 9]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 9]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 9]
.   .   .   .   Sibling: 1  While [line: 10]								.   .   .   .   Sibling: 1  While [line: 10]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 10]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 10]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 10]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 10]					.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 10]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 10]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 10]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 11]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 11]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 11]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 12]				.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 12]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 13]					.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 13]
.   .   .   .   .   .   Sibling: 3  If [line: 14]							.   .   .   .   .   .   Sibling: 3  If [line: 14]
.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 14]					.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 14]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 14]				.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 14]
.   .   .   .   .   .   .   Child: 1  Break [line: 14]							.   .   .   .   .   .   .   Child: 1  Break [line: 14]
.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 15]					.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 15]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 15]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   .   .   Sibling: 2  If [line: 17]								.   .   .   .   Sibling: 2  If [line: 17]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 17]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 17]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 17]					.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 17]
.   .   .   .   .   Child: 1  Break [line: 17]								.   .   .   .   .   Child: 1  Break [line: 17]
.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 18]						.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 18]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 2  Return [line: 21]									.   .   Sibling: 2  Return [line: 21]
.   .   .   Child: 0  Const 0 of type int [line: 21]							.   .   .   Child: 0  Const 0 of type int [line: 21]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
break2.out ztmp23114.txt differ: byte 1, line 1
break2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/break2.tm
Number of errors: 0										   |	0 0
------------------------------------								   |	0 1
Loading file: break2.tm										   |	0 2
												   >	0 3
												   >	0 4
												   >	0 5
Bye.													Bye.
====================================
FILE: call2.c-
-rw-------. 1 corg7983 domain_users  227 Nov 17 15:35 call2.c-
-rw-------. 1 corg7983 domain_users  233 Nov 17 15:35 call2.c-.f21
-rw-------. 1 corg7983 domain_users  227 Nov 17 15:35 call2.c-.f22
-rw-------. 1 corg7983 domain_users   43 Nov 17 15:35 call2.expected
-rw-------. 1 corg7983 domain_users 2937 Nov 22 12:27 call2.mem
-rw-------. 1 corg7983 domain_users  718 Nov 17 15:35 call2.mem.diffs
-rw-------. 1 corg7983 domain_users 3785 Nov 17 15:35 call2.mem.f21
-rw-------. 1 corg7983 domain_users  107 Nov 22 12:27 call2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 call2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 call2.tm.diffs
-rw-------. 1 corg7983 domain_users 6045 Nov 17 15:35 call2.tm.f21
TM CODE COMPARISON
call2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  call2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,444(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 42:    LDC  3,9(6)	Load integer constant 
												   >	 43:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	 44:    LDC  3,555(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 45:     LD  4,-4(1)	Pop index 
												   >	 46:     LD  5,-3(1)	Load address of base of array b
												   >	 47:    SUB  5,5,4	Compute offset of value 
												   >	 48:     ST  3,0(5)	Store variable b
												   >	* RETURN
												   >	 49:     LD  3,-3(1)	Load address of base of array b
												   >	 50:     LD  3,1(3)	Load array size 
												   >	 51:    LDA  2,0(3)	Copy result to return register 
												   >	 52:     LD  3,-1(1)	Load return address 
												   >	 53:     LD  1,0(1)	Adjust fp 
												   >	 54:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 55:    LDC  2,0(6)	Set return value to 0 
												   >	 56:     LD  3,-1(1)	Load return address 
												   >	 57:     LD  1,0(1)	Adjust fp 
												   >	 58:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 59:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	 60:    LDC  3,10(6)	load size of array y
												   >	 61:     ST  3,-3(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 62:    LDC  3,1(6)	Load Boolean constant 
												   >	 63:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	 64:    LDC  3,9(6)	Load integer constant 
												   >	 65:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	 66:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -14
												   >	 67:     LD  4,-14(1)	Pop index 
												   >	 68:    LDA  5,-2(0)	Load address of base of array h
												   >	 69:    SUB  5,5,4	Compute offset of value 
												   >	 70:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	 71:    LDC  3,111(6)	Load integer constant 
												   >	 72:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 73:    LDC  3,9(6)	Load integer constant 
												   >	 74:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	 75:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	 76:     LD  4,-14(1)	Pop index 
												   >	 77:    LDA  5,-4(1)	Load address of base of array y
												   >	 78:    SUB  5,5,4	Compute offset of value 
												   >	 79:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 80:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	 81:    LDC  3,333(6)	Load integer constant 
												   >	 82:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	* CALL dog
												   >	 83:     ST  1,-17(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -18
												   >	* TOFF dec: -19
												   >	* Param 1
												   >	 84:     LD  3,-2(1)	Load variable x
												   >	 85:     ST  3,-19(1)	Push parameter 
												   >	* TOFF dec: -20
												   >	* Param 2
												   >	 86:    LDA  3,-4(1)	Load address of base of array y
												   >	 87:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end dog
												   >	 88:    LDA  1,-17(1)	Ghost frame becomes new active frame 
												   >	 89:    LDA  3,1(7)	Return address in ac 
												   >	 90:    JMP  7,-52(7)	CALL dog
												   >	 91:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -17
												   >	* TOFF inc: -16
												   >	 92:     LD  4,-16(1)	Pop left into ac1 
												   >	 93:    ADD  3,4,3	Op + 
												   >	 94:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	 95:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	 96:    LDA  3,1(7)	Return address in ac 
												   >	 97:    JMP  7,-92(7)	CALL output
												   >	 98:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 99:    LDC  2,0(6)	Set return value to 0 
												   >	100:     LD  3,-1(1)	Load return address 
												   >	101:     LD  1,0(1)	Adjust fp 
												   >	102:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,102(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	103:    LDA  1,-12(0)	set first frame at end of globals 
												   >	104:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	105:    LDC  3,10(6)	load size of array h
												   >	106:     ST  3,-1(0)	save size of array h
												   >	* END INIT GLOBALS AND STATICS
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-50(7)	Jump to main 
												   >	109:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
call2.mem call2.mem.f21 differ: byte 1, line 1
call2 (MEM DIFF)
Var: g of type bool [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: h of array of type bool [mem: Global loc: -2 size: 11] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type bool [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: h of array of type bool [mem: Global loc: -2 size: 11] [line: 1]
												   >	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]			.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 5]			.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Const 444 of type int [line: 5]							.   .   .   Child: 1  Const 444 of type int [line: 5]
.   .   Sibling: 1  Assign: = of type int [line: 6]						   |	.   .   Sibling: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 9 of type int [line: 6]							.   .   .   .   Child: 1  Const 9 of type int [line: 6]
.   .   .   Child: 1  Const 555 of type int [line: 6]							.   .   .   Child: 1  Const 555 of type int [line: 6]
.   .   Sibling: 2  Return [line: 8]									.   .   Sibling: 2  Return [line: 8]
.   .   .   Child: 0  Op: sizeof of type int [line: 8]							.   .   .   Child: 0  Op: sizeof of type int [line: 8]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 8]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 8]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 12]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -4 size: 11] [line: 13]		.   .   Sibling: 1  Var: y of array of type int [mem: Local loc: -4 size: 11] [line: 13]
.   .   Child: 1  Assign: = of type bool [line: 15]						   |	.   .   Child: 1  Assign: := of type bool [line: 15]
.   .   .   Child: 0  Id: g of type bool [mem: Global loc: 0 size: 1] [line: 15]			.   .   .   Child: 0  Id: g of type bool [mem: Global loc: 0 size: 1] [line: 15]
.   .   .   Child: 1  Const true of type bool [line: 15]						.   .   .   Child: 1  Const true of type bool [line: 15]
.   .   Sibling: 1  Assign: = of type bool [line: 16]						   |	.   .   Sibling: 1  Assign: := of type bool [line: 16]
.   .   .   Child: 0  Op: [ of type bool [line: 16]							.   .   .   Child: 0  Op: [ of type bool [line: 16]
.   .   .   .   Child: 0  Id: h of array of type bool [mem: Global loc: -2 size: 11] [line: 16]		.   .   .   .   Child: 0  Id: h of array of type bool [mem: Global loc: -2 size: 11] [line: 16]
.   .   .   .   Child: 1  Const 9 of type int [line: 16]						.   .   .   .   Child: 1  Const 9 of type int [line: 16]
.   .   .   Child: 1  Const false of type bool [line: 16]						.   .   .   Child: 1  Const false of type bool [line: 16]
.   .   Sibling: 2  Assign: = of type int [line: 18]						   |	.   .   Sibling: 2  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   Child: 1  Const 111 of type int [line: 18]							.   .   .   Child: 1  Const 111 of type int [line: 18]
.   .   Sibling: 3  Assign: = of type int [line: 19]						   |	.   .   Sibling: 3  Assign: := of type int [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -4 size: 11] [line: 19]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -4 size: 11] [line: 19]
.   .   .   .   Child: 1  Const 9 of type int [line: 19]						.   .   .   .   Child: 1  Const 9 of type int [line: 19]
.   .   .   Child: 1  Const 222 of type int [line: 19]							.   .   .   Child: 1  Const 222 of type int [line: 19]
.   .   Sibling: 4  Call: output of type void [line: 21]						.   .   Sibling: 4  Call: output of type void [line: 21]
.   .   .   Child: 0  Op: + of type int [line: 21]							.   .   .   Child: 0  Op: + of type int [line: 21]
.   .   .   .   Child: 0  Const 333 of type int [line: 21]						.   .   .   .   Child: 0  Const 333 of type int [line: 21]
.   .   .   .   Child: 1  Call: dog of type int [line: 21]						.   .   .   .   Child: 1  Call: dog of type int [line: 21]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 21]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   .   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -4 size: 11] [line: 	.   .   .   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -4 size: 11] [line: 
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
call2.out ztmp23114.txt differ: byte 1, line 1
call2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/call2.tm
Number of errors: 0										   |	343
------------------------------------								   <
Loading file: call2.tm										   <
Bye.													Bye.
====================================
FILE: call5.c-
-rw-------. 1 corg7983 domain_users   370 Nov 17 15:35 call5.c-
-rw-------. 1 corg7983 domain_users   375 Nov 17 15:35 call5.c-.f21
-rw-------. 1 corg7983 domain_users   370 Nov 17 15:35 call5.c-.f22
-rw-------. 1 corg7983 domain_users    71 Nov 17 15:35 call5.expected
-rw-------. 1 corg7983 domain_users  4329 Nov 22 12:27 call5.mem
-rw-------. 1 corg7983 domain_users   581 Nov 17 15:35 call5.mem.diffs
-rw-------. 1 corg7983 domain_users  5178 Nov 17 15:35 call5.mem.f21
-rw-------. 1 corg7983 domain_users   107 Nov 22 12:27 call5.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 call5.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 call5.tm.diffs
-rw-------. 1 corg7983 domain_users 11339 Nov 17 15:35 call5.tm.f21
TM CODE COMPARISON
call5 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  call5.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,2(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    MUL  3,4,3	Op * 
												   >	 45:     ST  3,0(0)	Store variable g
												   >	* RETURN
												   >	 46:     LD  3,-2(1)	Load variable x
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 51:    LDC  2,0(6)	Set return value to 0 
												   >	 52:     LD  3,-1(1)	Load return address 
												   >	 53:     LD  1,0(1)	Adjust fp 
												   >	 54:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -3
												   >	 55:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 56:    LDC  3,3(6)	Load integer constant 
												   >	 57:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 58:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	 59:     LD  4,-3(1)	Pop left into ac1 
												   >	 60:    MUL  3,4,3	Op * 
												   >	 61:     ST  3,0(0)	Store variable g
												   >	* RETURN
												   >	 62:     LD  3,-1(1)	Load return address 
												   >	 63:     LD  1,0(1)	Adjust fp 
												   >	 64:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 65:    LDC  2,0(6)	Set return value to 0 
												   >	 66:     LD  3,-1(1)	Load return address 
												   >	 67:     LD  1,0(1)	Adjust fp 
												   >	 68:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION elk
												   >	* TOFF set: -3
												   >	 69:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 70:    LDC  3,4(6)	Load integer constant 
												   >	 71:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 72:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	 73:     LD  4,-3(1)	Pop left into ac1 
												   >	 74:    MUL  3,4,3	Op * 
												   >	 75:     ST  3,0(0)	Store variable g
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 76:    LDC  2,0(6)	Set return value to 0 
												   >	 77:     LD  3,-1(1)	Load return address 
												   >	 78:     LD  1,0(1)	Adjust fp 
												   >	 79:    JMP  7,0(3)	Return 
												   >	* END FUNCTION elk
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION fox
												   >	* TOFF set: -3
												   >	 80:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 81:    LDC  3,5(6)	Load integer constant 
												   >	 82:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 83:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	 84:     LD  4,-3(1)	Pop left into ac1 
												   >	 85:    MUL  3,4,3	Op * 
												   >	 86:     ST  3,0(0)	Store variable g
												   >	* RETURN
												   >	 87:     LD  3,0(0)	Load variable g
												   >	 88:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 89:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 90:     LD  4,-3(1)	Pop left into ac1 
												   >	 91:    ADD  3,4,3	Op + 
												   >	 92:    LDA  2,0(3)	Copy result to return register 
												   >	 93:     LD  3,-1(1)	Load return address 
												   >	 94:     LD  1,0(1)	Adjust fp 
												   >	 95:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 96:    LDC  2,0(6)	Set return value to 0 
												   >	 97:     LD  3,-1(1)	Load return address 
												   >	 98:     LD  1,0(1)	Adjust fp 
												   >	 99:    JMP  7,0(3)	Return 
												   >	* END FUNCTION fox
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	100:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	101:    LDC  3,1279(6)	Load integer constant 
												   >	102:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	103:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	104:     LD  3,0(0)	Load variable g
												   >	105:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	106:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-103(7)	CALL output
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	110:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL dog
												   >	111:     ST  1,-4(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	112:    LDC  3,111(6)	Load integer constant 
												   >	113:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end dog
												   >	114:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-78(7)	CALL dog
												   >	117:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -4
												   >	118:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	119:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-116(7)	CALL output
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	123:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	124:     LD  3,0(0)	Load variable g
												   >	125:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	126:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-123(7)	CALL output
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL cat
												   >	130:     ST  1,-2(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	131:    LDC  3,222(6)	Load integer constant 
												   >	132:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end cat
												   >	133:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	134:    LDA  3,1(7)	Return address in ac 
												   >	135:    JMP  7,-81(7)	CALL cat
												   >	136:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	137:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	138:     LD  3,0(0)	Load variable g
												   >	139:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	140:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	141:    LDA  3,1(7)	Return address in ac 
												   >	142:    JMP  7,-137(7)	CALL output
												   >	143:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL elk
												   >	144:     ST  1,-2(1)	Store fp in ghost frame for elk
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	145:    LDC  3,333(6)	Load integer constant 
												   >	146:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end elk
												   >	147:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	148:    LDA  3,1(7)	Return address in ac 
												   >	149:    JMP  7,-81(7)	CALL elk
												   >	150:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end elk
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	151:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	152:     LD  3,0(0)	Load variable g
												   >	153:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	154:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-151(7)	CALL output
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	158:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL fox
												   >	159:     ST  1,-4(1)	Store fp in ghost frame for fox
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	160:    LDC  3,444(6)	Load integer constant 
												   >	161:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end fox
												   >	162:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	163:    LDA  3,1(7)	Return address in ac 
												   >	164:    JMP  7,-85(7)	CALL fox
												   >	165:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fox
												   >	* TOFF set: -4
												   >	166:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	167:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	168:    LDA  3,1(7)	Return address in ac 
												   >	169:    JMP  7,-164(7)	CALL output
												   >	170:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	171:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	172:     LD  3,0(0)	Load variable g
												   >	173:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	174:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	175:    LDA  3,1(7)	Return address in ac 
												   >	176:    JMP  7,-171(7)	CALL output
												   >	177:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	178:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	179:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	180:    LDA  3,1(7)	Return address in ac 
												   >	181:    JMP  7,-148(7)	CALL outnl
												   >	182:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	183:    LDC  2,0(6)	Set return value to 0 
												   >	184:     LD  3,-1(1)	Load return address 
												   >	185:     LD  1,0(1)	Adjust fp 
												   >	186:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,186(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	187:    LDA  1,-1(0)	set first frame at end of globals 
												   >	188:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	189:    LDA  3,1(7)	Return address in ac 
												   >	190:    JMP  7,-91(7)	Jump to main 
												   >	191:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
call5.mem call5.mem.f21 differ: byte 1, line 1
call5 (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 1  Assign: = of type int [line: 3]						   |	.   .   Child: 1  Assign: := of type int [line: 3]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 3]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 3]
.   .   .   Child: 1  Op: * of type int [line: 3]							.   .   .   Child: 1  Op: * of type int [line: 3]
.   .   .   .   Child: 0  Const 2 of type int [line: 3]							.   .   .   .   Child: 0  Const 2 of type int [line: 3]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Return [line: 4]									.   .   Sibling: 1  Return [line: 4]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]
Sibling: 2  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 7]			   |	Sibling: 9  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 7]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]
.   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 8]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 8]
.   .   .   Child: 1  Op: * of type int [line: 8]							.   .   .   Child: 1  Op: * of type int [line: 8]
.   .   .   .   Child: 0  Const 3 of type int [line: 8]							.   .   .   .   Child: 0  Const 3 of type int [line: 8]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 8]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   Sibling: 1  Return [line: 9]									.   .   Sibling: 1  Return [line: 9]
Sibling: 3  Func: elk returns type void [mem: Global loc: 0 size: -3] [line: 12]		   |	Sibling: 10  Func: elk returns type void [mem: Global loc: 0 size: -3] [line: 12]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 13]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 13]
.   .   .   Child: 1  Op: * of type int [line: 13]							.   .   .   Child: 1  Op: * of type int [line: 13]
.   .   .   .   Child: 0  Const 4 of type int [line: 13]						.   .   .   .   Child: 0  Const 4 of type int [line: 13]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 13]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 13]
Sibling: 4  Func: fox returns type int [mem: Global loc: 0 size: -3] [line: 16]			   |	Sibling: 11  Func: fox returns type int [mem: Global loc: 0 size: -3] [line: 16]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 16]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 16]
.   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]
.   .   .   Child: 1  Op: * of type int [line: 17]							.   .   .   Child: 1  Op: * of type int [line: 17]
.   .   .   .   Child: 0  Const 5 of type int [line: 17]						.   .   .   .   Child: 0  Const 5 of type int [line: 17]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 17]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 17]
.   .   Sibling: 1  Return [line: 18]									.   .   Sibling: 1  Return [line: 18]
.   .   .   Child: 0  Op: + of type int [line: 18]							.   .   .   Child: 0  Op: + of type int [line: 18]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]
.   .   .   .   Child: 1  Const 1 of type int [line: 18]						.   .   .   .   Child: 1  Const 1 of type int [line: 18]
Sibling: 5  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 21]		   |	Sibling: 12  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 21]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 22]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 22]
.   .   Child: 1  Assign: = of type int [line: 23]						   |	.   .   Child: 1  Assign: := of type int [line: 23]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 23]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 23]
.   .   .   Child: 1  Const 1279 of type int [line: 23]							.   .   .   Child: 1  Const 1279 of type int [line: 23]
.   .   Sibling: 1  Call: output of type void [line: 24]						.   .   Sibling: 1  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]
.   .   Sibling: 2  Call: output of type void [line: 25]						.   .   Sibling: 2  Call: output of type void [line: 25]
.   .   .   Child: 0  Call: dog of type int [line: 25]							.   .   .   Child: 0  Call: dog of type int [line: 25]
.   .   .   .   Child: 0  Const 111 of type int [line: 25]						.   .   .   .   Child: 0  Const 111 of type int [line: 25]
.   .   Sibling: 3  Call: output of type void [line: 26]						.   .   Sibling: 3  Call: output of type void [line: 26]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 26]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 26]
.   .   Sibling: 4  Call: cat of type void [line: 27]							.   .   Sibling: 4  Call: cat of type void [line: 27]
.   .   .   Child: 0  Const 222 of type int [line: 27]							.   .   .   Child: 0  Const 222 of type int [line: 27]
.   .   Sibling: 5  Call: output of type void [line: 28]						.   .   Sibling: 5  Call: output of type void [line: 28]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 28]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 28]
.   .   Sibling: 6  Call: elk of type void [line: 29]							.   .   Sibling: 6  Call: elk of type void [line: 29]
.   .   .   Child: 0  Const 333 of type int [line: 29]							.   .   .   Child: 0  Const 333 of type int [line: 29]
.   .   Sibling: 7  Call: output of type void [line: 30]						.   .   Sibling: 7  Call: output of type void [line: 30]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 30]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 30]
.   .   Sibling: 8  Call: output of type void [line: 31]						.   .   Sibling: 8  Call: output of type void [line: 31]
.   .   .   Child: 0  Call: fox of type int [line: 31]							.   .   .   Child: 0  Call: fox of type int [line: 31]
.   .   .   .   Child: 0  Const 444 of type int [line: 31]						.   .   .   .   Child: 0  Const 444 of type int [line: 31]
.   .   Sibling: 9  Call: output of type void [line: 32]						.   .   Sibling: 9  Call: output of type void [line: 32]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 32]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 32]
.   .   Sibling: 10  Call: outnl of type void [line: 33]						.   .   Sibling: 10  Call: outnl of type void [line: 33]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
call5.out ztmp23114.txt differ: byte 1, line 1
call5 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/call5.tm
Number of errors: 0										   |	1279 111 222 666 1332 2221 2220
------------------------------------								   <
Loading file: call5.tm										   <
Bye.													Bye.
====================================
FILE: call.c-
-rw-------. 1 corg7983 domain_users  1267 Nov 17 15:35 call.c-
-rw-------. 1 corg7983 domain_users  1285 Nov 17 15:35 call.c-.f21
-rw-------. 1 corg7983 domain_users  1267 Nov 17 15:35 call.c-.f22
-rw-------. 1 corg7983 domain_users   115 Nov 17 15:35 call.expected
-rw-------. 1 corg7983 domain_users 15904 Nov 22 12:27 call.mem
-rw-------. 1 corg7983 domain_users  2220 Nov 17 15:35 call.mem.diffs
-rw-------. 1 corg7983 domain_users 16770 Nov 17 15:35 call.mem.f21
-rw-------. 1 corg7983 domain_users   106 Nov 22 12:27 call.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 call.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 call.tm.diffs
-rw-------. 1 corg7983 domain_users 32315 Nov 17 15:35 call.tm.f21
TM CODE COMPARISON
call (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  call.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION showInt
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load variable x
												   >	 42:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 43:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 47:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 48:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 49:    LDA  3,1(7)	Return address in ac 
												   >	 50:    JMP  7,-17(7)	CALL outnl
												   >	 51:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 52:    LDC  2,0(6)	Set return value to 0 
												   >	 53:     LD  3,-1(1)	Load return address 
												   >	 54:     LD  1,0(1)	Adjust fp 
												   >	 55:    JMP  7,0(3)	Return 
												   >	* END FUNCTION showInt
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION showIntArray
												   >	* TOFF set: -4
												   >	 56:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 57:    LDC  3,0(6)	Load integer constant 
												   >	 58:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	 59:     LD  3,-4(1)	Load variable i
												   >	 60:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 61:     LD  3,-3(1)	Load variable size
												   >	* TOFF inc: -5
												   >	 62:     LD  4,-5(1)	Pop left into ac1 
												   >	 63:    TLT  3,4,3	Op < 
												   >	 64:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 66:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 67:     LD  3,-2(1)	Load address of base of array x
												   >	 68:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 69:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -7
												   >	 70:     LD  4,-7(1)	Pop left into ac1 
												   >	 71:    SUB  3,4,3	compute location from index 
												   >	 72:     LD  3,0(3)	Load array element 
												   >	 73:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 74:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-71(7)	CALL output
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 78:     LD  3,-4(1)	Load variable i
												   >	 79:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 80:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 81:     LD  4,-5(1)	Pop left into ac1 
												   >	 82:    ADD  3,4,3	Op + 
												   >	 83:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 84:    JMP  7,-26(7)	go to beginning of loop 
												   >	 65:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 85:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	 86:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-55(7)	CALL outnl
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 90:    LDC  2,0(6)	Set return value to 0 
												   >	 91:     LD  3,-1(1)	Load return address 
												   >	 92:     LD  1,0(1)	Adjust fp 
												   >	 93:    JMP  7,0(3)	Return 
												   >	* END FUNCTION showIntArray
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION showBool
												   >	* TOFF set: -3
												   >	 94:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 95:     ST  1,-3(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 96:     LD  3,-2(1)	Load variable x
												   >	 97:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end outputb
												   >	 98:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-84(7)	CALL outputb
												   >	101:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	102:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	103:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	104:    LDA  3,1(7)	Return address in ac 
												   >	105:    JMP  7,-72(7)	CALL outnl
												   >	106:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	107:    LDC  2,0(6)	Set return value to 0 
												   >	108:     LD  3,-1(1)	Load return address 
												   >	109:     LD  1,0(1)	Adjust fp 
												   >	110:    JMP  7,0(3)	Return 
												   >	* END FUNCTION showBool
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION truth
												   >	* TOFF set: -2
												   >	111:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* RETURN
												   >	112:    LDC  3,1(6)	Load Boolean constant 
												   >	113:    LDA  2,0(3)	Copy result to return register 
												   >	114:     LD  3,-1(1)	Load return address 
												   >	115:     LD  1,0(1)	Adjust fp 
												   >	116:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	117:    LDC  2,0(6)	Set return value to 0 
												   >	118:     LD  3,-1(1)	Load return address 
												   >	119:     LD  1,0(1)	Adjust fp 
												   >	120:    JMP  7,0(3)	Return 
												   >	* END FUNCTION truth
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION magic
												   >	* TOFF set: -2
												   >	121:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* RETURN
												   >	122:    LDC  3,666(6)	Load integer constant 
												   >	123:    LDA  2,0(3)	Copy result to return register 
												   >	124:     LD  3,-1(1)	Load return address 
												   >	125:     LD  1,0(1)	Adjust fp 
												   >	126:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	127:    LDC  2,0(6)	Set return value to 0 
												   >	128:     LD  3,-1(1)	Load return address 
												   >	129:     LD  1,0(1)	Adjust fp 
												   >	130:    JMP  7,0(3)	Return 
												   >	* END FUNCTION magic
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION sqr
												   >	* TOFF set: -3
												   >	131:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	132:     LD  3,-2(1)	Load variable x
												   >	133:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	134:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	135:     LD  4,-3(1)	Pop left into ac1 
												   >	136:    MUL  3,4,3	Op * 
												   >	137:    LDA  2,0(3)	Copy result to return register 
												   >	138:     LD  3,-1(1)	Load return address 
												   >	139:     LD  1,0(1)	Adjust fp 
												   >	140:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	141:    LDC  2,0(6)	Set return value to 0 
												   >	142:     LD  3,-1(1)	Load return address 
												   >	143:     LD  1,0(1)	Adjust fp 
												   >	144:    JMP  7,0(3)	Return 
												   >	* END FUNCTION sqr
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION add
												   >	* TOFF set: -4
												   >	145:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	146:     LD  3,-2(1)	Load variable x
												   >	147:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	148:     LD  3,-3(1)	Load variable y
												   >	* TOFF inc: -4
												   >	149:     LD  4,-4(1)	Pop left into ac1 
												   >	150:    ADD  3,4,3	Op + 
												   >	151:    LDA  2,0(3)	Copy result to return register 
												   >	152:     LD  3,-1(1)	Load return address 
												   >	153:     LD  1,0(1)	Adjust fp 
												   >	154:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	155:    LDC  2,0(6)	Set return value to 0 
												   >	156:     LD  3,-1(1)	Load return address 
												   >	157:     LD  1,0(1)	Adjust fp 
												   >	158:    JMP  7,0(3)	Return 
												   >	* END FUNCTION add
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION mul
												   >	* TOFF set: -4
												   >	159:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	160:     LD  3,-2(1)	Load variable x
												   >	161:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	162:     LD  3,-3(1)	Load variable y
												   >	* TOFF inc: -4
												   >	163:     LD  4,-4(1)	Pop left into ac1 
												   >	164:    MUL  3,4,3	Op * 
												   >	165:    LDA  2,0(3)	Copy result to return register 
												   >	166:     LD  3,-1(1)	Load return address 
												   >	167:     LD  1,0(1)	Adjust fp 
												   >	168:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	169:    LDC  2,0(6)	Set return value to 0 
												   >	170:     LD  3,-1(1)	Load return address 
												   >	171:     LD  1,0(1)	Adjust fp 
												   >	172:    JMP  7,0(3)	Return 
												   >	* END FUNCTION mul
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION caller
												   >	* TOFF set: -4
												   >	173:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	174:    LDC  3,666(6)	Load integer constant 
												   >	175:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	176:    LDC  3,777(6)	Load integer constant 
												   >	177:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL sqr
												   >	178:     ST  1,-6(1)	Store fp in ghost frame for sqr
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	179:     LD  3,-2(1)	Load variable x
												   >	180:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end sqr
												   >	181:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	182:    LDA  3,1(7)	Return address in ac 
												   >	183:    JMP  7,-53(7)	CALL sqr
												   >	184:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqr
												   >	* TOFF set: -6
												   >	185:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	186:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	187:     LD  3,-4(1)	Load variable z
												   >	188:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	189:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	190:    LDA  3,1(7)	Return address in ac 
												   >	191:    JMP  7,-186(7)	CALL output
												   >	192:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	193:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	194:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	195:    LDA  3,1(7)	Return address in ac 
												   >	196:    JMP  7,-163(7)	CALL outnl
												   >	197:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL sqr
												   >	198:     ST  1,-6(1)	Store fp in ghost frame for sqr
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	199:     LD  3,-3(1)	Load address of base of array y
												   >	200:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	201:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	202:     LD  4,-8(1)	Pop left into ac1 
												   >	203:    SUB  3,4,3	compute location from index 
												   >	204:     LD  3,0(3)	Load array element 
												   >	205:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end sqr
												   >	206:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	207:    LDA  3,1(7)	Return address in ac 
												   >	208:    JMP  7,-78(7)	CALL sqr
												   >	209:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqr
												   >	* TOFF set: -6
												   >	210:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	211:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	212:     LD  3,-4(1)	Load variable z
												   >	213:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	214:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	215:    LDA  3,1(7)	Return address in ac 
												   >	216:    JMP  7,-211(7)	CALL output
												   >	217:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	218:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	219:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	220:    LDA  3,1(7)	Return address in ac 
												   >	221:    JMP  7,-188(7)	CALL outnl
												   >	222:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL sqr
												   >	223:     ST  1,-6(1)	Store fp in ghost frame for sqr
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	224:     LD  3,-5(1)	Load variable a
												   >	225:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end sqr
												   >	226:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	227:    LDA  3,1(7)	Return address in ac 
												   >	228:    JMP  7,-98(7)	CALL sqr
												   >	229:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqr
												   >	* TOFF set: -6
												   >	230:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	231:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	232:     LD  3,-4(1)	Load variable z
												   >	233:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	234:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-231(7)	CALL output
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	238:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	239:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	240:    LDA  3,1(7)	Return address in ac 
												   >	241:    JMP  7,-208(7)	CALL outnl
												   >	242:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL sqr
												   >	243:     ST  1,-6(1)	Store fp in ghost frame for sqr
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	244:     LD  3,0(0)	Load variable g
												   >	245:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end sqr
												   >	246:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	247:    LDA  3,1(7)	Return address in ac 
												   >	248:    JMP  7,-118(7)	CALL sqr
												   >	249:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqr
												   >	* TOFF set: -6
												   >	250:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	251:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	252:     LD  3,-4(1)	Load variable z
												   >	253:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	254:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	255:    LDA  3,1(7)	Return address in ac 
												   >	256:    JMP  7,-251(7)	CALL output
												   >	257:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	258:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	259:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	260:    LDA  3,1(7)	Return address in ac 
												   >	261:    JMP  7,-228(7)	CALL outnl
												   >	262:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	263:    LDC  2,0(6)	Set return value to 0 
												   >	264:     LD  3,-1(1)	Load return address 
												   >	265:     LD  1,0(1)	Adjust fp 
												   >	266:    JMP  7,0(3)	Return 
												   >	* END FUNCTION caller
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION swap
												   >	* TOFF set: -5
												   >	267:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	268:     LD  3,-2(1)	Load address of base of array x
												   >	269:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	270:     LD  3,-3(1)	Load variable z1
												   >	* TOFF inc: -6
												   >	271:     LD  4,-6(1)	Pop left into ac1 
												   >	272:    SUB  3,4,3	compute location from index 
												   >	273:     LD  3,0(3)	Load array element 
												   >	274:     ST  3,-5(1)	Store variable tmp
												   >	* EXPRESSION
												   >	275:     LD  3,-3(1)	Load variable z1
												   >	276:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	277:     LD  3,-2(1)	Load address of base of array x
												   >	278:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	279:     LD  3,-4(1)	Load variable z2
												   >	* TOFF inc: -7
												   >	280:     LD  4,-7(1)	Pop left into ac1 
												   >	281:    SUB  3,4,3	compute location from index 
												   >	282:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -6
												   >	283:     LD  4,-6(1)	Pop index 
												   >	284:     LD  5,-2(1)	Load address of base of array x
												   >	285:    SUB  5,5,4	Compute offset of value 
												   >	286:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	287:     LD  3,-4(1)	Load variable z2
												   >	288:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	289:     LD  3,-5(1)	Load variable tmp
												   >	* TOFF inc: -6
												   >	290:     LD  4,-6(1)	Pop index 
												   >	291:     LD  5,-2(1)	Load address of base of array x
												   >	292:    SUB  5,5,4	Compute offset of value 
												   >	293:     ST  3,0(5)	Store variable x
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	294:    LDC  2,0(6)	Set return value to 0 
												   >	295:     LD  3,-1(1)	Load return address 
												   >	296:     LD  1,0(1)	Adjust fp 
												   >	297:    JMP  7,0(3)	Return 
												   >	* END FUNCTION swap
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	298:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -26
												   >	299:    LDC  3,10(6)	load size of array r
												   >	300:     ST  3,-4(1)	save size of array r
												   >	301:    LDC  3,10(6)	load size of array s
												   >	302:     ST  3,-15(1)	save size of array s
												   >	* Compound Body
												   >	* EXPRESSION
												   >	303:    LDC  3,0(6)	Load integer constant 
												   >	304:     ST  3,-2(1)	Store variable p
												   >	* WHILE
												   >	305:     LD  3,-2(1)	Load variable p
												   >	306:     ST  3,-26(1)	Push left side 
												   >	* TOFF dec: -27
												   >	307:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -26
												   >	308:     LD  4,-26(1)	Pop left into ac1 
												   >	309:    TLT  3,4,3	Op < 
												   >	310:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -26
												   >	* Compound Body
												   >	* EXPRESSION
												   >	312:     LD  3,-2(1)	Load variable p
												   >	313:     ST  3,-26(1)	Push index 
												   >	* TOFF dec: -27
												   >	314:     LD  3,-2(1)	Load variable p
												   >	* TOFF inc: -26
												   >	315:     LD  4,-26(1)	Pop index 
												   >	316:    LDA  5,-5(1)	Load address of base of array r
												   >	317:    SUB  5,5,4	Compute offset of value 
												   >	318:     ST  3,0(5)	Store variable r
												   >	* EXPRESSION
												   >	319:     LD  3,-2(1)	load lhs variable p
												   >	320:    LDA  3,1(3)	increment value of p
												   >	321:     ST  3,-2(1)	Store variable p
												   >	* TOFF set: -26
												   >	* END COMPOUND
												   >	322:    JMP  7,-18(7)	go to beginning of loop 
												   >	311:    JMP  7,11(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	323:    LDC  3,111(6)	Load integer constant 
												   >	324:     ST  3,-2(1)	Store variable p
												   >	* EXPRESSION
												   >	325:    LDC  3,222(6)	Load integer constant 
												   >	326:     ST  3,-3(1)	Store variable q
												   >	* EXPRESSION
												   >	327:    LDC  3,7(6)	Load integer constant 
												   >	328:     ST  3,-26(1)	Push index 
												   >	* TOFF dec: -27
												   >	329:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -26
												   >	330:     LD  4,-26(1)	Pop index 
												   >	331:    LDA  5,-5(1)	Load address of base of array r
												   >	332:    SUB  5,5,4	Compute offset of value 
												   >	333:     ST  3,0(5)	Store variable r
												   >	* EXPRESSION
												   >	334:    LDC  3,7(6)	Load integer constant 
												   >	335:     ST  3,-26(1)	Push index 
												   >	* TOFF dec: -27
												   >	336:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -26
												   >	337:     LD  4,-26(1)	Pop index 
												   >	338:    LDA  5,-16(1)	Load address of base of array s
												   >	339:    SUB  5,5,4	Compute offset of value 
												   >	340:     ST  3,0(5)	Store variable s
												   >	* EXPRESSION
												   >	* CALL showInt
												   >	341:     ST  1,-26(1)	Store fp in ghost frame for showInt
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	342:     LD  3,-2(1)	Load variable p
												   >	343:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end showInt
												   >	344:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	345:    LDA  3,1(7)	Return address in ac 
												   >	346:    JMP  7,-308(7)	CALL showInt
												   >	347:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end showInt
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL showIntArray
												   >	348:     ST  1,-26(1)	Store fp in ghost frame for showIntArray
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	349:    LDA  3,-5(1)	Load address of base of array r
												   >	350:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param 2
												   >	351:    LDC  3,10(6)	Load integer constant 
												   >	352:     ST  3,-29(1)	Push parameter 
												   >	* TOFF dec: -30
												   >	* Param end showIntArray
												   >	353:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	354:    LDA  3,1(7)	Return address in ac 
												   >	355:    JMP  7,-300(7)	CALL showIntArray
												   >	356:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end showIntArray
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL showBool
												   >	357:     ST  1,-26(1)	Store fp in ghost frame for showBool
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	* CALL truth
												   >	358:     ST  1,-28(1)	Store fp in ghost frame for truth
												   >	* TOFF dec: -29
												   >	* TOFF dec: -30
												   >	* Param end truth
												   >	359:    LDA  1,-28(1)	Ghost frame becomes new active frame 
												   >	360:    LDA  3,1(7)	Return address in ac 
												   >	361:    JMP  7,-251(7)	CALL truth
												   >	362:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end truth
												   >	* TOFF set: -28
												   >	363:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end showBool
												   >	364:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	365:    LDA  3,1(7)	Return address in ac 
												   >	366:    JMP  7,-273(7)	CALL showBool
												   >	367:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end showBool
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL caller
												   >	368:     ST  1,-26(1)	Store fp in ghost frame for caller
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	369:     LD  3,-2(1)	Load variable p
												   >	370:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param 2
												   >	371:    LDA  3,-5(1)	Load address of base of array r
												   >	372:     ST  3,-29(1)	Push parameter 
												   >	* TOFF dec: -30
												   >	* Param end caller
												   >	373:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	374:    LDA  3,1(7)	Return address in ac 
												   >	375:    JMP  7,-203(7)	CALL caller
												   >	376:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end caller
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL output
												   >	377:     ST  1,-26(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	* CALL add
												   >	378:     ST  1,-28(1)	Store fp in ghost frame for add
												   >	* TOFF dec: -29
												   >	* TOFF dec: -30
												   >	* Param 1
												   >	* CALL add
												   >	379:     ST  1,-30(1)	Store fp in ghost frame for add
												   >	* TOFF dec: -31
												   >	* TOFF dec: -32
												   >	* Param 1
												   >	380:     LD  3,-2(1)	Load variable p
												   >	381:     ST  3,-32(1)	Push parameter 
												   >	* TOFF dec: -33
												   >	* Param 2
												   >	382:     LD  3,-3(1)	Load variable q
												   >	383:     ST  3,-33(1)	Push parameter 
												   >	* TOFF dec: -34
												   >	* Param end add
												   >	384:    LDA  1,-30(1)	Ghost frame becomes new active frame 
												   >	385:    LDA  3,1(7)	Return address in ac 
												   >	386:    JMP  7,-242(7)	CALL add
												   >	387:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end add
												   >	* TOFF set: -30
												   >	388:     ST  3,-30(1)	Push parameter 
												   >	* TOFF dec: -31
												   >	* Param 2
												   >	* CALL mul
												   >	389:     ST  1,-31(1)	Store fp in ghost frame for mul
												   >	* TOFF dec: -32
												   >	* TOFF dec: -33
												   >	* Param 1
												   >	390:     LD  3,-2(1)	Load variable p
												   >	391:     ST  3,-33(1)	Push parameter 
												   >	* TOFF dec: -34
												   >	* Param 2
												   >	392:     LD  3,-3(1)	Load variable q
												   >	393:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end mul
												   >	394:    LDA  1,-31(1)	Ghost frame becomes new active frame 
												   >	395:    LDA  3,1(7)	Return address in ac 
												   >	396:    JMP  7,-238(7)	CALL mul
												   >	397:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end mul
												   >	* TOFF set: -31
												   >	398:     ST  3,-31(1)	Push parameter 
												   >	* TOFF dec: -32
												   >	* Param end add
												   >	399:    LDA  1,-28(1)	Ghost frame becomes new active frame 
												   >	400:    LDA  3,1(7)	Return address in ac 
												   >	401:    JMP  7,-257(7)	CALL add
												   >	402:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end add
												   >	* TOFF set: -28
												   >	403:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end output
												   >	404:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	405:    LDA  3,1(7)	Return address in ac 
												   >	406:    JMP  7,-401(7)	CALL output
												   >	407:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	408:     ST  1,-26(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param end outnl
												   >	409:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	410:    LDA  3,1(7)	Return address in ac 
												   >	411:    JMP  7,-378(7)	CALL outnl
												   >	412:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	413:    LDC  3,9(6)	Load integer constant 
												   >	414:     ST  3,-26(1)	Push index 
												   >	* TOFF dec: -27
												   >	415:    LDC  3,555(6)	Load integer constant 
												   >	* TOFF inc: -26
												   >	416:     LD  4,-26(1)	Pop index 
												   >	417:    LDA  5,-5(1)	Load address of base of array r
												   >	418:    SUB  5,5,4	Compute offset of value 
												   >	419:     ST  3,0(5)	Store variable r
												   >	* EXPRESSION
												   >	* CALL swap
												   >	420:     ST  1,-26(1)	Store fp in ghost frame for swap
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	421:    LDA  3,-5(1)	Load address of base of array r
												   >	422:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param 2
												   >	423:    LDC  3,7(6)	Load integer constant 
												   >	424:     ST  3,-29(1)	Push parameter 
												   >	* TOFF dec: -30
												   >	* Param 3
												   >	425:    LDC  3,9(6)	Load integer constant 
												   >	426:     ST  3,-30(1)	Push parameter 
												   >	* TOFF dec: -31
												   >	* Param end swap
												   >	427:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	428:    LDA  3,1(7)	Return address in ac 
												   >	429:    JMP  7,-163(7)	CALL swap
												   >	430:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end swap
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL output
												   >	431:     ST  1,-26(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	432:    LDA  3,-5(1)	Load address of base of array r
												   >	433:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	434:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	435:     LD  4,-28(1)	Pop left into ac1 
												   >	436:    SUB  3,4,3	compute location from index 
												   >	437:     LD  3,0(3)	Load array element 
												   >	438:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end output
												   >	439:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	440:    LDA  3,1(7)	Return address in ac 
												   >	441:    JMP  7,-436(7)	CALL output
												   >	442:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	443:     ST  1,-26(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param end outnl
												   >	444:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	445:    LDA  3,1(7)	Return address in ac 
												   >	446:    JMP  7,-413(7)	CALL outnl
												   >	447:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL output
												   >	448:     ST  1,-26(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	449:    LDC  3,2(6)	Load integer constant 
												   >	450:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	* CALL add
												   >	451:     ST  1,-29(1)	Store fp in ghost frame for add
												   >	* TOFF dec: -30
												   >	* TOFF dec: -31
												   >	* Param 1
												   >	* CALL add
												   >	452:     ST  1,-31(1)	Store fp in ghost frame for add
												   >	* TOFF dec: -32
												   >	* TOFF dec: -33
												   >	* Param 1
												   >	453:    LDC  3,3(6)	Load integer constant 
												   >	454:     ST  3,-33(1)	Push left side 
												   >	* TOFF dec: -34
												   >	455:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -33
												   >	456:     LD  4,-33(1)	Pop left into ac1 
												   >	457:    MUL  3,4,3	Op * 
												   >	458:     ST  3,-33(1)	Push parameter 
												   >	* TOFF dec: -34
												   >	* Param 2
												   >	459:    LDC  3,5(6)	Load integer constant 
												   >	460:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	461:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	462:     LD  4,-34(1)	Pop left into ac1 
												   >	463:    MUL  3,4,3	Op * 
												   >	464:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param end add
												   >	465:    LDA  1,-31(1)	Ghost frame becomes new active frame 
												   >	466:    LDA  3,1(7)	Return address in ac 
												   >	467:    JMP  7,-323(7)	CALL add
												   >	468:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end add
												   >	* TOFF set: -31
												   >	469:     ST  3,-31(1)	Push left side 
												   >	* TOFF dec: -32
												   >	470:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -31
												   >	471:     LD  4,-31(1)	Pop left into ac1 
												   >	472:    MUL  3,4,3	Op * 
												   >	473:     ST  3,-31(1)	Push parameter 
												   >	* TOFF dec: -32
												   >	* Param 2
												   >	* CALL add
												   >	474:     ST  1,-32(1)	Store fp in ghost frame for add
												   >	* TOFF dec: -33
												   >	* TOFF dec: -34
												   >	* Param 1
												   >	475:    LDC  3,9(6)	Load integer constant 
												   >	476:     ST  3,-34(1)	Push left side 
												   >	* TOFF dec: -35
												   >	477:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -34
												   >	478:     LD  4,-34(1)	Pop left into ac1 
												   >	479:    MUL  3,4,3	Op * 
												   >	480:     ST  3,-34(1)	Push parameter 
												   >	* TOFF dec: -35
												   >	* Param 2
												   >	481:    LDC  3,11(6)	Load integer constant 
												   >	482:     ST  3,-35(1)	Push left side 
												   >	* TOFF dec: -36
												   >	483:    LDC  3,12(6)	Load integer constant 
												   >	* TOFF inc: -35
												   >	484:     LD  4,-35(1)	Pop left into ac1 
												   >	485:    MUL  3,4,3	Op * 
												   >	486:     ST  3,-35(1)	Push parameter 
												   >	* TOFF dec: -36
												   >	* Param end add
												   >	487:    LDA  1,-32(1)	Ghost frame becomes new active frame 
												   >	488:    LDA  3,1(7)	Return address in ac 
												   >	489:    JMP  7,-345(7)	CALL add
												   >	490:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end add
												   >	* TOFF set: -32
												   >	491:     ST  3,-32(1)	Push left side 
												   >	* TOFF dec: -33
												   >	492:    LDC  3,13(6)	Load integer constant 
												   >	* TOFF inc: -32
												   >	493:     LD  4,-32(1)	Pop left into ac1 
												   >	494:    MUL  3,4,3	Op * 
												   >	495:     ST  3,-32(1)	Push parameter 
												   >	* TOFF dec: -33
												   >	* Param end add
												   >	496:    LDA  1,-29(1)	Ghost frame becomes new active frame 
												   >	497:    LDA  3,1(7)	Return address in ac 
												   >	498:    JMP  7,-354(7)	CALL add
												   >	499:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end add
												   >	* TOFF set: -29
												   >	* TOFF inc: -28
												   >	500:     LD  4,-28(1)	Pop left into ac1 
												   >	501:    MUL  3,4,3	Op * 
												   >	502:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end output
												   >	503:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	504:    LDA  3,1(7)	Return address in ac 
												   >	505:    JMP  7,-500(7)	CALL output
												   >	506:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	507:     ST  1,-26(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param end outnl
												   >	508:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	509:    LDA  3,1(7)	Return address in ac 
												   >	510:    JMP  7,-477(7)	CALL outnl
												   >	511:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL output
												   >	512:     ST  1,-26(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	* CALL magic
												   >	513:     ST  1,-28(1)	Store fp in ghost frame for magic
												   >	* TOFF dec: -29
												   >	* TOFF dec: -30
												   >	* Param end magic
												   >	514:    LDA  1,-28(1)	Ghost frame becomes new active frame 
												   >	515:    LDA  3,1(7)	Return address in ac 
												   >	516:    JMP  7,-396(7)	CALL magic
												   >	517:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end magic
												   >	* TOFF set: -28
												   >	518:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	* CALL magic
												   >	519:     ST  1,-29(1)	Store fp in ghost frame for magic
												   >	* TOFF dec: -30
												   >	* TOFF dec: -31
												   >	* Param end magic
												   >	520:    LDA  1,-29(1)	Ghost frame becomes new active frame 
												   >	521:    LDA  3,1(7)	Return address in ac 
												   >	522:    JMP  7,-402(7)	CALL magic
												   >	523:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end magic
												   >	* TOFF set: -29
												   >	* TOFF inc: -28
												   >	524:     LD  4,-28(1)	Pop left into ac1 
												   >	525:    MUL  3,4,3	Op * 
												   >	526:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end output
												   >	527:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	528:    LDA  3,1(7)	Return address in ac 
												   >	529:    JMP  7,-524(7)	CALL output
												   >	530:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	531:     ST  1,-26(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param end outnl
												   >	532:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	533:    LDA  3,1(7)	Return address in ac 
												   >	534:    JMP  7,-501(7)	CALL outnl
												   >	535:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -26
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	536:    LDC  2,0(6)	Set return value to 0 
												   >	537:     LD  3,-1(1)	Load return address 
												   >	538:     LD  1,0(1)	Adjust fp 
												   >	539:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,539(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	540:    LDA  1,-1(0)	set first frame at end of globals 
												   >	541:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	542:    LDA  3,1(7)	Return address in ac 
												   >	543:    JMP  7,-246(7)	Jump to main 
												   >	544:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
call.mem call.mem.f21 differ: byte 7, line 1
call (MEM DIFF)
Func: showInt returns type void [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: showInt returns type void [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Call: outnl of type void [line: 4]							.   .   Sibling: 1  Call: outnl of type void [line: 4]
Sibling: 1  Func: showIntArray returns type void [mem: Global loc: 0 size: -4] [line: 7]	   |	Sibling: 8  Func: showIntArray returns type void [mem: Global loc: 0 size: -4] [line: 7]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 7]			.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 7]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 8]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 8]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 9]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Child: 1  Assign: = of type int [line: 10]						   |	.   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   Child: 1  Const 0 of type int [line: 10]							.   .   .   Child: 1  Const 0 of type int [line: 10]
.   .   Sibling: 1  While [line: 11]									.   .   Sibling: 1  While [line: 11]
.   .   .   Child: 0  Op: < of type bool [line: 11]							.   .   .   Child: 0  Op: < of type bool [line: 11]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 11]		.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 11]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 11]
.   .   .   .   Child: 1  Call: output of type void [line: 12]						.   .   .   .   Child: 1  Call: output of type void [line: 12]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 12]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 12]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 12]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 13]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 13]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 13]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   Child: 1  Op: + of type int [line: 13]						.   .   .   .   .   Child: 1  Op: + of type int [line: 13]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   Sibling: 2  Call: outnl of type void [line: 15]							.   .   Sibling: 2  Call: outnl of type void [line: 15]
Sibling: 2  Func: showBool returns type void [mem: Global loc: 0 size: -3] [line: 18]		   |	Sibling: 9  Func: showBool returns type void [mem: Global loc: 0 size: -3] [line: 18]
.   Child: 0  Parm: x of type bool [mem: Parameter loc: -2 size: 1] [line: 18]				.   Child: 0  Parm: x of type bool [mem: Parameter loc: -2 size: 1] [line: 18]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 19]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 19]
.   .   Child: 1  Call: outputb of type void [line: 20]							.   .   Child: 1  Call: outputb of type void [line: 20]
.   .   .   Child: 0  Id: x of type bool [mem: Parameter loc: -2 size: 1] [line: 20]			.   .   .   Child: 0  Id: x of type bool [mem: Parameter loc: -2 size: 1] [line: 20]
.   .   Sibling: 1  Call: outnl of type void [line: 21]							.   .   Sibling: 1  Call: outnl of type void [line: 21]
Sibling: 3  Func: truth returns type bool [mem: Global loc: 0 size: -2] [line: 24]		   |	Sibling: 10  Func: truth returns type bool [mem: Global loc: 0 size: -2] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 25]
.   .   Child: 1  Return [line: 26]									.   .   Child: 1  Return [line: 26]
.   .   .   Child: 0  Const true of type bool [line: 26]						.   .   .   Child: 0  Const true of type bool [line: 26]
Sibling: 4  Func: magic returns type int [mem: Global loc: 0 size: -2] [line: 29]		   |	Sibling: 11  Func: magic returns type int [mem: Global loc: 0 size: -2] [line: 29]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 30]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 30]
.   .   Child: 1  Return [line: 31]									.   .   Child: 1  Return [line: 31]
.   .   .   Child: 0  Const 666 of type int [line: 31]							.   .   .   Child: 0  Const 666 of type int [line: 31]
Sibling: 5  Func: sqr returns type int [mem: Global loc: 0 size: -3] [line: 34]			   |	Sibling: 12  Func: sqr returns type int [mem: Global loc: 0 size: -3] [line: 34]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 34]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 34]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 35]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 35]
.   .   Child: 1  Return [line: 36]									.   .   Child: 1  Return [line: 36]
.   .   .   Child: 0  Op: * of type int [line: 36]							.   .   .   Child: 0  Op: * of type int [line: 36]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 36]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 36]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 36]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 36]
Sibling: 6  Func: add returns type int [mem: Global loc: 0 size: -4] [line: 39]			   |	Sibling: 13  Func: add returns type int [mem: Global loc: 0 size: -4] [line: 39]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 39]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 39]
.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 39]				.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 39]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 40]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 40]
.   .   Child: 1  Return [line: 41]									.   .   Child: 1  Return [line: 41]
.   .   .   Child: 0  Op: + of type int [line: 41]							.   .   .   Child: 0  Op: + of type int [line: 41]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 41]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 41]
.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 41]			.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 41]
Sibling: 7  Func: mul returns type int [mem: Global loc: 0 size: -4] [line: 44]			   |	Sibling: 14  Func: mul returns type int [mem: Global loc: 0 size: -4] [line: 44]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 44]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 44]
.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 44]				.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 44]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 45]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 45]
.   .   Child: 1  Return [line: 46]									.   .   Child: 1  Return [line: 46]
.   .   .   Child: 0  Op: * of type int [line: 46]							.   .   .   Child: 0  Op: * of type int [line: 46]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 46]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 46]
.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 46]			.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 46]
Sibling: 8  Var: g of type int [mem: Global loc: 0 size: 1] [line: 49]				   |	Sibling: 15  Var: g of type int [mem: Global loc: 0 size: 1] [line: 49]
Sibling: 9  Func: caller returns type void [mem: Global loc: 0 size: -4] [line: 51]		   |	Sibling: 16  Func: caller returns type void [mem: Global loc: 0 size: -4] [line: 51]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 51]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 51]
.   Sibling: 1  Parm: y of array of type int [mem: Parameter loc: -3 size: 1] [line: 51]		.   Sibling: 1  Parm: y of array of type int [mem: Parameter loc: -3 size: 1] [line: 51]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 52]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 52]
.   .   Child: 0  Var: z of type int [mem: Local loc: -4 size: 1] [line: 53]				.   .   Child: 0  Var: z of type int [mem: Local loc: -4 size: 1] [line: 53]
.   .   Sibling: 1  Var: a of type int [mem: Local loc: -5 size: 1] [line: 54]				.   .   Sibling: 1  Var: a of type int [mem: Local loc: -5 size: 1] [line: 54]
.   .   Child: 1  Assign: = of type int [line: 56]						   |	.   .   Child: 1  Assign: := of type int [line: 56]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 56]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 56]
.   .   .   Child: 1  Const 666 of type int [line: 56]							.   .   .   Child: 1  Const 666 of type int [line: 56]
.   .   Sibling: 1  Assign: = of type int [line: 57]						   |	.   .   Sibling: 1  Assign: := of type int [line: 57]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 57]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 57]
.   .   .   Child: 1  Const 777 of type int [line: 57]							.   .   .   Child: 1  Const 777 of type int [line: 57]
.   .   Sibling: 2  Assign: = of type int [line: 59]						   |	.   .   Sibling: 2  Assign: := of type int [line: 59]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 59]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 59]
.   .   .   Child: 1  Call: sqr of type int [line: 59]							.   .   .   Child: 1  Call: sqr of type int [line: 59]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 59]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 59]
.   .   Sibling: 3  Call: output of type void [line: 60]						.   .   Sibling: 3  Call: output of type void [line: 60]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 60]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 60]
.   .   Sibling: 4  Call: outnl of type void [line: 61]							.   .   Sibling: 4  Call: outnl of type void [line: 61]
.   .   Sibling: 5  Assign: = of type int [line: 63]						   |	.   .   Sibling: 5  Assign: := of type int [line: 63]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 63]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 63]
.   .   .   Child: 1  Call: sqr of type int [line: 63]							.   .   .   Child: 1  Call: sqr of type int [line: 63]
.   .   .   .   Child: 0  Op: [ of type int [line: 63]							.   .   .   .   Child: 0  Op: [ of type int [line: 63]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -3 size: 1] [line:	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -3 size: 1] [line:
.   .   .   .   .   Child: 1  Const 7 of type int [line: 63]						.   .   .   .   .   Child: 1  Const 7 of type int [line: 63]
.   .   Sibling: 6  Call: output of type void [line: 64]						.   .   Sibling: 6  Call: output of type void [line: 64]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 64]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 64]
.   .   Sibling: 7  Call: outnl of type void [line: 65]							.   .   Sibling: 7  Call: outnl of type void [line: 65]
.   .   Sibling: 8  Assign: = of type int [line: 67]						   |	.   .   Sibling: 8  Assign: := of type int [line: 67]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 67]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 67]
.   .   .   Child: 1  Call: sqr of type int [line: 67]							.   .   .   Child: 1  Call: sqr of type int [line: 67]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 67]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 67]
.   .   Sibling: 9  Call: output of type void [line: 68]						.   .   Sibling: 9  Call: output of type void [line: 68]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 68]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 68]
.   .   Sibling: 10  Call: outnl of type void [line: 69]						.   .   Sibling: 10  Call: outnl of type void [line: 69]
.   .   Sibling: 11  Assign: = of type int [line: 71]						   |	.   .   Sibling: 11  Assign: := of type int [line: 71]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 71]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 71]
.   .   .   Child: 1  Call: sqr of type int [line: 71]							.   .   .   Child: 1  Call: sqr of type int [line: 71]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 71]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 71]
.   .   Sibling: 12  Call: output of type void [line: 72]						.   .   Sibling: 12  Call: output of type void [line: 72]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 72]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 72]
.   .   Sibling: 13  Call: outnl of type void [line: 73]						.   .   Sibling: 13  Call: outnl of type void [line: 73]
Sibling: 10  Func: swap returns type void [mem: Global loc: 0 size: -5] [line: 76]		   |	Sibling: 17  Func: swap returns type void [mem: Global loc: 0 size: -5] [line: 76]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 76]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 76]
.   Sibling: 1  Parm: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 76]			.   Sibling: 1  Parm: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 76]
.   Sibling: 2  Parm: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 76]			.   Sibling: 2  Parm: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 76]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 77]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 77]
.   .   Child: 0  Var: tmp of type int [mem: Local loc: -5 size: 1] [line: 78]				.   .   Child: 0  Var: tmp of type int [mem: Local loc: -5 size: 1] [line: 78]
.   .   Child: 1  Assign: = of type int [line: 79]						   |	.   .   Child: 1  Assign: := of type int [line: 79]
.   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -5 size: 1] [line: 79]			.   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -5 size: 1] [line: 79]
.   .   .   Child: 1  Op: [ of type int [line: 79]							.   .   .   Child: 1  Op: [ of type int [line: 79]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 79]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 79]
.   .   .   .   Child: 1  Id: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 79]		.   .   .   .   Child: 1  Id: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 79]
.   .   Sibling: 1  Assign: = of type int [line: 80]						   |	.   .   Sibling: 1  Assign: := of type int [line: 80]
.   .   .   Child: 0  Op: [ of type int [line: 80]							.   .   .   Child: 0  Op: [ of type int [line: 80]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 80]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 80]
.   .   .   .   Child: 1  Id: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 80]		.   .   .   .   Child: 1  Id: z1 of type int [mem: Parameter loc: -3 size: 1] [line: 80]
.   .   .   Child: 1  Op: [ of type int [line: 80]							.   .   .   Child: 1  Op: [ of type int [line: 80]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 80]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 80]
.   .   .   .   Child: 1  Id: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 80]		.   .   .   .   Child: 1  Id: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 80]
.   .   Sibling: 2  Assign: = of type int [line: 81]						   |	.   .   Sibling: 2  Assign: := of type int [line: 81]
.   .   .   Child: 0  Op: [ of type int [line: 81]							.   .   .   Child: 0  Op: [ of type int [line: 81]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 81]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 81]
.   .   .   .   Child: 1  Id: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 81]		.   .   .   .   Child: 1  Id: z2 of type int [mem: Parameter loc: -4 size: 1] [line: 81]
.   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -5 size: 1] [line: 81]			.   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -5 size: 1] [line: 81]
Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 84]		   |	Sibling: 18  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 84]
.   Child: 1  Compound [mem: None loc: 0 size: -26] [line: 85]						.   Child: 1  Compound [mem: None loc: 0 size: -26] [line: 85]
.   .   Child: 0  Var: p of type int [mem: Local loc: -2 size: 1] [line: 86]				.   .   Child: 0  Var: p of type int [mem: Local loc: -2 size: 1] [line: 86]
.   .   Sibling: 1  Var: q of type int [mem: Local loc: -3 size: 1] [line: 86]				.   .   Sibling: 1  Var: q of type int [mem: Local loc: -3 size: 1] [line: 86]
.   .   Sibling: 2  Var: r of array of type int [mem: Local loc: -5 size: 11] [line: 86]		.   .   Sibling: 2  Var: r of array of type int [mem: Local loc: -5 size: 11] [line: 86]
.   .   Sibling: 3  Var: s of array of type int [mem: Local loc: -16 size: 11] [line: 86]		.   .   Sibling: 3  Var: s of array of type int [mem: Local loc: -16 size: 11] [line: 86]
.   .   Child: 1  Assign: = of type int [line: 88]						   |	.   .   Child: 1  Assign: := of type int [line: 88]
.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 88]				.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 88]
.   .   .   Child: 1  Const 0 of type int [line: 88]							.   .   .   Child: 1  Const 0 of type int [line: 88]
.   .   Sibling: 1  While [line: 89]									.   .   Sibling: 1  While [line: 89]
.   .   .   Child: 0  Op: < of type bool [line: 89]							.   .   .   Child: 0  Op: < of type bool [line: 89]
.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 89]			.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 89]
.   .   .   .   Child: 1  Const 10 of type int [line: 89]						.   .   .   .   Child: 1  Const 10 of type int [line: 89]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -26] [line: 89]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -26] [line: 89]
.   .   .   .   Child: 1  Assign: = of type int [line: 90]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 90]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 90]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 90]
.   .   .   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line
.   .   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -2 size: 1] [line: 90]		.   .   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -2 size: 1] [line: 90]
.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -2 size: 1] [line: 90]			.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -2 size: 1] [line: 90]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 91]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 91]
.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 91]			.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 91]
.   .   Sibling: 2  Assign: = of type int [line: 94]						   |	.   .   Sibling: 2  Assign: := of type int [line: 94]
.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 94]				.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 94]
.   .   .   Child: 1  Const 111 of type int [line: 94]							.   .   .   Child: 1  Const 111 of type int [line: 94]
.   .   Sibling: 3  Assign: = of type int [line: 95]						   |	.   .   Sibling: 3  Assign: := of type int [line: 95]
.   .   .   Child: 0  Id: q of type int [mem: Local loc: -3 size: 1] [line: 95]				.   .   .   Child: 0  Id: q of type int [mem: Local loc: -3 size: 1] [line: 95]
.   .   .   Child: 1  Const 222 of type int [line: 95]							.   .   .   Child: 1  Const 222 of type int [line: 95]
.   .   Sibling: 4  Assign: = of type int [line: 96]						   |	.   .   Sibling: 4  Assign: := of type int [line: 96]
.   .   .   Child: 0  Op: [ of type int [line: 96]							.   .   .   Child: 0  Op: [ of type int [line: 96]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 96]		.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 96]
.   .   .   .   Child: 1  Const 7 of type int [line: 96]						.   .   .   .   Child: 1  Const 7 of type int [line: 96]
.   .   .   Child: 1  Const 333 of type int [line: 96]							.   .   .   Child: 1  Const 333 of type int [line: 96]
.   .   Sibling: 5  Assign: = of type int [line: 97]						   |	.   .   Sibling: 5  Assign: := of type int [line: 97]
.   .   .   Child: 0  Op: [ of type int [line: 97]							.   .   .   Child: 0  Op: [ of type int [line: 97]
.   .   .   .   Child: 0  Id: s of array of type int [mem: Local loc: -16 size: 11] [line: 97]		.   .   .   .   Child: 0  Id: s of array of type int [mem: Local loc: -16 size: 11] [line: 97]
.   .   .   .   Child: 1  Const 7 of type int [line: 97]						.   .   .   .   Child: 1  Const 7 of type int [line: 97]
.   .   .   Child: 1  Const 444 of type int [line: 97]							.   .   .   Child: 1  Const 444 of type int [line: 97]
.   .   Sibling: 6  Call: showInt of type void [line: 99]						.   .   Sibling: 6  Call: showInt of type void [line: 99]
.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 99]				.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 99]
.   .   Sibling: 7  Call: showIntArray of type void [line: 101]						.   .   Sibling: 7  Call: showIntArray of type void [line: 101]
.   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 101]		.   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 101]
.   .   .   Sibling: 1  Const 10 of type int [line: 101]						.   .   .   Sibling: 1  Const 10 of type int [line: 101]
.   .   Sibling: 8  Call: showBool of type void [line: 103]						.   .   Sibling: 8  Call: showBool of type void [line: 103]
.   .   .   Child: 0  Call: truth of type bool [line: 103]						.   .   .   Child: 0  Call: truth of type bool [line: 103]
.   .   Sibling: 9  Call: caller of type void [line: 105]						.   .   Sibling: 9  Call: caller of type void [line: 105]
.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 105]			.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 105]
.   .   .   Sibling: 1  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 105]		.   .   .   Sibling: 1  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 105]
.   .   Sibling: 10  Call: output of type void [line: 107]						.   .   Sibling: 10  Call: output of type void [line: 107]
.   .   .   Child: 0  Call: add of type int [line: 107]							.   .   .   Child: 0  Call: add of type int [line: 107]
.   .   .   .   Child: 0  Call: add of type int [line: 107]						.   .   .   .   Child: 0  Call: add of type int [line: 107]
.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 107]		.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 107]
.   .   .   .   .   Sibling: 1  Id: q of type int [mem: Local loc: -3 size: 1] [line: 107]		.   .   .   .   .   Sibling: 1  Id: q of type int [mem: Local loc: -3 size: 1] [line: 107]
.   .   .   .   Sibling: 1  Call: mul of type int [line: 107]						.   .   .   .   Sibling: 1  Call: mul of type int [line: 107]
.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 107]		.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 107]
.   .   .   .   .   Sibling: 1  Id: q of type int [mem: Local loc: -3 size: 1] [line: 107]		.   .   .   .   .   Sibling: 1  Id: q of type int [mem: Local loc: -3 size: 1] [line: 107]
.   .   Sibling: 11  Call: outnl of type void [line: 108]						.   .   Sibling: 11  Call: outnl of type void [line: 108]
.   .   Sibling: 12  Assign: = of type int [line: 109]						   |	.   .   Sibling: 12  Assign: := of type int [line: 109]
.   .   .   Child: 0  Op: [ of type int [line: 109]							.   .   .   Child: 0  Op: [ of type int [line: 109]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 109]		.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 109]
.   .   .   .   Child: 1  Const 9 of type int [line: 109]						.   .   .   .   Child: 1  Const 9 of type int [line: 109]
.   .   .   Child: 1  Const 555 of type int [line: 109]							.   .   .   Child: 1  Const 555 of type int [line: 109]
.   .   Sibling: 13  Call: swap of type void [line: 110]						.   .   Sibling: 13  Call: swap of type void [line: 110]
.   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 110]		.   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 110]
.   .   .   Sibling: 1  Const 7 of type int [line: 110]							.   .   .   Sibling: 1  Const 7 of type int [line: 110]
.   .   .   Sibling: 2  Const 9 of type int [line: 110]							.   .   .   Sibling: 2  Const 9 of type int [line: 110]
.   .   Sibling: 14  Call: output of type void [line: 111]						.   .   Sibling: 14  Call: output of type void [line: 111]
.   .   .   Child: 0  Op: [ of type int [line: 111]							.   .   .   Child: 0  Op: [ of type int [line: 111]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 111]		.   .   .   .   Child: 0  Id: r of array of type int [mem: Local loc: -5 size: 11] [line: 111]
.   .   .   .   Child: 1  Const 9 of type int [line: 111]						.   .   .   .   Child: 1  Const 9 of type int [line: 111]
.   .   Sibling: 15  Call: outnl of type void [line: 112]						.   .   Sibling: 15  Call: outnl of type void [line: 112]
.   .   Sibling: 16  Call: output of type void [line: 113]						.   .   Sibling: 16  Call: output of type void [line: 113]
.   .   .   Child: 0  Op: * of type int [line: 113]							.   .   .   Child: 0  Op: * of type int [line: 113]
.   .   .   .   Child: 0  Const 2 of type int [line: 113]						.   .   .   .   Child: 0  Const 2 of type int [line: 113]
.   .   .   .   Child: 1  Call: add of type int [line: 113]						.   .   .   .   Child: 1  Call: add of type int [line: 113]
.   .   .   .   .   Child: 0  Op: * of type int [line: 113]						.   .   .   .   .   Child: 0  Op: * of type int [line: 113]
.   .   .   .   .   .   Child: 0  Call: add of type int [line: 113]					.   .   .   .   .   .   Child: 0  Call: add of type int [line: 113]
.   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 113]					.   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 0  Const 3 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 0  Const 3 of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 113]
.   .   .   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]					.   .   .   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 0  Const 5 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 0  Const 5 of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 113]
.   .   .   .   .   .   Child: 1  Const 7 of type int [line: 113]					.   .   .   .   .   .   Child: 1  Const 7 of type int [line: 113]
.   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]						.   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]
.   .   .   .   .   .   Child: 0  Call: add of type int [line: 113]					.   .   .   .   .   .   Child: 0  Call: add of type int [line: 113]
.   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 113]					.   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 113]
.   .   .   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]					.   .   .   .   .   .   .   Sibling: 1  Op: * of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 0  Const 11 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 0  Const 11 of type int [line: 113]
.   .   .   .   .   .   .   .   Child: 1  Const 12 of type int [line: 113]				.   .   .   .   .   .   .   .   Child: 1  Const 12 of type int [line: 113]
.   .   .   .   .   .   Child: 1  Const 13 of type int [line: 113]					.   .   .   .   .   .   Child: 1  Const 13 of type int [line: 113]
.   .   Sibling: 17  Call: outnl of type void [line: 114]						.   .   Sibling: 17  Call: outnl of type void [line: 114]
.   .   Sibling: 18  Call: output of type void [line: 115]						.   .   Sibling: 18  Call: output of type void [line: 115]
.   .   .   Child: 0  Op: * of type int [line: 115]							.   .   .   Child: 0  Op: * of type int [line: 115]
.   .   .   .   Child: 0  Call: magic of type int [line: 115]						.   .   .   .   Child: 0  Call: magic of type int [line: 115]
.   .   .   .   Child: 1  Call: magic of type int [line: 115]						.   .   .   .   Child: 1  Call: magic of type int [line: 115]
.   .   Sibling: 19  Call: outnl of type void [line: 116]						.   .   Sibling: 19  Call: outnl of type void [line: 116]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
call.out ztmp23114.txt differ: byte 1, line 1
call (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/call.tm
Number of errors: 0										   |	111
------------------------------------								   |	0 1 2 3 4 5 6 333 8 9
Loading file: call.tm										   |	T
												   >	12321
												   >	110889
												   >	443556
												   >	603729
												   >	24975
												   >	333
												   >	6360
												   >	443556
Bye.													Bye.
====================================
FILE: charout.c-
-rw-------. 1 corg7983 domain_users  267 Nov 17 15:35 charout.c-
-rw-------. 1 corg7983 domain_users  268 Nov 17 15:35 charout.c-.f21
-rw-------. 1 corg7983 domain_users  267 Nov 17 15:35 charout.c-.f22
-rw-------. 1 corg7983 domain_users  840 Nov 17 15:35 charout.expected
-rw-------. 1 corg7983 domain_users   15 Nov 17 15:35 charout.in
-rw-------. 1 corg7983 domain_users 2916 Nov 22 12:27 charout.mem
-rw-------. 1 corg7983 domain_users  397 Nov 17 15:35 charout.mem.diffs
-rw-------. 1 corg7983 domain_users 3758 Nov 17 15:35 charout.mem.f21
-rw-------. 1 corg7983 domain_users  160 Nov 22 12:27 charout.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 charout.tm
-rw-------. 1 corg7983 domain_users  212 Nov 17 15:35 charout.tm.diffs
-rw-------. 1 corg7983 domain_users 6102 Nov 17 15:35 charout.tm.f21
TM CODE COMPARISON
charout (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  charout.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	 40:    LDC  3,30(6)	Load integer constant 
												   >	 41:     ST  3,-5(1)	Store variable max
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:    LDC  3,1(6)	Load integer constant 
												   >	 43:     ST  3,-4(1)	Store variable k
												   >	* WHILE
												   >	 44:     LD  3,-4(1)	Load variable k
												   >	 45:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 46:     LD  3,-5(1)	Load variable max
												   >	* TOFF inc: -6
												   >	 47:     LD  4,-6(1)	Pop left into ac1 
												   >	 48:    TLT  3,4,3	Op < 
												   >	 49:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 51:    LDC  3,0(6)	Load integer constant 
												   >	 52:     ST  3,-3(1)	Store variable i
												   >	* WHILE
												   >	 53:     LD  3,-3(1)	Load variable i
												   >	 54:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 55:     LD  3,-5(1)	Load variable max
												   >	* TOFF inc: -6
												   >	 56:     LD  4,-6(1)	Pop left into ac1 
												   >	 57:    TLT  3,4,3	Op < 
												   >	 58:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	 60:     LD  3,-3(1)	Load variable i
												   >	 61:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 62:     LD  3,-4(1)	Load variable k
												   >	* TOFF inc: -6
												   >	 63:     LD  4,-6(1)	Pop left into ac1 
												   >	 64:    MOD  3,4,3	Op % 
												   >	 65:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 66:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 67:     LD  4,-6(1)	Pop left into ac1 
												   >	 68:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	 70:     ST  1,-6(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 71:    LDC  3,88(6)	Load char constant 
												   >	 72:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputc
												   >	 73:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 74:    LDA  3,1(7)	Return address in ac 
												   >	 75:    JMP  7,-48(7)	CALL outputc
												   >	 76:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -6
												   >	 69:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	 78:     ST  1,-6(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 79:    LDC  3,32(6)	Load char constant 
												   >	 80:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputc
												   >	 81:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 82:    LDA  3,1(7)	Return address in ac 
												   >	 83:    JMP  7,-56(7)	CALL outputc
												   >	 84:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -6
												   >	 77:    JMP  7,7(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 85:     LD  3,-3(1)	load lhs variable i
												   >	 86:    LDA  3,1(3)	increment value of i
												   >	 87:     ST  3,-3(1)	Store variable i
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	 88:    JMP  7,-36(7)	go to beginning of loop 
												   >	 59:    JMP  7,29(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	 89:     ST  1,-6(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 90:    LDC  3,10(6)	Load char constant 
												   >	 91:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputc
												   >	 92:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 93:    LDA  3,1(7)	Return address in ac 
												   >	 94:    JMP  7,-67(7)	CALL outputc
												   >	 95:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 96:     LD  3,-4(1)	load lhs variable k
												   >	 97:    LDA  3,1(3)	increment value of k
												   >	 98:     ST  3,-4(1)	Store variable k
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	 99:    JMP  7,-56(7)	go to beginning of loop 
												   >	 50:    JMP  7,49(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	100:    LDC  2,0(6)	Set return value to 0 
												   >	101:     LD  3,-1(1)	Load return address 
												   >	102:     LD  1,0(1)	Adjust fp 
												   >	103:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,103(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	104:    LDA  1,0(0)	set first frame at end of globals 
												   >	105:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	106:    LDA  3,1(7)	Return address in ac 
												   >	107:    JMP  7,-69(7)	Jump to main 
												   >	108:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
charout.mem charout.mem.f21 differ: byte 58, line 2
charout (MEM DIFF)
WARNING(2): The variable 'c' seems not to be used.							WARNING(2): The variable 'c' seems not to be used.
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 1]
.   .   Child: 0  Var: c of type char [mem: Local loc: -2 size: 1] [line: 2]				.   .   Child: 0  Var: c of type char [mem: Local loc: -2 size: 1] [line: 2]
.   .   Sibling: 1  Var: i of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: i of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Sibling: 2  Var: k of type int [mem: Local loc: -4 size: 1] [line: 3]				.   .   Sibling: 2  Var: k of type int [mem: Local loc: -4 size: 1] [line: 3]
.   .   Sibling: 3  Var: max of type int [mem: Local loc: -5 size: 1] [line: 4]				.   .   Sibling: 3  Var: max of type int [mem: Local loc: -5 size: 1] [line: 4]
.   .   .   Child: 0  Const 30 of type int [line: 4]							.   .   .   Child: 0  Const 30 of type int [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   .   Child: 1  Const 1 of type int [line: 6]							.   .   .   Child: 1  Const 1 of type int [line: 6]
.   .   Sibling: 1  While [line: 7]									.   .   Sibling: 1  While [line: 7]
.   .   .   Child: 0  Op: < of type bool [line: 7]							.   .   .   Child: 0  Op: < of type bool [line: 7]
.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -5 size: 1] [line: 7]			.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -5 size: 1] [line: 7]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]
.   .   .   .   Child: 1  Assign: = of type int [line: 8]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 8]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 8]
.   .   .   .   Sibling: 1  While [line: 9]								.   .   .   .   Sibling: 1  While [line: 9]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 9]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 9]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -5 size: 1] [line: 9]		.   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -5 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 9]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 9]
.   .   .   .   .   .   Child: 1  If [line: 10]								.   .   .   .   .   .   Child: 1  If [line: 10]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 10]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 10]
.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 10]					.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 10]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -4 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 10]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 10]
.   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 10]				.   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 10]
.   .   .   .   .   .   .   .   Child: 0  Const 'X' of type char [line: 10]				.   .   .   .   .   .   .   .   Child: 0  Const 'X' of type char [line: 10]
.   .   .   .   .   .   .   Child: 2  Call: outputc of type void [line: 11]				.   .   .   .   .   .   .   Child: 2  Call: outputc of type void [line: 11]
.   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 11]				.   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 11]
.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 12]					.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 12]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 12]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   Sibling: 2  Call: outputc of type void [line: 14]					.   .   .   .   Sibling: 2  Call: outputc of type void [line: 14]
.   .   .   .   .   Child: 0  Const '									.   .   .   .   .   Child: 0  Const '
' of type char [line: 14]										' of type char [line: 14]
.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 15]						.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 15]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 15]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -4 size: 1] [line: 15]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
charout.out ztmp23114.txt differ: byte 52, line 2
charout (Output DIFF)
WARNING(2): The variable 'c' seems not to be used.							WARNING(2): The variable 'c' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/charout.tm
Number of errors: 0										   |	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
------------------------------------								   |	X X X X X X X X X X X X X X X
Loading file: charout.tm									   |	X  X  X  X  X  X  X  X  X  X
												   >	X   X   X   X   X   X   X   X
												   >	X    X    X    X    X    X
												   >	X     X     X     X     X
												   >	X      X      X      X      X
												   >	X       X       X       X
												   >	X        X        X        X
												   >	X         X         X
												   >	X          X          X
												   >	X           X           X
												   >	X            X            X
												   >	X             X             X
												   >	X              X
												   >	X               X
												   >	X                X
												   >	X                 X
												   >	X                  X
												   >	X                   X
												   >	X                    X
												   >	X                     X
												   >	X                      X
												   >	X                       X
												   >	X                        X
												   >	X                         X
												   >	X                          X
												   >	X                           X
												   >	X                            X
Bye.													Bye.
====================================
FILE: comb.c-
-rw-------. 1 corg7983 domain_users  503 Nov 17 15:35 comb.c-
-rw-------. 1 corg7983 domain_users  510 Nov 17 15:35 comb.c-.f21
-rw-------. 1 corg7983 domain_users  503 Nov 17 15:35 comb.c-.f22
-rw-------. 1 corg7983 domain_users  450 Nov 17 15:35 comb.expected
-rw-------. 1 corg7983 domain_users   17 Nov 17 15:35 comb.in
-rw-------. 1 corg7983 domain_users 6019 Nov 22 12:27 comb.mem
-rw-------. 1 corg7983 domain_users  857 Nov 17 15:35 comb.mem.diffs
-rw-------. 1 corg7983 domain_users 6867 Nov 17 15:35 comb.mem.f21
-rw-------. 1 corg7983 domain_users  159 Nov 22 12:27 comb.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 comb.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 comb.tm.diffs
-rw-------. 1 corg7983 domain_users 9263 Nov 17 15:35 comb.tm.f21
TM CODE COMPARISON
comb (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  comb.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION comb
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-2(1)	Load variable n
												   >	 41:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 42:     LD  3,-3(1)	Load variable r
												   >	* TOFF inc: -7
												   >	 43:     LD  4,-7(1)	Pop left into ac1 
												   >	 44:    SUB  3,4,3	Op - 
												   >	 45:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 46:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 47:     LD  4,-7(1)	Pop left into ac1 
												   >	 48:    ADD  3,4,3	Op + 
												   >	 49:     ST  3,-6(1)	Store variable c
												   >	* EXPRESSION
												   >	 50:     LD  3,-2(1)	Load variable n
												   >	 51:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 52:     LD  3,-3(1)	Load variable r
												   >	* TOFF inc: -7
												   >	 53:     LD  4,-7(1)	Pop left into ac1 
												   >	 54:    SUB  3,4,3	Op - 
												   >	 55:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 56:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 57:     LD  4,-7(1)	Pop left into ac1 
												   >	 58:    ADD  3,4,3	Op + 
												   >	 59:     ST  3,-4(1)	Store variable i
												   >	* EXPRESSION
												   >	 60:    LDC  3,2(6)	Load integer constant 
												   >	 61:     ST  3,-5(1)	Store variable j
												   >	* WHILE
												   >	 62:     LD  3,-4(1)	Load variable i
												   >	 63:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 64:     LD  3,-2(1)	Load variable n
												   >	* TOFF inc: -7
												   >	 65:     LD  4,-7(1)	Pop left into ac1 
												   >	 66:    TLE  3,4,3	Op <= 
												   >	 67:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 69:     LD  3,-6(1)	Load variable c
												   >	 70:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 71:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -7
												   >	 72:     LD  4,-7(1)	Pop left into ac1 
												   >	 73:    MUL  3,4,3	Op * 
												   >	 74:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 75:     LD  3,-5(1)	Load variable j
												   >	* TOFF inc: -7
												   >	 76:     LD  4,-7(1)	Pop left into ac1 
												   >	 77:    DIV  3,4,3	Op / 
												   >	 78:     ST  3,-6(1)	Store variable c
												   >	* EXPRESSION
												   >	 79:     LD  3,-4(1)	load lhs variable i
												   >	 80:    LDA  3,1(3)	increment value of i
												   >	 81:     ST  3,-4(1)	Store variable i
												   >	* EXPRESSION
												   >	 82:     LD  3,-5(1)	load lhs variable j
												   >	 83:    LDA  3,1(3)	increment value of j
												   >	 84:     ST  3,-5(1)	Store variable j
												   >	* TOFF set: -7
												   >	* END COMPOUND
												   >	 85:    JMP  7,-24(7)	go to beginning of loop 
												   >	 68:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 86:     LD  3,-6(1)	Load variable c
												   >	 87:    LDA  2,0(3)	Copy result to return register 
												   >	 88:     LD  3,-1(1)	Load return address 
												   >	 89:     LD  1,0(1)	Adjust fp 
												   >	 90:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 91:    LDC  2,0(6)	Set return value to 0 
												   >	 92:     LD  3,-1(1)	Load return address 
												   >	 93:     LD  1,0(1)	Adjust fp 
												   >	 94:    JMP  7,0(3)	Return 
												   >	* END FUNCTION comb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 95:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 96:    LDC  3,15(6)	Load integer constant 
												   >	 97:     ST  3,-2(1)	Store variable max
												   >	* EXPRESSION
												   >	 98:    LDC  3,2(6)	Load integer constant 
												   >	 99:     ST  3,-3(1)	Store variable n
												   >	* WHILE
												   >	100:     LD  3,-3(1)	Load variable n
												   >	101:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	102:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -6
												   >	103:     LD  4,-6(1)	Pop left into ac1 
												   >	104:    TLE  3,4,3	Op <= 
												   >	105:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	107:    LDC  3,2(6)	Load integer constant 
												   >	108:     ST  3,-5(1)	Store variable r
												   >	* WHILE
												   >	109:     LD  3,-5(1)	Load variable r
												   >	110:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	111:     LD  3,-3(1)	Load variable n
												   >	112:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	113:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	114:     LD  4,-7(1)	Pop left into ac1 
												   >	115:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -6
												   >	116:     LD  4,-6(1)	Pop left into ac1 
												   >	117:    TLE  3,4,3	Op <= 
												   >	118:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	120:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	121:     LD  3,-3(1)	Load variable n
												   >	122:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	123:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	124:    LDA  3,1(7)	Return address in ac 
												   >	125:    JMP  7,-120(7)	CALL output
												   >	126:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	127:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	128:     LD  3,-5(1)	Load variable r
												   >	129:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	130:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-127(7)	CALL output
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	134:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	* CALL comb
												   >	135:     ST  1,-8(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	136:     LD  3,-3(1)	Load variable n
												   >	137:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	138:     LD  3,-5(1)	Load variable r
												   >	139:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end comb
												   >	140:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	141:    LDA  3,1(7)	Return address in ac 
												   >	142:    JMP  7,-104(7)	CALL comb
												   >	143:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -8
												   >	144:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	145:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	146:    LDA  3,1(7)	Return address in ac 
												   >	147:    JMP  7,-142(7)	CALL output
												   >	148:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	149:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	150:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-119(7)	CALL outnl
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	154:     LD  3,-5(1)	load lhs variable r
												   >	155:    LDA  3,1(3)	increment value of r
												   >	156:     ST  3,-5(1)	Store variable r
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	157:    JMP  7,-49(7)	go to beginning of loop 
												   >	119:    JMP  7,38(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	158:     LD  3,-3(1)	load lhs variable n
												   >	159:    LDA  3,1(3)	increment value of n
												   >	160:     ST  3,-3(1)	Store variable n
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	161:    JMP  7,-62(7)	go to beginning of loop 
												   >	106:    JMP  7,55(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	162:    LDC  2,0(6)	Set return value to 0 
												   >	163:     LD  3,-1(1)	Load return address 
												   >	164:     LD  1,0(1)	Adjust fp 
												   >	165:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,165(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	166:    LDA  1,0(0)	set first frame at end of globals 
												   >	167:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	168:    LDA  3,1(7)	Return address in ac 
												   >	169:    JMP  7,-75(7)	Jump to main 
												   >	170:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
comb.mem comb.mem.f21 differ: byte 60, line 2
comb (MEM DIFF)
WARNING(20): The variable 'xx' seems not to be used.							WARNING(20): The variable 'xx' seems not to be used.
Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 2]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 2]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Sibling: 1  Parm: r of type int [mem: Parameter loc: -3 size: 1] [line: 2]				.   Sibling: 1  Parm: r of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 3]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -5 size: 1] [line: 4]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -5 size: 1] [line: 4]
.   .   Sibling: 2  Var: c of type int [mem: Local loc: -6 size: 1] [line: 4]				.   .   Sibling: 2  Var: c of type int [mem: Local loc: -6 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 6]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 6]
.   .   .   Child: 1  Op: + of type int [line: 6]							.   .   .   Child: 1  Op: + of type int [line: 6]
.   .   .   .   Child: 0  Op: - of type int [line: 6]							.   .   .   .   Child: 0  Op: - of type int [line: 6]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 6]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   .   Child: 1  Id: r of type int [mem: Parameter loc: -3 size: 1] [line: 6]		.   .   .   .   .   Child: 1  Id: r of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 1 of type int [line: 6]							.   .   .   .   Child: 1  Const 1 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type int [line: 7]						   |	.   .   Sibling: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   Child: 1  Op: + of type int [line: 7]							.   .   .   Child: 1  Op: + of type int [line: 7]
.   .   .   .   Child: 0  Op: - of type int [line: 7]							.   .   .   .   Child: 0  Op: - of type int [line: 7]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   .   Child: 1  Id: r of type int [mem: Parameter loc: -3 size: 1] [line: 7]		.   .   .   .   .   Child: 1  Id: r of type int [mem: Parameter loc: -3 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 2 of type int [line: 7]							.   .   .   .   Child: 1  Const 2 of type int [line: 7]
.   .   Sibling: 2  Assign: = of type int [line: 8]						   |	.   .   Sibling: 2  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 8]				.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 8]
.   .   .   Child: 1  Const 2 of type int [line: 8]							.   .   .   Child: 1  Const 2 of type int [line: 8]
.   .   Sibling: 3  While [line: 9]									.   .   Sibling: 3  While [line: 9]
.   .   .   Child: 0  Op: <= of type bool [line: 9]							.   .   .   Child: 0  Op: <= of type bool [line: 9]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 9]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 9]
.   .   .   .   Child: 1  Assign: = of type int [line: 10]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 10]			.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Op: / of type int [line: 10]						.   .   .   .   .   Child: 1  Op: / of type int [line: 10]
.   .   .   .   .   .   Child: 0  Op: * of type int [line: 10]						.   .   .   .   .   .   Child: 0  Op: * of type int [line: 10]
.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 10]		.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 10]
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line: 10]		.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line: 10]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 11]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 11]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 11]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 12]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 12]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 12]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 12]
.   .   Sibling: 4  Return [line: 14]									.   .   Sibling: 4  Return [line: 14]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 14]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 14]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 17]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 17]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 18]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 18]
.   .   Child: 0  Var: max of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   Child: 0  Var: max of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   Sibling: 1  Var: n of type int [mem: Local loc: -3 size: 1] [line: 19]				.   .   Sibling: 1  Var: n of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   Sibling: 2  Var: xx of type bool [mem: Local loc: -4 size: 1] [line: 20]			.   .   Sibling: 2  Var: xx of type bool [mem: Local loc: -4 size: 1] [line: 20]
.   .   Sibling: 3  Var: r of type int [mem: Local loc: -5 size: 1] [line: 21]				.   .   Sibling: 3  Var: r of type int [mem: Local loc: -5 size: 1] [line: 21]
.   .   Child: 1  Assign: = of type int [line: 23]						   |	.   .   Child: 1  Assign: := of type int [line: 23]
.   .   .   Child: 0  Id: max of type int [mem: Local loc: -2 size: 1] [line: 23]			.   .   .   Child: 0  Id: max of type int [mem: Local loc: -2 size: 1] [line: 23]
.   .   .   Child: 1  Const 15 of type int [line: 23]							.   .   .   Child: 1  Const 15 of type int [line: 23]
.   .   Sibling: 1  Assign: = of type int [line: 25]						   |	.   .   Sibling: 1  Assign: := of type int [line: 25]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 25]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 25]
.   .   .   Child: 1  Const 2 of type int [line: 25]							.   .   .   Child: 1  Const 2 of type int [line: 25]
.   .   Sibling: 2  While [line: 26]									.   .   Sibling: 2  While [line: 26]
.   .   .   Child: 0  Op: <= of type bool [line: 26]							.   .   .   Child: 0  Op: <= of type bool [line: 26]
.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 26]			.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 26]			.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 26]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 26]
.   .   .   .   Child: 1  Assign: = of type int [line: 27]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 27]
.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 27]			.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 27]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 27]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 27]
.   .   .   .   Sibling: 1  While [line: 28]								.   .   .   .   Sibling: 1  While [line: 28]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 28]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 28]
.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 28]		.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 28]
.   .   .   .   .   .   Child: 1  Op: / of type int [line: 28]						.   .   .   .   .   .   Child: 1  Op: / of type int [line: 28]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 28]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 28]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 28]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 28]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 28]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 28]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 29]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 29]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 29]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 29]
.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 30]				.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 30]
.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 30]		.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 30]
.   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 31]				.   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 31]
.   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 31]					.   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 31]
.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Sibling: 1  Id: r of type int [mem: Local loc: -5 size: 1] [line	.   .   .   .   .   .   .   .   Sibling: 1  Id: r of type int [mem: Local loc: -5 size: 1] [line
.   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 32]					.   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 32]
.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 33]					.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 33]
.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 33]		.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -5 size: 1] [line: 33]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 35]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 35]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 35]			.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -3 size: 1] [line: 35]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
comb.out ztmp23114.txt differ: byte 54, line 2
comb (Output DIFF)
WARNING(20): The variable 'xx' seems not to be used.							WARNING(20): The variable 'xx' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/comb.tm
Number of errors: 0										   |	4 2 6
------------------------------------								   |	5 2 10
Loading file: comb.tm										   |	6 2 15
												   >	6 3 20
												   >	7 2 21
												   >	7 3 35
												   >	8 2 28
												   >	8 3 56
												   >	8 4 70
												   >	9 2 36
												   >	9 3 84
												   >	9 4 126
												   >	10 2 45
												   >	10 3 120
												   >	10 4 210
												   >	10 5 252
												   >	11 2 55
												   >	11 3 165
												   >	11 4 330
												   >	11 5 462
												   >	12 2 66
												   >	12 3 220
												   >	12 4 495
												   >	12 5 792
												   >	12 6 924
												   >	13 2 78
												   >	13 3 286
												   >	13 4 715
												   >	13 5 1287
												   >	13 6 1716
												   >	14 2 91
												   >	14 3 364
												   >	14 4 1001
												   >	14 5 2002
												   >	14 6 3003
												   >	14 7 3432
												   >	15 2 105
												   >	15 3 455
												   >	15 4 1365
												   >	15 5 3003
												   >	15 6 5005
												   >	15 7 6435
Bye.													Bye.
====================================
FILE: combslow.c-
-rw-------. 1 corg7983 domain_users   632 Nov 17 15:35 combslow.c-
-rw-------. 1 corg7983 domain_users   631 Nov 17 15:35 combslow.c-.f21
-rw-------. 1 corg7983 domain_users   632 Nov 17 15:35 combslow.c-.f22
-rw-------. 1 corg7983 domain_users   372 Nov 17 15:35 combslow.expected
-rw-------. 1 corg7983 domain_users    24 Nov 17 15:35 combslow.in
-rw-------. 1 corg7983 domain_users  5372 Nov 22 12:27 combslow.mem
-rw-------. 1 corg7983 domain_users   921 Nov 17 15:35 combslow.mem.diffs
-rw-------. 1 corg7983 domain_users  6212 Nov 17 15:35 combslow.mem.f21
-rw-------. 1 corg7983 domain_users   197 Nov 22 12:27 combslow.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 combslow.tm
-rw-------. 1 corg7983 domain_users   411 Nov 17 15:35 combslow.tm.diffs
-rw-------. 1 corg7983 domain_users 10098 Nov 17 15:35 combslow.tm.f21
TM CODE COMPARISON
combslow (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  combslow.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION comb
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-2(1)	Load variable a
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 46:    LDC  3,1(6)	Load integer constant 
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 51:     LD  3,-3(1)	Load variable b
												   >	 52:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 53:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 54:     LD  4,-4(1)	Pop left into ac1 
												   >	 55:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 57:    LDC  3,1(6)	Load integer constant 
												   >	 58:    LDA  2,0(3)	Copy result to return register 
												   >	 59:     LD  3,-1(1)	Load return address 
												   >	 60:     LD  1,0(1)	Adjust fp 
												   >	 61:    JMP  7,0(3)	Return 
												   >	 56:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 62:     LD  3,-3(1)	Load variable b
												   >	 63:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 64:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 65:     LD  4,-4(1)	Pop left into ac1 
												   >	 66:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 68:     LD  3,-2(1)	Load variable a
												   >	 69:    LDA  2,0(3)	Copy result to return register 
												   >	 70:     LD  3,-1(1)	Load return address 
												   >	 71:     LD  1,0(1)	Adjust fp 
												   >	 72:    JMP  7,0(3)	Return 
												   >	 67:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	* CALL comb
												   >	 73:     ST  1,-4(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 74:     LD  3,-2(1)	Load variable a
												   >	 75:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 76:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 77:     LD  4,-6(1)	Pop left into ac1 
												   >	 78:    SUB  3,4,3	Op - 
												   >	 79:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 80:     LD  3,-3(1)	Load variable b
												   >	 81:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 82:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 83:     LD  4,-7(1)	Pop left into ac1 
												   >	 84:    SUB  3,4,3	Op - 
												   >	 85:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end comb
												   >	 86:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-50(7)	CALL comb
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -4
												   >	 90:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	* CALL comb
												   >	 91:     ST  1,-5(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 92:     LD  3,-2(1)	Load variable a
												   >	 93:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 94:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 95:     LD  4,-7(1)	Pop left into ac1 
												   >	 96:    SUB  3,4,3	Op - 
												   >	 97:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	 98:     LD  3,-3(1)	Load variable b
												   >	 99:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end comb
												   >	100:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-64(7)	CALL comb
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -5
												   >	* TOFF inc: -4
												   >	104:     LD  4,-4(1)	Pop left into ac1 
												   >	105:    ADD  3,4,3	Op + 
												   >	106:    LDA  2,0(3)	Copy result to return register 
												   >	107:     LD  3,-1(1)	Load return address 
												   >	108:     LD  1,0(1)	Adjust fp 
												   >	109:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	110:    LDC  2,0(6)	Set return value to 0 
												   >	111:     LD  3,-1(1)	Load return address 
												   >	112:     LD  1,0(1)	Adjust fp 
												   >	113:    JMP  7,0(3)	Return 
												   >	* END FUNCTION comb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	114:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* WHILE
												   >	115:    LDC  3,1(6)	Load Boolean constant 
												   >	116:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* IF
												   >	* CALL input
												   >	118:     ST  1,-5(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end input
												   >	119:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-121(7)	CALL input
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -5
												   >	123:     ST  3,-4(1)	Store variable n
												   >	124:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	125:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	126:     LD  4,-5(1)	Pop left into ac1 
												   >	127:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* BREAK
												   >	129:    JMP  7,-13(7)	break 
												   >	128:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	130:    LDC  3,0(6)	Load integer constant 
												   >	131:     ST  3,-2(1)	Store variable a
												   >	* WHILE
												   >	132:     LD  3,-2(1)	Load variable a
												   >	133:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	134:     LD  3,-4(1)	Load variable n
												   >	* TOFF inc: -5
												   >	135:     LD  4,-5(1)	Pop left into ac1 
												   >	136:    TLE  3,4,3	Op <= 
												   >	137:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	139:    LDC  3,0(6)	Load integer constant 
												   >	140:     ST  3,-3(1)	Store variable b
												   >	* WHILE
												   >	141:     LD  3,-3(1)	Load variable b
												   >	142:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	143:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -5
												   >	144:     LD  4,-5(1)	Pop left into ac1 
												   >	145:    TLE  3,4,3	Op <= 
												   >	146:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	148:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	* CALL comb
												   >	149:     ST  1,-7(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	150:     LD  3,-2(1)	Load variable a
												   >	151:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	152:     LD  3,-3(1)	Load variable b
												   >	153:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end comb
												   >	154:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-118(7)	CALL comb
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -7
												   >	158:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	159:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-156(7)	CALL output
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	163:     LD  3,-3(1)	load lhs variable b
												   >	164:    LDA  3,1(3)	increment value of b
												   >	165:     ST  3,-3(1)	Store variable b
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	166:    JMP  7,-26(7)	go to beginning of loop 
												   >	147:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	167:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	168:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-137(7)	CALL outnl
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	172:     LD  3,-2(1)	load lhs variable a
												   >	173:    LDA  3,1(3)	increment value of a
												   >	174:     ST  3,-2(1)	Store variable a
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	175:    JMP  7,-44(7)	go to beginning of loop 
												   >	138:    JMP  7,37(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	176:    JMP  7,-62(7)	go to beginning of loop 
												   >	117:    JMP  7,59(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	177:    LDC  2,0(6)	Set return value to 0 
												   >	178:     LD  3,-1(1)	Load return address 
												   >	179:     LD  1,0(1)	Adjust fp 
												   >	180:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,180(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	181:    LDA  1,0(0)	set first frame at end of globals 
												   >	182:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	183:    LDA  3,1(7)	Return address in ac 
												   >	184:    JMP  7,-71(7)	Jump to main 
												   >	185:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
combslow.mem combslow.mem.f21 differ: byte 7, line 1
combslow (MEM DIFF)
Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 6]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 6]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 6]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 6]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 7]
.   .   Child: 1  If [line: 8]										.   .   Child: 1  If [line: 8]
.   .   .   Child: 0  Op: == of type bool [line: 8]						   |	.   .   .   Child: 0  Op: = of type bool [line: 8]
.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   .   .   Child: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 8]
.   .   .   Child: 1  Return [line: 9]									.   .   .   Child: 1  Return [line: 9]
.   .   .   .   Child: 0  Const 1 of type int [line: 9]							.   .   .   .   Child: 0  Const 1 of type int [line: 9]
.   .   Sibling: 1  If [line: 10]									.   .   Sibling: 1  If [line: 10]
.   .   .   Child: 0  Op: == of type bool [line: 10]						   |	.   .   .   Child: 0  Op: = of type bool [line: 10]
.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   .   .   .   Child: 1  Const 0 of type int [line: 10]						.   .   .   .   Child: 1  Const 0 of type int [line: 10]
.   .   .   Child: 1  Return [line: 11]									.   .   .   Child: 1  Return [line: 11]
.   .   .   .   Child: 0  Const 1 of type int [line: 11]						.   .   .   .   Child: 0  Const 1 of type int [line: 11]
.   .   Sibling: 2  If [line: 12]									.   .   Sibling: 2  If [line: 12]
.   .   .   Child: 0  Op: == of type bool [line: 12]						   |	.   .   .   Child: 0  Op: = of type bool [line: 12]
.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 12]
.   .   .   .   Child: 1  Const 1 of type int [line: 12]						.   .   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   .   Child: 1  Return [line: 13]									.   .   .   Child: 1  Return [line: 13]
.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]			.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   .   Sibling: 3  Return [line: 15]									.   .   Sibling: 3  Return [line: 15]
.   .   .   Child: 0  Op: + of type int [line: 15]							.   .   .   Child: 0  Op: + of type int [line: 15]
.   .   .   .   Child: 0  Call: comb of type int [line: 15]						.   .   .   .   Child: 0  Call: comb of type int [line: 15]
.   .   .   .   .   Child: 0  Op: - of type int [line: 15]						.   .   .   .   .   Child: 0  Op: - of type int [line: 15]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]
.   .   .   .   .   Sibling: 1  Op: - of type int [line: 15]						.   .   .   .   .   Sibling: 1  Op: - of type int [line: 15]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 15]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 15]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]
.   .   .   .   Child: 1  Call: comb of type int [line: 15]						.   .   .   .   Child: 1  Call: comb of type int [line: 15]
.   .   .   .   .   Child: 0  Op: - of type int [line: 15]						.   .   .   .   .   Child: 0  Op: - of type int [line: 15]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 15]
.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 15]		.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 15]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 18]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 18]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 19]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 19]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 20]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 20]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 20]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 20]
.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 20]				.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 20]
.   .   Child: 1  While [line: 22]									.   .   Child: 1  While [line: 22]
.   .   .   Child: 0  Const true of type bool [line: 22]						.   .   .   Child: 0  Const true of type bool [line: 22]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 22]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 22]
.   .   .   .   Child: 1  If [line: 23]									.   .   .   .   Child: 1  If [line: 23]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 23]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Assign: = of type int [line: 23]				   |	.   .   .   .   .   .   Child: 0  Assign: := of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 23]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 23]
.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 23]				.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 23]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 23]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 23]
.   .   .   .   .   Child: 1  Break [line: 23]								.   .   .   .   .   Child: 1  Break [line: 23]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 24]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 24]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 24]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 24]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 24]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 24]
.   .   .   .   Sibling: 2  While [line: 25]								.   .   .   .   Sibling: 2  While [line: 25]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 25]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 25]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 25]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 25]
.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -4 size: 1] [line: 25]		.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -4 size: 1] [line: 25]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 26]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 26]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 26]		.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 26]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 26]
.   .   .   .   .   .   Sibling: 1  While [line: 27]							.   .   .   .   .   .   Sibling: 1  While [line: 27]
.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 27]					.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 27]
.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 27]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 27]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 28]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 28]
.   .   .   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 28]				.   .   .   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 28]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Local loc: -3 size: 	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Local loc: -3 size: 
.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 29]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 29]
.   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 31]					.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 31]
.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 32]					.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 32]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 32]		.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 32]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
combslow.out ztmp23114.txt differ: byte 1, line 1
combslow (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/combslow.tm
Number of errors: 0										   |	entered: 12
------------------------------------								   |	1
Loading file: combslow.tm									   |	1 1
ERROR: TM Command 1 unknown.									   |	1 2 1
ERROR: TM Command 5 unknown.									   |	1 3 3 1
ERROR: TM Command 0 unknown.									   |	1 4 6 4 1
												   >	1 5 10 10 5 1
												   >	1 6 15 20 15 6 1
												   >	1 7 21 35 35 21 7 1
												   >	1 8 28 56 70 56 28 8 1
												   >	1 9 36 84 126 126 84 36 9 1
												   >	1 10 45 120 210 252 210 120 45 10 1
												   >	1 11 55 165 330 462 462 330 165 55 11 1
												   >	1 12 66 220 495 792 924 792 495 220 66 12 1
												   >	entered: 5
												   >	1
												   >	1 1
												   >	1 2 1
												   >	1 3 3 1
												   >	1 4 6 4 1
												   >	1 5 10 10 5 1
												   >	entered: 0
Bye.													Bye.
====================================
FILE: compare.c-
-rw-------. 1 corg7983 domain_users   424 Nov 17 15:35 compare.c-
-rw-------. 1 corg7983 domain_users   421 Nov 17 15:35 compare.c-.f21
-rw-------. 1 corg7983 domain_users   424 Nov 17 15:35 compare.c-.f22
-rw-------. 1 corg7983 domain_users    77 Nov 17 15:35 compare.expected
-rw-------. 1 corg7983 domain_users  4232 Nov 22 12:27 compare.mem
-rw-------. 1 corg7983 domain_users   711 Nov 17 15:35 compare.mem.diffs
-rw-------. 1 corg7983 domain_users  5070 Nov 17 15:35 compare.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 compare.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 compare.tm
-rw-------. 1 corg7983 domain_users   550 Nov 17 15:35 compare.tm.diffs
-rw-------. 1 corg7983 domain_users 14128 Nov 17 15:35 compare.tm.f21
TM CODE COMPARISON
compare (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  compare.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,1(6)	Load integer constant 
												   >	 42:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 43:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 44:     LD  4,-4(1)	Pop left into ac1 
												   >	 45:    TLT  3,4,3	Op < 
												   >	 46:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 47:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-33(7)	CALL outputb
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 51:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 52:    LDC  3,2(6)	Load integer constant 
												   >	 53:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 54:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 55:     LD  4,-4(1)	Pop left into ac1 
												   >	 56:    TLT  3,4,3	Op < 
												   >	 57:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 58:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-44(7)	CALL outputb
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 62:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 63:    LDC  3,3(6)	Load integer constant 
												   >	 64:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 65:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 66:     LD  4,-4(1)	Pop left into ac1 
												   >	 67:    TLT  3,4,3	Op < 
												   >	 68:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 69:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-55(7)	CALL outputb
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 73:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 74:    LDC  3,1(6)	Load integer constant 
												   >	 75:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 76:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 77:     LD  4,-4(1)	Pop left into ac1 
												   >	 78:    TEQ  3,4,3	Op = 
												   >	 79:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 80:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-66(7)	CALL outputb
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 84:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 85:    LDC  3,2(6)	Load integer constant 
												   >	 86:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 87:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 88:     LD  4,-4(1)	Pop left into ac1 
												   >	 89:    TEQ  3,4,3	Op = 
												   >	 90:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 91:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 92:    LDA  3,1(7)	Return address in ac 
												   >	 93:    JMP  7,-77(7)	CALL outputb
												   >	 94:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 95:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 96:    LDC  3,3(6)	Load integer constant 
												   >	 97:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 98:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 99:     LD  4,-4(1)	Pop left into ac1 
												   >	100:    TEQ  3,4,3	Op = 
												   >	101:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	102:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	103:    LDA  3,1(7)	Return address in ac 
												   >	104:    JMP  7,-88(7)	CALL outputb
												   >	105:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	106:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	107:    LDC  3,1(6)	Load integer constant 
												   >	108:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	109:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	110:     LD  4,-4(1)	Pop left into ac1 
												   >	111:    TGT  3,4,3	Op > 
												   >	112:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	113:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-99(7)	CALL outputb
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	117:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	118:    LDC  3,2(6)	Load integer constant 
												   >	119:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	120:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	121:     LD  4,-4(1)	Pop left into ac1 
												   >	122:    TGT  3,4,3	Op > 
												   >	123:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	124:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	125:    LDA  3,1(7)	Return address in ac 
												   >	126:    JMP  7,-110(7)	CALL outputb
												   >	127:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	128:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	129:    LDC  3,3(6)	Load integer constant 
												   >	130:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	131:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	132:     LD  4,-4(1)	Pop left into ac1 
												   >	133:    TGT  3,4,3	Op > 
												   >	134:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	135:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	136:    LDA  3,1(7)	Return address in ac 
												   >	137:    JMP  7,-121(7)	CALL outputb
												   >	138:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	139:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	140:    LDC  3,1(6)	Load integer constant 
												   >	141:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	142:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	143:     LD  4,-4(1)	Pop left into ac1 
												   >	144:    TLE  3,4,3	Op <= 
												   >	145:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	146:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	147:    LDA  3,1(7)	Return address in ac 
												   >	148:    JMP  7,-132(7)	CALL outputb
												   >	149:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	150:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	151:    LDC  3,2(6)	Load integer constant 
												   >	152:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	153:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	154:     LD  4,-4(1)	Pop left into ac1 
												   >	155:    TLE  3,4,3	Op <= 
												   >	156:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	157:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	158:    LDA  3,1(7)	Return address in ac 
												   >	159:    JMP  7,-143(7)	CALL outputb
												   >	160:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	161:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	162:    LDC  3,3(6)	Load integer constant 
												   >	163:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	164:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	165:     LD  4,-4(1)	Pop left into ac1 
												   >	166:    TLE  3,4,3	Op <= 
												   >	167:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	168:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-154(7)	CALL outputb
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	172:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	173:    LDC  3,1(6)	Load integer constant 
												   >	174:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	175:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	176:     LD  4,-4(1)	Pop left into ac1 
												   >	177:    TGE  3,4,3	Op >= 
												   >	178:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	179:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	180:    LDA  3,1(7)	Return address in ac 
												   >	181:    JMP  7,-165(7)	CALL outputb
												   >	182:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	183:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	184:    LDC  3,2(6)	Load integer constant 
												   >	185:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	186:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	187:     LD  4,-4(1)	Pop left into ac1 
												   >	188:    TGE  3,4,3	Op >= 
												   >	189:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	190:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	191:    LDA  3,1(7)	Return address in ac 
												   >	192:    JMP  7,-176(7)	CALL outputb
												   >	193:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	194:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	195:    LDC  3,3(6)	Load integer constant 
												   >	196:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	197:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	198:     LD  4,-4(1)	Pop left into ac1 
												   >	199:    TGE  3,4,3	Op >= 
												   >	200:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	201:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	202:    LDA  3,1(7)	Return address in ac 
												   >	203:    JMP  7,-187(7)	CALL outputb
												   >	204:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	205:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	206:    LDC  3,1(6)	Load integer constant 
												   >	207:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	208:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	209:     LD  4,-4(1)	Pop left into ac1 
												   >	210:    TNE  3,4,3	Op >< 
												   >	211:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	212:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	213:    LDA  3,1(7)	Return address in ac 
												   >	214:    JMP  7,-198(7)	CALL outputb
												   >	215:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	216:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	217:    LDC  3,2(6)	Load integer constant 
												   >	218:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	219:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	220:     LD  4,-4(1)	Pop left into ac1 
												   >	221:    TNE  3,4,3	Op >< 
												   >	222:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	223:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	224:    LDA  3,1(7)	Return address in ac 
												   >	225:    JMP  7,-209(7)	CALL outputb
												   >	226:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	227:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	228:    LDC  3,3(6)	Load integer constant 
												   >	229:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	230:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	231:     LD  4,-4(1)	Pop left into ac1 
												   >	232:    TNE  3,4,3	Op >< 
												   >	233:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	234:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-220(7)	CALL outputb
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	238:    LDC  2,0(6)	Set return value to 0 
												   >	239:     LD  3,-1(1)	Load return address 
												   >	240:     LD  1,0(1)	Adjust fp 
												   >	241:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,241(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	242:    LDA  1,0(0)	set first frame at end of globals 
												   >	243:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	244:    LDA  3,1(7)	Return address in ac 
												   >	245:    JMP  7,-207(7)	Jump to main 
												   >	246:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
compare.mem compare.mem.f21 differ: byte 7, line 1
compare (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: outputb of type void [line: 3]							.   .   Child: 1  Call: outputb of type void [line: 3]
.   .   .   Child: 0  Op: < of type bool [line: 3]							.   .   .   Child: 0  Op: < of type bool [line: 3]
.   .   .   .   Child: 0  Const 1 of type int [line: 3]							.   .   .   .   Child: 0  Const 1 of type int [line: 3]
.   .   .   .   Child: 1  Const 2 of type int [line: 3]							.   .   .   .   Child: 1  Const 2 of type int [line: 3]
.   .   Sibling: 1  Call: outputb of type void [line: 4]						.   .   Sibling: 1  Call: outputb of type void [line: 4]
.   .   .   Child: 0  Op: < of type bool [line: 4]							.   .   .   Child: 0  Op: < of type bool [line: 4]
.   .   .   .   Child: 0  Const 2 of type int [line: 4]							.   .   .   .   Child: 0  Const 2 of type int [line: 4]
.   .   .   .   Child: 1  Const 2 of type int [line: 4]							.   .   .   .   Child: 1  Const 2 of type int [line: 4]
.   .   Sibling: 2  Call: outputb of type void [line: 5]						.   .   Sibling: 2  Call: outputb of type void [line: 5]
.   .   .   Child: 0  Op: < of type bool [line: 5]							.   .   .   Child: 0  Op: < of type bool [line: 5]
.   .   .   .   Child: 0  Const 3 of type int [line: 5]							.   .   .   .   Child: 0  Const 3 of type int [line: 5]
.   .   .   .   Child: 1  Const 2 of type int [line: 5]							.   .   .   .   Child: 1  Const 2 of type int [line: 5]
.   .   Sibling: 3  Call: outputb of type void [line: 7]						.   .   Sibling: 3  Call: outputb of type void [line: 7]
.   .   .   Child: 0  Op: == of type bool [line: 7]						   |	.   .   .   Child: 0  Op: = of type bool [line: 7]
.   .   .   .   Child: 0  Const 1 of type int [line: 7]							.   .   .   .   Child: 0  Const 1 of type int [line: 7]
.   .   .   .   Child: 1  Const 2 of type int [line: 7]							.   .   .   .   Child: 1  Const 2 of type int [line: 7]
.   .   Sibling: 4  Call: outputb of type void [line: 8]						.   .   Sibling: 4  Call: outputb of type void [line: 8]
.   .   .   Child: 0  Op: == of type bool [line: 8]						   |	.   .   .   Child: 0  Op: = of type bool [line: 8]
.   .   .   .   Child: 0  Const 2 of type int [line: 8]							.   .   .   .   Child: 0  Const 2 of type int [line: 8]
.   .   .   .   Child: 1  Const 2 of type int [line: 8]							.   .   .   .   Child: 1  Const 2 of type int [line: 8]
.   .   Sibling: 5  Call: outputb of type void [line: 9]						.   .   Sibling: 5  Call: outputb of type void [line: 9]
.   .   .   Child: 0  Op: == of type bool [line: 9]						   |	.   .   .   Child: 0  Op: = of type bool [line: 9]
.   .   .   .   Child: 0  Const 3 of type int [line: 9]							.   .   .   .   Child: 0  Const 3 of type int [line: 9]
.   .   .   .   Child: 1  Const 2 of type int [line: 9]							.   .   .   .   Child: 1  Const 2 of type int [line: 9]
.   .   Sibling: 6  Call: outputb of type void [line: 11]						.   .   Sibling: 6  Call: outputb of type void [line: 11]
.   .   .   Child: 0  Op: > of type bool [line: 11]							.   .   .   Child: 0  Op: > of type bool [line: 11]
.   .   .   .   Child: 0  Const 1 of type int [line: 11]						.   .   .   .   Child: 0  Const 1 of type int [line: 11]
.   .   .   .   Child: 1  Const 2 of type int [line: 11]						.   .   .   .   Child: 1  Const 2 of type int [line: 11]
.   .   Sibling: 7  Call: outputb of type void [line: 12]						.   .   Sibling: 7  Call: outputb of type void [line: 12]
.   .   .   Child: 0  Op: > of type bool [line: 12]							.   .   .   Child: 0  Op: > of type bool [line: 12]
.   .   .   .   Child: 0  Const 2 of type int [line: 12]						.   .   .   .   Child: 0  Const 2 of type int [line: 12]
.   .   .   .   Child: 1  Const 2 of type int [line: 12]						.   .   .   .   Child: 1  Const 2 of type int [line: 12]
.   .   Sibling: 8  Call: outputb of type void [line: 13]						.   .   Sibling: 8  Call: outputb of type void [line: 13]
.   .   .   Child: 0  Op: > of type bool [line: 13]							.   .   .   Child: 0  Op: > of type bool [line: 13]
.   .   .   .   Child: 0  Const 3 of type int [line: 13]						.   .   .   .   Child: 0  Const 3 of type int [line: 13]
.   .   .   .   Child: 1  Const 2 of type int [line: 13]						.   .   .   .   Child: 1  Const 2 of type int [line: 13]
.   .   Sibling: 9  Call: outputb of type void [line: 15]						.   .   Sibling: 9  Call: outputb of type void [line: 15]
.   .   .   Child: 0  Op: <= of type bool [line: 15]							.   .   .   Child: 0  Op: <= of type bool [line: 15]
.   .   .   .   Child: 0  Const 1 of type int [line: 15]						.   .   .   .   Child: 0  Const 1 of type int [line: 15]
.   .   .   .   Child: 1  Const 2 of type int [line: 15]						.   .   .   .   Child: 1  Const 2 of type int [line: 15]
.   .   Sibling: 10  Call: outputb of type void [line: 16]						.   .   Sibling: 10  Call: outputb of type void [line: 16]
.   .   .   Child: 0  Op: <= of type bool [line: 16]							.   .   .   Child: 0  Op: <= of type bool [line: 16]
.   .   .   .   Child: 0  Const 2 of type int [line: 16]						.   .   .   .   Child: 0  Const 2 of type int [line: 16]
.   .   .   .   Child: 1  Const 2 of type int [line: 16]						.   .   .   .   Child: 1  Const 2 of type int [line: 16]
.   .   Sibling: 11  Call: outputb of type void [line: 17]						.   .   Sibling: 11  Call: outputb of type void [line: 17]
.   .   .   Child: 0  Op: <= of type bool [line: 17]							.   .   .   Child: 0  Op: <= of type bool [line: 17]
.   .   .   .   Child: 0  Const 3 of type int [line: 17]						.   .   .   .   Child: 0  Const 3 of type int [line: 17]
.   .   .   .   Child: 1  Const 2 of type int [line: 17]						.   .   .   .   Child: 1  Const 2 of type int [line: 17]
.   .   Sibling: 12  Call: outputb of type void [line: 19]						.   .   Sibling: 12  Call: outputb of type void [line: 19]
.   .   .   Child: 0  Op: >= of type bool [line: 19]							.   .   .   Child: 0  Op: >= of type bool [line: 19]
.   .   .   .   Child: 0  Const 1 of type int [line: 19]						.   .   .   .   Child: 0  Const 1 of type int [line: 19]
.   .   .   .   Child: 1  Const 2 of type int [line: 19]						.   .   .   .   Child: 1  Const 2 of type int [line: 19]
.   .   Sibling: 13  Call: outputb of type void [line: 20]						.   .   Sibling: 13  Call: outputb of type void [line: 20]
.   .   .   Child: 0  Op: >= of type bool [line: 20]							.   .   .   Child: 0  Op: >= of type bool [line: 20]
.   .   .   .   Child: 0  Const 2 of type int [line: 20]						.   .   .   .   Child: 0  Const 2 of type int [line: 20]
.   .   .   .   Child: 1  Const 2 of type int [line: 20]						.   .   .   .   Child: 1  Const 2 of type int [line: 20]
.   .   Sibling: 14  Call: outputb of type void [line: 21]						.   .   Sibling: 14  Call: outputb of type void [line: 21]
.   .   .   Child: 0  Op: >= of type bool [line: 21]							.   .   .   Child: 0  Op: >= of type bool [line: 21]
.   .   .   .   Child: 0  Const 3 of type int [line: 21]						.   .   .   .   Child: 0  Const 3 of type int [line: 21]
.   .   .   .   Child: 1  Const 2 of type int [line: 21]						.   .   .   .   Child: 1  Const 2 of type int [line: 21]
.   .   Sibling: 15  Call: outputb of type void [line: 23]						.   .   Sibling: 15  Call: outputb of type void [line: 23]
.   .   .   Child: 0  Op: != of type bool [line: 23]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 23]
.   .   .   .   Child: 0  Const 1 of type int [line: 23]						.   .   .   .   Child: 0  Const 1 of type int [line: 23]
.   .   .   .   Child: 1  Const 2 of type int [line: 23]						.   .   .   .   Child: 1  Const 2 of type int [line: 23]
.   .   Sibling: 16  Call: outputb of type void [line: 24]						.   .   Sibling: 16  Call: outputb of type void [line: 24]
.   .   .   Child: 0  Op: != of type bool [line: 24]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 24]
.   .   .   .   Child: 0  Const 2 of type int [line: 24]						.   .   .   .   Child: 0  Const 2 of type int [line: 24]
.   .   .   .   Child: 1  Const 2 of type int [line: 24]						.   .   .   .   Child: 1  Const 2 of type int [line: 24]
.   .   Sibling: 17  Call: outputb of type void [line: 25]						.   .   Sibling: 17  Call: outputb of type void [line: 25]
.   .   .   Child: 0  Op: != of type bool [line: 25]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 25]
.   .   .   .   Child: 0  Const 3 of type int [line: 25]						.   .   .   .   Child: 0  Const 3 of type int [line: 25]
.   .   .   .   Child: 1  Const 2 of type int [line: 25]						.   .   .   .   Child: 1  Const 2 of type int [line: 25]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
compare.out ztmp23114.txt differ: byte 1, line 1
compare (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/compare.tm
Number of errors: 0										   |	T F F F T F F F T T T F F T T T F T
------------------------------------								   <
Loading file: compare.tm									   <
Bye.													Bye.
====================================
FILE: control2.c-
-rw-------. 1 corg7983 domain_users  310 Nov 17 15:35 control2.c-
-rw-------. 1 corg7983 domain_users  316 Nov 17 15:35 control2.c-.f21
-rw-------. 1 corg7983 domain_users  310 Nov 17 15:35 control2.c-.f22
-rw-------. 1 corg7983 domain_users  112 Nov 17 15:35 control2.expected
-rw-------. 1 corg7983 domain_users 4356 Nov 22 12:27 control2.mem
-rw-------. 1 corg7983 domain_users 1004 Nov 17 15:35 control2.mem.diffs
-rw-------. 1 corg7983 domain_users 5203 Nov 17 15:35 control2.mem.f21
-rw-------. 1 corg7983 domain_users  110 Nov 22 12:27 control2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 control2.tm
-rw-------. 1 corg7983 domain_users  212 Nov 17 15:35 control2.tm.diffs
-rw-------. 1 corg7983 domain_users 8430 Nov 17 15:35 control2.tm.f21
TM CODE COMPARISON
control2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  control2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,10(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 42:    LDC  3,7(6)	Load integer constant 
												   >	 43:     ST  3,-3(1)	Store variable y
												   >	* WHILE
												   >	 44:     LD  3,-2(1)	Load variable x
												   >	 45:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 46:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 47:     LD  4,-4(1)	Pop left into ac1 
												   >	 48:    TGT  3,4,3	Op > 
												   >	 49:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* IF
												   >	 51:     LD  3,-2(1)	Load variable x
												   >	 52:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 53:     LD  3,-3(1)	Load variable y
												   >	* TOFF inc: -4
												   >	 54:     LD  4,-4(1)	Pop left into ac1 
												   >	 55:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	 57:    LDC  3,666(6)	Load integer constant 
												   >	 58:     ST  3,-3(1)	Store variable y
												   >	 56:    JZR  3,3(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	 60:     LD  3,-2(1)	Load variable x
												   >	 61:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 62:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 63:     LD  4,-4(1)	Pop left into ac1 
												   >	 64:    SUB  3,4,3	Op - 
												   >	 65:     ST  3,-2(1)	Store variable x
												   >	 59:    JMP  7,6(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	 66:    JMP  7,-23(7)	go to beginning of loop 
												   >	 50:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	 67:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 68:     LD  3,-3(1)	Load variable y
												   >	 69:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 70:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 71:    LDA  3,1(7)	Return address in ac 
												   >	 72:    JMP  7,-67(7)	CALL output
												   >	 73:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 74:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 75:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 76:    LDA  3,1(7)	Return address in ac 
												   >	 77:    JMP  7,-44(7)	CALL outnl
												   >	 78:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 79:    LDC  3,1(6)	Load integer constant 
												   >	 80:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 81:    LDC  3,1(6)	Load integer constant 
												   >	 82:     ST  3,-3(1)	Store variable y
												   >	* WHILE
												   >	 83:     LD  3,-2(1)	Load variable x
												   >	 84:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 85:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 86:     LD  4,-4(1)	Pop left into ac1 
												   >	 87:    TLT  3,4,3	Op < 
												   >	 88:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* IF
												   >	 90:     LD  3,-3(1)	Load variable y
												   >	 91:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 92:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 93:     LD  4,-4(1)	Pop left into ac1 
												   >	 94:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* WHILE
												   >	 96:     LD  3,-3(1)	Load variable y
												   >	 97:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 98:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 99:     LD  4,-4(1)	Pop left into ac1 
												   >	100:    TLT  3,4,3	Op < 
												   >	101:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	103:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	104:     LD  3,-2(1)	Load variable x
												   >	105:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	106:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-103(7)	CALL output
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	110:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	111:     LD  3,-3(1)	Load variable y
												   >	112:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	113:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-110(7)	CALL output
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	117:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	118:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	119:    LDA  3,1(7)	Return address in ac 
												   >	120:    JMP  7,-87(7)	CALL outnl
												   >	121:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	122:     LD  3,-3(1)	load lhs variable y
												   >	123:    LDA  3,1(3)	increment value of y
												   >	124:     ST  3,-3(1)	Store variable y
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	125:    JMP  7,-30(7)	go to beginning of loop 
												   >	102:    JMP  7,23(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	 95:    JZR  3,31(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	127:    LDC  3,1(6)	Load integer constant 
												   >	128:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	129:     LD  3,-2(1)	load lhs variable x
												   >	130:    LDA  3,1(3)	increment value of x
												   >	131:     ST  3,-2(1)	Store variable x
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	126:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	132:    JMP  7,-50(7)	go to beginning of loop 
												   >	 89:    JMP  7,43(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	133:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	134:     LD  3,-2(1)	Load variable x
												   >	135:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	136:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	137:    LDA  3,1(7)	Return address in ac 
												   >	138:    JMP  7,-133(7)	CALL output
												   >	139:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* RETURN
												   >	140:     LD  3,-1(1)	Load return address 
												   >	141:     LD  1,0(1)	Adjust fp 
												   >	142:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	143:    LDC  2,0(6)	Set return value to 0 
												   >	144:     LD  3,-1(1)	Load return address 
												   >	145:     LD  1,0(1)	Adjust fp 
												   >	146:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,146(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	147:    LDA  1,0(0)	set first frame at end of globals 
												   >	148:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-112(7)	Jump to main 
												   >	151:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
control2.mem control2.mem.f21 differ: byte 7, line 1
control2 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 2]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 4]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 4]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Const 10 of type int [line: 7]							.   .   .   Child: 1  Const 10 of type int [line: 7]
.   .   Sibling: 1  Assign: = of type int [line: 8]						   |	.   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   Child: 1  Const 7 of type int [line: 8]							.   .   .   Child: 1  Const 7 of type int [line: 8]
.   .   Sibling: 2  While [line: 9]									.   .   Sibling: 2  While [line: 9]
.   .   .   Child: 0  Op: > of type bool [line: 9]							.   .   .   Child: 0  Op: > of type bool [line: 9]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Const 0 of type int [line: 9]							.   .   .   .   Child: 1  Const 0 of type int [line: 9]
.   .   .   Child: 1  If [line: 9]									.   .   .   Child: 1  If [line: 9]
.   .   .   .   Child: 0  Op: == of type bool [line: 9]						   |	.   .   .   .   Child: 0  Op: = of type bool [line: 9]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   Child: 1  Assign: = of type int [line: 9]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Const 666 of type int [line: 9]						.   .   .   .   .   Child: 1  Const 666 of type int [line: 9]
.   .   .   .   Child: 2  Assign: = of type int [line: 9]					   |	.   .   .   .   Child: 2  Assign: := of type int [line: 9]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Op: - of type int [line: 9]						.   .   .   .   .   Child: 1  Op: - of type int [line: 9]
.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]		.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 9]						.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 9]
.   .   Sibling: 3  Call: output of type void [line: 10]						.   .   Sibling: 3  Call: output of type void [line: 10]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   Sibling: 4  Call: outnl of type void [line: 11]							.   .   Sibling: 4  Call: outnl of type void [line: 11]
.   .   Sibling: 5  Assign: = of type int [line: 13]						   |	.   .   Sibling: 5  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Const 1 of type int [line: 13]							.   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   Sibling: 6  Assign: = of type int [line: 14]						   |	.   .   Sibling: 6  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   Child: 1  Const 1 of type int [line: 14]							.   .   .   Child: 1  Const 1 of type int [line: 14]
.   .   Sibling: 7  While [line: 15]									.   .   Sibling: 7  While [line: 15]
.   .   .   Child: 0  Op: < of type bool [line: 15]							.   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 5 of type int [line: 15]						.   .   .   .   Child: 1  Const 5 of type int [line: 15]
.   .   .   Child: 1  If [line: 15]									.   .   .   Child: 1  If [line: 15]
.   .   .   .   Child: 0  Op: < of type bool [line: 15]							.   .   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]			.   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   .   .   .   Child: 1  Const 5 of type int [line: 15]						.   .   .   .   .   Child: 1  Const 5 of type int [line: 15]
.   .   .   .   Child: 1  While [line: 15]								.   .   .   .   Child: 1  While [line: 15]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 15]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]		.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 15]					.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 15]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 15]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 15]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 16]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 16]
.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]		.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 16]				.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 16]
.   .   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 16]		.   .   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 16]
.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 16]					.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 16]
.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 17]					.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -4] [line: 18]				.   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -4] [line: 18]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 18]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 18]
.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]		.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 18]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 18]
.   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 18]					.   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 18]
.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]		.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 8  Call: output of type void [line: 19]						.   .   Sibling: 8  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   Sibling: 9  Return [line: 21]									.   .   Sibling: 9  Return [line: 21]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
control2.out ztmp23114.txt differ: byte 1, line 1
control2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/control2.tm
Number of errors: 0										   |	666
------------------------------------								   |	1 1
Loading file: control2.tm									   |	1 2
												   >	1 3
												   >	1 4
												   >	2 1
												   >	2 2
												   >	2 3
												   >	2 4
												   >	3 1
												   >	3 2
												   >	3 3
												   >	3 4
												   >	4 1
												   >	4 2
												   >	4 3
												   >	4 4
												   >	5
Bye.													Bye.
====================================
FILE: e.c-
-rw-------. 1 corg7983 domain_users  233 Nov 17 15:35 e.c-
-rw-------. 1 corg7983 domain_users  233 Nov 17 15:35 e.c-.f21
-rw-------. 1 corg7983 domain_users  233 Nov 17 15:35 e.c-.f22
-rw-------. 1 corg7983 domain_users   60 Nov 17 15:35 e.expected
-rw-------. 1 corg7983 domain_users 2829 Nov 22 12:27 e.mem
-rw-------. 1 corg7983 domain_users    0 Nov 17 15:35 e.mem.diffs
-rw-------. 1 corg7983 domain_users 3670 Nov 17 15:35 e.mem.f21
-rw-------. 1 corg7983 domain_users  103 Nov 22 12:27 e.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 e.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 e.tm.diffs
-rw-------. 1 corg7983 domain_users 9398 Nov 17 15:35 e.tm.f21
TM CODE COMPARISON
e (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  e.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,111(6)	Load integer constant 
												   >	 42:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 43:    LDC  3,222(6)	Load integer constant 
												   >	 44:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 45:    LDC  3,333(6)	Load integer constant 
												   >	 46:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 47:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 48:     LD  4,-6(1)	Pop left into ac1 
												   >	 49:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -5
												   >	 50:     LD  4,-5(1)	Pop left into ac1 
												   >	 51:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -4
												   >	 52:     LD  4,-4(1)	Pop left into ac1 
												   >	 53:    ADD  3,4,3	Op + 
												   >	 54:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 55:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-52(7)	CALL output
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 59:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 60:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-29(7)	CALL outnl
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	 64:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 65:    LDC  3,111(6)	Load integer constant 
												   >	 66:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 67:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 68:     LD  4,-4(1)	Pop left into ac1 
												   >	 69:    ADD  3,4,3	Op + 
												   >	 70:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 71:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 72:     LD  4,-4(1)	Pop left into ac1 
												   >	 73:    ADD  3,4,3	Op + 
												   >	 74:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 75:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 76:     LD  4,-4(1)	Pop left into ac1 
												   >	 77:    ADD  3,4,3	Op + 
												   >	 78:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 79:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 80:    LDA  3,1(7)	Return address in ac 
												   >	 81:    JMP  7,-76(7)	CALL output
												   >	 82:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 83:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 84:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 85:    LDA  3,1(7)	Return address in ac 
												   >	 86:    JMP  7,-53(7)	CALL outnl
												   >	 87:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	 88:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 89:    LDC  3,111(6)	Load integer constant 
												   >	 90:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 91:    LDC  3,222(6)	Load integer constant 
												   >	 92:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 93:    LDC  3,333(6)	Load integer constant 
												   >	 94:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 95:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 96:     LD  4,-6(1)	Pop left into ac1 
												   >	 97:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -5
												   >	 98:     LD  4,-5(1)	Pop left into ac1 
												   >	 99:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -4
												   >	100:     LD  4,-4(1)	Pop left into ac1 
												   >	101:    SUB  3,4,3	Op - 
												   >	102:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	103:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	104:    LDA  3,1(7)	Return address in ac 
												   >	105:    JMP  7,-100(7)	CALL output
												   >	106:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	107:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	108:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-77(7)	CALL outnl
												   >	111:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	112:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	113:    LDC  3,111(6)	Load integer constant 
												   >	114:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	115:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	116:     LD  4,-4(1)	Pop left into ac1 
												   >	117:    SUB  3,4,3	Op - 
												   >	118:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	119:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	120:     LD  4,-4(1)	Pop left into ac1 
												   >	121:    SUB  3,4,3	Op - 
												   >	122:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	123:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	124:     LD  4,-4(1)	Pop left into ac1 
												   >	125:    SUB  3,4,3	Op - 
												   >	126:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	127:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	128:    LDA  3,1(7)	Return address in ac 
												   >	129:    JMP  7,-124(7)	CALL output
												   >	130:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	131:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	132:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	133:    LDA  3,1(7)	Return address in ac 
												   >	134:    JMP  7,-101(7)	CALL outnl
												   >	135:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	136:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	137:    LDC  3,111(6)	Load integer constant 
												   >	138:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	139:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	140:     LD  4,-4(1)	Pop left into ac1 
												   >	141:    SUB  3,4,3	Op - 
												   >	142:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	143:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	144:     LD  4,-4(1)	Pop left into ac1 
												   >	145:    SUB  3,4,3	Op - 
												   >	146:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	147:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	148:     LD  4,-4(1)	Pop left into ac1 
												   >	149:    SUB  3,4,3	Op - 
												   >	150:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	151:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	152:    LDA  3,1(7)	Return address in ac 
												   >	153:    JMP  7,-148(7)	CALL output
												   >	154:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	155:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	156:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	157:    LDA  3,1(7)	Return address in ac 
												   >	158:    JMP  7,-125(7)	CALL outnl
												   >	159:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	160:    LDC  2,0(6)	Set return value to 0 
												   >	161:     LD  3,-1(1)	Load return address 
												   >	162:     LD  1,0(1)	Adjust fp 
												   >	163:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,163(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	164:    LDA  1,0(0)	set first frame at end of globals 
												   >	165:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-129(7)	Jump to main 
												   >	168:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
e.mem e.mem.f21 differ: byte 7, line 1
e (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Op: + of type int [line: 3]							.   .   .   Child: 0  Op: + of type int [line: 3]
.   .   .   .   Child: 0  Const 111 of type int [line: 3]						.   .   .   .   Child: 0  Const 111 of type int [line: 3]
.   .   .   .   Child: 1  Op: + of type int [line: 3]							.   .   .   .   Child: 1  Op: + of type int [line: 3]
.   .   .   .   .   Child: 0  Const 222 of type int [line: 3]						.   .   .   .   .   Child: 0  Const 222 of type int [line: 3]
.   .   .   .   .   Child: 1  Op: + of type int [line: 3]						.   .   .   .   .   Child: 1  Op: + of type int [line: 3]
.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 3]					.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 3]
.   .   .   .   .   .   Child: 1  Const 444 of type int [line: 3]					.   .   .   .   .   .   Child: 1  Const 444 of type int [line: 3]
.   .   Sibling: 1  Call: outnl of type void [line: 3]							.   .   Sibling: 1  Call: outnl of type void [line: 3]
.   .   Sibling: 2  Call: output of type void [line: 4]							.   .   Sibling: 2  Call: output of type void [line: 4]
.   .   .   Child: 0  Op: + of type int [line: 4]							.   .   .   Child: 0  Op: + of type int [line: 4]
.   .   .   .   Child: 0  Op: + of type int [line: 4]							.   .   .   .   Child: 0  Op: + of type int [line: 4]
.   .   .   .   .   Child: 0  Op: + of type int [line: 4]						.   .   .   .   .   Child: 0  Op: + of type int [line: 4]
.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 4]					.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 4]
.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 4]					.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 4]
.   .   .   .   .   Child: 1  Const 333 of type int [line: 4]						.   .   .   .   .   Child: 1  Const 333 of type int [line: 4]
.   .   .   .   Child: 1  Const 444 of type int [line: 4]						.   .   .   .   Child: 1  Const 444 of type int [line: 4]
.   .   Sibling: 3  Call: outnl of type void [line: 4]							.   .   Sibling: 3  Call: outnl of type void [line: 4]
.   .   Sibling: 4  Call: output of type void [line: 5]							.   .   Sibling: 4  Call: output of type void [line: 5]
.   .   .   Child: 0  Op: - of type int [line: 5]							.   .   .   Child: 0  Op: - of type int [line: 5]
.   .   .   .   Child: 0  Const 111 of type int [line: 5]						.   .   .   .   Child: 0  Const 111 of type int [line: 5]
.   .   .   .   Child: 1  Op: - of type int [line: 5]							.   .   .   .   Child: 1  Op: - of type int [line: 5]
.   .   .   .   .   Child: 0  Const 222 of type int [line: 5]						.   .   .   .   .   Child: 0  Const 222 of type int [line: 5]
.   .   .   .   .   Child: 1  Op: - of type int [line: 5]						.   .   .   .   .   Child: 1  Op: - of type int [line: 5]
.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 5]					.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 5]
.   .   .   .   .   .   Child: 1  Const 444 of type int [line: 5]					.   .   .   .   .   .   Child: 1  Const 444 of type int [line: 5]
.   .   Sibling: 5  Call: outnl of type void [line: 5]							.   .   Sibling: 5  Call: outnl of type void [line: 5]
.   .   Sibling: 6  Call: output of type void [line: 6]							.   .   Sibling: 6  Call: output of type void [line: 6]
.   .   .   Child: 0  Op: - of type int [line: 6]							.   .   .   Child: 0  Op: - of type int [line: 6]
.   .   .   .   Child: 0  Op: - of type int [line: 6]							.   .   .   .   Child: 0  Op: - of type int [line: 6]
.   .   .   .   .   Child: 0  Op: - of type int [line: 6]						.   .   .   .   .   Child: 0  Op: - of type int [line: 6]
.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 6]					.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 6]
.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 6]					.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 6]
.   .   .   .   .   Child: 1  Const 333 of type int [line: 6]						.   .   .   .   .   Child: 1  Const 333 of type int [line: 6]
.   .   .   .   Child: 1  Const 444 of type int [line: 6]						.   .   .   .   Child: 1  Const 444 of type int [line: 6]
.   .   Sibling: 7  Call: outnl of type void [line: 6]							.   .   Sibling: 7  Call: outnl of type void [line: 6]
.   .   Sibling: 8  Call: output of type void [line: 7]							.   .   Sibling: 8  Call: output of type void [line: 7]
.   .   .   Child: 0  Op: - of type int [line: 7]							.   .   .   Child: 0  Op: - of type int [line: 7]
.   .   .   .   Child: 0  Op: - of type int [line: 7]							.   .   .   .   Child: 0  Op: - of type int [line: 7]
.   .   .   .   .   Child: 0  Op: - of type int [line: 7]						.   .   .   .   .   Child: 0  Op: - of type int [line: 7]
.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 7]					.   .   .   .   .   .   Child: 0  Const 111 of type int [line: 7]
.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 7]					.   .   .   .   .   .   Child: 1  Const 222 of type int [line: 7]
.   .   .   .   .   Child: 1  Const 333 of type int [line: 7]						.   .   .   .   .   Child: 1  Const 333 of type int [line: 7]
.   .   .   .   Child: 1  Const 444 of type int [line: 7]						.   .   .   .   Child: 1  Const 444 of type int [line: 7]
.   .   Sibling: 9  Call: outnl of type void [line: 7]							.   .   Sibling: 9  Call: outnl of type void [line: 7]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
e.out ztmp23114.txt differ: byte 1, line 1
e (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/e.tm
Number of errors: 0										   |	1110
------------------------------------								   |	1110
Loading file: e.tm										   |	-222
												   >	-888
												   >	-888
Bye.													Bye.
====================================
FILE: examplearray3.c-
-rw-------. 1 corg7983 domain_users  183 Nov 17 15:35 examplearray3.c-
-rw-------. 1 corg7983 domain_users  184 Nov 17 15:35 examplearray3.c-.f21
-rw-------. 1 corg7983 domain_users  183 Nov 17 15:35 examplearray3.c-.f22
-rw-------. 1 corg7983 domain_users  205 Nov 17 15:35 examplearray3.expected
-rw-------. 1 corg7983 domain_users 2152 Nov 22 12:27 examplearray3.mem
-rw-------. 1 corg7983 domain_users  117 Nov 17 15:35 examplearray3.mem.diffs
-rw-------. 1 corg7983 domain_users 2994 Nov 17 15:35 examplearray3.mem.f21
-rw-------. 1 corg7983 domain_users  269 Nov 22 12:27 examplearray3.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 examplearray3.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 examplearray3.tm.diffs
-rw-------. 1 corg7983 domain_users 5886 Nov 17 15:35 examplearray3.tm.f21
TM CODE COMPARISON
examplearray3 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  examplearray3.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	 40:    LDC  3,9999(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable q
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 42:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 43:     LD  3,-2(1)	Load address of base of array x
												   >	 44:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 45:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 46:     LD  4,-6(1)	Pop left into ac1 
												   >	 47:    SUB  3,4,3	compute location from index 
												   >	 48:     LD  3,0(3)	Load array element 
												   >	 49:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 50:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-47(7)	CALL output
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 54:    LDC  2,0(6)	Set return value to 0 
												   >	 55:     LD  3,-1(1)	Load return address 
												   >	 56:     LD  1,0(1)	Adjust fp 
												   >	 57:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 58:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	 59:    LDC  3,9999(6)	Load integer constant 
												   >	 60:     ST  3,-3(1)	Store variable q
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL cat
												   >	 61:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 62:     LD  3,-2(1)	Load address of base of array y
												   >	 63:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end cat
												   >	 64:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 65:    LDA  3,1(7)	Return address in ac 
												   >	 66:    JMP  7,-28(7)	CALL cat
												   >	 67:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 68:    LDC  2,0(6)	Set return value to 0 
												   >	 69:     LD  3,-1(1)	Load return address 
												   >	 70:     LD  1,0(1)	Adjust fp 
												   >	 71:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 72:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	 73:    LDC  3,9999(6)	Load integer constant 
												   >	 74:     ST  3,-2(1)	Store variable q
												   >	 75:    LDC  3,10(6)	load size of array z
												   >	 76:     ST  3,-3(1)	save size of array z
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 77:    LDC  3,1(6)	Load integer constant 
												   >	 78:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	 79:    LDC  3,777(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	 80:     LD  4,-14(1)	Pop index 
												   >	 81:    LDA  5,-4(1)	Load address of base of array z
												   >	 82:    SUB  5,5,4	Compute offset of value 
												   >	 83:     ST  3,0(5)	Store variable z
												   >	* EXPRESSION
												   >	* CALL dog
												   >	 84:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	 85:    LDA  3,-4(1)	Load address of base of array z
												   >	 86:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end dog
												   >	 87:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-32(7)	CALL dog
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 91:    LDC  2,0(6)	Set return value to 0 
												   >	 92:     LD  3,-1(1)	Load return address 
												   >	 93:     LD  1,0(1)	Adjust fp 
												   >	 94:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,94(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 95:    LDA  1,0(0)	set first frame at end of globals 
												   >	 96:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 97:    LDA  3,1(7)	Return address in ac 
												   >	 98:    JMP  7,-27(7)	Jump to main 
												   >	 99:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
examplearray3.mem examplearray3.mem.f21 differ: byte 161, line 4
examplearray3 (MEM DIFF)
WARNING(2): The variable 'q' seems not to be used.							WARNING(2): The variable 'q' seems not to be used.
WARNING(7): The variable 'q' seems not to be used.							WARNING(7): The variable 'q' seems not to be used.
WARNING(12): The variable 'q' seems not to be used.							WARNING(12): The variable 'q' seems not to be used.
Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]
.   .   Child: 0  Var: q of type int [mem: Local loc: -3 size: 1] [line: 2]				.   .   Child: 0  Var: q of type int [mem: Local loc: -3 size: 1] [line: 2]
.   .   .   Child: 0  Const 9999 of type int [line: 2]							.   .   .   Child: 0  Const 9999 of type int [line: 2]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Op: [ of type int [line: 3]							.   .   .   Child: 0  Op: [ of type int [line: 3]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   .   .   Child: 1  Const 1 of type int [line: 3]							.   .   .   .   Child: 1  Const 1 of type int [line: 3]
Sibling: 1  Func: dog returns type void [mem: Global loc: 0 size: -3] [line: 6]			   |	Sibling: 8  Func: dog returns type void [mem: Global loc: 0 size: -3] [line: 6]
.   Child: 0  Parm: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   Child: 0  Parm: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]
.   .   Child: 0  Var: q of type int [mem: Local loc: -3 size: 1] [line: 7]				.   .   Child: 0  Var: q of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Child: 0  Const 9999 of type int [line: 7]							.   .   .   Child: 0  Const 9999 of type int [line: 7]
.   .   Child: 1  Call: cat of type void [line: 8]							.   .   Child: 1  Call: cat of type void [line: 8]
.   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]		.   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 11]
.   .   Child: 0  Var: q of type int [mem: Local loc: -2 size: 1] [line: 12]				.   .   Child: 0  Var: q of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   Child: 0  Const 9999 of type int [line: 12]							.   .   .   Child: 0  Const 9999 of type int [line: 12]
.   .   Sibling: 1  Var: z of array of type int [mem: Local loc: -4 size: 11] [line: 13]		.   .   Sibling: 1  Var: z of array of type int [mem: Local loc: -4 size: 11] [line: 13]
.   .   Child: 1  Assign: = of type int [line: 14]						   |	.   .   Child: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 11] [line: 14]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 11] [line: 14]
.   .   .   .   Child: 1  Const 1 of type int [line: 14]						.   .   .   .   Child: 1  Const 1 of type int [line: 14]
.   .   .   Child: 1  Const 777 of type int [line: 14]							.   .   .   Child: 1  Const 777 of type int [line: 14]
.   .   Sibling: 1  Call: dog of type void [line: 15]							.   .   Sibling: 1  Call: dog of type void [line: 15]
.   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 11] [line: 15]		.   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 11] [line: 15]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 3											Number of warnings: 3
Number of errors: 0											Number of errors: 0
examplearray3.out ztmp23114.txt differ: byte 155, line 4
examplearray3 (Output DIFF)
WARNING(2): The variable 'q' seems not to be used.							WARNING(2): The variable 'q' seems not to be used.
WARNING(7): The variable 'q' seems not to be used.							WARNING(7): The variable 'q' seems not to be used.
WARNING(12): The variable 'q' seems not to be used.							WARNING(12): The variable 'q' seems not to be used.
Number of warnings: 3										   |	Loading file: BroadTests/examplearray3.tm
Number of errors: 0										   |	777
------------------------------------								   <
Loading file: examplearray3.tm									   <
Bye.													Bye.
====================================
FILE: exp3.c-
-rw-------. 1 corg7983 domain_users   883 Nov 17 15:35 exp3.c-
-rw-------. 1 corg7983 domain_users   895 Nov 17 15:35 exp3.c-.f21
-rw-------. 1 corg7983 domain_users   883 Nov 17 15:35 exp3.c-.f22
-rw-------. 1 corg7983 domain_users    85 Nov 17 15:35 exp3.expected
-rw-------. 1 corg7983 domain_users  7997 Nov 22 12:27 exp3.mem
-rw-------. 1 corg7983 domain_users  1462 Nov 17 15:35 exp3.mem.diffs
-rw-------. 1 corg7983 domain_users  8850 Nov 17 15:35 exp3.mem.f21
-rw-------. 1 corg7983 domain_users   106 Nov 22 12:27 exp3.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 exp3.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 exp3.tm.diffs
-rw-------. 1 corg7983 domain_users 12562 Nov 17 15:35 exp3.tm.f21
TM CODE COMPARISON
exp3 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  exp3.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	 42:    LDC  3,10(6)	Load integer constant 
												   >	 43:     ST  3,-2(1)	Store variable frodo
												   >	* EXPRESSION
												   >	 44:    LDC  3,100(6)	Load integer constant 
												   >	 45:     ST  3,-4(1)	Store variable sam
												   >	* EXPRESSION
												   >	 46:    LDC  3,1000(6)	Load integer constant 
												   >	 47:     ST  3,-5(1)	Store variable merry
												   >	* EXPRESSION
												   >	 48:    LDC  3,10000(6)	Load integer constant 
												   >	 49:     ST  3,-6(1)	Store variable pippin
												   >	* EXPRESSION
												   >	 50:     LD  3,-3(1)	Load variable bilbo
												   >	 51:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	* CALL output
												   >	 52:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	 53:     LD  3,-3(1)	Load variable bilbo
												   >	 54:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	 55:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-52(7)	CALL output
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 59:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	 60:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-29(7)	CALL outnl
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	 64:     LD  3,-3(1)	Load variable bilbo
												   >	 65:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 66:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 67:     LD  4,-8(1)	Pop left into ac1 
												   >	 68:    ADD  3,4,3	Op + 
												   >	 69:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	* CALL output
												   >	 70:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	 71:     LD  3,-3(1)	Load variable bilbo
												   >	 72:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	 73:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 74:    LDA  3,1(7)	Return address in ac 
												   >	 75:    JMP  7,-70(7)	CALL output
												   >	 76:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 77:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	 78:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-47(7)	CALL outnl
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	 82:     LD  3,-2(1)	Load variable frodo
												   >	 83:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 84:     LD  3,-3(1)	Load variable bilbo
												   >	 85:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 86:     LD  3,-4(1)	Load variable sam
												   >	 87:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 88:     LD  3,-5(1)	Load variable merry
												   >	 89:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 90:     LD  3,-6(1)	Load variable pippin
												   >	* TOFF inc: -11
												   >	 91:     LD  4,-11(1)	Pop left into ac1 
												   >	 92:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -10
												   >	 93:     LD  4,-10(1)	Pop left into ac1 
												   >	 94:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -9
												   >	 95:     LD  4,-9(1)	Pop left into ac1 
												   >	 96:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	 97:     LD  4,-8(1)	Pop left into ac1 
												   >	 98:    ADD  3,4,3	Op + 
												   >	 99:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	* CALL output
												   >	100:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	101:     LD  3,-3(1)	Load variable bilbo
												   >	102:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	103:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	104:    LDA  3,1(7)	Return address in ac 
												   >	105:    JMP  7,-100(7)	CALL output
												   >	106:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	107:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	108:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-77(7)	CALL outnl
												   >	111:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	112:     LD  3,-5(1)	Load variable merry
												   >	113:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	114:     LD  3,-6(1)	Load variable pippin
												   >	* TOFF inc: -8
												   >	115:     LD  4,-8(1)	Pop left into ac1 
												   >	116:    MUL  3,4,3	Op * 
												   >	117:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	118:     LD  3,-4(1)	Load variable sam
												   >	* TOFF inc: -8
												   >	119:     LD  4,-8(1)	Pop left into ac1 
												   >	120:    ADD  3,4,3	Op + 
												   >	121:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	122:     LD  3,-3(1)	Load variable bilbo
												   >	* TOFF inc: -8
												   >	123:     LD  4,-8(1)	Pop left into ac1 
												   >	124:    MUL  3,4,3	Op * 
												   >	125:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	126:     LD  3,-2(1)	Load variable frodo
												   >	* TOFF inc: -8
												   >	127:     LD  4,-8(1)	Pop left into ac1 
												   >	128:    ADD  3,4,3	Op + 
												   >	129:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	* CALL output
												   >	130:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	131:     LD  3,-3(1)	Load variable bilbo
												   >	132:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	133:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	134:    LDA  3,1(7)	Return address in ac 
												   >	135:    JMP  7,-130(7)	CALL output
												   >	136:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	137:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	138:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	139:    LDA  3,1(7)	Return address in ac 
												   >	140:    JMP  7,-107(7)	CALL outnl
												   >	141:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	142:     LD  3,-3(1)	Load variable bilbo
												   >	143:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	144:     LD  3,-3(1)	Load variable bilbo
												   >	145:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	146:     LD  3,-3(1)	Load variable bilbo
												   >	147:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	148:     LD  3,-3(1)	Load variable bilbo
												   >	149:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	150:     LD  3,-3(1)	Load variable bilbo
												   >	151:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	152:     LD  3,-3(1)	Load variable bilbo
												   >	* TOFF inc: -12
												   >	153:     LD  4,-12(1)	Pop left into ac1 
												   >	154:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	155:     LD  4,-11(1)	Pop left into ac1 
												   >	156:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -10
												   >	157:     LD  4,-10(1)	Pop left into ac1 
												   >	158:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -9
												   >	159:     LD  4,-9(1)	Pop left into ac1 
												   >	160:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -8
												   >	161:     LD  4,-8(1)	Pop left into ac1 
												   >	162:    ADD  3,4,3	Op + 
												   >	163:     ST  3,-3(1)	Store variable bilbo
												   >	* EXPRESSION
												   >	* CALL output
												   >	164:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	165:     LD  3,-3(1)	Load variable bilbo
												   >	166:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	167:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	168:    LDA  3,1(7)	Return address in ac 
												   >	169:    JMP  7,-164(7)	CALL output
												   >	170:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	171:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	172:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-141(7)	CALL outnl
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	176:    LDC  3,1(6)	Load Boolean constant 
												   >	177:     ST  3,-7(1)	Store variable arwen
												   >	* EXPRESSION
												   >	178:    LDC  3,0(6)	Load Boolean constant 
												   >	179:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	180:     LD  3,-7(1)	Load variable arwen
												   >	181:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	182:     LD  3,-5(1)	Load variable merry
												   >	183:    NEG  3,3,3	Op unary - 
												   >	184:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	185:     LD  3,-4(1)	Load variable sam
												   >	186:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -10
												   >	187:     LD  4,-10(1)	Pop left into ac1 
												   >	188:    MUL  3,4,3	Op * 
												   >	189:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	190:     LD  3,-6(1)	Load variable pippin
												   >	* TOFF inc: -10
												   >	191:     LD  4,-10(1)	Pop left into ac1 
												   >	192:    ADD  3,4,3	Op + 
												   >	193:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	194:     LD  3,-3(1)	Load variable bilbo
												   >	195:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	196:     LD  3,-2(1)	Load variable frodo
												   >	197:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	198:     LD  3,-2(1)	Load variable frodo
												   >	199:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -12
												   >	200:     LD  4,-12(1)	Pop left into ac1 
												   >	201:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -11
												   >	202:     LD  4,-11(1)	Pop left into ac1 
												   >	203:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -10
												   >	204:     LD  4,-10(1)	Pop left into ac1 
												   >	205:    TGE  3,4,3	Op >= 
												   >	206:    LDC  4,1(6)	Load 1 
												   >	207:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -9
												   >	208:     LD  4,-9(1)	Pop left into ac1 
												   >	209:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	210:     LD  4,-8(1)	Pop left into ac1 
												   >	211:     OR  3,4,3	Op OR 
												   >	212:     ST  3,-7(1)	Store variable arwen
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	213:     ST  1,-8(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	214:     LD  3,-7(1)	Load variable arwen
												   >	215:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end outputb
												   >	216:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	217:    LDA  3,1(7)	Return address in ac 
												   >	218:    JMP  7,-202(7)	CALL outputb
												   >	219:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	220:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	221:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-190(7)	CALL outnl
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	225:    LDC  2,0(6)	Set return value to 0 
												   >	226:     LD  3,-1(1)	Load return address 
												   >	227:     LD  1,0(1)	Adjust fp 
												   >	228:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,228(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	229:    LDA  1,0(0)	set first frame at end of globals 
												   >	230:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	231:    LDA  3,1(7)	Return address in ac 
												   >	232:    JMP  7,-194(7)	Jump to main 
												   >	233:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
exp3.mem exp3.mem.f21 differ: byte 7, line 1
exp3 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 4]
.   .   Child: 0  Var: frodo of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   Child: 0  Var: frodo of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Var: bilbo of type int [mem: Local loc: -3 size: 1] [line: 6]			.   .   Sibling: 1  Var: bilbo of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   Sibling: 2  Var: sam of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   Sibling: 2  Var: sam of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   Sibling: 3  Var: merry of type int [mem: Local loc: -5 size: 1] [line: 8]			.   .   Sibling: 3  Var: merry of type int [mem: Local loc: -5 size: 1] [line: 8]
.   .   Sibling: 4  Var: pippin of type int [mem: Local loc: -6 size: 1] [line: 9]			.   .   Sibling: 4  Var: pippin of type int [mem: Local loc: -6 size: 1] [line: 9]
.   .   Sibling: 5  Var: arwen of type bool [mem: Local loc: -7 size: 1] [line: 10]			.   .   Sibling: 5  Var: arwen of type bool [mem: Local loc: -7 size: 1] [line: 10]
.   .   Child: 1  Assign: = of type int [line: 12]						   |	.   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 12]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   Child: 1  Const 1 of type int [line: 12]							.   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   Sibling: 1  Assign: = of type int [line: 13]						   |	.   .   Sibling: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 13]			.   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Const 10 of type int [line: 13]							.   .   .   Child: 1  Const 10 of type int [line: 13]
.   .   Sibling: 2  Assign: = of type int [line: 14]						   |	.   .   Sibling: 2  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 14]			.   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 14]
.   .   .   Child: 1  Const 100 of type int [line: 14]							.   .   .   Child: 1  Const 100 of type int [line: 14]
.   .   Sibling: 3  Assign: = of type int [line: 15]						   |	.   .   Sibling: 3  Assign: := of type int [line: 15]
.   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 15]			.   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 15]
.   .   .   Child: 1  Const 1000 of type int [line: 15]							.   .   .   Child: 1  Const 1000 of type int [line: 15]
.   .   Sibling: 4  Assign: = of type int [line: 16]						   |	.   .   Sibling: 4  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: pippin of type int [mem: Local loc: -6 size: 1] [line: 16]			.   .   .   Child: 0  Id: pippin of type int [mem: Local loc: -6 size: 1] [line: 16]
.   .   .   Child: 1  Const 10000 of type int [line: 16]						.   .   .   Child: 1  Const 10000 of type int [line: 16]
.   .   Sibling: 5  Assign: = of type int [line: 18]						   |	.   .   Sibling: 5  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 18]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 18]			.   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   Sibling: 6  Call: output of type void [line: 19]						.   .   Sibling: 6  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 19]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   Sibling: 7  Call: outnl of type void [line: 20]							.   .   Sibling: 7  Call: outnl of type void [line: 20]
.   .   Sibling: 8  Assign: = of type int [line: 22]						   |	.   .   Sibling: 8  Assign: := of type int [line: 22]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 22]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   .   Child: 1  Op: + of type int [line: 22]							.   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 22]			.   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   .   .   Child: 1  Const 1 of type int [line: 22]						.   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   Sibling: 9  Call: output of type void [line: 23]						.   .   Sibling: 9  Call: output of type void [line: 23]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 23]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   Sibling: 10  Call: outnl of type void [line: 24]						.   .   Sibling: 10  Call: outnl of type void [line: 24]
.   .   Sibling: 11  Assign: = of type int [line: 26]						   |	.   .   Sibling: 11  Assign: := of type int [line: 26]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 26]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   Child: 1  Op: + of type int [line: 26]							.   .   .   Child: 1  Op: + of type int [line: 26]
.   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 26]			.   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   .   .   Child: 1  Op: * of type int [line: 26]							.   .   .   .   Child: 1  Op: * of type int [line: 26]
.   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 26]		.   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   .   .   Child: 1  Op: + of type int [line: 26]						.   .   .   .   .   Child: 1  Op: + of type int [line: 26]
.   .   .   .   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 26]		.   .   .   .   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 26]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 26]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 26]
.   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [line:	.   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [line:
.   .   Sibling: 12  Call: output of type void [line: 27]						.   .   Sibling: 12  Call: output of type void [line: 27]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 27]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   Sibling: 13  Call: outnl of type void [line: 28]						.   .   Sibling: 13  Call: outnl of type void [line: 28]
.   .   Sibling: 14  Assign: = of type int [line: 30]						   |	.   .   Sibling: 14  Assign: := of type int [line: 30]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 30]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 30]
.   .   .   Child: 1  Op: + of type int [line: 30]							.   .   .   Child: 1  Op: + of type int [line: 30]
.   .   .   .   Child: 0  Op: * of type int [line: 30]							.   .   .   .   Child: 0  Op: * of type int [line: 30]
.   .   .   .   .   Child: 0  Op: + of type int [line: 30]						.   .   .   .   .   Child: 0  Op: + of type int [line: 30]
.   .   .   .   .   .   Child: 0  Op: * of type int [line: 30]						.   .   .   .   .   .   Child: 0  Op: * of type int [line: 30]
.   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [line:	.   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [line:
.   .   .   .   .   .   Child: 1  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 30]		.   .   .   .   .   .   Child: 1  Id: sam of type int [mem: Local loc: -4 size: 1] [line: 30]
.   .   .   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 30]		.   .   .   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 30]
.   .   .   .   Child: 1  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 30]			.   .   .   .   Child: 1  Id: frodo of type int [mem: Local loc: -2 size: 1] [line: 30]
.   .   Sibling: 15  Call: output of type void [line: 31]						.   .   Sibling: 15  Call: output of type void [line: 31]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 31]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 31]
.   .   Sibling: 16  Call: outnl of type void [line: 32]						.   .   Sibling: 16  Call: outnl of type void [line: 32]
.   .   Sibling: 17  Assign: = of type int [line: 34]						   |	.   .   Sibling: 17  Assign: := of type int [line: 34]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]
.   .   .   Child: 1  Op: + of type int [line: 34]							.   .   .   Child: 1  Op: + of type int [line: 34]
.   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]			.   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]
.   .   .   .   Child: 1  Op: - of type int [line: 34]							.   .   .   .   Child: 1  Op: - of type int [line: 34]
.   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]		.   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]
.   .   .   .   .   Child: 1  Op: + of type int [line: 34]						.   .   .   .   .   Child: 1  Op: + of type int [line: 34]
.   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]		.   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 34]
.   .   .   .   .   .   Child: 1  Op: - of type int [line: 34]						.   .   .   .   .   .   Child: 1  Op: - of type int [line: 34]
.   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 34]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 34]
.   .   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li
.   .   Sibling: 18  Call: output of type void [line: 35]						.   .   Sibling: 18  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 35]			.   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [line: 35]
.   .   Sibling: 19  Call: outnl of type void [line: 36]						.   .   Sibling: 19  Call: outnl of type void [line: 36]
.   .   Sibling: 20  Assign: = of type bool [line: 38]						   |	.   .   Sibling: 20  Assign: := of type bool [line: 38]
.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 38]			.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 38]
.   .   .   Child: 1  Const true of type bool [line: 38]						.   .   .   Child: 1  Const true of type bool [line: 38]
.   .   Sibling: 21  Assign: = of type bool [line: 39]						   |	.   .   Sibling: 21  Assign: := of type bool [line: 39]
.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 39]			.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 39]
.   .   .   Child: 1  Op: or of type bool [line: 39]							.   .   .   Child: 1  Op: or of type bool [line: 39]
.   .   .   .   Child: 0  Const false of type bool [line: 39]						.   .   .   .   Child: 0  Const false of type bool [line: 39]
.   .   .   .   Child: 1  Op: and of type bool [line: 39]						.   .   .   .   Child: 1  Op: and of type bool [line: 39]
.   .   .   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 39]		.   .   .   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 39]
.   .   .   .   .   Child: 1  Op: not of type bool [line: 39]						.   .   .   .   .   Child: 1  Op: not of type bool [line: 39]
.   .   .   .   .   .   Child: 0  Op: >= of type bool [line: 39]					.   .   .   .   .   .   Child: 0  Op: >= of type bool [line: 39]
.   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 39]					.   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 39]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 39]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 39]
.   .   .   .   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: merry of type int [mem: Local loc: -5 size
.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: sam of type int [mem: Local loc: -4 size: 
.   .   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [l	.   .   .   .   .   .   .   .   Child: 1  Id: pippin of type int [mem: Local loc: -6 size: 1] [l
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 39]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 39]
.   .   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: bilbo of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 39]					.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 39]
.   .   .   .   .   .   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: frodo of type int [mem: Local loc: -2 size
.   .   Sibling: 22  Call: outputb of type void [line: 40]						.   .   Sibling: 22  Call: outputb of type void [line: 40]
.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 40]			.   .   .   Child: 0  Id: arwen of type bool [mem: Local loc: -7 size: 1] [line: 40]
.   .   Sibling: 23  Call: outnl of type void [line: 41]						.   .   Sibling: 23  Call: outnl of type void [line: 41]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
exp3.out ztmp23114.txt differ: byte 1, line 1
exp3 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/exp3.tm
Number of errors: 0										   |	1
------------------------------------								   |	2
Loading file: exp3.tm										   |	20000210
												   >	200004100021010
												   >	400008200042020
												   >	T
Bye.													Bye.
====================================
FILE: factor2.c-
-rw-------. 1 corg7983 domain_users  431 Nov 17 15:35 factor2.c-
-rw-------. 1 corg7983 domain_users  431 Nov 17 15:35 factor2.c-.f21
-rw-------. 1 corg7983 domain_users  431 Nov 17 15:35 factor2.c-.f22
-rw-------. 1 corg7983 domain_users  249 Nov 17 15:35 factor2.expected
-rw-------. 1 corg7983 domain_users   63 Nov 17 15:35 factor2.in
-rw-------. 1 corg7983 domain_users 4364 Nov 22 12:27 factor2.mem
-rw-------. 1 corg7983 domain_users  415 Nov 17 15:35 factor2.mem.diffs
-rw-------. 1 corg7983 domain_users 5204 Nov 17 15:35 factor2.mem.f21
-rw-------. 1 corg7983 domain_users  370 Nov 22 12:27 factor2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 factor2.tm
-rw-------. 1 corg7983 domain_users  279 Nov 17 15:35 factor2.tm.diffs
-rw-------. 1 corg7983 domain_users 8601 Nov 17 15:35 factor2.tm.f21
TM CODE COMPARISON
factor2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  factor2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* WHILE
												   >	 40:    LDC  3,1(6)	Load Boolean constant 
												   >	 41:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 43:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	 44:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 45:    LDA  3,1(7)	Return address in ac 
												   >	 46:    JMP  7,-46(7)	CALL input
												   >	 47:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	 48:     ST  3,-2(1)	Store variable n
												   >	* IF
												   >	 49:     LD  3,-2(1)	Load variable n
												   >	 50:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 51:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 52:     LD  4,-3(1)	Pop left into ac1 
												   >	 53:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* BREAK
												   >	 55:    JMP  7,-14(7)	break 
												   >	 54:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* WHILE
												   >	 56:     LD  3,-2(1)	Load variable n
												   >	 57:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 58:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 59:     LD  4,-3(1)	Pop left into ac1 
												   >	 60:    MOD  3,4,3	Op % 
												   >	 61:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 62:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 63:     LD  4,-3(1)	Pop left into ac1 
												   >	 64:    TEQ  3,4,3	Op = 
												   >	 65:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 67:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 68:    LDC  3,2(6)	Load integer constant 
												   >	 69:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 70:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 71:    LDA  3,1(7)	Return address in ac 
												   >	 72:    JMP  7,-67(7)	CALL output
												   >	 73:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	 74:    LDC  3,2(6)	Load integer constant 
												   >	 75:     LD  4,-2(1)	load lhs variable n
												   >	 76:    DIV  3,4,3	op /= 
												   >	 77:     ST  3,-2(1)	Store variable n
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 78:    JMP  7,-23(7)	go to beginning of loop 
												   >	 66:    JMP  7,12(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -6
												   >	* FOR
												   >	 79:    LDC  3,3(6)	Load integer constant 
												   >	 80:     ST  3,-3(1)	save starting value in index variable 
												   >	 81:     LD  3,-2(1)	Load variable n
												   >	 82:     ST  3,-4(1)	save stop value 
												   >	 83:    LDC  3,2(6)	Load integer constant 
												   >	 84:     ST  3,-5(1)	save step value 
												   >	 85:     LD  4,-3(1)	loop index 
												   >	 86:     LD  5,-4(1)	stop value 
												   >	 87:     LD  3,-5(1)	step value 
												   >	 88:    SLT  3,4,5	Op < 
												   >	 89:    JNZ  3,1(7)	Jump to loop body 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	 91:     LD  3,-3(1)	Load variable i
												   >	 92:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 93:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -6
												   >	 94:     LD  4,-6(1)	Pop left into ac1 
												   >	 95:    MUL  3,4,3	Op * 
												   >	 96:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 97:     LD  3,-2(1)	Load variable n
												   >	* TOFF inc: -6
												   >	 98:     LD  4,-6(1)	Pop left into ac1 
												   >	 99:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* BREAK
												   >	101:    JMP  7,-12(7)	break 
												   >	100:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* WHILE
												   >	102:     LD  3,-2(1)	Load variable n
												   >	103:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	104:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -6
												   >	105:     LD  4,-6(1)	Pop left into ac1 
												   >	106:    MOD  3,4,3	Op % 
												   >	107:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	108:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	109:     LD  4,-6(1)	Pop left into ac1 
												   >	110:    TEQ  3,4,3	Op = 
												   >	111:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	113:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	114:     LD  3,-3(1)	Load variable i
												   >	115:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	116:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	117:    LDA  3,1(7)	Return address in ac 
												   >	118:    JMP  7,-113(7)	CALL output
												   >	119:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	120:     LD  3,-3(1)	Load variable i
												   >	121:     LD  4,-2(1)	load lhs variable n
												   >	122:    DIV  3,4,3	op /= 
												   >	123:     ST  3,-2(1)	Store variable n
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	124:    JMP  7,-23(7)	go to beginning of loop 
												   >	112:    JMP  7,12(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	* Bottom of loop increment and jump
												   >	125:     LD  3,-3(1)	Load index 
												   >	126:     LD  5,-5(1)	Load step 
												   >	127:    ADD  3,3,5	increment 
												   >	128:     ST  3,-3(1)	store back to index 
												   >	129:    JMP  7,-45(7)	go to beginning of loop 
												   >	 90:    JMP  7,39(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* IF
												   >	130:     LD  3,-2(1)	Load variable n
												   >	131:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	132:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	133:     LD  4,-6(1)	Pop left into ac1 
												   >	134:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	136:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	137:     LD  3,-2(1)	Load variable n
												   >	138:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	139:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	140:    LDA  3,1(7)	Return address in ac 
												   >	141:    JMP  7,-136(7)	CALL output
												   >	142:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	135:    JZR  3,7(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	143:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	144:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	145:    LDA  3,1(7)	Return address in ac 
												   >	146:    JMP  7,-113(7)	CALL outnl
												   >	147:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	148:    JMP  7,-109(7)	go to beginning of loop 
												   >	 42:    JMP  7,106(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	149:    LDC  2,0(6)	Set return value to 0 
												   >	150:     LD  3,-1(1)	Load return address 
												   >	151:     LD  1,0(1)	Adjust fp 
												   >	152:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,152(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	153:    LDA  1,0(0)	set first frame at end of globals 
												   >	154:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-118(7)	Jump to main 
												   >	157:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
factor2.mem factor2.mem.f21 differ: byte 7, line 1
factor2 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Child: 1  While [line: 5]									.   .   Child: 1  While [line: 5]
.   .   .   Child: 0  Const true of type bool [line: 5]							.   .   .   Child: 0  Const true of type bool [line: 5]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 5]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 5]
.   .   .   .   Child: 1  Assign: = of type int [line: 6]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 6]			.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   .   .   Child: 1  Call: input of type int [line: 6]						.   .   .   .   .   Child: 1  Call: input of type int [line: 6]
.   .   .   .   Sibling: 1  If [line: 7]								.   .   .   .   Sibling: 1  If [line: 7]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 7]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 7]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 7]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 7]						.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 7]
.   .   .   .   .   Child: 1  Break [line: 7]								.   .   .   .   .   Child: 1  Break [line: 7]
.   .   .   .   Sibling: 2  While [line: 9]								.   .   .   .   Sibling: 2  While [line: 9]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 9]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 9]
.   .   .   .   .   .   Child: 0  Op: % of type int [line: 9]						.   .   .   .   .   .   Child: 0  Op: % of type int [line: 9]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 9]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 9]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 9]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 9]						.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 9]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 9]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 9]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 10]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 10]
.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 10]					.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 10]
.   .   .   .   .   .   Sibling: 1  Assign: /= of type int [line: 11]					.   .   .   .   .   .   Sibling: 1  Assign: /= of type int [line: 11]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 11]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]
.   .   .   .   Sibling: 3  For [mem: None loc: 0 size: -4] [line: 14]				   |	.   .   .   .   Sibling: 3  For [mem: None loc: 0 size: -6] [line: 14]
.   .   .   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 14]		.   .   .   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   .   .   Child: 1  Range [line: 14]								.   .   .   .   .   Child: 1  Range [line: 14]
.   .   .   .   .   .   Child: 0  Const 3 of type int [line: 14]					.   .   .   .   .   .   Child: 0  Const 3 of type int [line: 14]
.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -2 size: 1] [line: 14]		.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   .   .   .   .   Child: 2  Const 2 of type int [line: 14]					.   .   .   .   .   .   Child: 2  Const 2 of type int [line: 14]
.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -4] [line: 14]			   |	.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -6] [line: 14]
.   .   .   .   .   .   Child: 1  If [line: 15]								.   .   .   .   .   .   Child: 1  If [line: 15]
.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 15]					.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 15]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 15]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 15]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Break [line: 15]							.   .   .   .   .   .   .   Child: 1  Break [line: 15]
.   .   .   .   .   .   Sibling: 1  While [line: 16]							.   .   .   .   .   .   Sibling: 1  While [line: 16]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 16]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 16]
.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 16]					.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 16]
.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 16]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 16]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 16]		   |	.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 16]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 17]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 17]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 1  Assign: /= of type int [line: 18]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: /= of type int [line: 18]
.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   Sibling: 4  If [line: 21]								.   .   .   .   Sibling: 4  If [line: 21]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 21]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 21]
.   .   .   .   .   Child: 1  Call: output of type void [line: 21]					.   .   .   .   .   Child: 1  Call: output of type void [line: 21]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   .   .   Sibling: 5  Call: outnl of type void [line: 22]						.   .   .   .   Sibling: 5  Call: outnl of type void [line: 22]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
factor2.out ztmp23114.txt differ: byte 1, line 1
factor2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/factor2.tm
Number of errors: 0										   |	entered: 210
------------------------------------								   |	2 3 5 7
Loading file: factor2.tm									   |	entered: 666
ERROR: TM Command 2 unknown.									   |	2 3 3 37
ERROR: TM Command 6 unknown.									   |	entered: 4096
ERROR: TM Command 4 unknown.									   |	2 2 2 2 2 2 2 2 2 2 2 2
ERROR: TM Command 3 unknown.									   |	entered: 3331
ERROR: TM Command 3 unknown.									   |	3331
ERROR: TM Command 5 unknown.									   |	entered: 3333331
ERROR: TM Command 3 unknown.									   |	3333331
ERROR: TM Command 2 unknown.									   |	entered: 552390973
ERROR: TM Command 0 unknown.									   |	23497 23509
												   >	entered: 343
												   >	7 7 7
												   >	entered: 2401
												   >	7 7 7 7
												   >	entered: 0
Bye.													Bye.
====================================
FILE: factor.c-
-rw-------. 1 corg7983 domain_users   825 Nov 17 15:35 factor.c-
-rw-------. 1 corg7983 domain_users   834 Nov 17 15:35 factor.c-.f21
-rw-------. 1 corg7983 domain_users   825 Nov 17 15:35 factor.c-.f22
-rw-------. 1 corg7983 domain_users   330 Nov 17 15:35 factor.expected
-rw-------. 1 corg7983 domain_users    77 Nov 17 15:35 factor.in
-rw-------. 1 corg7983 domain_users  9248 Nov 22 12:27 factor.mem
-rw-------. 1 corg7983 domain_users  2091 Nov 17 15:35 factor.mem.diffs
-rw-------. 1 corg7983 domain_users 10098 Nov 17 15:35 factor.mem.f21
-rw-------. 1 corg7983 domain_users   514 Nov 22 12:27 factor.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 factor.tm
-rw-------. 1 corg7983 domain_users   344 Nov 17 15:35 factor.tm.diffs
-rw-------. 1 corg7983 domain_users 13143 Nov 17 15:35 factor.tm.f21
TM CODE COMPARISON
factor (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  factor.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION sqrt
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-2(1)	Load variable x
												   >	 41:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 42:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 43:     LD  4,-5(1)	Pop left into ac1 
												   >	 44:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 46:    LDC  3,1(6)	Load integer constant 
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 51:     LD  3,-2(1)	Load variable x
												   >	 52:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 53:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 54:     LD  4,-5(1)	Pop left into ac1 
												   >	 55:    DIV  3,4,3	Op / 
												   >	 56:     ST  3,-3(1)	Store variable guess
												   >	* EXPRESSION
												   >	 57:     LD  3,-2(1)	Load variable x
												   >	 58:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 59:     LD  3,-3(1)	Load variable guess
												   >	* TOFF inc: -5
												   >	 60:     LD  4,-5(1)	Pop left into ac1 
												   >	 61:    DIV  3,4,3	Op / 
												   >	 62:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 63:     LD  3,-3(1)	Load variable guess
												   >	* TOFF inc: -5
												   >	 64:     LD  4,-5(1)	Pop left into ac1 
												   >	 65:    ADD  3,4,3	Op + 
												   >	 66:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 67:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 68:     LD  4,-5(1)	Pop left into ac1 
												   >	 69:    DIV  3,4,3	Op / 
												   >	 70:     ST  3,-4(1)	Store variable newguess
												   >	* WHILE
												   >	 71:     LD  3,-3(1)	Load variable guess
												   >	 72:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 73:     LD  3,-4(1)	Load variable newguess
												   >	* TOFF inc: -5
												   >	 74:     LD  4,-5(1)	Pop left into ac1 
												   >	 75:    SUB  3,4,3	Op - 
												   >	 76:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 77:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 78:     LD  4,-5(1)	Pop left into ac1 
												   >	 79:    TGT  3,4,3	Op > 
												   >	 80:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 82:     LD  3,-4(1)	Load variable newguess
												   >	 83:     ST  3,-3(1)	Store variable guess
												   >	* EXPRESSION
												   >	 84:     LD  3,-2(1)	Load variable x
												   >	 85:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 86:     LD  3,-3(1)	Load variable guess
												   >	* TOFF inc: -5
												   >	 87:     LD  4,-5(1)	Pop left into ac1 
												   >	 88:    DIV  3,4,3	Op / 
												   >	 89:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 90:     LD  3,-3(1)	Load variable guess
												   >	* TOFF inc: -5
												   >	 91:     LD  4,-5(1)	Pop left into ac1 
												   >	 92:    ADD  3,4,3	Op + 
												   >	 93:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 94:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 95:     LD  4,-5(1)	Pop left into ac1 
												   >	 96:    DIV  3,4,3	Op / 
												   >	 97:     ST  3,-4(1)	Store variable newguess
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 98:    JMP  7,-28(7)	go to beginning of loop 
												   >	 81:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	 99:     LD  3,-4(1)	Load variable newguess
												   >	100:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	101:     LD  3,-4(1)	Load variable newguess
												   >	* TOFF inc: -5
												   >	102:     LD  4,-5(1)	Pop left into ac1 
												   >	103:    MUL  3,4,3	Op * 
												   >	104:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	105:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -5
												   >	106:     LD  4,-5(1)	Pop left into ac1 
												   >	107:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	109:     LD  3,-4(1)	Load variable newguess
												   >	110:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	111:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	112:     LD  4,-5(1)	Pop left into ac1 
												   >	113:    SUB  3,4,3	Op - 
												   >	114:     ST  3,-4(1)	Store variable newguess
												   >	108:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	115:     LD  3,-4(1)	Load variable newguess
												   >	116:    LDA  2,0(3)	Copy result to return register 
												   >	117:     LD  3,-1(1)	Load return address 
												   >	118:     LD  1,0(1)	Adjust fp 
												   >	119:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	120:    LDC  2,0(6)	Set return value to 0 
												   >	121:     LD  3,-1(1)	Load return address 
												   >	122:     LD  1,0(1)	Adjust fp 
												   >	123:    JMP  7,0(3)	Return 
												   >	* END FUNCTION sqrt
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	124:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* WHILE
												   >	* CALL input
												   >	125:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	126:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-128(7)	CALL input
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	130:     ST  3,-2(1)	Store variable n
												   >	131:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	132:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	133:     LD  4,-4(1)	Pop left into ac1 
												   >	134:    TGT  3,4,3	Op > 
												   >	135:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL sqrt
												   >	137:     ST  1,-5(1)	Store fp in ghost frame for sqrt
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	138:     LD  3,-2(1)	Load variable n
												   >	139:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end sqrt
												   >	140:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	141:    LDA  3,1(7)	Return address in ac 
												   >	142:    JMP  7,-104(7)	CALL sqrt
												   >	143:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqrt
												   >	* TOFF set: -5
												   >	144:     ST  3,-4(1)	Store variable limit
												   >	* WHILE
												   >	145:     LD  3,-2(1)	Load variable n
												   >	146:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	147:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	148:     LD  4,-5(1)	Pop left into ac1 
												   >	149:    MOD  3,4,3	Op % 
												   >	150:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	151:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	152:     LD  4,-5(1)	Pop left into ac1 
												   >	153:    TEQ  3,4,3	Op = 
												   >	154:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	156:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	157:    LDC  3,2(6)	Load integer constant 
												   >	158:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	159:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-156(7)	CALL output
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	163:     LD  3,-2(1)	Load variable n
												   >	164:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	165:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	166:     LD  4,-5(1)	Pop left into ac1 
												   >	167:    DIV  3,4,3	Op / 
												   >	168:     ST  3,-2(1)	Store variable n
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	169:    JMP  7,-25(7)	go to beginning of loop 
												   >	155:    JMP  7,14(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	170:    LDC  3,3(6)	Load integer constant 
												   >	171:     ST  3,-3(1)	Store variable i
												   >	* WHILE
												   >	172:     LD  3,-3(1)	Load variable i
												   >	173:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	174:     LD  3,-4(1)	Load variable limit
												   >	* TOFF inc: -5
												   >	175:     LD  4,-5(1)	Pop left into ac1 
												   >	176:    TLE  3,4,3	Op <= 
												   >	177:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* WHILE
												   >	179:     LD  3,-2(1)	Load variable n
												   >	180:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	181:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -5
												   >	182:     LD  4,-5(1)	Pop left into ac1 
												   >	183:    MOD  3,4,3	Op % 
												   >	184:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	185:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	186:     LD  4,-5(1)	Pop left into ac1 
												   >	187:    TEQ  3,4,3	Op = 
												   >	188:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	190:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	191:     LD  3,-3(1)	Load variable i
												   >	192:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	193:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	194:    LDA  3,1(7)	Return address in ac 
												   >	195:    JMP  7,-190(7)	CALL output
												   >	196:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	197:     LD  3,-2(1)	Load variable n
												   >	198:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	199:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -5
												   >	200:     LD  4,-5(1)	Pop left into ac1 
												   >	201:    DIV  3,4,3	Op / 
												   >	202:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL sqrt
												   >	203:     ST  1,-5(1)	Store fp in ghost frame for sqrt
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	204:     LD  3,-2(1)	Load variable n
												   >	205:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end sqrt
												   >	206:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	207:    LDA  3,1(7)	Return address in ac 
												   >	208:    JMP  7,-170(7)	CALL sqrt
												   >	209:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sqrt
												   >	* TOFF set: -5
												   >	210:     ST  3,-4(1)	Store variable limit
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	211:    JMP  7,-33(7)	go to beginning of loop 
												   >	189:    JMP  7,22(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	212:     LD  3,-3(1)	Load variable i
												   >	213:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	214:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	215:     LD  4,-5(1)	Pop left into ac1 
												   >	216:    ADD  3,4,3	Op + 
												   >	217:     ST  3,-3(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	218:    JMP  7,-47(7)	go to beginning of loop 
												   >	178:    JMP  7,40(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	219:     LD  3,-2(1)	Load variable n
												   >	220:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	221:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	222:     LD  4,-5(1)	Pop left into ac1 
												   >	223:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	225:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	226:     LD  3,-2(1)	Load variable n
												   >	227:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	228:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	229:    LDA  3,1(7)	Return address in ac 
												   >	230:    JMP  7,-225(7)	CALL output
												   >	231:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	224:    JZR  3,7(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	232:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	233:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	234:    LDA  3,1(7)	Return address in ac 
												   >	235:    JMP  7,-202(7)	CALL outnl
												   >	236:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	237:    JMP  7,-113(7)	go to beginning of loop 
												   >	136:    JMP  7,101(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	238:    LDC  2,0(6)	Set return value to 0 
												   >	239:     LD  3,-1(1)	Load return address 
												   >	240:     LD  1,0(1)	Adjust fp 
												   >	241:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,241(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	242:    LDA  1,0(0)	set first frame at end of globals 
												   >	243:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	244:    LDA  3,1(7)	Return address in ac 
												   >	245:    JMP  7,-122(7)	Jump to main 
												   >	246:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
factor.mem factor.mem.f21 differ: byte 7, line 1
factor (MEM DIFF)
Func: sqrt returns type int [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: sqrt returns type int [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]
.   .   Child: 0  Var: guess of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Child: 0  Var: guess of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Sibling: 1  Var: newguess of type int [mem: Local loc: -4 size: 1] [line: 4]			.   .   Sibling: 1  Var: newguess of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Child: 1  If [line: 6]										.   .   Child: 1  If [line: 6]
.   .   .   Child: 0  Op: == of type bool [line: 6]						   |	.   .   .   Child: 0  Op: = of type bool [line: 6]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 1 of type int [line: 6]							.   .   .   .   Child: 1  Const 1 of type int [line: 6]
.   .   .   Child: 1  Return [line: 6]									.   .   .   Child: 1  Return [line: 6]
.   .   .   .   Child: 0  Const 1 of type int [line: 6]							.   .   .   .   Child: 0  Const 1 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type int [line: 7]						   |	.   .   Sibling: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Child: 1  Op: / of type int [line: 7]							.   .   .   Child: 1  Op: / of type int [line: 7]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 2 of type int [line: 7]							.   .   .   .   Child: 1  Const 2 of type int [line: 7]
.   .   Sibling: 2  Assign: = of type int [line: 8]						   |	.   .   Sibling: 2  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 1  Op: / of type int [line: 8]							.   .   .   Child: 1  Op: / of type int [line: 8]
.   .   .   .   Child: 0  Op: + of type int [line: 8]							.   .   .   .   Child: 0  Op: + of type int [line: 8]
.   .   .   .   .   Child: 0  Op: / of type int [line: 8]						.   .   .   .   .   Child: 0  Op: / of type int [line: 8]
.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 8]		.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 8]		.   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 8]		.   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 2 of type int [line: 8]							.   .   .   .   Child: 1  Const 2 of type int [line: 8]
.   .   Sibling: 3  While [line: 9]									.   .   Sibling: 3  While [line: 9]
.   .   .   Child: 0  Op: > of type bool [line: 9]							.   .   .   Child: 0  Op: > of type bool [line: 9]
.   .   .   .   Child: 0  Op: - of type int [line: 9]							.   .   .   .   Child: 0  Op: - of type int [line: 9]
.   .   .   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 9]		.   .   .   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 9]		.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   .   .   Child: 1  Const 1 of type int [line: 9]							.   .   .   .   Child: 1  Const 1 of type int [line: 9]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 9]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 9]
.   .   .   .   Child: 1  Assign: = of type int [line: 10]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 10]		.   .   .   .   .   Child: 0  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 10]		.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 11]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 11]
.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 11]		.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Op: / of type int [line: 11]						.   .   .   .   .   Child: 1  Op: / of type int [line: 11]
.   .   .   .   .   .   Child: 0  Op: + of type int [line: 11]						.   .   .   .   .   .   Child: 0  Op: + of type int [line: 11]
.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 11]					.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 11]
.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 1  Id: guess of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]
.   .   Sibling: 4  If [line: 13]									.   .   Sibling: 4  If [line: 13]
.   .   .   Child: 0  Op: > of type bool [line: 13]							.   .   .   Child: 0  Op: > of type bool [line: 13]
.   .   .   .   Child: 0  Op: * of type int [line: 13]							.   .   .   .   Child: 0  Op: * of type int [line: 13]
.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   Child: 1  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 13]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   Child: 1  Op: - of type int [line: 13]							.   .   .   .   Child: 1  Op: - of type int [line: 13]
.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 13]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   Sibling: 5  Return [line: 15]									.   .   Sibling: 5  Return [line: 15]
.   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 15]			.   .   .   Child: 0  Id: newguess of type int [mem: Local loc: -4 size: 1] [line: 15]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 19]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 19]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 20]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 20]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 21]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   Sibling: 1  Var: i of type int [mem: Local loc: -3 size: 1] [line: 22]				.   .   Sibling: 1  Var: i of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   Child: 1  While [line: 24]									.   .   Child: 1  While [line: 24]
.   .   .   Child: 0  Op: > of type bool [line: 24]							.   .   .   Child: 0  Op: > of type bool [line: 24]
.   .   .   .   Child: 0  Assign: = of type int [line: 24]					   |	.   .   .   .   Child: 0  Assign: := of type int [line: 24]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 24]			.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 24]
.   .   .   .   .   Child: 1  Call: input of type int [line: 24]					.   .   .   .   .   Child: 1  Call: input of type int [line: 24]
.   .   .   .   Child: 1  Const 1 of type int [line: 24]						.   .   .   .   Child: 1  Const 1 of type int [line: 24]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 24]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 24]
.   .   .   .   Child: 0  Var: limit of type int [mem: Local loc: -4 size: 1] [line: 25]		.   .   .   .   Child: 0  Var: limit of type int [mem: Local loc: -4 size: 1] [line: 25]
.   .   .   .   Child: 1  Assign: = of type int [line: 26]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 26]
.   .   .   .   .   Child: 0  Id: limit of type int [mem: Local loc: -4 size: 1] [line: 26]		.   .   .   .   .   Child: 0  Id: limit of type int [mem: Local loc: -4 size: 1] [line: 26]
.   .   .   .   .   Child: 1  Call: sqrt of type int [line: 26]						.   .   .   .   .   Child: 1  Call: sqrt of type int [line: 26]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 26]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   .   .   Sibling: 1  While [line: 29]								.   .   .   .   Sibling: 1  While [line: 29]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 29]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 29]
.   .   .   .   .   .   Child: 0  Op: % of type int [line: 29]						.   .   .   .   .   .   Child: 0  Op: % of type int [line: 29]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 29]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 29]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 29]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 29]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 29]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 29]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 30]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 30]
.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 30]					.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 30]
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 31]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 31]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 31]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 31]
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 31]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 31]
.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 31]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 31]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 35]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 35]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 35]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 35]
.   .   .   .   .   Child: 1  Const 3 of type int [line: 35]						.   .   .   .   .   Child: 1  Const 3 of type int [line: 35]
.   .   .   .   Sibling: 3  While [line: 36]								.   .   .   .   Sibling: 3  While [line: 36]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 36]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 36]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 36]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 36]
.   .   .   .   .   .   Child: 1  Id: limit of type int [mem: Local loc: -4 size: 1] [line: 36]		.   .   .   .   .   .   Child: 1  Id: limit of type int [mem: Local loc: -4 size: 1] [line: 36]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 36]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 36]
.   .   .   .   .   .   Child: 1  While [line: 37]							.   .   .   .   .   .   Child: 1  While [line: 37]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 37]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 37]
.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 37]					.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 37]
.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 37]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 37]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 37]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 37]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 38]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 38]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 39]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 39]
.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 40]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 40]
.   .   .   .   .   .   .   .   .   Child: 0  Id: limit of type int [mem: Local loc: -4 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: limit of type int [mem: Local loc: -4 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Call: sqrt of type int [line: 40]				.   .   .   .   .   .   .   .   .   Child: 1  Call: sqrt of type int [line: 40]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 42]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 42]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 42]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 42]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 42]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 42]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 42]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 42]
.   .   .   .   Sibling: 4  If [line: 45]								.   .   .   .   Sibling: 4  If [line: 45]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 45]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 45]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 45]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 45]
.   .   .   .   .   Child: 1  Call: output of type void [line: 45]					.   .   .   .   .   Child: 1  Call: output of type void [line: 45]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]
.   .   .   .   Sibling: 5  Call: outnl of type void [line: 46]						.   .   .   .   Sibling: 5  Call: outnl of type void [line: 46]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
factor.out ztmp23114.txt differ: byte 1, line 1
factor (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/factor.tm
Number of errors: 0										   |	entered: 2
------------------------------------								   |	2
Loading file: factor.tm										   |	entered: 3
ERROR: TM Command 2 unknown.									   |	3
ERROR: TM Command 3 unknown.									   |	entered: 5
ERROR: TM Command 5 unknown.									   |	5
ERROR: TM Command 3 unknown.									   |	entered: 30
ERROR: TM Command 2 unknown.									   |	2 3 5
ERROR: TM Command 2 unknown.									   |	entered: 210
ERROR: TM Command 6 unknown.									   |	2 3 5 7
ERROR: TM Command 4 unknown.									   |	entered: 2310
ERROR: TM Command 3 unknown.									   |	2 3 5 7 11
ERROR: TM Command 3 unknown.									   |	entered: 666
ERROR: TM Command 5 unknown.									   |	2 3 3 37
ERROR: TM Command 3 unknown.									   |	entered: 4096
ERROR: TM Command 2 unknown.									   |	2 2 2 2 2 2 2 2 2 2 2 2
ERROR: TM Command 0 unknown.									   |	entered: 3331
												   >	3331
												   >	entered: 3333331
												   >	3333331
												   >	entered: 552390973
												   >	23497 23509
												   >	entered: 343
												   >	7 7 7
												   >	entered: 2401
												   >	7 7 7 7
												   >	entered: 0
Bye.													Bye.
====================================
FILE: factorial2.c-
-rw-------. 1 corg7983 domain_users  320 Nov 17 15:35 factorial2.c-
-rw-------. 1 corg7983 domain_users  325 Nov 17 15:35 factorial2.c-.f21
-rw-------. 1 corg7983 domain_users  320 Nov 17 15:35 factorial2.c-.f22
-rw-------. 1 corg7983 domain_users  106 Nov 17 15:35 factorial2.expected
-rw-------. 1 corg7983 domain_users   17 Nov 17 15:35 factorial2.in
-rw-------. 1 corg7983 domain_users 2835 Nov 22 12:27 factorial2.mem
-rw-------. 1 corg7983 domain_users  611 Nov 17 15:35 factorial2.mem.diffs
-rw-------. 1 corg7983 domain_users 3681 Nov 17 15:35 factorial2.mem.f21
-rw-------. 1 corg7983 domain_users  141 Nov 22 12:27 factorial2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 factorial2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 factorial2.tm.diffs
-rw-------. 1 corg7983 domain_users 6509 Nov 17 15:35 factorial2.tm.f21
TM CODE COMPARISON
factorial2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  factorial2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION factorial
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable i
												   >	 42:     ST  3,-4(1)	Store variable f
												   >	* WHILE
												   >	 43:     LD  3,-3(1)	Load variable i
												   >	 44:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 45:     LD  3,-2(1)	Load variable n
												   >	* TOFF inc: -5
												   >	 46:     LD  4,-5(1)	Pop left into ac1 
												   >	 47:    TLE  3,4,3	Op <= 
												   >	 48:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 50:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 51:     LD  3,-3(1)	Load variable i
												   >	 52:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 53:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 54:    LDA  3,1(7)	Return address in ac 
												   >	 55:    JMP  7,-50(7)	CALL output
												   >	 56:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 57:     LD  3,-4(1)	Load variable f
												   >	 58:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 59:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -5
												   >	 60:     LD  4,-5(1)	Pop left into ac1 
												   >	 61:    MUL  3,4,3	Op * 
												   >	 62:     ST  3,-4(1)	Store variable f
												   >	* EXPRESSION
												   >	 63:    LDC  3,1(6)	Load integer constant 
												   >	 64:     LD  4,-3(1)	load lhs variable i
												   >	 65:    ADD  3,4,3	op += 
												   >	 66:     ST  3,-3(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 67:    JMP  7,-25(7)	go to beginning of loop 
												   >	 49:    JMP  7,18(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 68:     LD  3,-4(1)	Load variable f
												   >	 69:    LDA  2,0(3)	Copy result to return register 
												   >	 70:     LD  3,-1(1)	Load return address 
												   >	 71:     LD  1,0(1)	Adjust fp 
												   >	 72:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 73:    LDC  2,0(6)	Set return value to 0 
												   >	 74:     LD  3,-1(1)	Load return address 
												   >	 75:     LD  1,0(1)	Adjust fp 
												   >	 76:    JMP  7,0(3)	Return 
												   >	* END FUNCTION factorial
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 77:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 78:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	 79:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 80:    LDA  3,1(7)	Return address in ac 
												   >	 81:    JMP  7,-81(7)	CALL input
												   >	 82:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	 83:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL factorial
												   >	 84:     ST  1,-3(1)	Store fp in ghost frame for factorial
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 85:     LD  3,-2(1)	Load variable n
												   >	 86:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end factorial
												   >	 87:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-51(7)	CALL factorial
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end factorial
												   >	* TOFF set: -3
												   >	 91:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL output
												   >	 92:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 93:     LD  3,-2(1)	Load variable n
												   >	 94:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 95:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 96:    LDA  3,1(7)	Return address in ac 
												   >	 97:    JMP  7,-92(7)	CALL output
												   >	 98:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 99:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	100:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-69(7)	CALL outnl
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	104:    LDC  2,0(6)	Set return value to 0 
												   >	105:     LD  3,-1(1)	Load return address 
												   >	106:     LD  1,0(1)	Adjust fp 
												   >	107:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,107(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	108:    LDA  1,0(0)	set first frame at end of globals 
												   >	109:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-35(7)	Jump to main 
												   >	112:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
factorial2.mem factorial2.mem.f21 differ: byte 7, line 1
factorial2 (MEM DIFF)
Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]
.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Sibling: 1  Var: f of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Sibling: 1  Var: f of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 1 of type int [line: 6]							.   .   .   .   Child: 1  Const 1 of type int [line: 6]
.   .   Sibling: 1  While [line: 7]									.   .   Sibling: 1  While [line: 7]
.   .   .   Child: 0  Op: <= of type bool [line: 7]							.   .   .   Child: 0  Op: <= of type bool [line: 7]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 7]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 7]
.   .   .   .   Child: 1  Call: output of type void [line: 8]						.   .   .   .   Child: 1  Call: output of type void [line: 8]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 9]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 9]
.   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Op: * of type int [line: 9]						.   .   .   .   .   Child: 1  Op: * of type int [line: 9]
.   .   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 9]		.   .   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   Sibling: 2  Assign: += of type int [line: 10]						.   .   .   .   Sibling: 2  Assign: += of type int [line: 10]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 10]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 10]
.   .   Sibling: 2  Return [line: 13]									.   .   Sibling: 2  Return [line: 13]
.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 13]				.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 13]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 16]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 16]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 17]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 17]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Child: 1  Assign: = of type int [line: 19]						   |	.   .   Child: 1  Assign: := of type int [line: 19]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   .   Child: 1  Call: input of type int [line: 19]						.   .   .   Child: 1  Call: input of type int [line: 19]
.   .   Sibling: 1  Assign: = of type int [line: 20]						   |	.   .   Sibling: 1  Assign: := of type int [line: 20]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 20]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 20]
.   .   .   Child: 1  Call: factorial of type int [line: 20]						.   .   .   Child: 1  Call: factorial of type int [line: 20]
.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 20]			.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 20]
.   .   Sibling: 2  Call: output of type void [line: 21]						.   .   Sibling: 2  Call: output of type void [line: 21]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   Sibling: 3  Call: outnl of type void [line: 22]							.   .   Sibling: 3  Call: outnl of type void [line: 22]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
factorial2.out ztmp23114.txt differ: byte 1, line 1
factorial2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/factorial2.tm
Number of errors: 0										   |	entered: 15
------------------------------------								   |	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1307674368000
Loading file: factorial2.tm									   <
ERROR: TM Command 1 unknown.									   <
Bye.													Bye.
====================================
FILE: factorial.c-
-rw-------. 1 corg7983 domain_users  317 Nov 17 15:35 factorial.c-
-rw-------. 1 corg7983 domain_users  322 Nov 17 15:35 factorial.c-.f21
-rw-------. 1 corg7983 domain_users  317 Nov 17 15:35 factorial.c-.f22
-rw-------. 1 corg7983 domain_users  105 Nov 17 15:35 factorial.expected
-rw-------. 1 corg7983 domain_users   17 Nov 17 15:35 factorial.in
-rw-------. 1 corg7983 domain_users 2772 Nov 22 12:27 factorial.mem
-rw-------. 1 corg7983 domain_users  611 Nov 17 15:35 factorial.mem.diffs
-rw-------. 1 corg7983 domain_users 3618 Nov 17 15:35 factorial.mem.f21
-rw-------. 1 corg7983 domain_users  140 Nov 22 12:27 factorial.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 factorial.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 factorial.tm.diffs
-rw-------. 1 corg7983 domain_users 6480 Nov 17 15:35 factorial.tm.f21
TM CODE COMPARISON
factorial (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  factorial.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION factorial
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable i
												   >	 42:     ST  3,-4(1)	Store variable f
												   >	* WHILE
												   >	 43:     LD  3,-3(1)	Load variable i
												   >	 44:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 45:     LD  3,-2(1)	Load variable n
												   >	* TOFF inc: -5
												   >	 46:     LD  4,-5(1)	Pop left into ac1 
												   >	 47:    TLE  3,4,3	Op <= 
												   >	 48:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 50:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 51:     LD  3,-3(1)	Load variable i
												   >	 52:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 53:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 54:    LDA  3,1(7)	Return address in ac 
												   >	 55:    JMP  7,-50(7)	CALL output
												   >	 56:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 57:     LD  3,-4(1)	Load variable f
												   >	 58:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 59:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -5
												   >	 60:     LD  4,-5(1)	Pop left into ac1 
												   >	 61:    MUL  3,4,3	Op * 
												   >	 62:     ST  3,-4(1)	Store variable f
												   >	* EXPRESSION
												   >	 63:     LD  3,-3(1)	load lhs variable i
												   >	 64:    LDA  3,1(3)	increment value of i
												   >	 65:     ST  3,-3(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 66:    JMP  7,-24(7)	go to beginning of loop 
												   >	 49:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 67:     LD  3,-4(1)	Load variable f
												   >	 68:    LDA  2,0(3)	Copy result to return register 
												   >	 69:     LD  3,-1(1)	Load return address 
												   >	 70:     LD  1,0(1)	Adjust fp 
												   >	 71:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 72:    LDC  2,0(6)	Set return value to 0 
												   >	 73:     LD  3,-1(1)	Load return address 
												   >	 74:     LD  1,0(1)	Adjust fp 
												   >	 75:    JMP  7,0(3)	Return 
												   >	* END FUNCTION factorial
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 76:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 77:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	 78:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-80(7)	CALL input
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	 82:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL factorial
												   >	 83:     ST  1,-3(1)	Store fp in ghost frame for factorial
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 84:     LD  3,-2(1)	Load variable n
												   >	 85:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end factorial
												   >	 86:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-50(7)	CALL factorial
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end factorial
												   >	* TOFF set: -3
												   >	 90:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL output
												   >	 91:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 92:     LD  3,-2(1)	Load variable n
												   >	 93:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 94:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-91(7)	CALL output
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 98:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 99:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-68(7)	CALL outnl
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	103:    LDC  2,0(6)	Set return value to 0 
												   >	104:     LD  3,-1(1)	Load return address 
												   >	105:     LD  1,0(1)	Adjust fp 
												   >	106:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,106(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	107:    LDA  1,0(0)	set first frame at end of globals 
												   >	108:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	109:    LDA  3,1(7)	Return address in ac 
												   >	110:    JMP  7,-35(7)	Jump to main 
												   >	111:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
factorial.mem factorial.mem.f21 differ: byte 7, line 1
factorial (MEM DIFF)
Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]
.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Sibling: 1  Var: f of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Sibling: 1  Var: f of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 5]				.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 5]
.   .   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 5]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   .   .   Child: 1  Const 1 of type int [line: 5]							.   .   .   .   Child: 1  Const 1 of type int [line: 5]
.   .   Sibling: 1  While [line: 6]									.   .   Sibling: 1  While [line: 6]
.   .   .   Child: 0  Op: <= of type bool [line: 6]							.   .   .   Child: 0  Op: <= of type bool [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 6]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 6]
.   .   .   .   Child: 1  Call: output of type void [line: 7]						.   .   .   .   Child: 1  Call: output of type void [line: 7]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 8]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   .   .   Child: 1  Op: * of type int [line: 8]						.   .   .   .   .   Child: 1  Op: * of type int [line: 8]
.   .   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 8]		.   .   .   .   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 9]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 9]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 2  Return [line: 11]									.   .   Sibling: 2  Return [line: 11]
.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 11]				.   .   .   Child: 0  Id: f of type int [mem: Local loc: -4 size: 1] [line: 11]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 15]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 15]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 17]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 17]
.   .   .   Child: 1  Call: input of type int [line: 17]						.   .   .   Child: 1  Call: input of type int [line: 17]
.   .   Sibling: 1  Assign: = of type int [line: 18]						   |	.   .   Sibling: 1  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   Child: 1  Call: factorial of type int [line: 18]						.   .   .   Child: 1  Call: factorial of type int [line: 18]
.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 2  Call: output of type void [line: 19]						.   .   Sibling: 2  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   Sibling: 3  Call: outnl of type void [line: 20]							.   .   Sibling: 3  Call: outnl of type void [line: 20]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
factorial.out ztmp23114.txt differ: byte 1, line 1
factorial (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/factorial.tm
Number of errors: 0										   |	entered: 15
------------------------------------								   |	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1307674368000
Loading file: factorial.tm									   <
ERROR: TM Command 1 unknown.									   <
Bye.													Bye.
====================================
FILE: factorialr.c-
-rw-------. 1 corg7983 domain_users  245 Nov 17 15:35 factorialr.c-
-rw-------. 1 corg7983 domain_users  247 Nov 17 15:35 factorialr.c-.f21
-rw-------. 1 corg7983 domain_users  245 Nov 17 15:35 factorialr.c-.f22
-rw-------. 1 corg7983 domain_users   70 Nov 17 15:35 factorialr.expected
-rw-------. 1 corg7983 domain_users   17 Nov 17 15:35 factorialr.in
-rw-------. 1 corg7983 domain_users 1966 Nov 22 12:27 factorialr.mem
-rw-------. 1 corg7983 domain_users  238 Nov 17 15:35 factorialr.mem.diffs
-rw-------. 1 corg7983 domain_users 2809 Nov 17 15:35 factorialr.mem.f21
-rw-------. 1 corg7983 domain_users  141 Nov 22 12:27 factorialr.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 factorialr.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 factorialr.tm.diffs
-rw-------. 1 corg7983 domain_users 6391 Nov 17 15:35 factorialr.tm.f21
TM CODE COMPARISON
factorialr (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  factorialr.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION factorial
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-2(1)	Load variable n
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* RETURN
												   >	 46:    LDC  3,1(6)	Load integer constant 
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	 52:     LD  3,-2(1)	Load variable n
												   >	 53:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	* CALL factorial
												   >	 54:     ST  1,-4(1)	Store fp in ghost frame for factorial
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 55:     LD  3,-2(1)	Load variable n
												   >	 56:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 57:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 58:     LD  4,-6(1)	Pop left into ac1 
												   >	 59:    SUB  3,4,3	Op - 
												   >	 60:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end factorial
												   >	 61:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 62:    LDA  3,1(7)	Return address in ac 
												   >	 63:    JMP  7,-25(7)	CALL factorial
												   >	 64:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end factorial
												   >	* TOFF set: -4
												   >	* TOFF inc: -3
												   >	 65:     LD  4,-3(1)	Pop left into ac1 
												   >	 66:    MUL  3,4,3	Op * 
												   >	 67:    LDA  2,0(3)	Copy result to return register 
												   >	 68:     LD  3,-1(1)	Load return address 
												   >	 69:     LD  1,0(1)	Adjust fp 
												   >	 70:    JMP  7,0(3)	Return 
												   >	 51:    JMP  7,19(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 71:    LDC  2,0(6)	Set return value to 0 
												   >	 72:     LD  3,-1(1)	Load return address 
												   >	 73:     LD  1,0(1)	Adjust fp 
												   >	 74:    JMP  7,0(3)	Return 
												   >	* END FUNCTION factorial
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 75:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 76:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	 77:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-79(7)	CALL input
												   >	 80:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	 81:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL factorial
												   >	 82:     ST  1,-3(1)	Store fp in ghost frame for factorial
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 83:     LD  3,-2(1)	Load variable n
												   >	 84:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end factorial
												   >	 85:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-49(7)	CALL factorial
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end factorial
												   >	* TOFF set: -3
												   >	 89:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL output
												   >	 90:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 91:     LD  3,-2(1)	Load variable n
												   >	 92:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 93:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 94:    LDA  3,1(7)	Return address in ac 
												   >	 95:    JMP  7,-90(7)	CALL output
												   >	 96:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 97:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 98:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-67(7)	CALL outnl
												   >	101:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	102:    LDC  2,0(6)	Set return value to 0 
												   >	103:     LD  3,-1(1)	Load return address 
												   >	104:     LD  1,0(1)	Adjust fp 
												   >	105:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,105(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	106:    LDA  1,0(0)	set first frame at end of globals 
												   >	107:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-35(7)	Jump to main 
												   >	110:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
factorialr.mem factorialr.mem.f21 differ: byte 7, line 1
factorialr (MEM DIFF)
Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: factorial returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]
.   .   Child: 1  If [line: 4]										.   .   Child: 1  If [line: 4]
.   .   .   Child: 0  Op: < of type bool [line: 4]							.   .   .   Child: 0  Op: < of type bool [line: 4]
.   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   .   .   Child: 1  Const 2 of type int [line: 4]							.   .   .   .   Child: 1  Const 2 of type int [line: 4]
.   .   .   Child: 1  Return [line: 4]									.   .   .   Child: 1  Return [line: 4]
.   .   .   .   Child: 0  Const 1 of type int [line: 4]							.   .   .   .   Child: 0  Const 1 of type int [line: 4]
.   .   .   Child: 2  Return [line: 5]									.   .   .   Child: 2  Return [line: 5]
.   .   .   .   Child: 0  Op: * of type int [line: 5]							.   .   .   .   Child: 0  Op: * of type int [line: 5]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   .   .   Child: 1  Call: factorial of type int [line: 5]					.   .   .   .   .   Child: 1  Call: factorial of type int [line: 5]
.   .   .   .   .   .   Child: 0  Op: - of type int [line: 5]						.   .   .   .   .   .   Child: 0  Op: - of type int [line: 5]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 5]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 5]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 8]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 8]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 9]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 9]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   Child: 1  Assign: = of type int [line: 11]						   |	.   .   Child: 1  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 11]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   Child: 1  Call: input of type int [line: 11]						.   .   .   Child: 1  Call: input of type int [line: 11]
.   .   Sibling: 1  Assign: = of type int [line: 12]						   |	.   .   Sibling: 1  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 12]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   Child: 1  Call: factorial of type int [line: 12]						.   .   .   Child: 1  Call: factorial of type int [line: 12]
.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   Sibling: 2  Call: output of type void [line: 13]						.   .   Sibling: 2  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   Sibling: 3  Call: outnl of type void [line: 14]							.   .   Sibling: 3  Call: outnl of type void [line: 14]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
factorialr.out ztmp23114.txt differ: byte 1, line 1
factorialr (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/factorialr.tm
Number of errors: 0										   |	entered: 15
------------------------------------								   |	1307674368000
Loading file: factorialr.tm									   <
ERROR: TM Command 1 unknown.									   <
Bye.													Bye.
====================================
FILE: fib.c-
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 fib.c-
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 fib.c-.f21
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 fib.c-.f22
-rw-------. 1 corg7983 domain_users   80 Nov 17 15:35 fib.expected
-rw-------. 1 corg7983 domain_users   16 Nov 17 15:35 fib.in
-rw-------. 1 corg7983 domain_users 1841 Nov 22 12:27 fib.mem
-rw-------. 1 corg7983 domain_users    0 Nov 17 15:35 fib.mem.diffs
-rw-------. 1 corg7983 domain_users 2682 Nov 17 15:35 fib.mem.f21
-rw-------. 1 corg7983 domain_users  134 Nov 22 12:27 fib.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 fib.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 fib.tm.diffs
-rw-------. 1 corg7983 domain_users 7470 Nov 17 15:35 fib.tm.f21
TM CODE COMPARISON
fib (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  fib.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION fib
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load variable n
												   >	 42:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 43:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 47:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 48:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 49:    LDA  3,1(7)	Return address in ac 
												   >	 50:    JMP  7,-17(7)	CALL outnl
												   >	 51:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* IF
												   >	 52:     LD  3,-2(1)	Load variable n
												   >	 53:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 54:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 55:     LD  4,-3(1)	Pop left into ac1 
												   >	 56:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* RETURN
												   >	 58:    LDC  3,1(6)	Load integer constant 
												   >	 59:    LDA  2,0(3)	Copy result to return register 
												   >	 60:     LD  3,-1(1)	Load return address 
												   >	 61:     LD  1,0(1)	Adjust fp 
												   >	 62:    JMP  7,0(3)	Return 
												   >	 57:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	* CALL fib
												   >	 64:     ST  1,-3(1)	Store fp in ghost frame for fib
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 65:     LD  3,-2(1)	Load variable n
												   >	 66:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 67:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 68:     LD  4,-5(1)	Pop left into ac1 
												   >	 69:    SUB  3,4,3	Op - 
												   >	 70:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end fib
												   >	 71:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 72:    LDA  3,1(7)	Return address in ac 
												   >	 73:    JMP  7,-35(7)	CALL fib
												   >	 74:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fib
												   >	* TOFF set: -3
												   >	 75:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	* CALL fib
												   >	 76:     ST  1,-4(1)	Store fp in ghost frame for fib
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 77:     LD  3,-2(1)	Load variable n
												   >	 78:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 79:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 80:     LD  4,-6(1)	Pop left into ac1 
												   >	 81:    SUB  3,4,3	Op - 
												   >	 82:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end fib
												   >	 83:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-47(7)	CALL fib
												   >	 86:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fib
												   >	* TOFF set: -4
												   >	* TOFF inc: -3
												   >	 87:     LD  4,-3(1)	Pop left into ac1 
												   >	 88:    ADD  3,4,3	Op + 
												   >	 89:    LDA  2,0(3)	Copy result to return register 
												   >	 90:     LD  3,-1(1)	Load return address 
												   >	 91:     LD  1,0(1)	Adjust fp 
												   >	 92:    JMP  7,0(3)	Return 
												   >	 63:    JMP  7,29(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 93:    LDC  2,0(6)	Set return value to 0 
												   >	 94:     LD  3,-1(1)	Load return address 
												   >	 95:     LD  1,0(1)	Adjust fp 
												   >	 96:    JMP  7,0(3)	Return 
												   >	* END FUNCTION fib
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 97:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 98:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL fib
												   >	 99:     ST  1,-4(1)	Store fp in ghost frame for fib
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	* CALL input
												   >	100:     ST  1,-6(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end input
												   >	101:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	102:    LDA  3,1(7)	Return address in ac 
												   >	103:    JMP  7,-103(7)	CALL input
												   >	104:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -6
												   >	105:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end fib
												   >	106:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-70(7)	CALL fib
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fib
												   >	* TOFF set: -4
												   >	110:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	111:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	112:    LDA  3,1(7)	Return address in ac 
												   >	113:    JMP  7,-108(7)	CALL output
												   >	114:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	115:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	116:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	117:    LDA  3,1(7)	Return address in ac 
												   >	118:    JMP  7,-85(7)	CALL outnl
												   >	119:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	120:    LDC  2,0(6)	Set return value to 0 
												   >	121:     LD  3,-1(1)	Load return address 
												   >	122:     LD  1,0(1)	Adjust fp 
												   >	123:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,123(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	124:    LDA  1,0(0)	set first frame at end of globals 
												   >	125:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-31(7)	Jump to main 
												   >	128:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
fib.mem fib.mem.f21 differ: byte 7, line 1
fib (MEM DIFF)
Func: fib returns type int [mem: Global loc: 0 size: -3] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: fib returns type int [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]
.   .   Child: 1  Call: output of type void [line: 5]							.   .   Child: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 5]			.   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Call: outnl of type void [line: 6]							.   .   Sibling: 1  Call: outnl of type void [line: 6]
.   .   Sibling: 2  If [line: 7]									.   .   Sibling: 2  If [line: 7]
.   .   .   Child: 0  Op: < of type bool [line: 7]							.   .   .   Child: 0  Op: < of type bool [line: 7]
.   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 3 of type int [line: 7]							.   .   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   .   Child: 1  Return [line: 7]									.   .   .   Child: 1  Return [line: 7]
.   .   .   .   Child: 0  Const 1 of type int [line: 7]							.   .   .   .   Child: 0  Const 1 of type int [line: 7]
.   .   .   Child: 2  Return [line: 8]									.   .   .   Child: 2  Return [line: 8]
.   .   .   .   Child: 0  Op: + of type int [line: 8]							.   .   .   .   Child: 0  Op: + of type int [line: 8]
.   .   .   .   .   Child: 0  Call: fib of type int [line: 8]						.   .   .   .   .   Child: 0  Call: fib of type int [line: 8]
.   .   .   .   .   .   Child: 0  Op: - of type int [line: 8]						.   .   .   .   .   .   Child: 0  Op: - of type int [line: 8]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 8]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 8]
.   .   .   .   .   Child: 1  Call: fib of type int [line: 8]						.   .   .   .   .   Child: 1  Call: fib of type int [line: 8]
.   .   .   .   .   .   Child: 0  Op: - of type int [line: 8]						.   .   .   .   .   .   Child: 0  Op: - of type int [line: 8]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 8]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 8]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 12]
.   .   Child: 1  Call: output of type void [line: 13]							.   .   Child: 1  Call: output of type void [line: 13]
.   .   .   Child: 0  Call: fib of type int [line: 13]							.   .   .   Child: 0  Call: fib of type int [line: 13]
.   .   .   .   Child: 0  Call: input of type int [line: 13]						.   .   .   .   Child: 0  Call: input of type int [line: 13]
.   .   Sibling: 1  Call: outnl of type void [line: 14]							.   .   Sibling: 1  Call: outnl of type void [line: 14]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
fib.out ztmp23114.txt differ: byte 1, line 1
fib (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/fib.tm
Number of errors: 0										   |	entered: 6
------------------------------------								   |	6
Loading file: fib.tm										   |	5
ERROR: TM Command 6 unknown.									   |	4
												   >	3
												   >	2
												   >	1
												   >	2
												   >	3
												   >	2
												   >	1
												   >	4
												   >	3
												   >	2
												   >	1
												   >	2
												   >	8
Bye.													Bye.
====================================
FILE: fractal.c-
-rw-------. 1 corg7983 domain_users  3509 Nov 17 15:35 fractal.c-
-rw-------. 1 corg7983 domain_users  3557 Nov 17 15:35 fractal.c-.f21
-rw-------. 1 corg7983 domain_users  3509 Nov 17 15:35 fractal.c-.f22
-rw-------. 1 corg7983 domain_users  6004 Nov 17 15:35 fractal.expected
-rw-------. 1 corg7983 domain_users    26 Nov 17 15:35 fractal.in
-rw-------. 1 corg7983 domain_users 32388 Nov 22 12:27 fractal.mem
-rw-------. 1 corg7983 domain_users  8016 Nov 17 15:35 fractal.mem.diffs
-rw-------. 1 corg7983 domain_users 33288 Nov 17 15:35 fractal.mem.f21
-rw-------. 1 corg7983 domain_users   294 Nov 22 12:27 fractal.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 fractal.tm
-rw-------. 1 corg7983 domain_users   279 Nov 17 15:35 fractal.tm.diffs
-rw-------. 1 corg7983 domain_users 30627 Nov 17 15:35 fractal.tm.f21
TM CODE COMPARISON
fractal (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  fractal.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION Mandelbrot
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* WHILE
												   >	 40:     LD  3,0(0)	Load variable TOP
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:     LD  3,-7(0)	Load variable YMax
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    TLT  3,4,3	Op < 
												   >	 45:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 47:    LDC  3,512(6)	Load integer constant 
												   >	 48:    NEG  3,3,3	Op unary - 
												   >	 49:     ST  3,-1(0)	Store variable LEFT
												   >	* WHILE
												   >	 50:     LD  3,-1(0)	Load variable LEFT
												   >	 51:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 52:     LD  3,-6(0)	Load variable XMax
												   >	* TOFF inc: -3
												   >	 53:     LD  4,-3(1)	Pop left into ac1 
												   >	 54:    TLT  3,4,3	Op < 
												   >	 55:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 57:     LD  3,-1(0)	Load variable LEFT
												   >	 58:     ST  3,-5(1)	Store variable A
												   >	* EXPRESSION
												   >	 59:     LD  3,0(0)	Load variable TOP
												   >	 60:     ST  3,-4(1)	Store variable Bi
												   >	* EXPRESSION
												   >	 61:     LD  3,-5(1)	Load variable A
												   >	 62:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 63:     LD  3,-5(1)	Load variable A
												   >	* TOFF inc: -8
												   >	 64:     LD  4,-8(1)	Pop left into ac1 
												   >	 65:    MUL  3,4,3	Op * 
												   >	 66:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 67:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 68:     LD  4,-8(1)	Pop left into ac1 
												   >	 69:    DIV  3,4,3	Op / 
												   >	 70:     ST  3,-6(1)	Store variable NextA
												   >	* EXPRESSION
												   >	 71:     LD  3,-4(1)	Load variable Bi
												   >	 72:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 73:     LD  3,-4(1)	Load variable Bi
												   >	* TOFF inc: -8
												   >	 74:     LD  4,-8(1)	Pop left into ac1 
												   >	 75:    MUL  3,4,3	Op * 
												   >	 76:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 77:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 78:     LD  4,-8(1)	Pop left into ac1 
												   >	 79:    DIV  3,4,3	Op / 
												   >	 80:     ST  3,-7(1)	Store variable NextBi
												   >	* EXPRESSION
												   >	 81:     LD  3,-6(1)	Load variable NextA
												   >	 82:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 83:     LD  3,-7(1)	Load variable NextBi
												   >	* TOFF inc: -8
												   >	 84:     LD  4,-8(1)	Pop left into ac1 
												   >	 85:    ADD  3,4,3	Op + 
												   >	 86:     ST  3,-3(1)	Store variable Len
												   >	* EXPRESSION
												   >	 87:    LDC  3,0(6)	Load integer constant 
												   >	 88:     ST  3,-8(0)	Store variable iter
												   >	* WHILE
												   >	 89:     LD  3,-3(1)	Load variable Len
												   >	 90:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 91:    LDC  3,1024(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 92:     LD  4,-8(1)	Pop left into ac1 
												   >	 93:    TLE  3,4,3	Op <= 
												   >	 94:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 95:     LD  3,-8(0)	Load variable iter
												   >	 96:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 97:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	 98:     LD  4,-9(1)	Pop left into ac1 
												   >	 99:    TLT  3,4,3	Op < 
												   >	* TOFF inc: -8
												   >	100:     LD  4,-8(1)	Pop left into ac1 
												   >	101:    AND  3,4,3	Op AND 
												   >	102:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	104:    LDC  3,2(6)	Load integer constant 
												   >	105:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	106:     LD  3,-5(1)	Load variable A
												   >	107:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	108:     LD  3,-4(1)	Load variable Bi
												   >	* TOFF inc: -9
												   >	109:     LD  4,-9(1)	Pop left into ac1 
												   >	110:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	111:     LD  4,-8(1)	Pop left into ac1 
												   >	112:    MUL  3,4,3	Op * 
												   >	113:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	114:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	115:     LD  4,-8(1)	Pop left into ac1 
												   >	116:    DIV  3,4,3	Op / 
												   >	117:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	118:     LD  3,0(0)	Load variable TOP
												   >	* TOFF inc: -8
												   >	119:     LD  4,-8(1)	Pop left into ac1 
												   >	120:    ADD  3,4,3	Op + 
												   >	121:     ST  3,-4(1)	Store variable Bi
												   >	* EXPRESSION
												   >	122:     LD  3,-6(1)	Load variable NextA
												   >	123:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	124:     LD  3,-7(1)	Load variable NextBi
												   >	* TOFF inc: -8
												   >	125:     LD  4,-8(1)	Pop left into ac1 
												   >	126:    SUB  3,4,3	Op - 
												   >	127:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	128:     LD  3,-1(0)	Load variable LEFT
												   >	* TOFF inc: -8
												   >	129:     LD  4,-8(1)	Pop left into ac1 
												   >	130:    ADD  3,4,3	Op + 
												   >	131:     ST  3,-5(1)	Store variable A
												   >	* EXPRESSION
												   >	132:     LD  3,-5(1)	Load variable A
												   >	133:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	134:     LD  3,-5(1)	Load variable A
												   >	* TOFF inc: -8
												   >	135:     LD  4,-8(1)	Pop left into ac1 
												   >	136:    MUL  3,4,3	Op * 
												   >	137:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	138:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	139:     LD  4,-8(1)	Pop left into ac1 
												   >	140:    DIV  3,4,3	Op / 
												   >	141:     ST  3,-6(1)	Store variable NextA
												   >	* EXPRESSION
												   >	142:     LD  3,-4(1)	Load variable Bi
												   >	143:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	144:     LD  3,-4(1)	Load variable Bi
												   >	* TOFF inc: -8
												   >	145:     LD  4,-8(1)	Pop left into ac1 
												   >	146:    MUL  3,4,3	Op * 
												   >	147:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	148:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	149:     LD  4,-8(1)	Pop left into ac1 
												   >	150:    DIV  3,4,3	Op / 
												   >	151:     ST  3,-7(1)	Store variable NextBi
												   >	* EXPRESSION
												   >	152:     LD  3,-6(1)	Load variable NextA
												   >	153:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	154:     LD  3,-7(1)	Load variable NextBi
												   >	* TOFF inc: -8
												   >	155:     LD  4,-8(1)	Pop left into ac1 
												   >	156:    ADD  3,4,3	Op + 
												   >	157:     ST  3,-3(1)	Store variable Len
												   >	* EXPRESSION
												   >	158:     LD  3,-8(0)	load lhs variable iter
												   >	159:    LDA  3,1(3)	increment value of iter
												   >	160:     ST  3,-8(0)	Store variable iter
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	161:    JMP  7,-73(7)	go to beginning of loop 
												   >	103:    JMP  7,58(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	162:     LD  3,-8(0)	Load variable iter
												   >	163:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	164:    LDC  3,12(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	165:     LD  4,-8(1)	Pop left into ac1 
												   >	166:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	168:     ST  1,-8(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	169:    LDA  3,-10(0)	Load address of base of array grayScale
												   >	170:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	171:     LD  3,-8(0)	Load variable iter
												   >	* TOFF inc: -10
												   >	172:     LD  4,-10(1)	Pop left into ac1 
												   >	173:    SUB  3,4,3	compute location from index 
												   >	174:     LD  3,0(3)	Load array element 
												   >	175:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end outputc
												   >	176:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	177:    LDA  3,1(7)	Return address in ac 
												   >	178:    JMP  7,-151(7)	CALL outputc
												   >	179:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	180:     ST  1,-8(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	181:    LDC  3,32(6)	Load char constant 
												   >	182:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end outputc
												   >	183:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	184:    LDA  3,1(7)	Return address in ac 
												   >	185:    JMP  7,-158(7)	CALL outputc
												   >	186:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -8
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	167:    JZR  3,19(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	187:     LD  3,-8(0)	Load variable iter
												   >	188:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	189:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	190:     LD  4,-8(1)	Pop left into ac1 
												   >	191:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	193:    LDC  3,0(6)	Load integer constant 
												   >	194:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	195:     LD  3,-1(0)	Load variable LEFT
												   >	* TOFF inc: -8
												   >	196:     LD  4,-8(1)	Pop index 
												   >	197:     LD  5,-2(1)	Load address of base of array JuliaVals
												   >	198:    SUB  5,5,4	Compute offset of value 
												   >	199:     ST  3,0(5)	Store variable JuliaVals
												   >	* EXPRESSION
												   >	200:    LDC  3,1(6)	Load integer constant 
												   >	201:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	202:     LD  3,0(0)	Load variable TOP
												   >	* TOFF inc: -8
												   >	203:     LD  4,-8(1)	Pop index 
												   >	204:     LD  5,-2(1)	Load address of base of array JuliaVals
												   >	205:    SUB  5,5,4	Compute offset of value 
												   >	206:     ST  3,0(5)	Store variable JuliaVals
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	192:    JZR  3,14(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	207:     LD  3,-4(0)	Load variable XStep
												   >	208:     LD  4,-1(0)	load lhs variable LEFT
												   >	209:    ADD  3,4,3	op += 
												   >	210:     ST  3,-1(0)	Store variable LEFT
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	211:    JMP  7,-162(7)	go to beginning of loop 
												   >	 56:    JMP  7,155(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	212:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	213:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	214:    LDA  3,1(7)	Return address in ac 
												   >	215:    JMP  7,-182(7)	CALL outnl
												   >	216:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	217:     LD  3,-5(0)	Load variable YStep
												   >	218:     LD  4,0(0)	load lhs variable TOP
												   >	219:    ADD  3,4,3	op += 
												   >	220:     ST  3,0(0)	Store variable TOP
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	221:    JMP  7,-182(7)	go to beginning of loop 
												   >	 46:    JMP  7,175(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	222:    LDC  2,0(6)	Set return value to 0 
												   >	223:     LD  3,-1(1)	Load return address 
												   >	224:     LD  1,0(1)	Adjust fp 
												   >	225:    JMP  7,0(3)	Return 
												   >	* END FUNCTION Mandelbrot
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION Julia
												   >	* TOFF set: -4
												   >	226:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* WHILE
												   >	227:     LD  3,0(0)	Load variable TOP
												   >	228:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	229:     LD  3,-7(0)	Load variable YMax
												   >	* TOFF inc: -4
												   >	230:     LD  4,-4(1)	Pop left into ac1 
												   >	231:    TLT  3,4,3	Op < 
												   >	232:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	234:    LDC  3,512(6)	Load integer constant 
												   >	235:    NEG  3,3,3	Op unary - 
												   >	236:     ST  3,-1(0)	Store variable LEFT
												   >	* WHILE
												   >	237:     LD  3,-1(0)	Load variable LEFT
												   >	238:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	239:     LD  3,-6(0)	Load variable XMax
												   >	* TOFF inc: -4
												   >	240:     LD  4,-4(1)	Pop left into ac1 
												   >	241:    TLT  3,4,3	Op < 
												   >	242:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	244:     LD  3,-1(0)	Load variable LEFT
												   >	245:     ST  3,-6(1)	Store variable A
												   >	* EXPRESSION
												   >	246:     LD  3,0(0)	Load variable TOP
												   >	247:     ST  3,-5(1)	Store variable Bi
												   >	* EXPRESSION
												   >	248:     LD  3,-6(1)	Load variable A
												   >	249:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	250:     LD  3,-6(1)	Load variable A
												   >	* TOFF inc: -9
												   >	251:     LD  4,-9(1)	Pop left into ac1 
												   >	252:    MUL  3,4,3	Op * 
												   >	253:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	254:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	255:     LD  4,-9(1)	Pop left into ac1 
												   >	256:    DIV  3,4,3	Op / 
												   >	257:     ST  3,-7(1)	Store variable NextA
												   >	* EXPRESSION
												   >	258:     LD  3,-5(1)	Load variable Bi
												   >	259:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	260:     LD  3,-5(1)	Load variable Bi
												   >	* TOFF inc: -9
												   >	261:     LD  4,-9(1)	Pop left into ac1 
												   >	262:    MUL  3,4,3	Op * 
												   >	263:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	264:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	265:     LD  4,-9(1)	Pop left into ac1 
												   >	266:    DIV  3,4,3	Op / 
												   >	267:     ST  3,-8(1)	Store variable NextBi
												   >	* EXPRESSION
												   >	268:     LD  3,-7(1)	Load variable NextA
												   >	269:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	270:     LD  3,-8(1)	Load variable NextBi
												   >	* TOFF inc: -9
												   >	271:     LD  4,-9(1)	Pop left into ac1 
												   >	272:    ADD  3,4,3	Op + 
												   >	273:     ST  3,-4(1)	Store variable Len
												   >	* EXPRESSION
												   >	274:    LDC  3,0(6)	Load integer constant 
												   >	275:     ST  3,-8(0)	Store variable iter
												   >	* WHILE
												   >	276:     LD  3,-4(1)	Load variable Len
												   >	277:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	278:    LDC  3,1024(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	279:     LD  4,-9(1)	Pop left into ac1 
												   >	280:    TLE  3,4,3	Op <= 
												   >	281:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	282:     LD  3,-8(0)	Load variable iter
												   >	283:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	284:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	285:     LD  4,-10(1)	Pop left into ac1 
												   >	286:    TLT  3,4,3	Op < 
												   >	* TOFF inc: -9
												   >	287:     LD  4,-9(1)	Pop left into ac1 
												   >	288:    AND  3,4,3	Op AND 
												   >	289:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	291:    LDC  3,2(6)	Load integer constant 
												   >	292:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	293:     LD  3,-6(1)	Load variable A
												   >	294:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	295:     LD  3,-5(1)	Load variable Bi
												   >	* TOFF inc: -10
												   >	296:     LD  4,-10(1)	Pop left into ac1 
												   >	297:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -9
												   >	298:     LD  4,-9(1)	Pop left into ac1 
												   >	299:    MUL  3,4,3	Op * 
												   >	300:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	301:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	302:     LD  4,-9(1)	Pop left into ac1 
												   >	303:    DIV  3,4,3	Op / 
												   >	304:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	305:     LD  3,-3(1)	Load variable CBi
												   >	* TOFF inc: -9
												   >	306:     LD  4,-9(1)	Pop left into ac1 
												   >	307:    ADD  3,4,3	Op + 
												   >	308:     ST  3,-5(1)	Store variable Bi
												   >	* EXPRESSION
												   >	309:     LD  3,-7(1)	Load variable NextA
												   >	310:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	311:     LD  3,-8(1)	Load variable NextBi
												   >	* TOFF inc: -9
												   >	312:     LD  4,-9(1)	Pop left into ac1 
												   >	313:    SUB  3,4,3	Op - 
												   >	314:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	315:     LD  3,-2(1)	Load variable CA
												   >	* TOFF inc: -9
												   >	316:     LD  4,-9(1)	Pop left into ac1 
												   >	317:    ADD  3,4,3	Op + 
												   >	318:     ST  3,-6(1)	Store variable A
												   >	* EXPRESSION
												   >	319:     LD  3,-6(1)	Load variable A
												   >	320:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	321:     LD  3,-6(1)	Load variable A
												   >	* TOFF inc: -9
												   >	322:     LD  4,-9(1)	Pop left into ac1 
												   >	323:    MUL  3,4,3	Op * 
												   >	324:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	325:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	326:     LD  4,-9(1)	Pop left into ac1 
												   >	327:    DIV  3,4,3	Op / 
												   >	328:     ST  3,-7(1)	Store variable NextA
												   >	* EXPRESSION
												   >	329:     LD  3,-5(1)	Load variable Bi
												   >	330:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	331:     LD  3,-5(1)	Load variable Bi
												   >	* TOFF inc: -9
												   >	332:     LD  4,-9(1)	Pop left into ac1 
												   >	333:    MUL  3,4,3	Op * 
												   >	334:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	335:    LDC  3,256(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	336:     LD  4,-9(1)	Pop left into ac1 
												   >	337:    DIV  3,4,3	Op / 
												   >	338:     ST  3,-8(1)	Store variable NextBi
												   >	* EXPRESSION
												   >	339:     LD  3,-7(1)	Load variable NextA
												   >	340:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	341:     LD  3,-8(1)	Load variable NextBi
												   >	* TOFF inc: -9
												   >	342:     LD  4,-9(1)	Pop left into ac1 
												   >	343:    ADD  3,4,3	Op + 
												   >	344:     ST  3,-4(1)	Store variable Len
												   >	* EXPRESSION
												   >	345:     LD  3,-8(0)	load lhs variable iter
												   >	346:    LDA  3,1(3)	increment value of iter
												   >	347:     ST  3,-8(0)	Store variable iter
												   >	* TOFF set: -9
												   >	* END COMPOUND
												   >	348:    JMP  7,-73(7)	go to beginning of loop 
												   >	290:    JMP  7,58(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	349:     LD  3,-8(0)	Load variable iter
												   >	350:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	351:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	352:     LD  4,-9(1)	Pop left into ac1 
												   >	353:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	355:     ST  1,-9(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	356:    LDA  3,-10(0)	Load address of base of array grayScale
												   >	357:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	358:     LD  3,-8(0)	Load variable iter
												   >	* TOFF inc: -11
												   >	359:     LD  4,-11(1)	Pop left into ac1 
												   >	360:    SUB  3,4,3	compute location from index 
												   >	361:     LD  3,0(3)	Load array element 
												   >	362:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end outputc
												   >	363:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	364:    LDA  3,1(7)	Return address in ac 
												   >	365:    JMP  7,-338(7)	CALL outputc
												   >	366:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -9
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	367:     ST  1,-9(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	368:    LDC  3,32(6)	Load char constant 
												   >	369:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end outputc
												   >	370:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	371:    LDA  3,1(7)	Return address in ac 
												   >	372:    JMP  7,-345(7)	CALL outputc
												   >	373:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -9
												   >	* TOFF set: -9
												   >	* END COMPOUND
												   >	354:    JZR  3,20(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	375:     ST  1,-9(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	376:     LD  3,-8(0)	Load variable iter
												   >	377:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	378:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	379:     LD  4,-11(1)	Pop left into ac1 
												   >	380:    TEQ  3,4,3	Op = 
												   >	381:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end outputb
												   >	382:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	383:    LDA  3,1(7)	Return address in ac 
												   >	384:    JMP  7,-368(7)	CALL outputb
												   >	385:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -9
												   >	374:    JMP  7,11(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	386:     LD  3,-4(0)	Load variable XStep
												   >	387:     LD  4,-1(0)	load lhs variable LEFT
												   >	388:    ADD  3,4,3	op += 
												   >	389:     ST  3,-1(0)	Store variable LEFT
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	390:    JMP  7,-154(7)	go to beginning of loop 
												   >	243:    JMP  7,147(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	391:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	392:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	393:    LDA  3,1(7)	Return address in ac 
												   >	394:    JMP  7,-361(7)	CALL outnl
												   >	395:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	396:     LD  3,-5(0)	Load variable YStep
												   >	397:     LD  4,0(0)	load lhs variable TOP
												   >	398:    ADD  3,4,3	op += 
												   >	399:     ST  3,0(0)	Store variable TOP
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	400:    JMP  7,-174(7)	go to beginning of loop 
												   >	233:    JMP  7,167(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	401:    LDC  2,0(6)	Set return value to 0 
												   >	402:     LD  3,-1(1)	Load return address 
												   >	403:     LD  1,0(1)	Adjust fp 
												   >	404:    JMP  7,0(3)	Return 
												   >	* END FUNCTION Julia
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	405:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	406:    LDC  3,2(6)	load size of array JuliaVals
												   >	407:     ST  3,-2(1)	save size of array JuliaVals
												   >	* Compound Body
												   >	* EXPRESSION
												   >	408:    LDC  3,0(6)	Load integer constant 
												   >	409:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	410:    LDC  3,32(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	411:     LD  4,-5(1)	Pop index 
												   >	412:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	413:    SUB  5,5,4	Compute offset of value 
												   >	414:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	415:    LDC  3,1(6)	Load integer constant 
												   >	416:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	417:    LDC  3,46(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	418:     LD  4,-5(1)	Pop index 
												   >	419:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	420:    SUB  5,5,4	Compute offset of value 
												   >	421:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	422:    LDC  3,2(6)	Load integer constant 
												   >	423:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	424:    LDC  3,32(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	425:     LD  4,-5(1)	Pop index 
												   >	426:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	427:    SUB  5,5,4	Compute offset of value 
												   >	428:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	429:    LDC  3,3(6)	Load integer constant 
												   >	430:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	431:    LDC  3,59(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	432:     LD  4,-5(1)	Pop index 
												   >	433:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	434:    SUB  5,5,4	Compute offset of value 
												   >	435:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	436:    LDC  3,4(6)	Load integer constant 
												   >	437:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	438:    LDC  3,45(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	439:     LD  4,-5(1)	Pop index 
												   >	440:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	441:    SUB  5,5,4	Compute offset of value 
												   >	442:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	443:    LDC  3,5(6)	Load integer constant 
												   >	444:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	445:    LDC  3,43(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	446:     LD  4,-5(1)	Pop index 
												   >	447:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	448:    SUB  5,5,4	Compute offset of value 
												   >	449:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	450:    LDC  3,6(6)	Load integer constant 
												   >	451:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	452:    LDC  3,73(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	453:     LD  4,-5(1)	Pop index 
												   >	454:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	455:    SUB  5,5,4	Compute offset of value 
												   >	456:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	457:    LDC  3,7(6)	Load integer constant 
												   >	458:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	459:    LDC  3,79(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	460:     LD  4,-5(1)	Pop index 
												   >	461:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	462:    SUB  5,5,4	Compute offset of value 
												   >	463:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	464:    LDC  3,8(6)	Load integer constant 
												   >	465:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	466:    LDC  3,86(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	467:     LD  4,-5(1)	Pop index 
												   >	468:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	469:    SUB  5,5,4	Compute offset of value 
												   >	470:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	471:    LDC  3,9(6)	Load integer constant 
												   >	472:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	473:    LDC  3,87(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	474:     LD  4,-5(1)	Pop index 
												   >	475:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	476:    SUB  5,5,4	Compute offset of value 
												   >	477:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	478:    LDC  3,10(6)	Load integer constant 
												   >	479:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	480:    LDC  3,35(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	481:     LD  4,-5(1)	Pop index 
												   >	482:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	483:    SUB  5,5,4	Compute offset of value 
												   >	484:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	485:    LDC  3,11(6)	Load integer constant 
												   >	486:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	487:    LDC  3,64(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	488:     LD  4,-5(1)	Pop index 
												   >	489:    LDA  5,-10(0)	Load address of base of array grayScale
												   >	490:    SUB  5,5,4	Compute offset of value 
												   >	491:     ST  3,0(5)	Store variable grayScale
												   >	* EXPRESSION
												   >	492:    LDC  3,320(6)	Load integer constant 
												   >	493:    NEG  3,3,3	Op unary - 
												   >	494:     ST  3,0(0)	Store variable TOP
												   >	* EXPRESSION
												   >	495:    LDC  3,512(6)	Load integer constant 
												   >	496:    NEG  3,3,3	Op unary - 
												   >	497:     ST  3,-1(0)	Store variable LEFT
												   >	* EXPRESSION
												   >	498:    LDC  3,640(6)	Load integer constant 
												   >	499:     ST  3,-2(0)	Store variable HEIGHT
												   >	* EXPRESSION
												   >	500:    LDC  3,716(6)	Load integer constant 
												   >	501:     ST  3,-3(0)	Store variable WIDTH
												   >	* EXPRESSION
												   >	502:     LD  3,-3(0)	Load variable WIDTH
												   >	503:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	504:    LDC  3,40(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	505:     LD  4,-5(1)	Pop left into ac1 
												   >	506:    DIV  3,4,3	Op / 
												   >	507:     ST  3,-4(0)	Store variable XStep
												   >	* EXPRESSION
												   >	508:     LD  3,-2(0)	Load variable HEIGHT
												   >	509:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	510:    LDC  3,36(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	511:     LD  4,-5(1)	Pop left into ac1 
												   >	512:    DIV  3,4,3	Op / 
												   >	513:     ST  3,-5(0)	Store variable YStep
												   >	* EXPRESSION
												   >	514:     LD  3,-1(0)	Load variable LEFT
												   >	515:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	516:     LD  3,-3(0)	Load variable WIDTH
												   >	* TOFF inc: -5
												   >	517:     LD  4,-5(1)	Pop left into ac1 
												   >	518:    ADD  3,4,3	Op + 
												   >	519:     ST  3,-6(0)	Store variable XMax
												   >	* EXPRESSION
												   >	520:     LD  3,0(0)	Load variable TOP
												   >	521:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	522:     LD  3,-2(0)	Load variable HEIGHT
												   >	* TOFF inc: -5
												   >	523:     LD  4,-5(1)	Pop left into ac1 
												   >	524:    ADD  3,4,3	Op + 
												   >	525:     ST  3,-7(0)	Store variable YMax
												   >	* EXPRESSION
												   >	* CALL Mandelbrot
												   >	526:     ST  1,-5(1)	Store fp in ghost frame for Mandelbrot
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	527:    LDA  3,-3(1)	Load address of base of array JuliaVals
												   >	528:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end Mandelbrot
												   >	529:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	530:    LDA  3,1(7)	Return address in ac 
												   >	531:    JMP  7,-493(7)	CALL Mandelbrot
												   >	532:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end Mandelbrot
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	533:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	534:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	535:    LDA  3,1(7)	Return address in ac 
												   >	536:    JMP  7,-503(7)	CALL outnl
												   >	537:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	538:    LDC  3,320(6)	Load integer constant 
												   >	539:    NEG  3,3,3	Op unary - 
												   >	540:     ST  3,0(0)	Store variable TOP
												   >	* EXPRESSION
												   >	541:    LDC  3,512(6)	Load integer constant 
												   >	542:    NEG  3,3,3	Op unary - 
												   >	543:     ST  3,-1(0)	Store variable LEFT
												   >	* EXPRESSION
												   >	544:    LDC  3,640(6)	Load integer constant 
												   >	545:     ST  3,-2(0)	Store variable HEIGHT
												   >	* EXPRESSION
												   >	546:    LDC  3,716(6)	Load integer constant 
												   >	547:     ST  3,-3(0)	Store variable WIDTH
												   >	* EXPRESSION
												   >	548:     LD  3,-3(0)	Load variable WIDTH
												   >	549:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	550:    LDC  3,40(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	551:     LD  4,-5(1)	Pop left into ac1 
												   >	552:    DIV  3,4,3	Op / 
												   >	553:     ST  3,-4(0)	Store variable XStep
												   >	* EXPRESSION
												   >	554:     LD  3,-2(0)	Load variable HEIGHT
												   >	555:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	556:    LDC  3,36(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	557:     LD  4,-5(1)	Pop left into ac1 
												   >	558:    DIV  3,4,3	Op / 
												   >	559:     ST  3,-5(0)	Store variable YStep
												   >	* EXPRESSION
												   >	560:     LD  3,-1(0)	Load variable LEFT
												   >	561:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	562:     LD  3,-3(0)	Load variable WIDTH
												   >	* TOFF inc: -5
												   >	563:     LD  4,-5(1)	Pop left into ac1 
												   >	564:    ADD  3,4,3	Op + 
												   >	565:     ST  3,-6(0)	Store variable XMax
												   >	* EXPRESSION
												   >	566:     LD  3,0(0)	Load variable TOP
												   >	567:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	568:     LD  3,-2(0)	Load variable HEIGHT
												   >	* TOFF inc: -5
												   >	569:     LD  4,-5(1)	Pop left into ac1 
												   >	570:    ADD  3,4,3	Op + 
												   >	571:     ST  3,-7(0)	Store variable YMax
												   >	* EXPRESSION
												   >	* CALL Julia
												   >	572:     ST  1,-5(1)	Store fp in ghost frame for Julia
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	573:    LDA  3,-3(1)	Load address of base of array JuliaVals
												   >	574:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	575:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	576:     LD  4,-7(1)	Pop left into ac1 
												   >	577:    SUB  3,4,3	compute location from index 
												   >	578:     LD  3,0(3)	Load array element 
												   >	579:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	580:    LDA  3,-3(1)	Load address of base of array JuliaVals
												   >	581:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	582:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	583:     LD  4,-8(1)	Pop left into ac1 
												   >	584:    SUB  3,4,3	compute location from index 
												   >	585:     LD  3,0(3)	Load array element 
												   >	586:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end Julia
												   >	587:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	588:    LDA  3,1(7)	Return address in ac 
												   >	589:    JMP  7,-364(7)	CALL Julia
												   >	590:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end Julia
												   >	* TOFF set: -5
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	591:    LDC  2,0(6)	Set return value to 0 
												   >	592:     LD  3,-1(1)	Load return address 
												   >	593:     LD  1,0(1)	Adjust fp 
												   >	594:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,594(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	595:    LDA  1,-22(0)	set first frame at end of globals 
												   >	596:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	597:    LDC  3,12(6)	load size of array grayScale
												   >	598:     ST  3,-9(0)	save size of array grayScale
												   >	* END INIT GLOBALS AND STATICS
												   >	599:    LDA  3,1(7)	Return address in ac 
												   >	600:    JMP  7,-196(7)	Jump to main 
												   >	601:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
fractal.mem fractal.mem.f21 differ: byte 186, line 3
fractal (MEM DIFF)
WARNING(120): character is 4 characters long and not a single character: '' by ''.  The first ch	WARNING(120): character is 4 characters long and not a single character: '' by ''.  The first ch
WARNING(140): Variable 'JuliaVals' may be uninitialized when used here.					WARNING(140): Variable 'JuliaVals' may be uninitialized when used here.
Var: TOP of type int [mem: Global loc: 0 size: 1] [line: 22]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: LEFT of type int [mem: Global loc: -1 size: 1] [line: 23]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 24]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Var: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 25]			   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 4  Var: XStep of type int [mem: Global loc: -4 size: 1] [line: 26]			   |	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 5  Var: YStep of type int [mem: Global loc: -5 size: 1] [line: 27]			   |	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 6  Var: XMax of type int [mem: Global loc: -6 size: 1] [line: 28]			   |	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 7  Var: YMax of type int [mem: Global loc: -7 size: 1] [line: 28]			   |	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 8  Var: iter of type int [mem: Global loc: -8 size: 1] [line: 29]			   |	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 9  Var: grayScale of array of type char [mem: Global loc: -10 size: 13] [line: 30]	   |	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 10  Func: Mandelbrot returns type void [mem: Global loc: 0 size: -3] [line: 33]	   |	Sibling: 7  Var: TOP of type int [mem: Global loc: 0 size: 1] [line: 22]
												   >	Sibling: 8  Var: LEFT of type int [mem: Global loc: -1 size: 1] [line: 23]
												   >	Sibling: 9  Var: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 24]
												   >	Sibling: 10  Var: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 25]
												   >	Sibling: 11  Var: XStep of type int [mem: Global loc: -4 size: 1] [line: 26]
												   >	Sibling: 12  Var: YStep of type int [mem: Global loc: -5 size: 1] [line: 27]
												   >	Sibling: 13  Var: XMax of type int [mem: Global loc: -6 size: 1] [line: 28]
												   >	Sibling: 14  Var: YMax of type int [mem: Global loc: -7 size: 1] [line: 28]
												   >	Sibling: 15  Var: iter of type int [mem: Global loc: -8 size: 1] [line: 29]
												   >	Sibling: 16  Var: grayScale of array of type char [mem: Global loc: -10 size: 13] [line: 30]
												   >	Sibling: 17  Func: Mandelbrot returns type void [mem: Global loc: 0 size: -3] [line: 33]
.   Child: 0  Parm: JuliaVals of array of type int [mem: Parameter loc: -2 size: 1] [line: 33]		.   Child: 0  Parm: JuliaVals of array of type int [mem: Parameter loc: -2 size: 1] [line: 33]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 34]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 34]
.   .   Child: 1  While [line: 35]									.   .   Child: 1  While [line: 35]
.   .   .   Child: 0  Op: < of type bool [line: 35]							.   .   .   Child: 0  Op: < of type bool [line: 35]
.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 35]			.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 35]
.   .   .   .   Child: 1  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 35]			.   .   .   .   Child: 1  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 35]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]
.   .   .   .   Child: 1  Assign: = of type int [line: 37]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 37]
.   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 37]		.   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 37]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 37]						.   .   .   .   .   Child: 1  Op: chsign of type int [line: 37]
.   .   .   .   .   .   Child: 0  Const 512 of type int [line: 37]					.   .   .   .   .   .   Child: 0  Const 512 of type int [line: 37]
.   .   .   .   Sibling: 1  While [line: 38]								.   .   .   .   Sibling: 1  While [line: 38]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 38]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 38]
.   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 38]		.   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 38]
.   .   .   .   .   .   Child: 1  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 38]		.   .   .   .   .   .   Child: 1  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 38]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 39]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 39]
.   .   .   .   .   .   Child: 0  Var: Len of type int [mem: Local loc: -3 size: 1] [line: 40]		.   .   .   .   .   .   Child: 0  Var: Len of type int [mem: Local loc: -3 size: 1] [line: 40]
.   .   .   .   .   .   Sibling: 1  Var: Bi of type int [mem: Local loc: -4 size: 1] [line: 41]		.   .   .   .   .   .   Sibling: 1  Var: Bi of type int [mem: Local loc: -4 size: 1] [line: 41]
.   .   .   .   .   .   Sibling: 2  Var: A of type int [mem: Local loc: -5 size: 1] [line: 41]		.   .   .   .   .   .   Sibling: 2  Var: A of type int [mem: Local loc: -5 size: 1] [line: 41]
.   .   .   .   .   .   Sibling: 3  Var: NextA of type int [mem: Local loc: -6 size: 1] [line: 4	.   .   .   .   .   .   Sibling: 3  Var: NextA of type int [mem: Local loc: -6 size: 1] [line: 4
.   .   .   .   .   .   Sibling: 4  Var: NextBi of type int [mem: Local loc: -7 size: 1] [line: 	.   .   .   .   .   .   Sibling: 4  Var: NextBi of type int [mem: Local loc: -7 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 43]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 43]
.   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [line: 43]		.   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [line: 43]
.   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 	.   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 44]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 44]
.   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [line: 44]	.   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [line: 44]
.   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 44	.   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 44
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 45]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 45]
.   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 45]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 45]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 45]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 45]
.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -5 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -5 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 45]				.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 45]
.   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 46]				   |	.   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 46]
.   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -7 size: 1] [line:	.   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -7 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 46]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 46]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 46]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 46]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -4 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -4 size: 1] [l
.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 46]				.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 46]
.   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 47]				   |	.   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 47]
.   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [line: 47	.   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [line: 47
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 47]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 47]
.   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7 size: 1] [l	.   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7 size: 1] [l
.   .   .   .   .   .   Sibling: 5  Assign: = of type int [line: 48]				   |	.   .   .   .   .   .   Sibling: 5  Assign: := of type int [line: 48]
.   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 48]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 48]
.   .   .   .   .   .   Sibling: 6  While [line: 50]							.   .   .   .   .   .   Sibling: 6  While [line: 50]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 50]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 50]
.   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 50]				.   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 50]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [
.   .   .   .   .   .   .   .   .   Child: 1  Const 1024 of type int [line: 50]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1024 of type int [line: 50]
.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 50]					.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 50]
.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 50]				.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 50]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 51]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 51]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 52]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 52]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 52]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 52]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 52]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 52]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 52]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 52]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 52]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 53]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 53]
.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 53]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 53]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 53]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 53]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 54]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 54]
.   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 54]				.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 54]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 54]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 54]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -5 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -5 size	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -5 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 54]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 54]
.   .   .   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 55]			   |	.   .   .   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 55]
.   .   .   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -7 size: 1	.   .   .   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -7 size: 1
.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 55]				.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 55]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 55]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 55]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 55]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 55]
.   .   .   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 56]			   |	.   .   .   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 56]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -3 size: 1] [
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 56]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 56]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -6 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7 siz	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -7 siz
.   .   .   .   .   .   .   .   Sibling: 5  Assign: ++ of type int [line: 57]				.   .   .   .   .   .   .   .   Sibling: 5  Assign: ++ of type int [line: 57]
.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]
.   .   .   .   .   .   Sibling: 7  If [line: 59]							.   .   .   .   .   .   Sibling: 7  If [line: 59]
.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 59]					.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 59]
.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 12 of type int [line: 59]				.   .   .   .   .   .   .   .   Child: 1  Const 12 of type int [line: 59]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 59]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 59]
.   .   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 60]				.   .   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 60]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 60]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 60]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Glob	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Glob
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: iter of type int [mem: Global loc: -8 size	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: iter of type int [mem: Global loc: -8 size
.   .   .   .   .   .   .   .   Sibling: 1  Call: outputc of type void [line: 61]			.   .   .   .   .   .   .   .   Sibling: 1  Call: outputc of type void [line: 61]
.   .   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 61]				.   .   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 61]
.   .   .   .   .   .   Sibling: 8  If [line: 63]							.   .   .   .   .   .   Sibling: 8  If [line: 63]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 63]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 63]
.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 63]				.   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 63]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 64]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 64]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 65]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 65]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 65]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 65]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Param	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Param
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 65]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 65]
.   .   .   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1]	.   .   .   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 66]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 66]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 66]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 66]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Param	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Param
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 66]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 66]
.   .   .   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [
.   .   .   .   .   .   Sibling: 9  Assign: += of type int [line: 68]					.   .   .   .   .   .   Sibling: 9  Assign: += of type int [line: 68]
.   .   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Id: XStep of type int [mem: Global loc: -4 size: 1] [line:	.   .   .   .   .   .   .   Child: 1  Id: XStep of type int [mem: Global loc: -4 size: 1] [line:
.   .   .   .   Sibling: 2  Call: outnl of type void [line: 70]						.   .   .   .   Sibling: 2  Call: outnl of type void [line: 70]
.   .   .   .   Sibling: 3  Assign: += of type int [line: 71]						.   .   .   .   Sibling: 3  Assign: += of type int [line: 71]
.   .   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 71]		.   .   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 71]
.   .   .   .   .   Child: 1  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 71]		.   .   .   .   .   Child: 1  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 71]
Sibling: 11  Func: Julia returns type void [mem: Global loc: 0 size: -4] [line: 76]		   |	Sibling: 18  Func: Julia returns type void [mem: Global loc: 0 size: -4] [line: 76]
.   Child: 0  Parm: CA of type int [mem: Parameter loc: -2 size: 1] [line: 76]				.   Child: 0  Parm: CA of type int [mem: Parameter loc: -2 size: 1] [line: 76]
.   Sibling: 1  Parm: CBi of type int [mem: Parameter loc: -3 size: 1] [line: 76]			.   Sibling: 1  Parm: CBi of type int [mem: Parameter loc: -3 size: 1] [line: 76]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 77]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 77]
.   .   Child: 1  While [line: 78]									.   .   Child: 1  While [line: 78]
.   .   .   Child: 0  Op: < of type bool [line: 78]							.   .   .   Child: 0  Op: < of type bool [line: 78]
.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 78]			.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 78]
.   .   .   .   Child: 1  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 78]			.   .   .   .   Child: 1  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 78]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 79]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 79]
.   .   .   .   Child: 1  Assign: = of type int [line: 80]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 80]
.   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 80]		.   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 80]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 80]						.   .   .   .   .   Child: 1  Op: chsign of type int [line: 80]
.   .   .   .   .   .   Child: 0  Const 512 of type int [line: 80]					.   .   .   .   .   .   Child: 0  Const 512 of type int [line: 80]
.   .   .   .   Sibling: 1  While [line: 81]								.   .   .   .   Sibling: 1  While [line: 81]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 81]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 81]
.   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 81]		.   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 81]
.   .   .   .   .   .   Child: 1  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 81]		.   .   .   .   .   .   Child: 1  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 81]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 82]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 82]
.   .   .   .   .   .   Child: 0  Var: Len of type int [mem: Local loc: -4 size: 1] [line: 83]		.   .   .   .   .   .   Child: 0  Var: Len of type int [mem: Local loc: -4 size: 1] [line: 83]
.   .   .   .   .   .   Sibling: 1  Var: Bi of type int [mem: Local loc: -5 size: 1] [line: 84]		.   .   .   .   .   .   Sibling: 1  Var: Bi of type int [mem: Local loc: -5 size: 1] [line: 84]
.   .   .   .   .   .   Sibling: 2  Var: A of type int [mem: Local loc: -6 size: 1] [line: 84]		.   .   .   .   .   .   Sibling: 2  Var: A of type int [mem: Local loc: -6 size: 1] [line: 84]
.   .   .   .   .   .   Sibling: 3  Var: NextA of type int [mem: Local loc: -7 size: 1] [line: 8	.   .   .   .   .   .   Sibling: 3  Var: NextA of type int [mem: Local loc: -7 size: 1] [line: 8
.   .   .   .   .   .   Sibling: 4  Var: NextBi of type int [mem: Local loc: -8 size: 1] [line: 	.   .   .   .   .   .   Sibling: 4  Var: NextBi of type int [mem: Local loc: -8 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 86]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 86]
.   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [line: 86]		.   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [line: 86]
.   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 	.   .   .   .   .   .   .   Child: 1  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 87]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 87]
.   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [line: 87]	.   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [line: 87]
.   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 87	.   .   .   .   .   .   .   Child: 1  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 87
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 88]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 88]
.   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 88]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 88]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 88]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 88]
.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -6 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -6 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 88]				.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 88]
.   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 89]				   |	.   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 89]
.   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -8 size: 1] [line:	.   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -8 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 89]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 89]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 89]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 89]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -5 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -5 size: 1] [l
.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 89]				.   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 89]
.   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 90]				   |	.   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 90]
.   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [line: 90	.   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [line: 90
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 90]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 90]
.   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8 size: 1] [l	.   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8 size: 1] [l
.   .   .   .   .   .   Sibling: 5  Assign: = of type int [line: 91]				   |	.   .   .   .   .   .   Sibling: 5  Assign: := of type int [line: 91]
.   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 91]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 91]
.   .   .   .   .   .   Sibling: 6  While [line: 92]							.   .   .   .   .   .   Sibling: 6  While [line: 92]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 92]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 92]
.   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 92]				.   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 92]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [
.   .   .   .   .   .   .   .   .   Child: 1  Const 1024 of type int [line: 92]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1024 of type int [line: 92]
.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 92]					.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 92]
.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 92]				.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 92]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 93]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 93]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 94]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 94]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 94]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 94]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 94]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 94]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 94]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 94]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 94]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: CBi of type int [mem: Parameter loc: -3 si	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: CBi of type int [mem: Parameter loc: -3 si
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 95]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 95]
.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 95]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 95]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 95]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 95]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: CA of type int [mem: Parameter loc: -2 siz	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: CA of type int [mem: Parameter loc: -2 siz
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 96]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 96]
.   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 96]				.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 96]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 96]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 96]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: A of type int [mem: Local loc: -6 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -6 size	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: A of type int [mem: Local loc: -6 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 96]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 96]
.   .   .   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 97]			   |	.   .   .   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 97]
.   .   .   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -8 size: 1	.   .   .   .   .   .   .   .   .   Child: 0  Id: NextBi of type int [mem: Local loc: -8 size: 1
.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 97]				.   .   .   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 97]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 97]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 97]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: Bi of type int [mem: Local loc: -5 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -5 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: Bi of type int [mem: Local loc: -5 siz
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 97]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 256 of type int [line: 97]
.   .   .   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 98]			   |	.   .   .   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 98]
.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 0  Id: Len of type int [mem: Local loc: -4 size: 1] [
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 98]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 98]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: NextA of type int [mem: Local loc: -7 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8 siz	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: NextBi of type int [mem: Local loc: -8 siz
.   .   .   .   .   .   .   .   Sibling: 5  Assign: ++ of type int [line: 99]				.   .   .   .   .   .   .   .   Sibling: 5  Assign: ++ of type int [line: 99]
.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]
.   .   .   .   .   .   Sibling: 7  If [line: 101]							.   .   .   .   .   .   Sibling: 7  If [line: 101]
.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 101]					.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 101]
.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 101]				.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 101]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 101]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 101]
.   .   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 102]			.   .   .   .   .   .   .   .   Child: 1  Call: outputc of type void [line: 102]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 102]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 102]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Glob	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Glob
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: iter of type int [mem: Global loc: -8 size	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: iter of type int [mem: Global loc: -8 size
.   .   .   .   .   .   .   .   Sibling: 1  Call: outputc of type void [line: 103]			.   .   .   .   .   .   .   .   Sibling: 1  Call: outputc of type void [line: 103]
.   .   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 103]			.   .   .   .   .   .   .   .   .   Child: 0  Const ' ' of type char [line: 103]
.   .   .   .   .   .   .   Child: 2  Call: outputb of type void [line: 106]				.   .   .   .   .   .   .   Child: 2  Call: outputb of type void [line: 106]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 106]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 106]
.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: iter of type int [mem: Global loc: -8 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 106]				.   .   .   .   .   .   .   .   .   Child: 1  Const 11 of type int [line: 106]
.   .   .   .   .   .   Sibling: 8  Assign: += of type int [line: 107]					.   .   .   .   .   .   Sibling: 8  Assign: += of type int [line: 107]
.   .   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Id: XStep of type int [mem: Global loc: -4 size: 1] [line:	.   .   .   .   .   .   .   Child: 1  Id: XStep of type int [mem: Global loc: -4 size: 1] [line:
.   .   .   .   Sibling: 2  Call: outnl of type void [line: 109]					.   .   .   .   Sibling: 2  Call: outnl of type void [line: 109]
.   .   .   .   Sibling: 3  Assign: += of type int [line: 110]						.   .   .   .   Sibling: 3  Assign: += of type int [line: 110]
.   .   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 110]		.   .   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 110]
.   .   .   .   .   Child: 1  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 110]		.   .   .   .   .   Child: 1  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 110]
Sibling: 12  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 114]		   |	Sibling: 19  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 114]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 115]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 115]
.   .   Child: 0  Var: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line: 116]		.   .   Child: 0  Var: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line: 116]
.   .   Child: 1  Assign: = of type char [line: 118]						   |	.   .   Child: 1  Assign: := of type char [line: 118]
.   .   .   Child: 0  Op: [ of type char [line: 118]							.   .   .   Child: 0  Op: [ of type char [line: 118]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 0 of type int [line: 118]						.   .   .   .   Child: 1  Const 0 of type int [line: 118]
.   .   .   Child: 1  Const ' ' of type char [line: 118]						.   .   .   Child: 1  Const ' ' of type char [line: 118]
.   .   Sibling: 1  Assign: = of type char [line: 119]						   |	.   .   Sibling: 1  Assign: := of type char [line: 119]
.   .   .   Child: 0  Op: [ of type char [line: 119]							.   .   .   Child: 0  Op: [ of type char [line: 119]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 1 of type int [line: 119]						.   .   .   .   Child: 1  Const 1 of type int [line: 119]
.   .   .   Child: 1  Const '.' of type char [line: 119]						.   .   .   Child: 1  Const '.' of type char [line: 119]
.   .   Sibling: 2  Assign: = of type char [line: 120]						   |	.   .   Sibling: 2  Assign: := of type char [line: 120]
.   .   .   Child: 0  Op: [ of type char [line: 120]							.   .   .   Child: 0  Op: [ of type char [line: 120]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 2 of type int [line: 120]						.   .   .   .   Child: 1  Const 2 of type int [line: 120]
.   .   .   Child: 1  Const ' ' of type char [line: 120]						.   .   .   Child: 1  Const ' ' of type char [line: 120]
.   .   Sibling: 3  Assign: = of type char [line: 121]						   |	.   .   Sibling: 3  Assign: := of type char [line: 121]
.   .   .   Child: 0  Op: [ of type char [line: 121]							.   .   .   Child: 0  Op: [ of type char [line: 121]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 3 of type int [line: 121]						.   .   .   .   Child: 1  Const 3 of type int [line: 121]
.   .   .   Child: 1  Const ';' of type char [line: 121]						.   .   .   Child: 1  Const ';' of type char [line: 121]
.   .   Sibling: 4  Assign: = of type char [line: 122]						   |	.   .   Sibling: 4  Assign: := of type char [line: 122]
.   .   .   Child: 0  Op: [ of type char [line: 122]							.   .   .   Child: 0  Op: [ of type char [line: 122]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 4 of type int [line: 122]						.   .   .   .   Child: 1  Const 4 of type int [line: 122]
.   .   .   Child: 1  Const '-' of type char [line: 122]						.   .   .   Child: 1  Const '-' of type char [line: 122]
.   .   Sibling: 5  Assign: = of type char [line: 123]						   |	.   .   Sibling: 5  Assign: := of type char [line: 123]
.   .   .   Child: 0  Op: [ of type char [line: 123]							.   .   .   Child: 0  Op: [ of type char [line: 123]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 5 of type int [line: 123]						.   .   .   .   Child: 1  Const 5 of type int [line: 123]
.   .   .   Child: 1  Const '+' of type char [line: 123]						.   .   .   Child: 1  Const '+' of type char [line: 123]
.   .   Sibling: 6  Assign: = of type char [line: 124]						   |	.   .   Sibling: 6  Assign: := of type char [line: 124]
.   .   .   Child: 0  Op: [ of type char [line: 124]							.   .   .   Child: 0  Op: [ of type char [line: 124]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 6 of type int [line: 124]						.   .   .   .   Child: 1  Const 6 of type int [line: 124]
.   .   .   Child: 1  Const 'I' of type char [line: 124]						.   .   .   Child: 1  Const 'I' of type char [line: 124]
.   .   Sibling: 7  Assign: = of type char [line: 125]						   |	.   .   Sibling: 7  Assign: := of type char [line: 125]
.   .   .   Child: 0  Op: [ of type char [line: 125]							.   .   .   Child: 0  Op: [ of type char [line: 125]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 7 of type int [line: 125]						.   .   .   .   Child: 1  Const 7 of type int [line: 125]
.   .   .   Child: 1  Const 'O' of type char [line: 125]						.   .   .   Child: 1  Const 'O' of type char [line: 125]
.   .   Sibling: 8  Assign: = of type char [line: 126]						   |	.   .   Sibling: 8  Assign: := of type char [line: 126]
.   .   .   Child: 0  Op: [ of type char [line: 126]							.   .   .   Child: 0  Op: [ of type char [line: 126]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 8 of type int [line: 126]						.   .   .   .   Child: 1  Const 8 of type int [line: 126]
.   .   .   Child: 1  Const 'V' of type char [line: 126]						.   .   .   Child: 1  Const 'V' of type char [line: 126]
.   .   Sibling: 9  Assign: = of type char [line: 127]						   |	.   .   Sibling: 9  Assign: := of type char [line: 127]
.   .   .   Child: 0  Op: [ of type char [line: 127]							.   .   .   Child: 0  Op: [ of type char [line: 127]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 9 of type int [line: 127]						.   .   .   .   Child: 1  Const 9 of type int [line: 127]
.   .   .   Child: 1  Const 'W' of type char [line: 127]						.   .   .   Child: 1  Const 'W' of type char [line: 127]
.   .   Sibling: 10  Assign: = of type char [line: 128]						   |	.   .   Sibling: 10  Assign: := of type char [line: 128]
.   .   .   Child: 0  Op: [ of type char [line: 128]							.   .   .   Child: 0  Op: [ of type char [line: 128]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 10 of type int [line: 128]						.   .   .   .   Child: 1  Const 10 of type int [line: 128]
.   .   .   Child: 1  Const '#' of type char [line: 128]						.   .   .   Child: 1  Const '#' of type char [line: 128]
.   .   Sibling: 11  Assign: = of type char [line: 129]						   |	.   .   Sibling: 11  Assign: := of type char [line: 129]
.   .   .   Child: 0  Op: [ of type char [line: 129]							.   .   .   Child: 0  Op: [ of type char [line: 129]
.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l	.   .   .   .   Child: 0  Id: grayScale of array of type char [mem: Global loc: -10 size: 13] [l
.   .   .   .   Child: 1  Const 11 of type int [line: 129]						.   .   .   .   Child: 1  Const 11 of type int [line: 129]
.   .   .   Child: 1  Const '@' of type char [line: 129]						.   .   .   Child: 1  Const '@' of type char [line: 129]
.   .   Sibling: 12  Assign: = of type int [line: 132]						   |	.   .   Sibling: 12  Assign: := of type int [line: 132]
.   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 132]			.   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 132]
.   .   .   Child: 1  Op: chsign of type int [line: 132]						.   .   .   Child: 1  Op: chsign of type int [line: 132]
.   .   .   .   Child: 0  Const 320 of type int [line: 132]						.   .   .   .   Child: 0  Const 320 of type int [line: 132]
.   .   Sibling: 13  Assign: = of type int [line: 133]						   |	.   .   Sibling: 13  Assign: := of type int [line: 133]
.   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 133]			.   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 133]
.   .   .   Child: 1  Op: chsign of type int [line: 133]						.   .   .   Child: 1  Op: chsign of type int [line: 133]
.   .   .   .   Child: 0  Const 512 of type int [line: 133]						.   .   .   .   Child: 0  Const 512 of type int [line: 133]
.   .   Sibling: 14  Assign: = of type int [line: 134]						   |	.   .   Sibling: 14  Assign: := of type int [line: 134]
.   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 134]			.   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 134]
.   .   .   Child: 1  Const 640 of type int [line: 134]							.   .   .   Child: 1  Const 640 of type int [line: 134]
.   .   Sibling: 15  Assign: = of type int [line: 135]						   |	.   .   Sibling: 15  Assign: := of type int [line: 135]
.   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 135]			.   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 135]
.   .   .   Child: 1  Const 716 of type int [line: 135]							.   .   .   Child: 1  Const 716 of type int [line: 135]
.   .   Sibling: 16  Assign: = of type int [line: 136]						   |	.   .   Sibling: 16  Assign: := of type int [line: 136]
.   .   .   Child: 0  Id: XStep of type int [mem: Global loc: -4 size: 1] [line: 136]			.   .   .   Child: 0  Id: XStep of type int [mem: Global loc: -4 size: 1] [line: 136]
.   .   .   Child: 1  Op: / of type int [line: 136]							.   .   .   Child: 1  Op: / of type int [line: 136]
.   .   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 136]		.   .   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 136]
.   .   .   .   Child: 1  Const 40 of type int [line: 136]						.   .   .   .   Child: 1  Const 40 of type int [line: 136]
.   .   Sibling: 17  Assign: = of type int [line: 137]						   |	.   .   Sibling: 17  Assign: := of type int [line: 137]
.   .   .   Child: 0  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 137]			.   .   .   Child: 0  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 137]
.   .   .   Child: 1  Op: / of type int [line: 137]							.   .   .   Child: 1  Op: / of type int [line: 137]
.   .   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 137]		.   .   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 137]
.   .   .   .   Child: 1  Const 36 of type int [line: 137]						.   .   .   .   Child: 1  Const 36 of type int [line: 137]
.   .   Sibling: 18  Assign: = of type int [line: 138]						   |	.   .   Sibling: 18  Assign: := of type int [line: 138]
.   .   .   Child: 0  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 138]			.   .   .   Child: 0  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 138]
.   .   .   Child: 1  Op: + of type int [line: 138]							.   .   .   Child: 1  Op: + of type int [line: 138]
.   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 138]		.   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 138]
.   .   .   .   Child: 1  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 138]		.   .   .   .   Child: 1  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 138]
.   .   Sibling: 19  Assign: = of type int [line: 139]						   |	.   .   Sibling: 19  Assign: := of type int [line: 139]
.   .   .   Child: 0  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 139]			.   .   .   Child: 0  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 139]
.   .   .   Child: 1  Op: + of type int [line: 139]							.   .   .   Child: 1  Op: + of type int [line: 139]
.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 139]			.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 139]
.   .   .   .   Child: 1  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 139]		.   .   .   .   Child: 1  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 139]
.   .   Sibling: 20  Call: Mandelbrot of type void [line: 140]						.   .   Sibling: 20  Call: Mandelbrot of type void [line: 140]
.   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line: 140	.   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line: 140
.   .   Sibling: 21  Call: outnl of type void [line: 142]						.   .   Sibling: 21  Call: outnl of type void [line: 142]
.   .   Sibling: 22  Assign: = of type int [line: 144]						   |	.   .   Sibling: 22  Assign: := of type int [line: 144]
.   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 144]			.   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 144]
.   .   .   Child: 1  Op: chsign of type int [line: 144]						.   .   .   Child: 1  Op: chsign of type int [line: 144]
.   .   .   .   Child: 0  Const 320 of type int [line: 144]						.   .   .   .   Child: 0  Const 320 of type int [line: 144]
.   .   Sibling: 23  Assign: = of type int [line: 145]						   |	.   .   Sibling: 23  Assign: := of type int [line: 145]
.   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 145]			.   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 145]
.   .   .   Child: 1  Op: chsign of type int [line: 145]						.   .   .   Child: 1  Op: chsign of type int [line: 145]
.   .   .   .   Child: 0  Const 512 of type int [line: 145]						.   .   .   .   Child: 0  Const 512 of type int [line: 145]
.   .   Sibling: 24  Assign: = of type int [line: 146]						   |	.   .   Sibling: 24  Assign: := of type int [line: 146]
.   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 146]			.   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 146]
.   .   .   Child: 1  Const 640 of type int [line: 146]							.   .   .   Child: 1  Const 640 of type int [line: 146]
.   .   Sibling: 25  Assign: = of type int [line: 147]						   |	.   .   Sibling: 25  Assign: := of type int [line: 147]
.   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 147]			.   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 147]
.   .   .   Child: 1  Const 716 of type int [line: 147]							.   .   .   Child: 1  Const 716 of type int [line: 147]
.   .   Sibling: 26  Assign: = of type int [line: 148]						   |	.   .   Sibling: 26  Assign: := of type int [line: 148]
.   .   .   Child: 0  Id: XStep of type int [mem: Global loc: -4 size: 1] [line: 148]			.   .   .   Child: 0  Id: XStep of type int [mem: Global loc: -4 size: 1] [line: 148]
.   .   .   Child: 1  Op: / of type int [line: 148]							.   .   .   Child: 1  Op: / of type int [line: 148]
.   .   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 148]		.   .   .   .   Child: 0  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 148]
.   .   .   .   Child: 1  Const 40 of type int [line: 148]						.   .   .   .   Child: 1  Const 40 of type int [line: 148]
.   .   Sibling: 27  Assign: = of type int [line: 149]						   |	.   .   Sibling: 27  Assign: := of type int [line: 149]
.   .   .   Child: 0  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 149]			.   .   .   Child: 0  Id: YStep of type int [mem: Global loc: -5 size: 1] [line: 149]
.   .   .   Child: 1  Op: / of type int [line: 149]							.   .   .   Child: 1  Op: / of type int [line: 149]
.   .   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 149]		.   .   .   .   Child: 0  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 149]
.   .   .   .   Child: 1  Const 36 of type int [line: 149]						.   .   .   .   Child: 1  Const 36 of type int [line: 149]
.   .   Sibling: 28  Assign: = of type int [line: 150]						   |	.   .   Sibling: 28  Assign: := of type int [line: 150]
.   .   .   Child: 0  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 150]			.   .   .   Child: 0  Id: XMax of type int [mem: Global loc: -6 size: 1] [line: 150]
.   .   .   Child: 1  Op: + of type int [line: 150]							.   .   .   Child: 1  Op: + of type int [line: 150]
.   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 150]		.   .   .   .   Child: 0  Id: LEFT of type int [mem: Global loc: -1 size: 1] [line: 150]
.   .   .   .   Child: 1  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 150]		.   .   .   .   Child: 1  Id: WIDTH of type int [mem: Global loc: -3 size: 1] [line: 150]
.   .   Sibling: 29  Assign: = of type int [line: 151]						   |	.   .   Sibling: 29  Assign: := of type int [line: 151]
.   .   .   Child: 0  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 151]			.   .   .   Child: 0  Id: YMax of type int [mem: Global loc: -7 size: 1] [line: 151]
.   .   .   Child: 1  Op: + of type int [line: 151]							.   .   .   Child: 1  Op: + of type int [line: 151]
.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 151]			.   .   .   .   Child: 0  Id: TOP of type int [mem: Global loc: 0 size: 1] [line: 151]
.   .   .   .   Child: 1  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 151]		.   .   .   .   Child: 1  Id: HEIGHT of type int [mem: Global loc: -2 size: 1] [line: 151]
.   .   Sibling: 30  Call: Julia of type void [line: 152]						.   .   Sibling: 30  Call: Julia of type void [line: 152]
.   .   .   Child: 0  Op: [ of type int [line: 152]							.   .   .   Child: 0  Op: [ of type int [line: 152]
.   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line:	.   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line:
.   .   .   .   Child: 1  Const 0 of type int [line: 152]						.   .   .   .   Child: 1  Const 0 of type int [line: 152]
.   .   .   Sibling: 1  Op: [ of type int [line: 152]							.   .   .   Sibling: 1  Op: [ of type int [line: 152]
.   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line:	.   .   .   .   Child: 0  Id: JuliaVals of array of type int [mem: Local loc: -3 size: 3] [line:
.   .   .   .   Child: 1  Const 1 of type int [line: 152]						.   .   .   .   Child: 1  Const 1 of type int [line: 152]
Offset for end of global space: -22									Offset for end of global space: -22
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
fractal.out ztmp23114.txt differ: byte 186, line 3
fractal (Output DIFF)
WARNING(120): character is 4 characters long and not a single character: '' by ''.  The first ch	WARNING(120): character is 4 characters long and not a single character: '' by ''.  The first ch
WARNING(140): Variable 'JuliaVals' may be uninitialized when used here.					WARNING(140): Variable 'JuliaVals' may be uninitialized when used here.
Number of warnings: 2										   |	Loading file: BroadTests/fractal.tm
Number of errors: 0										   |	. . . . . . . . .                               . . . . . . . . . . . .
------------------------------------								   |	. . . . . . .                                         . . . . . . . . . .
Loading file: fractal.tm									   |	. . . . .                         ; ; ; ; # - - ; ;       . . . . . . . .
												   >	. . . .                         ; ; ; ; - - I W + - ; ; ;       . . . . . .
												   >	. . . .                         ; ; ; ; ; - - I @ @ O - ; ; ;       . . . . .
												   >	. . .                         ; ; ; ; ; - - I O @ @ I + - ; ; ;       . . . .
												   >	. . .                       ; ; ; ; ; ; - - + @ @ @ @ @ I - - ; ; ;       . . .
												   >	. .                       ; ; ; ; ; - - + + I # @ @ @ @ I + - - - ;         . .
												   >	. .                       ; ; ; ; ; - + I I I V # @ @ @ @ V I + + + - ;         .
												   >	.                       ; ; ; - - - + @ @ W @ @ @ @ @ @ @ @ @ V O V I - ;
												   >	.                     ; ; - - - - + I W @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ - ;
												   >	; ; - - - - - + + O # @ @ @ @ @ @ @ @ @ @ @ @ @ @ O - ;
												   >	.               ; ; + + + - - + + I O @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ O + - ;
												   >	; ; ; - + # O I O O I I O V @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ - ;
												   >	; ; ; ; - - + W @ # # @ @ V V @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ V - ;
												   >	; ; ; ; ; - - - I V @ @ @ @ @ @ # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I - ; ;
												   >	; ; ; ; ; - - - I O @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I - ; ;
												   >	; ; ; ; - + + I @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ # + - ; ;
												   >	. - + I I I I O W @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I - - ; ;
												   >	I O W # # # # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ W I - - ; ;
												   >	- - ; + + + I O # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ O + - ; ;
												   >	; ; ; ; - - + I @ V @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ + - ; ;
												   >	; ; ; ; - - - + I W @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I - ; ;
												   >	; ; ; ; - - - I O @ @ @ @ @ @ W @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I - ;
												   >	; ; ; ; - - + @ V V W # V O O # @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ - ;
												   >	.           ; ; ; + @ I + I I I I I O @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ V @ - ;
												   >	.                 ; - - - - - - + + I @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ I + - ;
												   >	; - - - - - + + O W @ @ @ @ @ @ @ @ @ @ @ @ @ @ V - ;
												   >	.                     ; ; ; - - - + I @ @ @ @ @ @ @ @ @ @ @ @ # @ @ @ - ;
												   >	. .                     ; ; ; ; - - + @ @ V W @ @ @ @ @ @ @ @ O I O I ;
												   >	.                         ; ; ; ; - - + + I O @ @ @ @ @ O I + + - ; ;         .
												   >	. .                         ; ; ; ; ; - - + I W @ @ @ @ I - - - ; ;         . .
												   >	. .                         ; ; ; ; ; - - + O # @ @ V + - - ; ; ;       . . .
												   >	. . .                         ; ; ; ; ; - - + O # # I - ; ; ; ;       . . . .
												   >	. . .                         ; ; ; ; ; - - I @ O @ ; ; ; ;       . . . . .
												   >	. . . . .                         ; ; ; ; - O I + - ; ;       . . . . . . .
												   >	. . . . .                           ; ; ; - - ; ;         . . . . . . . .
												   >	. . . . . . .                                       . . . . . . . . . .
												   >	. . . . . . . . . . . . . . . . . . . . . .
												   >	. . . . . . . . . . . . . . . . . . . . . .       ; ; ; ; ; ; ; ;
												   >	. . . . . . . . . . . . . . . . . . . . .     ; ; - T + - ; ; ; ; ; ; ; ;
												   >	. . . . . . . . . . . . . . . . . . . .       ; ; - I T + - - ; ; ; ; ; ; ;
												   >	. . . . . . . . . . . . . . . . . . . .       ; ; ; + V W I - - - ; ; ; ; ; -
												   >	. . . . . . . . . . . . . . . . . . .         ; ; ; - O T O I + - - - - - - +
												   >	. . . . . . . . . . . . . . . . . . .         ; ; ; - - + F T W V + + + + + I T
												   >	. . . . . . . . . . . . . . . . . .           ; ; ; - - + I V T O I I + + I W T
												   >	. . . . . . . . . . . . . . . . . .             ; ; ; - - + I O T F O I I O W T V
												   >	. . . . . . . . . . . . . . . . .               ; ; - - - + I O F T W W T W T F I
												   >	. . . . . . . . . . . . . . . .               ; ; ; - - + + O W T T T T W T V I +
												   >	. . . . . . . . . . . . . . .                 ; ; - - + + I V T W V V O O V W + -
												   >	. . . . . . . . . . . . . . .                   ; ; - I I I O W T O O I I I I + - -
												   >	. . . . . . . . . . . . . .                     ; ; I F V V V T F O I + + + + - - ;
												   >	. . . . . . . . . . . . .                     ; ; - + O F T T F T I + + + - - - ; ;
												   >	. . . . . . . . . . . .                       ; ; - + I V T F O O + + + - - - ; ; ;
												   >	. . . . . . . . . . . .                     ; ; ; - + I O T W O I + + - - - ; ; ; ;
												   >	. . . . . . . . . . .                       ; ; - - + I T T W I I + - - - - ; ; ;
												   >	. . . . . . . . . . .                       ; ; - - - + I V T T I + - - - - ; ; ;
												   >	. . . . . . . . . . .                     ; ; ; - - - + I W T T O + - - - ; ; ;
												   >	. . . . . . . . .                     ; ; ; - - - - + I F T T O + - - - ; ;
												   >	. . . . . . . . .                 ; ; ; ; - - - - + I I V T W O + - - ; ;
												   >	. . . . . . . .                 ; ; ; ; - - - - + + I O V T O I + - - ; ;
												   >	. . . . . . . .             ; ; ; ; ; ; - - - + + + I V F T V I + - ; ;
												   >	. . . . . . . .           ; ; ; ; ; ; - - + + + + I V T T F T T I - ; ;
												   >	. . . . . . .         ; ; ; ; ; ; ; - - + + + + I O F T V O I O I ; ;
												   >	. . . . . . .       ; ; ; ; ; ; ; - - I O I I I O V T F O I + + - ; ;
												   >	. . . . . .       ; ; ; ; - - - + + O T V V T V W T F I + + - - ; ;
												   >	. . . . . .     ; - - - - - + + + O V T T T T T T V O + + - - ; ; ;
												   >	. . . . . .     - O I + + I I I O F T V W V V F F O I + - - - ; ; ;             .
												   >	. . . . .     - W T T T O O V V T V O I I I O T V I + - - ; ; ;             . .
												   >	. . . . . .   ; + + I O T T F T O I + + + I O T F O + - - ; ; ;           . . .
												   >	. . . . .   ; ; - - I T O I W I + + + + + + O W T V - - ; ; ;         . . . .
												   >	. . . . .     ; ; - + F + + - - - ; - - - - + I W O + ; ; ;         . . . . .
												   >	. . . . .     ; ; O I - - ; ; ; ; ; ; - - - + V T T ; ; ;       . . . . . .
												   >	. . . . .         ; ; ; ; ; ; ; ; ; ; ; ; - + O + - ; ;     . . . . . . . .
												   >	. . . . .                   ; ; ; ; ; ; ; - T - ;       . . . . . . . . .
												   >	. . . . .                         ; ; ; ; ;         . . . . . . . . . .
Bye.													Bye.
====================================
FILE: fromroman.c-
-rw-------. 1 corg7983 domain_users  1362 Nov 17 15:35 fromroman.c-
-rw-------. 1 corg7983 domain_users  1360 Nov 17 15:35 fromroman.c-.f21
-rw-------. 1 corg7983 domain_users  1362 Nov 17 15:35 fromroman.c-.f22
-rw-------. 1 corg7983 domain_users   347 Nov 17 15:35 fromroman.expected
-rw-------. 1 corg7983 domain_users   150 Nov 17 15:35 fromroman.in
-rw-------. 1 corg7983 domain_users 13367 Nov 22 12:27 fromroman.mem
-rw-------. 1 corg7983 domain_users  2176 Nov 17 15:35 fromroman.mem.diffs
-rw-------. 1 corg7983 domain_users 14208 Nov 17 15:35 fromroman.mem.f21
-rw-------. 1 corg7983 domain_users  1015 Nov 22 12:27 fromroman.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 fromroman.tm
-rw-------. 1 corg7983 domain_users   748 Nov 17 15:35 fromroman.tm.diffs
-rw-------. 1 corg7983 domain_users 21556 Nov 17 15:35 fromroman.tm.f21
TM CODE COMPARISON
fromroman (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  fromroman.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getstring
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:    NEG  3,3,3	Op unary - 
												   >	 42:     ST  3,-3(1)	Store variable i
												   >	* WHILE
												   >	 43:    LDC  3,1(6)	Load Boolean constant 
												   >	 44:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL inputc
												   >	 46:     ST  1,-5(1)	Store fp in ghost frame for inputc
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end inputc
												   >	 47:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-27(7)	CALL inputc
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputc
												   >	* TOFF set: -5
												   >	 51:     ST  3,-4(1)	Store variable c
												   >	* IF
												   >	 52:     LD  3,-3(1)	Load variable i
												   >	 53:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 54:     LD  3,-2(1)	Load address of base of array s
												   >	 55:     LD  3,1(3)	Load array size 
												   >	* TOFF inc: -5
												   >	 56:     LD  4,-5(1)	Pop left into ac1 
												   >	 57:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 59:     LD  3,-3(1)	load lhs variable i
												   >	 60:    LDA  3,1(3)	increment value of i
												   >	 61:     ST  3,-3(1)	Store variable i
												   >	* EXPRESSION
												   >	 62:     LD  3,-3(1)	Load variable i
												   >	 63:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	 64:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -5
												   >	 65:     LD  4,-5(1)	Pop index 
												   >	 66:     LD  5,-2(1)	Load address of base of array s
												   >	 67:    SUB  5,5,4	Compute offset of value 
												   >	 68:     ST  3,0(5)	Store variable s
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 58:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 69:     LD  3,-4(1)	Load variable c
												   >	 70:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 71:    LDC  3,10(6)	Load char constant 
												   >	* TOFF inc: -5
												   >	 72:     LD  4,-5(1)	Pop left into ac1 
												   >	 73:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* BREAK
												   >	 75:    JMP  7,-31(7)	break 
												   >	 74:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	 76:    JMP  7,-34(7)	go to beginning of loop 
												   >	 45:    JMP  7,31(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 77:     LD  3,-3(1)	Load variable i
												   >	 78:    LDA  2,0(3)	Copy result to return register 
												   >	 79:     LD  3,-1(1)	Load return address 
												   >	 80:     LD  1,0(1)	Adjust fp 
												   >	 81:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 82:    LDC  2,0(6)	Set return value to 0 
												   >	 83:     LD  3,-1(1)	Load return address 
												   >	 84:     LD  1,0(1)	Adjust fp 
												   >	 85:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getstring
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION putstring
												   >	* TOFF set: -4
												   >	 86:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 87:    LDC  3,0(6)	Load integer constant 
												   >	 88:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	 89:     LD  3,-4(1)	Load variable i
												   >	 90:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 91:     LD  3,-2(1)	Load variable len
												   >	* TOFF inc: -5
												   >	 92:     LD  4,-5(1)	Pop left into ac1 
												   >	 93:    TLT  3,4,3	Op < 
												   >	 94:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	 96:     ST  1,-5(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 97:     LD  3,-3(1)	Load address of base of array s
												   >	 98:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 99:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -7
												   >	100:     LD  4,-7(1)	Pop left into ac1 
												   >	101:    SUB  3,4,3	compute location from index 
												   >	102:     LD  3,0(3)	Load array element 
												   >	103:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end outputc
												   >	104:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	105:    LDA  3,1(7)	Return address in ac 
												   >	106:    JMP  7,-79(7)	CALL outputc
												   >	107:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	108:     LD  3,-4(1)	load lhs variable i
												   >	109:    LDA  3,1(3)	increment value of i
												   >	110:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	111:    JMP  7,-23(7)	go to beginning of loop 
												   >	 95:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	112:    LDC  2,0(6)	Set return value to 0 
												   >	113:     LD  3,-1(1)	Load return address 
												   >	114:     LD  1,0(1)	Adjust fp 
												   >	115:    JMP  7,0(3)	Return 
												   >	* END FUNCTION putstring
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION charvalue
												   >	* TOFF set: -3
												   >	116:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	117:     LD  3,-2(1)	Load variable c
												   >	118:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	119:    LDC  3,73(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	120:     LD  4,-3(1)	Pop left into ac1 
												   >	121:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	123:    LDC  3,1(6)	Load integer constant 
												   >	124:    LDA  2,0(3)	Copy result to return register 
												   >	125:     LD  3,-1(1)	Load return address 
												   >	126:     LD  1,0(1)	Adjust fp 
												   >	127:    JMP  7,0(3)	Return 
												   >	122:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	129:     LD  3,-2(1)	Load variable c
												   >	130:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	131:    LDC  3,86(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	132:     LD  4,-3(1)	Pop left into ac1 
												   >	133:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	135:    LDC  3,5(6)	Load integer constant 
												   >	136:    LDA  2,0(3)	Copy result to return register 
												   >	137:     LD  3,-1(1)	Load return address 
												   >	138:     LD  1,0(1)	Adjust fp 
												   >	139:    JMP  7,0(3)	Return 
												   >	134:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	141:     LD  3,-2(1)	Load variable c
												   >	142:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	143:    LDC  3,88(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	144:     LD  4,-3(1)	Pop left into ac1 
												   >	145:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	147:    LDC  3,10(6)	Load integer constant 
												   >	148:    LDA  2,0(3)	Copy result to return register 
												   >	149:     LD  3,-1(1)	Load return address 
												   >	150:     LD  1,0(1)	Adjust fp 
												   >	151:    JMP  7,0(3)	Return 
												   >	146:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	153:     LD  3,-2(1)	Load variable c
												   >	154:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	155:    LDC  3,76(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	156:     LD  4,-3(1)	Pop left into ac1 
												   >	157:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	159:    LDC  3,50(6)	Load integer constant 
												   >	160:    LDA  2,0(3)	Copy result to return register 
												   >	161:     LD  3,-1(1)	Load return address 
												   >	162:     LD  1,0(1)	Adjust fp 
												   >	163:    JMP  7,0(3)	Return 
												   >	158:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	165:     LD  3,-2(1)	Load variable c
												   >	166:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	167:    LDC  3,67(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	168:     LD  4,-3(1)	Pop left into ac1 
												   >	169:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	171:    LDC  3,100(6)	Load integer constant 
												   >	172:    LDA  2,0(3)	Copy result to return register 
												   >	173:     LD  3,-1(1)	Load return address 
												   >	174:     LD  1,0(1)	Adjust fp 
												   >	175:    JMP  7,0(3)	Return 
												   >	170:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	177:     LD  3,-2(1)	Load variable c
												   >	178:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	179:    LDC  3,68(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	180:     LD  4,-3(1)	Pop left into ac1 
												   >	181:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	183:    LDC  3,500(6)	Load integer constant 
												   >	184:    LDA  2,0(3)	Copy result to return register 
												   >	185:     LD  3,-1(1)	Load return address 
												   >	186:     LD  1,0(1)	Adjust fp 
												   >	187:    JMP  7,0(3)	Return 
												   >	182:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	189:     LD  3,-2(1)	Load variable c
												   >	190:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	191:    LDC  3,77(6)	Load char constant 
												   >	* TOFF inc: -3
												   >	192:     LD  4,-3(1)	Pop left into ac1 
												   >	193:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	195:    LDC  3,1000(6)	Load integer constant 
												   >	196:    LDA  2,0(3)	Copy result to return register 
												   >	197:     LD  3,-1(1)	Load return address 
												   >	198:     LD  1,0(1)	Adjust fp 
												   >	199:    JMP  7,0(3)	Return 
												   >	194:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	201:    LDC  3,0(6)	Load integer constant 
												   >	202:    LDA  2,0(3)	Copy result to return register 
												   >	203:     LD  3,-1(1)	Load return address 
												   >	204:     LD  1,0(1)	Adjust fp 
												   >	205:    JMP  7,0(3)	Return 
												   >	200:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	188:    JMP  7,17(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	176:    JMP  7,29(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	164:    JMP  7,41(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	152:    JMP  7,53(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	140:    JMP  7,65(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	128:    JMP  7,77(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	206:    LDC  2,0(6)	Set return value to 0 
												   >	207:     LD  3,-1(1)	Load return address 
												   >	208:     LD  1,0(1)	Adjust fp 
												   >	209:    JMP  7,0(3)	Return 
												   >	* END FUNCTION charvalue
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION roman2arabic
												   >	* TOFF set: -4
												   >	210:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	211:    LDC  3,0(6)	Load integer constant 
												   >	212:     ST  3,-5(1)	Store variable sum
												   >	* EXPRESSION
												   >	213:    LDC  3,0(6)	Load integer constant 
												   >	214:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	215:     LD  3,-4(1)	Load variable i
												   >	216:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	217:     LD  3,-2(1)	Load variable len
												   >	218:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	219:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	220:     LD  4,-7(1)	Pop left into ac1 
												   >	221:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -6
												   >	222:     LD  4,-6(1)	Pop left into ac1 
												   >	223:    TLT  3,4,3	Op < 
												   >	224:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	* CALL charvalue
												   >	226:     ST  1,-6(1)	Store fp in ghost frame for charvalue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	227:     LD  3,-3(1)	Load address of base of array roman
												   >	228:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	229:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -8
												   >	230:     LD  4,-8(1)	Pop left into ac1 
												   >	231:    SUB  3,4,3	compute location from index 
												   >	232:     LD  3,0(3)	Load array element 
												   >	233:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end charvalue
												   >	234:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-121(7)	CALL charvalue
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end charvalue
												   >	* TOFF set: -6
												   >	238:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL charvalue
												   >	239:     ST  1,-7(1)	Store fp in ghost frame for charvalue
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	240:     LD  3,-3(1)	Load address of base of array roman
												   >	241:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	242:     LD  3,-4(1)	Load variable i
												   >	243:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	244:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	245:     LD  4,-10(1)	Pop left into ac1 
												   >	246:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -9
												   >	247:     LD  4,-9(1)	Pop left into ac1 
												   >	248:    SUB  3,4,3	compute location from index 
												   >	249:     LD  3,0(3)	Load array element 
												   >	250:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end charvalue
												   >	251:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	252:    LDA  3,1(7)	Return address in ac 
												   >	253:    JMP  7,-138(7)	CALL charvalue
												   >	254:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end charvalue
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	255:     LD  4,-6(1)	Pop left into ac1 
												   >	256:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL charvalue
												   >	258:     ST  1,-6(1)	Store fp in ghost frame for charvalue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	259:     LD  3,-3(1)	Load address of base of array roman
												   >	260:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	261:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -8
												   >	262:     LD  4,-8(1)	Pop left into ac1 
												   >	263:    SUB  3,4,3	compute location from index 
												   >	264:     LD  3,0(3)	Load array element 
												   >	265:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end charvalue
												   >	266:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	267:    LDA  3,1(7)	Return address in ac 
												   >	268:    JMP  7,-153(7)	CALL charvalue
												   >	269:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end charvalue
												   >	* TOFF set: -6
												   >	270:     LD  4,-5(1)	load lhs variable sum
												   >	271:    SUB  3,4,3	op -= 
												   >	272:     ST  3,-5(1)	Store variable sum
												   >	257:    JZR  3,16(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL charvalue
												   >	274:     ST  1,-6(1)	Store fp in ghost frame for charvalue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	275:     LD  3,-3(1)	Load address of base of array roman
												   >	276:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	277:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -8
												   >	278:     LD  4,-8(1)	Pop left into ac1 
												   >	279:    SUB  3,4,3	compute location from index 
												   >	280:     LD  3,0(3)	Load array element 
												   >	281:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end charvalue
												   >	282:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	283:    LDA  3,1(7)	Return address in ac 
												   >	284:    JMP  7,-169(7)	CALL charvalue
												   >	285:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end charvalue
												   >	* TOFF set: -6
												   >	286:     LD  4,-5(1)	load lhs variable sum
												   >	287:    ADD  3,4,3	op += 
												   >	288:     ST  3,-5(1)	Store variable sum
												   >	273:    JMP  7,15(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	289:     LD  3,-4(1)	load lhs variable i
												   >	290:    LDA  3,1(3)	increment value of i
												   >	291:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	292:    JMP  7,-78(7)	go to beginning of loop 
												   >	225:    JMP  7,67(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL charvalue
												   >	293:     ST  1,-6(1)	Store fp in ghost frame for charvalue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	294:     LD  3,-3(1)	Load address of base of array roman
												   >	295:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	296:     LD  3,-2(1)	Load variable len
												   >	297:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	298:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	299:     LD  4,-9(1)	Pop left into ac1 
												   >	300:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -8
												   >	301:     LD  4,-8(1)	Pop left into ac1 
												   >	302:    SUB  3,4,3	compute location from index 
												   >	303:     LD  3,0(3)	Load array element 
												   >	304:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end charvalue
												   >	305:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	306:    LDA  3,1(7)	Return address in ac 
												   >	307:    JMP  7,-192(7)	CALL charvalue
												   >	308:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end charvalue
												   >	* TOFF set: -6
												   >	309:     LD  4,-5(1)	load lhs variable sum
												   >	310:    ADD  3,4,3	op += 
												   >	311:     ST  3,-5(1)	Store variable sum
												   >	* RETURN
												   >	312:     LD  3,-5(1)	Load variable sum
												   >	313:    LDA  2,0(3)	Copy result to return register 
												   >	314:     LD  3,-1(1)	Load return address 
												   >	315:     LD  1,0(1)	Adjust fp 
												   >	316:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	317:    LDC  2,0(6)	Set return value to 0 
												   >	318:     LD  3,-1(1)	Load return address 
												   >	319:     LD  1,0(1)	Adjust fp 
												   >	320:    JMP  7,0(3)	Return 
												   >	* END FUNCTION roman2arabic
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	321:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -54
												   >	322:    LDC  3,50(6)	load size of array s
												   >	323:     ST  3,-2(1)	save size of array s
												   >	* Compound Body
												   >	* WHILE
												   >	324:    LDC  3,1(6)	Load Boolean constant 
												   >	325:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -54
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL getstring
												   >	327:     ST  1,-54(1)	Store fp in ghost frame for getstring
												   >	* TOFF dec: -55
												   >	* TOFF dec: -56
												   >	* Param 1
												   >	328:    LDA  3,-3(1)	Load address of base of array s
												   >	329:     ST  3,-56(1)	Push parameter 
												   >	* TOFF dec: -57
												   >	* Param end getstring
												   >	330:    LDA  1,-54(1)	Ghost frame becomes new active frame 
												   >	331:    LDA  3,1(7)	Return address in ac 
												   >	332:    JMP  7,-294(7)	CALL getstring
												   >	333:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getstring
												   >	* TOFF set: -54
												   >	334:     ST  3,-53(1)	Store variable len
												   >	* IF
												   >	335:    LDA  3,-3(1)	Load address of base of array s
												   >	336:     ST  3,-54(1)	Push left side 
												   >	* TOFF dec: -55
												   >	337:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -54
												   >	338:     LD  4,-54(1)	Pop left into ac1 
												   >	339:    SUB  3,4,3	compute location from index 
												   >	340:     LD  3,0(3)	Load array element 
												   >	341:     ST  3,-54(1)	Push left side 
												   >	* TOFF dec: -55
												   >	342:    LDC  3,113(6)	Load char constant 
												   >	* TOFF inc: -54
												   >	343:     LD  4,-54(1)	Pop left into ac1 
												   >	344:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* BREAK
												   >	346:    JMP  7,-21(7)	break 
												   >	345:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL putstring
												   >	347:     ST  1,-54(1)	Store fp in ghost frame for putstring
												   >	* TOFF dec: -55
												   >	* TOFF dec: -56
												   >	* Param 1
												   >	348:     LD  3,-53(1)	Load variable len
												   >	349:     ST  3,-56(1)	Push parameter 
												   >	* TOFF dec: -57
												   >	* Param 2
												   >	350:    LDA  3,-3(1)	Load address of base of array s
												   >	351:     ST  3,-57(1)	Push parameter 
												   >	* TOFF dec: -58
												   >	* Param end putstring
												   >	352:    LDA  1,-54(1)	Ghost frame becomes new active frame 
												   >	353:    LDA  3,1(7)	Return address in ac 
												   >	354:    JMP  7,-269(7)	CALL putstring
												   >	355:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end putstring
												   >	* TOFF set: -54
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	356:     ST  1,-54(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -55
												   >	* TOFF dec: -56
												   >	* Param end outnl
												   >	357:    LDA  1,-54(1)	Ghost frame becomes new active frame 
												   >	358:    LDA  3,1(7)	Return address in ac 
												   >	359:    JMP  7,-326(7)	CALL outnl
												   >	360:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -54
												   >	* EXPRESSION
												   >	* CALL output
												   >	361:     ST  1,-54(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -55
												   >	* TOFF dec: -56
												   >	* Param 1
												   >	* CALL roman2arabic
												   >	362:     ST  1,-56(1)	Store fp in ghost frame for roman2arabic
												   >	* TOFF dec: -57
												   >	* TOFF dec: -58
												   >	* Param 1
												   >	363:     LD  3,-53(1)	Load variable len
												   >	364:     ST  3,-58(1)	Push parameter 
												   >	* TOFF dec: -59
												   >	* Param 2
												   >	365:    LDA  3,-3(1)	Load address of base of array s
												   >	366:     ST  3,-59(1)	Push parameter 
												   >	* TOFF dec: -60
												   >	* Param end roman2arabic
												   >	367:    LDA  1,-56(1)	Ghost frame becomes new active frame 
												   >	368:    LDA  3,1(7)	Return address in ac 
												   >	369:    JMP  7,-160(7)	CALL roman2arabic
												   >	370:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end roman2arabic
												   >	* TOFF set: -56
												   >	371:     ST  3,-56(1)	Push parameter 
												   >	* TOFF dec: -57
												   >	* Param end output
												   >	372:    LDA  1,-54(1)	Ghost frame becomes new active frame 
												   >	373:    LDA  3,1(7)	Return address in ac 
												   >	374:    JMP  7,-369(7)	CALL output
												   >	375:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -54
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	376:     ST  1,-54(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -55
												   >	* TOFF dec: -56
												   >	* Param end outnl
												   >	377:    LDA  1,-54(1)	Ghost frame becomes new active frame 
												   >	378:    LDA  3,1(7)	Return address in ac 
												   >	379:    JMP  7,-346(7)	CALL outnl
												   >	380:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -54
												   >	* TOFF set: -54
												   >	* END COMPOUND
												   >	381:    JMP  7,-58(7)	go to beginning of loop 
												   >	326:    JMP  7,55(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	382:    LDC  2,0(6)	Set return value to 0 
												   >	383:     LD  3,-1(1)	Load return address 
												   >	384:     LD  1,0(1)	Adjust fp 
												   >	385:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,385(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	386:    LDA  1,0(0)	set first frame at end of globals 
												   >	387:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	388:    LDA  3,1(7)	Return address in ac 
												   >	389:    JMP  7,-69(7)	Jump to main 
												   >	390:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
fromroman.mem fromroman.mem.f21 differ: byte 70, line 2
fromroman (MEM DIFF)
WARNING(70): Variable 's' may be uninitialized when used here.						WARNING(70): Variable 's' may be uninitialized when used here.
Func: getstring returns type int [mem: Global loc: 0 size: -3] [line: 5]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: getstring returns type int [mem: Global loc: 0 size: -3] [line: 5]
.   Child: 0  Parm: s of array of type char [mem: Parameter loc: -2 size: 1] [line: 5]			.   Child: 0  Parm: s of array of type char [mem: Parameter loc: -2 size: 1] [line: 5]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 6]
.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 7]				.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   Child: 1  Assign: = of type int [line: 9]						   |	.   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   Child: 1  Op: chsign of type int [line: 9]							.   .   .   Child: 1  Op: chsign of type int [line: 9]
.   .   .   .   Child: 0  Const 1 of type int [line: 9]							.   .   .   .   Child: 0  Const 1 of type int [line: 9]
.   .   Sibling: 1  While [line: 10]									.   .   Sibling: 1  While [line: 10]
.   .   .   Child: 0  Const true of type bool [line: 10]						.   .   .   Child: 0  Const true of type bool [line: 10]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]
.   .   .   .   Child: 0  Var: c of type char [mem: Local loc: -4 size: 1] [line: 11]			.   .   .   .   Child: 0  Var: c of type char [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   Child: 1  Assign: = of type char [line: 13]					   |	.   .   .   .   Child: 1  Assign: := of type char [line: 13]
.   .   .   .   .   Child: 0  Id: c of type char [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   Child: 0  Id: c of type char [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   Child: 1  Call: inputc of type char [line: 13]					.   .   .   .   .   Child: 1  Call: inputc of type char [line: 13]
.   .   .   .   Sibling: 1  If [line: 14]								.   .   .   .   Sibling: 1  If [line: 14]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 14]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 14]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 14]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   .   .   .   Child: 1  Op: sizeof of type int [line: 14]					.   .   .   .   .   .   Child: 1  Op: sizeof of type int [line: 14]
.   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -2 size: 	.   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -2 size: 
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 14]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 14]
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 15]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 15]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 15]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   .   .   .   .   Sibling: 1  Assign: = of type char [line: 16]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type char [line: 16]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 16]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 16]
.   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -2 si	.   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -2 si
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Id: c of type char [mem: Local loc: -4 size: 1] [line: 16]	.   .   .   .   .   .   .   Child: 1  Id: c of type char [mem: Local loc: -4 size: 1] [line: 16]
.   .   .   .   Sibling: 2  If [line: 18]								.   .   .   .   Sibling: 2  If [line: 18]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 18]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 18]
.   .   .   .   .   .   Child: 0  Id: c of type char [mem: Local loc: -4 size: 1] [line: 18]		.   .   .   .   .   .   Child: 0  Id: c of type char [mem: Local loc: -4 size: 1] [line: 18]
.   .   .   .   .   .   Child: 1  Const '								.   .   .   .   .   .   Child: 1  Const '
' of type char [line: 18]										' of type char [line: 18]
.   .   .   .   .   Child: 1  Break [line: 18]								.   .   .   .   .   Child: 1  Break [line: 18]
.   .   Sibling: 2  Return [line: 21]									.   .   Sibling: 2  Return [line: 21]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 21]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 21]
Sibling: 1  Func: putstring returns type void [mem: Global loc: 0 size: -4] [line: 24]		   |	Sibling: 8  Func: putstring returns type void [mem: Global loc: 0 size: -4] [line: 24]
.   Child: 0  Parm: len of type int [mem: Parameter loc: -2 size: 1] [line: 24]				.   Child: 0  Parm: len of type int [mem: Parameter loc: -2 size: 1] [line: 24]
.   Sibling: 1  Parm: s of array of type char [mem: Parameter loc: -3 size: 1] [line: 24]		.   Sibling: 1  Parm: s of array of type char [mem: Parameter loc: -3 size: 1] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 26]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 26]
.   .   Child: 1  Assign: = of type int [line: 28]						   |	.   .   Child: 1  Assign: := of type int [line: 28]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]
.   .   .   Child: 1  Const 0 of type int [line: 28]							.   .   .   Child: 1  Const 0 of type int [line: 28]
.   .   Sibling: 1  While [line: 29]									.   .   Sibling: 1  While [line: 29]
.   .   .   Child: 0  Op: < of type bool [line: 29]							.   .   .   Child: 0  Op: < of type bool [line: 29]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 29]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 29]
.   .   .   .   Child: 1  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 29]		.   .   .   .   Child: 1  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 29]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]
.   .   .   .   Child: 1  Call: outputc of type void [line: 30]						.   .   .   .   Child: 1  Call: outputc of type void [line: 30]
.   .   .   .   .   Child: 0  Op: [ of type char [line: 30]						.   .   .   .   .   Child: 0  Op: [ of type char [line: 30]
.   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -3 size: 1] [	.   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Parameter loc: -3 size: 1] [
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 30]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 30]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 31]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 31]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 31]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 31]
Sibling: 2  Func: charvalue returns type int [mem: Global loc: 0 size: -3] [line: 35]		   |	Sibling: 9  Func: charvalue returns type int [mem: Global loc: 0 size: -3] [line: 35]
.   Child: 0  Parm: c of type char [mem: Parameter loc: -2 size: 1] [line: 35]				.   Child: 0  Parm: c of type char [mem: Parameter loc: -2 size: 1] [line: 35]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]
.   .   Child: 1  If [line: 37]										.   .   Child: 1  If [line: 37]
.   .   .   Child: 0  Op: == of type bool [line: 37]						   |	.   .   .   Child: 0  Op: = of type bool [line: 37]
.   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 37]		.   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 37]
.   .   .   .   Child: 1  Const 'I' of type char [line: 37]						.   .   .   .   Child: 1  Const 'I' of type char [line: 37]
.   .   .   Child: 1  Return [line: 37]									.   .   .   Child: 1  Return [line: 37]
.   .   .   .   Child: 0  Const 1 of type int [line: 37]						.   .   .   .   Child: 0  Const 1 of type int [line: 37]
.   .   .   Child: 2  If [line: 38]									.   .   .   Child: 2  If [line: 38]
.   .   .   .   Child: 0  Op: == of type bool [line: 38]					   |	.   .   .   .   Child: 0  Op: = of type bool [line: 38]
.   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 38]		.   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 38]
.   .   .   .   .   Child: 1  Const 'V' of type char [line: 38]						.   .   .   .   .   Child: 1  Const 'V' of type char [line: 38]
.   .   .   .   Child: 1  Return [line: 38]								.   .   .   .   Child: 1  Return [line: 38]
.   .   .   .   .   Child: 0  Const 5 of type int [line: 38]						.   .   .   .   .   Child: 0  Const 5 of type int [line: 38]
.   .   .   .   Child: 2  If [line: 39]									.   .   .   .   Child: 2  If [line: 39]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 39]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 39]
.   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 39]	.   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line: 39]
.   .   .   .   .   .   Child: 1  Const 'X' of type char [line: 39]					.   .   .   .   .   .   Child: 1  Const 'X' of type char [line: 39]
.   .   .   .   .   Child: 1  Return [line: 39]								.   .   .   .   .   Child: 1  Return [line: 39]
.   .   .   .   .   .   Child: 0  Const 10 of type int [line: 39]					.   .   .   .   .   .   Child: 0  Const 10 of type int [line: 39]
.   .   .   .   .   Child: 2  If [line: 40]								.   .   .   .   .   Child: 2  If [line: 40]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 40]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 40]
.   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Const 'L' of type char [line: 40]					.   .   .   .   .   .   .   Child: 1  Const 'L' of type char [line: 40]
.   .   .   .   .   .   Child: 1  Return [line: 40]							.   .   .   .   .   .   Child: 1  Return [line: 40]
.   .   .   .   .   .   .   Child: 0  Const 50 of type int [line: 40]					.   .   .   .   .   .   .   Child: 0  Const 50 of type int [line: 40]
.   .   .   .   .   .   Child: 2  If [line: 41]								.   .   .   .   .   .   Child: 2  If [line: 41]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 41]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 41]
.   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   .   .   Child: 1  Const 'C' of type char [line: 41]				.   .   .   .   .   .   .   .   Child: 1  Const 'C' of type char [line: 41]
.   .   .   .   .   .   .   Child: 1  Return [line: 41]							.   .   .   .   .   .   .   Child: 1  Return [line: 41]
.   .   .   .   .   .   .   .   Child: 0  Const 100 of type int [line: 41]				.   .   .   .   .   .   .   .   Child: 0  Const 100 of type int [line: 41]
.   .   .   .   .   .   .   Child: 2  If [line: 42]							.   .   .   .   .   .   .   Child: 2  If [line: 42]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 42]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 42]
.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   .   .   Child: 1  Const 'D' of type char [line: 42]				.   .   .   .   .   .   .   .   .   Child: 1  Const 'D' of type char [line: 42]
.   .   .   .   .   .   .   .   Child: 1  Return [line: 42]						.   .   .   .   .   .   .   .   Child: 1  Return [line: 42]
.   .   .   .   .   .   .   .   .   Child: 0  Const 500 of type int [line: 42]				.   .   .   .   .   .   .   .   .   Child: 0  Const 500 of type int [line: 42]
.   .   .   .   .   .   .   .   Child: 2  If [line: 43]							.   .   .   .   .   .   .   .   Child: 2  If [line: 43]
.   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 43]			   |	.   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 siz	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type char [mem: Parameter loc: -2 siz
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 'M' of type char [line: 43]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 'M' of type char [line: 43]
.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 43]						.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 43]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1000 of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1000 of type int [line: 43]
.   .   .   .   .   .   .   .   .   Child: 2  Return [line: 44]						.   .   .   .   .   .   .   .   .   Child: 2  Return [line: 44]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 0 of type int [line: 44]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 0 of type int [line: 44]
Sibling: 3  Func: roman2arabic returns type int [mem: Global loc: 0 size: -4] [line: 47]	   |	Sibling: 10  Func: roman2arabic returns type int [mem: Global loc: 0 size: -4] [line: 47]
.   Child: 0  Parm: len of type int [mem: Parameter loc: -2 size: 1] [line: 47]				.   Child: 0  Parm: len of type int [mem: Parameter loc: -2 size: 1] [line: 47]
.   Sibling: 1  Parm: roman of array of type char [mem: Parameter loc: -3 size: 1] [line: 47]		.   Sibling: 1  Parm: roman of array of type char [mem: Parameter loc: -3 size: 1] [line: 47]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 48]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 48]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 49]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 49]
.   .   Sibling: 1  Var: sum of type int [mem: Local loc: -5 size: 1] [line: 49]			.   .   Sibling: 1  Var: sum of type int [mem: Local loc: -5 size: 1] [line: 49]
.   .   Child: 1  Assign: = of type int [line: 51]						   |	.   .   Child: 1  Assign: := of type int [line: 51]
.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 51]			.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 51]
.   .   .   Child: 1  Const 0 of type int [line: 51]							.   .   .   Child: 1  Const 0 of type int [line: 51]
.   .   Sibling: 1  Assign: = of type int [line: 52]						   |	.   .   Sibling: 1  Assign: := of type int [line: 52]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 52]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 52]
.   .   .   Child: 1  Const 0 of type int [line: 52]							.   .   .   Child: 1  Const 0 of type int [line: 52]
.   .   Sibling: 2  While [line: 53]									.   .   Sibling: 2  While [line: 53]
.   .   .   Child: 0  Op: < of type bool [line: 53]							.   .   .   Child: 0  Op: < of type bool [line: 53]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 53]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 53]
.   .   .   .   Child: 1  Op: - of type int [line: 53]							.   .   .   .   Child: 1  Op: - of type int [line: 53]
.   .   .   .   .   Child: 0  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 53]		.   .   .   .   .   Child: 0  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 53]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 53]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 53]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 53]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 53]
.   .   .   .   Child: 1  If [line: 54]									.   .   .   .   Child: 1  If [line: 54]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 54]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 54]
.   .   .   .   .   .   Child: 0  Call: charvalue of type int [line: 54]				.   .   .   .   .   .   Child: 0  Call: charvalue of type int [line: 54]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -	.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 54]				.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 54]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -	.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -
.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 54]					.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 54]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]
.   .   .   .   .   Child: 1  Assign: -= of type int [line: 54]						.   .   .   .   .   Child: 1  Assign: -= of type int [line: 54]
.   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 54]		.   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 54]
.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 54]				.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 54]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -	.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 
.   .   .   .   .   Child: 2  Assign: += of type int [line: 55]						.   .   .   .   .   Child: 2  Assign: += of type int [line: 55]
.   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 55]		.   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 55]
.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 55]				.   .   .   .   .   .   Child: 1  Call: charvalue of type int [line: 55]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 55]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 55]
.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -	.   .   .   .   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 56]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 56]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 56]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 56]
.   .   Sibling: 3  Assign: += of type int [line: 58]							.   .   Sibling: 3  Assign: += of type int [line: 58]
.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 58]			.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 58]
.   .   .   Child: 1  Call: charvalue of type int [line: 58]						.   .   .   Child: 1  Call: charvalue of type int [line: 58]
.   .   .   .   Child: 0  Op: [ of type char [line: 58]							.   .   .   .   Child: 0  Op: [ of type char [line: 58]
.   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -3 size: 1] [	.   .   .   .   .   Child: 0  Id: roman of array of type char [mem: Parameter loc: -3 size: 1] [
.   .   .   .   .   Child: 1  Op: - of type int [line: 58]						.   .   .   .   .   Child: 1  Op: - of type int [line: 58]
.   .   .   .   .   .   Child: 0  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 58	.   .   .   .   .   .   Child: 0  Id: len of type int [mem: Parameter loc: -2 size: 1] [line: 58
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 58]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 58]
.   .   Sibling: 4  Return [line: 60]									.   .   Sibling: 4  Return [line: 60]
.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 60]			.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -5 size: 1] [line: 60]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 64]		   |	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 64]
.   Child: 1  Compound [mem: None loc: 0 size: -54] [line: 65]						.   Child: 1  Compound [mem: None loc: 0 size: -54] [line: 65]
.   .   Child: 0  Var: s of array of type char [mem: Local loc: -3 size: 51] [line: 66]			.   .   Child: 0  Var: s of array of type char [mem: Local loc: -3 size: 51] [line: 66]
.   .   Sibling: 1  Var: len of type int [mem: Local loc: -53 size: 1] [line: 67]			.   .   Sibling: 1  Var: len of type int [mem: Local loc: -53 size: 1] [line: 67]
.   .   Child: 1  While [line: 69]									.   .   Child: 1  While [line: 69]
.   .   .   Child: 0  Const true of type bool [line: 69]						.   .   .   Child: 0  Const true of type bool [line: 69]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -54] [line: 69]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -54] [line: 69]
.   .   .   .   Child: 1  Assign: = of type int [line: 70]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 70]
.   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 70]		.   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 70]
.   .   .   .   .   Child: 1  Call: getstring of type int [line: 70]					.   .   .   .   .   Child: 1  Call: getstring of type int [line: 70]
.   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -3 size: 51] [lin	.   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -3 size: 51] [lin
.   .   .   .   Sibling: 1  If [line: 71]								.   .   .   .   Sibling: 1  If [line: 71]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 71]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 71]
.   .   .   .   .   .   Child: 0  Op: [ of type char [line: 71]						.   .   .   .   .   .   Child: 0  Op: [ of type char [line: 71]
.   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -3 size: 51] 	.   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -3 size: 51] 
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 71]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 71]
.   .   .   .   .   .   Child: 1  Const 'q' of type char [line: 71]					.   .   .   .   .   .   Child: 1  Const 'q' of type char [line: 71]
.   .   .   .   .   Child: 1  Break [line: 71]								.   .   .   .   .   Child: 1  Break [line: 71]
.   .   .   .   Sibling: 2  Call: putstring of type void [line: 72]					.   .   .   .   Sibling: 2  Call: putstring of type void [line: 72]
.   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 72]		.   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 72]
.   .   .   .   .   Sibling: 1  Id: s of array of type char [mem: Local loc: -3 size: 51] [line:	.   .   .   .   .   Sibling: 1  Id: s of array of type char [mem: Local loc: -3 size: 51] [line:
.   .   .   .   Sibling: 3  Call: outnl of type void [line: 73]						.   .   .   .   Sibling: 3  Call: outnl of type void [line: 73]
.   .   .   .   Sibling: 4  Call: output of type void [line: 74]					.   .   .   .   Sibling: 4  Call: output of type void [line: 74]
.   .   .   .   .   Child: 0  Call: roman2arabic of type int [line: 74]					.   .   .   .   .   Child: 0  Call: roman2arabic of type int [line: 74]
.   .   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 74]		.   .   .   .   .   .   Child: 0  Id: len of type int [mem: Local loc: -53 size: 1] [line: 74]
.   .   .   .   .   .   Sibling: 1  Id: s of array of type char [mem: Local loc: -3 size: 51] [l	.   .   .   .   .   .   Sibling: 1  Id: s of array of type char [mem: Local loc: -3 size: 51] [l
.   .   .   .   Sibling: 5  Call: outnl of type void [line: 75]						.   .   .   .   Sibling: 5  Call: outnl of type void [line: 75]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
fromroman.out ztmp23114.txt differ: byte 64, line 2
fromroman (Output DIFF)
WARNING(70): Variable 's' may be uninitialized when used here.						WARNING(70): Variable 's' may be uninitialized when used here.
Number of warnings: 1										   |	Loading file: BroadTests/fromroman.tm
Number of errors: 0										   |	I
------------------------------------								   |	1
Loading file: fromroman.tm									   |	II
ERROR: TM Command I unknown.									   |	2
ERROR: TM Command I unknown.									   |	III
ERROR: TM Command I unknown.									   |	3
ERROR: TM Command I unknown.									   |	IIII
ERROR: TM Command I unknown.									   |	4
ERROR: TM Command V unknown.									   |	IV
ERROR: TM Command V unknown.									   |	4
ERROR: TM Command V unknown.									   |	V
ERROR: TM Command V unknown.									   |	5
ERROR: TM Command V unknown.									   |	VV
ERROR: TM Command I unknown.									   |	10
ERROR: TM Command I unknown.									   |	VI
ERROR: TM Command M unknown.									   |	6
ERROR: TM Command X unknown.									   |	VII
ERROR: TM Command X unknown.									   |	7
ERROR: TM Command L unknown.									   |	VIIIII
ERROR: TM Command X unknown.									   |	10
ERROR: TM Command C unknown.									   |	IX
ERROR: TM Command M unknown.									   |	9
ERROR: TM Command M unknown.									   |	IM
ERROR: TM Command D unknown.									   |	999
ERROR: TM Command D unknown.									   |	MI
ERROR: TM Command M unknown.									   |	1001
ERROR: TM Command M unknown.									   |	XX
ERROR: TM Command C unknown.									   |	20
ERROR: TM Command C unknown.									   |	XL
ERROR: TM Command L unknown.									   |	40
ERROR: TM Command M unknown.									   |	LX
												   >	60
												   >	XC
												   >	90
												   >	CX
												   >	110
												   >	MDCCCCLVII
												   >	1957
												   >	MCDXCIX
												   >	1499
												   >	DIM
												   >	1499
												   >	DILL
												   >	599
												   >	MILL
												   >	1099
												   >	MILD
												   >	1449
												   >	CIVIC
												   >	203
												   >	CIVIL
												   >	153
												   >	LIVID
												   >	553
												   >	MIMIC
ERROR: TM Command V unknown.										ERROR: TM Command V unknown.
Bye.													Bye.
====================================
FILE: gcd.c-
-rw-------. 1 corg7983 domain_users  313 Nov 17 15:35 gcd.c-
-rw-------. 1 corg7983 domain_users  315 Nov 17 15:35 gcd.c-.f21
-rw-------. 1 corg7983 domain_users  313 Nov 17 15:35 gcd.c-.f22
-rw-------. 1 corg7983 domain_users  310 Nov 17 15:35 gcd.expected
-rw-------. 1 corg7983 domain_users   74 Nov 17 15:35 gcd.in
-rw-------. 1 corg7983 domain_users 2796 Nov 22 12:27 gcd.mem
-rw-------. 1 corg7983 domain_users  476 Nov 17 15:35 gcd.mem.diffs
-rw-------. 1 corg7983 domain_users 3639 Nov 17 15:35 gcd.mem.f21
-rw-------. 1 corg7983 domain_users  479 Nov 22 12:27 gcd.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 gcd.tm
-rw-------. 1 corg7983 domain_users  210 Nov 17 15:35 gcd.tm.diffs
-rw-------. 1 corg7983 domain_users 7044 Nov 17 15:35 gcd.tm.f21
TM CODE COMPARISON
gcd (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  gcd.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION gcd
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-3(1)	Load variable v
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 46:     LD  3,-2(1)	Load variable u
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	* CALL gcd
												   >	 52:     ST  1,-4(1)	Store fp in ghost frame for gcd
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 53:     LD  3,-3(1)	Load variable v
												   >	 54:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 55:     LD  3,-2(1)	Load variable u
												   >	 56:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 57:     LD  3,-2(1)	Load variable u
												   >	 58:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 59:     LD  3,-3(1)	Load variable v
												   >	* TOFF inc: -8
												   >	 60:     LD  4,-8(1)	Pop left into ac1 
												   >	 61:    DIV  3,4,3	Op / 
												   >	 62:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 63:     LD  3,-3(1)	Load variable v
												   >	* TOFF inc: -8
												   >	 64:     LD  4,-8(1)	Pop left into ac1 
												   >	 65:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -7
												   >	 66:     LD  4,-7(1)	Pop left into ac1 
												   >	 67:    SUB  3,4,3	Op - 
												   >	 68:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end gcd
												   >	 69:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-33(7)	CALL gcd
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end gcd
												   >	* TOFF set: -4
												   >	 73:    LDA  2,0(3)	Copy result to return register 
												   >	 74:     LD  3,-1(1)	Load return address 
												   >	 75:     LD  1,0(1)	Adjust fp 
												   >	 76:    JMP  7,0(3)	Return 
												   >	 51:    JMP  7,25(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 77:    LDC  2,0(6)	Set return value to 0 
												   >	 78:     LD  3,-1(1)	Load return address 
												   >	 79:     LD  1,0(1)	Adjust fp 
												   >	 80:    JMP  7,0(3)	Return 
												   >	* END FUNCTION gcd
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 81:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 82:     ST  1,-5(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end input
												   >	 83:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-85(7)	CALL input
												   >	 86:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -5
												   >	 87:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL input
												   >	 88:     ST  1,-5(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end input
												   >	 89:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-91(7)	CALL input
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -5
												   >	 93:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL gcd
												   >	 94:     ST  1,-5(1)	Store fp in ghost frame for gcd
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 95:     LD  3,-2(1)	Load variable x
												   >	 96:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	 97:     LD  3,-3(1)	Load variable y
												   >	 98:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end gcd
												   >	 99:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-63(7)	CALL gcd
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end gcd
												   >	* TOFF set: -5
												   >	103:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	104:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	105:     LD  3,-4(1)	Load variable z
												   >	106:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	107:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-104(7)	CALL output
												   >	110:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	111:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	112:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	113:    LDA  3,1(7)	Return address in ac 
												   >	114:    JMP  7,-81(7)	CALL outnl
												   >	115:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	116:    LDC  2,0(6)	Set return value to 0 
												   >	117:     LD  3,-1(1)	Load return address 
												   >	118:     LD  1,0(1)	Adjust fp 
												   >	119:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,119(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	120:    LDA  1,0(0)	set first frame at end of globals 
												   >	121:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	122:    LDA  3,1(7)	Return address in ac 
												   >	123:    JMP  7,-43(7)	Jump to main 
												   >	124:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
gcd.mem gcd.mem.f21 differ: byte 7, line 1
gcd (MEM DIFF)
Func: gcd returns type int [mem: Global loc: 0 size: -4] [line: 4]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: gcd returns type int [mem: Global loc: 0 size: -4] [line: 4]
.   Child: 0  Parm: u of type int [mem: Parameter loc: -2 size: 1] [line: 4]				.   Child: 0  Parm: u of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   Sibling: 1  Parm: v of type int [mem: Parameter loc: -3 size: 1] [line: 4]				.   Sibling: 1  Parm: v of type int [mem: Parameter loc: -3 size: 1] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]
.   .   Child: 1  If [line: 6]										.   .   Child: 1  If [line: 6]
.   .   .   Child: 0  Op: == of type bool [line: 6]						   |	.   .   .   Child: 0  Op: = of type bool [line: 6]
.   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 0 of type int [line: 6]							.   .   .   .   Child: 1  Const 0 of type int [line: 6]
.   .   .   Child: 1  Return [line: 7]									.   .   .   Child: 1  Return [line: 7]
.   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   Child: 2  Return [line: 9]									.   .   .   Child: 2  Return [line: 9]
.   .   .   .   Child: 0  Call: gcd of type int [line: 9]						.   .   .   .   Child: 0  Call: gcd of type int [line: 9]
.   .   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 9]		.   .   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 9]
.   .   .   .   .   Sibling: 1  Op: - of type int [line: 9]						.   .   .   .   .   Sibling: 1  Op: - of type int [line: 9]
.   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 9]		.   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 9]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 9]
.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 9]					.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 9]
.   .   .   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 12]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 12]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 13]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 13]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 14]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 14]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 14]				.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 14]
.   .   Child: 1  Assign: = of type int [line: 16]						   |	.   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   .   Child: 1  Call: input of type int [line: 16]						.   .   .   Child: 1  Call: input of type int [line: 16]
.   .   Sibling: 1  Assign: = of type int [line: 17]						   |	.   .   Sibling: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   Child: 1  Call: input of type int [line: 17]						.   .   .   Child: 1  Call: input of type int [line: 17]
.   .   Sibling: 2  Assign: = of type int [line: 18]						   |	.   .   Sibling: 2  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 18]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   .   Child: 1  Call: gcd of type int [line: 18]							.   .   .   Child: 1  Call: gcd of type int [line: 18]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]			.   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   Sibling: 3  Call: output of type void [line: 19]						.   .   Sibling: 3  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 19]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 19]
.   .   Sibling: 4  Call: outnl of type void [line: 20]							.   .   Sibling: 4  Call: outnl of type void [line: 20]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
gcd.out ztmp23114.txt differ: byte 1, line 1
gcd (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/gcd.tm
Number of errors: 0										   |	entered: 60
------------------------------------								   |	entered: 210
Loading file: gcd.tm										   |	30
ERROR: TM Command 6 unknown.									   |	Loading file: BroadTests/gcd.tm
ERROR: TM Command 2 unknown.									   |	entered: 210
Loading file: gcd.tm										   |	entered: 60
ERROR: TM Command 2 unknown.									   |	30
ERROR: TM Command 6 unknown.									   |	Loading file: BroadTests/gcd.tm
Loading file: gcd.tm										   |	entered: 8192
ERROR: TM Command 8 unknown.									   |	entered: 496
ERROR: TM Command 4 unknown.									   |	16
Loading file: gcd.tm										   |	Loading file: BroadTests/gcd.tm
ERROR: TM Command 1 unknown.									   |	entered: 1234
ERROR: TM Command 4 unknown.									   |	entered: 4321
Loading file: gcd.tm										   |	1
ERROR: TM Command 2 unknown.									   |	Loading file: BroadTests/gcd.tm
ERROR: TM Command 6 unknown.									   |	entered: 216
												   >	entered: 666
												   >	18
Bye.													Bye.
====================================
FILE: gcdsm.c-
-rw-------. 1 corg7983 domain_users  160 Nov 17 15:35 gcdsm.c-
-rw-------. 1 corg7983 domain_users  161 Nov 17 15:35 gcdsm.c-.f21
-rw-------. 1 corg7983 domain_users  160 Nov 17 15:35 gcdsm.c-.f22
-rw-------. 1 corg7983 domain_users  320 Nov 17 15:35 gcdsm.expected
-rw-------. 1 corg7983 domain_users   74 Nov 17 15:35 gcdsm.in
-rw-------. 1 corg7983 domain_users 2434 Nov 22 12:27 gcdsm.mem
-rw-------. 1 corg7983 domain_users  351 Nov 17 15:35 gcdsm.mem.diffs
-rw-------. 1 corg7983 domain_users 3276 Nov 17 15:35 gcdsm.mem.f21
-rw-------. 1 corg7983 domain_users  489 Nov 22 12:27 gcdsm.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 gcdsm.tm
-rw-------. 1 corg7983 domain_users  210 Nov 17 15:35 gcdsm.tm.diffs
-rw-------. 1 corg7983 domain_users 6621 Nov 17 15:35 gcdsm.tm.f21
TM CODE COMPARISON
gcdsm (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  gcdsm.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION gcd
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-3(1)	Load variable v
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 46:     LD  3,-2(1)	Load variable u
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	* CALL gcd
												   >	 52:     ST  1,-4(1)	Store fp in ghost frame for gcd
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 53:     LD  3,-3(1)	Load variable v
												   >	 54:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 55:     LD  3,-2(1)	Load variable u
												   >	 56:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 57:     LD  3,-2(1)	Load variable u
												   >	 58:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 59:     LD  3,-3(1)	Load variable v
												   >	* TOFF inc: -8
												   >	 60:     LD  4,-8(1)	Pop left into ac1 
												   >	 61:    DIV  3,4,3	Op / 
												   >	 62:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 63:     LD  3,-3(1)	Load variable v
												   >	* TOFF inc: -8
												   >	 64:     LD  4,-8(1)	Pop left into ac1 
												   >	 65:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -7
												   >	 66:     LD  4,-7(1)	Pop left into ac1 
												   >	 67:    SUB  3,4,3	Op - 
												   >	 68:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end gcd
												   >	 69:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-33(7)	CALL gcd
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end gcd
												   >	* TOFF set: -4
												   >	 73:    LDA  2,0(3)	Copy result to return register 
												   >	 74:     LD  3,-1(1)	Load return address 
												   >	 75:     LD  1,0(1)	Adjust fp 
												   >	 76:    JMP  7,0(3)	Return 
												   >	 51:    JMP  7,25(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 77:    LDC  2,0(6)	Set return value to 0 
												   >	 78:     LD  3,-1(1)	Load return address 
												   >	 79:     LD  1,0(1)	Adjust fp 
												   >	 80:    JMP  7,0(3)	Return 
												   >	* END FUNCTION gcd
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 81:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 82:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	 83:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-85(7)	CALL input
												   >	 86:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	 87:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL input
												   >	 88:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	 89:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-91(7)	CALL input
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	 93:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 94:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	* CALL gcd
												   >	 95:     ST  1,-6(1)	Store fp in ghost frame for gcd
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 96:     LD  3,-2(1)	Load variable x
												   >	 97:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	 98:     LD  3,-3(1)	Load variable y
												   >	 99:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end gcd
												   >	100:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-64(7)	CALL gcd
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end gcd
												   >	* TOFF set: -6
												   >	104:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	105:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	106:    LDA  3,1(7)	Return address in ac 
												   >	107:    JMP  7,-102(7)	CALL output
												   >	108:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	109:    LDC  2,0(6)	Set return value to 0 
												   >	110:     LD  3,-1(1)	Load return address 
												   >	111:     LD  1,0(1)	Adjust fp 
												   >	112:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,112(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	113:    LDA  1,0(0)	set first frame at end of globals 
												   >	114:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-36(7)	Jump to main 
												   >	117:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
gcdsm.mem gcdsm.mem.f21 differ: byte 7, line 1
gcdsm (MEM DIFF)
Func: gcd returns type int [mem: Global loc: 0 size: -4] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: gcd returns type int [mem: Global loc: 0 size: -4] [line: 1]
.   Child: 0  Parm: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Sibling: 1  Parm: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]				.   Sibling: 1  Parm: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]
.   .   Child: 1  If [line: 1]										.   .   Child: 1  If [line: 1]
.   .   .   Child: 0  Op: == of type bool [line: 1]						   |	.   .   .   Child: 0  Op: = of type bool [line: 1]
.   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]			.   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   .   .   .   Child: 1  Const 0 of type int [line: 1]							.   .   .   .   Child: 1  Const 0 of type int [line: 1]
.   .   .   Child: 1  Return [line: 1]									.   .   .   Child: 1  Return [line: 1]
.   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   .   .   Child: 2  Return [line: 1]									.   .   .   Child: 2  Return [line: 1]
.   .   .   .   Child: 0  Call: gcd of type int [line: 1]						.   .   .   .   Child: 0  Call: gcd of type int [line: 1]
.   .   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]		.   .   .   .   .   Child: 0  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   .   .   .   .   Sibling: 1  Op: - of type int [line: 1]						.   .   .   .   .   Sibling: 1  Op: - of type int [line: 1]
.   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]		.   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 1]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 1]
.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 1]					.   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 1]
.   .   .   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: u of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 1  Id: v of type int [mem: Parameter loc: -3 size: 1] [line: 
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Call: input of type int [line: 7]							.   .   .   Child: 1  Call: input of type int [line: 7]
.   .   Sibling: 1  Assign: = of type int [line: 8]						   |	.   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   Child: 1  Call: input of type int [line: 8]							.   .   .   Child: 1  Call: input of type int [line: 8]
.   .   Sibling: 2  Call: output of type void [line: 9]							.   .   Sibling: 2  Call: output of type void [line: 9]
.   .   .   Child: 0  Call: gcd of type int [line: 9]							.   .   .   Child: 0  Call: gcd of type int [line: 9]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
gcdsm.out ztmp23114.txt differ: byte 1, line 1
gcdsm (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/gcdsm.tm
Number of errors: 0										   |	entered: 60
------------------------------------								   |	entered: 210
Loading file: gcdsm.tm										   |	30
ERROR: TM Command 6 unknown.									   |	Loading file: BroadTests/gcdsm.tm
ERROR: TM Command 2 unknown.									   |	entered: 210
Loading file: gcdsm.tm										   |	entered: 60
ERROR: TM Command 2 unknown.									   |	30
ERROR: TM Command 6 unknown.									   |	Loading file: BroadTests/gcdsm.tm
Loading file: gcdsm.tm										   |	entered: 8192
ERROR: TM Command 8 unknown.									   |	entered: 496
ERROR: TM Command 4 unknown.									   |	16
Loading file: gcdsm.tm										   |	Loading file: BroadTests/gcdsm.tm
ERROR: TM Command 1 unknown.									   |	entered: 1234
ERROR: TM Command 4 unknown.									   |	entered: 4321
Loading file: gcdsm.tm										   |	1
ERROR: TM Command 2 unknown.									   |	Loading file: BroadTests/gcdsm.tm
ERROR: TM Command 6 unknown.									   |	entered: 216
												   >	entered: 666
												   >	18
Bye.													Bye.
====================================
FILE: globalArray.c-
-rw-------. 1 corg7983 domain_users  115 Nov 17 15:35 globalArray.c-
-rw-------. 1 corg7983 domain_users  117 Nov 17 15:35 globalArray.c-.f21
-rw-------. 1 corg7983 domain_users  115 Nov 17 15:35 globalArray.c-.f22
-rw-------. 1 corg7983 domain_users   51 Nov 17 15:35 globalArray.expected
-rw-------. 1 corg7983 domain_users 1536 Nov 22 12:27 globalArray.mem
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 globalArray.mem.diffs
-rw-------. 1 corg7983 domain_users 2379 Nov 17 15:35 globalArray.mem.f21
-rw-------. 1 corg7983 domain_users  113 Nov 22 12:27 globalArray.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 globalArray.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 globalArray.tm.diffs
-rw-------. 1 corg7983 domain_users 5137 Nov 17 15:35 globalArray.tm.f21
TM CODE COMPARISON
globalArray (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  globalArray.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,2(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	 42:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 43:     LD  4,-2(1)	Pop index 
												   >	 44:    LDA  5,-1(0)	Load address of base of array x
												   >	 45:    SUB  5,5,4	Compute offset of value 
												   >	 46:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	 47:    LDC  3,3(6)	Load integer constant 
												   >	 48:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	 49:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -2
												   >	 50:     LD  4,-2(1)	Pop index 
												   >	 51:    LDA  5,-5(0)	Load address of base of array b
												   >	 52:    SUB  5,5,4	Compute offset of value 
												   >	 53:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	 54:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 55:    LDA  3,-1(0)	Load address of base of array x
												   >	 56:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 57:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 58:     LD  4,-4(1)	Pop left into ac1 
												   >	 59:    SUB  3,4,3	compute location from index 
												   >	 60:     LD  3,0(3)	Load array element 
												   >	 61:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 62:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 63:    LDA  3,1(7)	Return address in ac 
												   >	 64:    JMP  7,-59(7)	CALL output
												   >	 65:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 66:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 67:    LDA  3,-5(0)	Load address of base of array b
												   >	 68:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 69:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 70:     LD  4,-4(1)	Pop left into ac1 
												   >	 71:    SUB  3,4,3	compute location from index 
												   >	 72:     LD  3,0(3)	Load array element 
												   >	 73:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 74:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-60(7)	CALL outputb
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* RETURN
												   >	 78:     LD  3,-1(1)	Load return address 
												   >	 79:     LD  1,0(1)	Adjust fp 
												   >	 80:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 81:    LDC  2,0(6)	Set return value to 0 
												   >	 82:     LD  3,-1(1)	Load return address 
												   >	 83:     LD  1,0(1)	Adjust fp 
												   >	 84:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,84(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 85:    LDA  1,-9(0)	set first frame at end of globals 
												   >	 86:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	 87:    LDC  3,4(6)	load size of array b
												   >	 88:     ST  3,-4(0)	save size of array b
												   >	 89:    LDC  3,3(6)	load size of array x
												   >	 90:     ST  3,0(0)	save size of array x
												   >	* END INIT GLOBALS AND STATICS
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-54(7)	Jump to main 
												   >	 93:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
globalArray.mem globalArray.mem.f21 differ: byte 1, line 1
globalArray (MEM DIFF)
Var: x of array of type int [mem: Global loc: -1 size: 4] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: b of array of type bool [mem: Global loc: -5 size: 5] [line: 2]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: x of array of type int [mem: Global loc: -1 size: 4] [line: 1]
												   >	Sibling: 8  Var: b of array of type bool [mem: Global loc: -5 size: 5] [line: 2]
												   >	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 4] [line: 6]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 4] [line: 6]
.   .   .   .   Child: 1  Const 2 of type int [line: 6]							.   .   .   .   Child: 1  Const 2 of type int [line: 6]
.   .   .   Child: 1  Const 666 of type int [line: 6]							.   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type bool [line: 7]						   |	.   .   Sibling: 1  Assign: := of type bool [line: 7]
.   .   .   Child: 0  Op: [ of type bool [line: 7]							.   .   .   Child: 0  Op: [ of type bool [line: 7]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Global loc: -5 size: 5] [line: 7]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Global loc: -5 size: 5] [line: 7]
.   .   .   .   Child: 1  Const 3 of type int [line: 7]							.   .   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   .   Child: 1  Const true of type bool [line: 7]							.   .   .   Child: 1  Const true of type bool [line: 7]
.   .   Sibling: 2  Call: output of type void [line: 9]							.   .   Sibling: 2  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 4] [line: 9]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 4] [line: 9]
.   .   .   .   Child: 1  Const 2 of type int [line: 9]							.   .   .   .   Child: 1  Const 2 of type int [line: 9]
.   .   Sibling: 3  Call: outputb of type void [line: 10]						.   .   Sibling: 3  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: [ of type bool [line: 10]							.   .   .   Child: 0  Op: [ of type bool [line: 10]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Global loc: -5 size: 5] [line: 10]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Global loc: -5 size: 5] [line: 10]
.   .   .   .   Child: 1  Const 3 of type int [line: 10]						.   .   .   .   Child: 1  Const 3 of type int [line: 10]
.   .   Sibling: 4  Return [line: 12]									.   .   Sibling: 4  Return [line: 12]
Offset for end of global space: -9									Offset for end of global space: -9
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
globalArray.out ztmp23114.txt differ: byte 1, line 1
globalArray (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/globalArray.tm
Number of errors: 0										   |	666 T
------------------------------------								   <
Loading file: globalArray.tm									   <
Bye.													Bye.
====================================
FILE: global.c-
-rw-------. 1 corg7983 domain_users  102 Nov 17 15:35 global.c-
-rw-------. 1 corg7983 domain_users  104 Nov 17 15:35 global.c-.f21
-rw-------. 1 corg7983 domain_users  102 Nov 17 15:35 global.c-.f22
-rw-------. 1 corg7983 domain_users   46 Nov 17 15:35 global.expected
-rw-------. 1 corg7983 domain_users 1035 Nov 22 12:27 global.mem
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 global.mem.diffs
-rw-------. 1 corg7983 domain_users 1878 Nov 17 15:35 global.mem.f21
-rw-------. 1 corg7983 domain_users  108 Nov 22 12:27 global.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 global.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 global.tm.diffs
-rw-------. 1 corg7983 domain_users 3989 Nov 17 15:35 global.tm.f21
TM CODE COMPARISON
global (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  global.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,666(6)	Load integer constant 
												   >	 41:     ST  3,0(0)	Store variable x
												   >	* EXPRESSION
												   >	 42:    LDC  3,1(6)	Load Boolean constant 
												   >	 43:     ST  3,-1(0)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	 44:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 45:     LD  3,0(0)	Load variable x
												   >	 46:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 47:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-44(7)	CALL output
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 51:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 52:     LD  3,-1(0)	Load variable b
												   >	 53:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 54:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 55:    LDA  3,1(7)	Return address in ac 
												   >	 56:    JMP  7,-40(7)	CALL outputb
												   >	 57:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* RETURN
												   >	 58:     LD  3,-1(1)	Load return address 
												   >	 59:     LD  1,0(1)	Adjust fp 
												   >	 60:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 61:    LDC  2,0(6)	Set return value to 0 
												   >	 62:     LD  3,-1(1)	Load return address 
												   >	 63:     LD  1,0(1)	Adjust fp 
												   >	 64:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,64(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 65:    LDA  1,-2(0)	set first frame at end of globals 
												   >	 66:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-30(7)	Jump to main 
												   >	 69:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
global.mem global.mem.f21 differ: byte 1, line 1
global (MEM DIFF)
Var: x of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: b of type bool [mem: Global loc: -1 size: 1] [line: 2]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: x of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: b of type bool [mem: Global loc: -1 size: 1] [line: 2]
												   >	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 6]				.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 6]
.   .   .   Child: 1  Const 666 of type int [line: 6]							.   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type bool [line: 7]						   |	.   .   Sibling: 1  Assign: := of type bool [line: 7]
.   .   .   Child: 0  Id: b of type bool [mem: Global loc: -1 size: 1] [line: 7]			.   .   .   Child: 0  Id: b of type bool [mem: Global loc: -1 size: 1] [line: 7]
.   .   .   Child: 1  Const true of type bool [line: 7]							.   .   .   Child: 1  Const true of type bool [line: 7]
.   .   Sibling: 2  Call: output of type void [line: 9]							.   .   Sibling: 2  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 9]				.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 9]
.   .   Sibling: 3  Call: outputb of type void [line: 10]						.   .   Sibling: 3  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Id: b of type bool [mem: Global loc: -1 size: 1] [line: 10]			.   .   .   Child: 0  Id: b of type bool [mem: Global loc: -1 size: 1] [line: 10]
.   .   Sibling: 4  Return [line: 12]									.   .   Sibling: 4  Return [line: 12]
Offset for end of global space: -2									Offset for end of global space: -2
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
global.out ztmp23114.txt differ: byte 1, line 1
global (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/global.tm
Number of errors: 0										   |	666 T
------------------------------------								   <
Loading file: global.tm										   <
Bye.													Bye.
====================================
FILE: if.c-
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 if.c-
-rw-------. 1 corg7983 domain_users  149 Nov 17 15:35 if.c-.f21
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 if.c-.f22
-rw-------. 1 corg7983 domain_users   43 Nov 17 15:35 if.expected
-rw-------. 1 corg7983 domain_users 2099 Nov 22 12:27 if.mem
-rw-------. 1 corg7983 domain_users  724 Nov 17 15:35 if.mem.diffs
-rw-------. 1 corg7983 domain_users 2944 Nov 17 15:35 if.mem.f21
-rw-------. 1 corg7983 domain_users  104 Nov 22 12:27 if.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 if.tm
-rw-------. 1 corg7983 domain_users  212 Nov 17 15:35 if.tm.diffs
-rw-------. 1 corg7983 domain_users 5081 Nov 17 15:35 if.tm.f21
TM CODE COMPARISON
if (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  if.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,23(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable j
												   >	 42:     ST  3,-2(1)	Store variable i
												   >	* IF
												   >	 43:     LD  3,-2(1)	Load variable i
												   >	 44:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 45:     LD  3,-3(1)	Load variable j
												   >	* TOFF inc: -4
												   >	 46:     LD  4,-4(1)	Pop left into ac1 
												   >	 47:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	 49:    LDC  3,666(6)	Load integer constant 
												   >	 50:     ST  3,-2(1)	Store variable i
												   >	 48:    JZR  3,2(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 51:     LD  3,-3(1)	Load variable j
												   >	 52:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 53:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -4
												   >	 54:     LD  4,-4(1)	Pop left into ac1 
												   >	 55:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	 57:    LDC  3,666(6)	Load integer constant 
												   >	 58:     ST  3,-2(1)	Store variable i
												   >	 56:    JZR  3,3(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	 60:    LDC  3,777(6)	Load integer constant 
												   >	 61:     ST  3,-3(1)	Store variable j
												   >	 59:    JMP  7,2(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL output
												   >	 62:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 63:     LD  3,-2(1)	Load variable i
												   >	 64:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 65:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 66:    LDA  3,1(7)	Return address in ac 
												   >	 67:    JMP  7,-62(7)	CALL output
												   >	 68:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 69:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 70:     LD  3,-3(1)	Load variable j
												   >	 71:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 72:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-69(7)	CALL output
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 76:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 77:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-46(7)	CALL outnl
												   >	 80:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 81:    LDC  2,0(6)	Set return value to 0 
												   >	 82:     LD  3,-1(1)	Load return address 
												   >	 83:     LD  1,0(1)	Adjust fp 
												   >	 84:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,84(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 85:    LDA  1,0(0)	set first frame at end of globals 
												   >	 86:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-50(7)	Jump to main 
												   >	 89:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
if.mem if.mem.f21 differ: byte 7, line 1
if (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 5]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   .   .   Child: 1  Const 23 of type int [line: 5]						.   .   .   .   Child: 1  Const 23 of type int [line: 5]
.   .   Sibling: 1  If [line: 6]									.   .   Sibling: 1  If [line: 6]
.   .   .   Child: 0  Op: > of type bool [line: 6]							.   .   .   Child: 0  Op: > of type bool [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 666 of type int [line: 6]						.   .   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 2  If [line: 7]									.   .   Sibling: 2  If [line: 7]
.   .   .   Child: 0  Op: == of type bool [line: 7]						   |	.   .   .   Child: 0  Op: = of type bool [line: 7]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 666 of type int [line: 7]						.   .   .   .   Child: 1  Const 666 of type int [line: 7]
.   .   .   Child: 2  Assign: = of type int [line: 8]						   |	.   .   .   Child: 2  Assign: := of type int [line: 8]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 777 of type int [line: 8]						.   .   .   .   Child: 1  Const 777 of type int [line: 8]
.   .   Sibling: 3  Call: output of type void [line: 10]						.   .   Sibling: 3  Call: output of type void [line: 10]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   Sibling: 4  Call: output of type void [line: 11]						.   .   Sibling: 4  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 11]				.   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   Sibling: 5  Call: outnl of type void [line: 12]							.   .   Sibling: 5  Call: outnl of type void [line: 12]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
if.out ztmp23114.txt differ: byte 1, line 1
if (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/if.tm
Number of errors: 0										   |	666 23
------------------------------------								   <
Loading file: if.tm										   <
Bye.													Bye.
====================================
FILE: inc.c-
-rw-------. 1 corg7983 domain_users   423 Nov 17 15:35 inc.c-
-rw-------. 1 corg7983 domain_users   428 Nov 17 15:35 inc.c-.f21
-rw-------. 1 corg7983 domain_users   423 Nov 17 15:35 inc.c-.f22
-rw-------. 1 corg7983 domain_users    85 Nov 17 15:35 inc.expected
-rw-------. 1 corg7983 domain_users  5009 Nov 22 12:27 inc.mem
-rw-------. 1 corg7983 domain_users   601 Nov 17 15:35 inc.mem.diffs
-rw-------. 1 corg7983 domain_users  5855 Nov 17 15:35 inc.mem.f21
-rw-------. 1 corg7983 domain_users   105 Nov 22 12:27 inc.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 inc.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 inc.tm.diffs
-rw-------. 1 corg7983 domain_users 11555 Nov 17 15:35 inc.tm.f21
TM CODE COMPARISON
inc (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  inc.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	 40:    LDC  3,1(6)	load size of array z
												   >	 41:     ST  3,-3(1)	save size of array z
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 42:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 43:    LDC  3,0(6)	Load integer constant 
												   >	 44:     LD  5,-2(1)	Load address of base of array y
												   >	 45:    SUB  5,5,3	Compute offset of value 
												   >	 46:     LD  3,0(5)	load lhs variable y
												   >	 47:    LDA  3,1(3)	increment value of y
												   >	 48:     ST  3,0(5)	Store variable y
												   >	 49:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 50:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-47(7)	CALL output
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	 54:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 55:     LD  3,-2(1)	Load address of base of array y
												   >	 56:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 57:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 58:     LD  4,-8(1)	Pop left into ac1 
												   >	 59:    SUB  3,4,3	compute location from index 
												   >	 60:     LD  3,0(3)	Load array element 
												   >	 61:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 62:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 63:    LDA  3,1(7)	Return address in ac 
												   >	 64:    JMP  7,-59(7)	CALL output
												   >	 65:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	 66:    LDC  3,777(6)	Load integer constant 
												   >	 67:     ST  3,-5(1)	Store variable w
												   >	* EXPRESSION
												   >	 68:    LDC  3,0(6)	Load integer constant 
												   >	 69:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 70:    LDC  3,888(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 71:     LD  4,-6(1)	Pop index 
												   >	 72:    LDA  5,-4(1)	Load address of base of array z
												   >	 73:    SUB  5,5,4	Compute offset of value 
												   >	 74:     ST  3,0(5)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	 75:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 76:     LD  3,-5(1)	load lhs variable w
												   >	 77:    LDA  3,1(3)	increment value of w
												   >	 78:     ST  3,-5(1)	Store variable w
												   >	 79:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 80:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-77(7)	CALL output
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	 84:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 85:     LD  3,-5(1)	Load variable w
												   >	 86:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 87:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-84(7)	CALL output
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	 91:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 92:    LDC  3,0(6)	Load integer constant 
												   >	 93:    LDA  5,-4(1)	Load address of base of array z
												   >	 94:    SUB  5,5,3	Compute offset of value 
												   >	 95:     LD  3,0(5)	load lhs variable z
												   >	 96:    LDA  3,1(3)	increment value of z
												   >	 97:     ST  3,0(5)	Store variable z
												   >	 98:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 99:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-96(7)	CALL output
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	103:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	104:    LDA  3,-4(1)	Load address of base of array z
												   >	105:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	106:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	107:     LD  4,-8(1)	Pop left into ac1 
												   >	108:    SUB  3,4,3	compute location from index 
												   >	109:     LD  3,0(3)	Load array element 
												   >	110:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	111:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	112:    LDA  3,1(7)	Return address in ac 
												   >	113:    JMP  7,-108(7)	CALL output
												   >	114:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	115:    LDC  3,1023(6)	Load integer constant 
												   >	116:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	117:     LD  3,0(0)	load lhs variable g
												   >	118:    LDA  3,1(3)	increment value of g
												   >	119:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	120:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	121:     LD  3,0(0)	Load variable g
												   >	122:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	123:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	124:    LDA  3,1(7)	Return address in ac 
												   >	125:    JMP  7,-120(7)	CALL output
												   >	126:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	127:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	128:     LD  3,0(0)	load lhs variable g
												   >	129:    LDA  3,1(3)	increment value of g
												   >	130:     ST  3,0(0)	Store variable g
												   >	131:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	132:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	133:    LDA  3,1(7)	Return address in ac 
												   >	134:    JMP  7,-129(7)	CALL output
												   >	135:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	136:    LDC  2,0(6)	Set return value to 0 
												   >	137:     LD  3,-1(1)	Load return address 
												   >	138:     LD  1,0(1)	Adjust fp 
												   >	139:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	140:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	141:    LDC  3,1(6)	load size of array x
												   >	142:     ST  3,-2(1)	save size of array x
												   >	* Compound Body
												   >	* EXPRESSION
												   >	143:    LDC  3,0(6)	Load integer constant 
												   >	144:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	145:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	146:     LD  4,-4(1)	Pop index 
												   >	147:    LDA  5,-3(1)	Load address of base of array x
												   >	148:    SUB  5,5,4	Compute offset of value 
												   >	149:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	* CALL cat
												   >	150:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	151:    LDA  3,-3(1)	Load address of base of array x
												   >	152:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end cat
												   >	153:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	154:    LDA  3,1(7)	Return address in ac 
												   >	155:    JMP  7,-117(7)	CALL cat
												   >	156:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	157:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	158:    LDA  3,-3(1)	Load address of base of array x
												   >	159:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	160:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	161:     LD  4,-6(1)	Pop left into ac1 
												   >	162:    SUB  3,4,3	compute location from index 
												   >	163:     LD  3,0(3)	Load array element 
												   >	164:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	165:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-162(7)	CALL output
												   >	168:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	169:    LDC  3,1023(6)	Load integer constant 
												   >	170:     ST  3,-1(0)	Store variable s
												   >	* EXPRESSION
												   >	171:     LD  3,-1(0)	load lhs variable s
												   >	172:    LDA  3,1(3)	increment value of s
												   >	173:     ST  3,-1(0)	Store variable s
												   >	* EXPRESSION
												   >	* CALL output
												   >	174:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	175:     LD  3,-1(0)	Load variable s
												   >	176:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	177:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	178:    LDA  3,1(7)	Return address in ac 
												   >	179:    JMP  7,-174(7)	CALL output
												   >	180:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	181:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	182:     LD  3,-1(0)	load lhs variable s
												   >	183:    LDA  3,1(3)	increment value of s
												   >	184:     ST  3,-1(0)	Store variable s
												   >	185:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	186:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	187:    LDA  3,1(7)	Return address in ac 
												   >	188:    JMP  7,-183(7)	CALL output
												   >	189:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* RETURN
												   >	190:    LDC  3,0(6)	Load integer constant 
												   >	191:    LDA  2,0(3)	Copy result to return register 
												   >	192:     LD  3,-1(1)	Load return address 
												   >	193:     LD  1,0(1)	Adjust fp 
												   >	194:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	195:    LDC  2,0(6)	Set return value to 0 
												   >	196:     LD  3,-1(1)	Load return address 
												   >	197:     LD  1,0(1)	Adjust fp 
												   >	198:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,198(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	199:    LDA  1,-2(0)	set first frame at end of globals 
												   >	200:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	201:    LDA  3,1(7)	Return address in ac 
												   >	202:    JMP  7,-63(7)	Jump to main 
												   >	203:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
inc.mem inc.mem.f21 differ: byte 1, line 1
inc (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 3]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   Child: 0  Parm: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 4]
.   .   Child: 0  Var: z of array of type int [mem: Local loc: -4 size: 2] [line: 5]			.   .   Child: 0  Var: z of array of type int [mem: Local loc: -4 size: 2] [line: 5]
.   .   Sibling: 1  Var: w of type int [mem: Local loc: -5 size: 1] [line: 6]				.   .   Sibling: 1  Var: w of type int [mem: Local loc: -5 size: 1] [line: 6]
.   .   Child: 1  Call: output of type void [line: 8]							.   .   Child: 1  Call: output of type void [line: 8]
.   .   .   Child: 0  Assign: ++ of type int [line: 8]							.   .   .   Child: 0  Assign: ++ of type int [line: 8]
.   .   .   .   Child: 0  Op: [ of type int [line: 8]							.   .   .   .   Child: 0  Op: [ of type int [line: 8]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   Child: 1  Const 0 of type int [line: 8]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 8]
.   .   Sibling: 1  Call: output of type void [line: 9]							.   .   Sibling: 1  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 9]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Const 0 of type int [line: 9]							.   .   .   .   Child: 1  Const 0 of type int [line: 9]
.   .   Sibling: 2  Assign: = of type int [line: 11]						   |	.   .   Sibling: 2  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 11]				.   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 11]
.   .   .   Child: 1  Const 777 of type int [line: 11]							.   .   .   Child: 1  Const 777 of type int [line: 11]
.   .   Sibling: 3  Assign: = of type int [line: 12]						   |	.   .   Sibling: 3  Assign: := of type int [line: 12]
.   .   .   Child: 0  Op: [ of type int [line: 12]							.   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 12]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 12]
.   .   .   .   Child: 1  Const 0 of type int [line: 12]						.   .   .   .   Child: 1  Const 0 of type int [line: 12]
.   .   .   Child: 1  Const 888 of type int [line: 12]							.   .   .   Child: 1  Const 888 of type int [line: 12]
.   .   Sibling: 4  Call: output of type void [line: 13]						.   .   Sibling: 4  Call: output of type void [line: 13]
.   .   .   Child: 0  Assign: ++ of type int [line: 13]							.   .   .   Child: 0  Assign: ++ of type int [line: 13]
.   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 13]			.   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 13]
.   .   Sibling: 5  Call: output of type void [line: 14]						.   .   Sibling: 5  Call: output of type void [line: 14]
.   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 14]				.   .   .   Child: 0  Id: w of type int [mem: Local loc: -5 size: 1] [line: 14]
.   .   Sibling: 6  Call: output of type void [line: 15]						.   .   Sibling: 6  Call: output of type void [line: 15]
.   .   .   Child: 0  Assign: ++ of type int [line: 15]							.   .   .   Child: 0  Assign: ++ of type int [line: 15]
.   .   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 15]	.   .   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 15]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 15]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 15]
.   .   Sibling: 7  Call: output of type void [line: 16]						.   .   Sibling: 7  Call: output of type void [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 16]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -4 size: 2] [line: 16]
.   .   .   .   Child: 1  Const 0 of type int [line: 16]						.   .   .   .   Child: 1  Const 0 of type int [line: 16]
.   .   Sibling: 8  Assign: = of type int [line: 18]						   |	.   .   Sibling: 8  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 18]
.   .   .   Child: 1  Const 1023 of type int [line: 18]							.   .   .   Child: 1  Const 1023 of type int [line: 18]
.   .   Sibling: 9  Assign: ++ of type int [line: 19]							.   .   Sibling: 9  Assign: ++ of type int [line: 19]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]
.   .   Sibling: 10  Call: output of type void [line: 20]						.   .   Sibling: 10  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]
.   .   Sibling: 11  Call: output of type void [line: 21]						.   .   Sibling: 11  Call: output of type void [line: 21]
.   .   .   Child: 0  Assign: ++ of type int [line: 21]							.   .   .   Child: 0  Assign: ++ of type int [line: 21]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 21]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 21]
Sibling: 2  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 24]		   |	Sibling: 9  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 25]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 2] [line: 26]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 2] [line: 26]
.   .   Sibling: 1  Var: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 27]		.   .   Sibling: 1  Var: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 27]
.   .   Child: 1  Assign: = of type int [line: 29]						   |	.   .   Child: 1  Assign: := of type int [line: 29]
.   .   .   Child: 0  Op: [ of type int [line: 29]							.   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 29]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 29]
.   .   .   .   Child: 1  Const 0 of type int [line: 29]						.   .   .   .   Child: 1  Const 0 of type int [line: 29]
.   .   .   Child: 1  Const 666 of type int [line: 29]							.   .   .   Child: 1  Const 666 of type int [line: 29]
.   .   Sibling: 1  Call: cat of type void [line: 30]							.   .   Sibling: 1  Call: cat of type void [line: 30]
.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 30]		.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 30]
.   .   Sibling: 2  Call: output of type void [line: 31]						.   .   Sibling: 2  Call: output of type void [line: 31]
.   .   .   Child: 0  Op: [ of type int [line: 31]							.   .   .   Child: 0  Op: [ of type int [line: 31]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 31]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 2] [line: 31]
.   .   .   .   Child: 1  Const 0 of type int [line: 31]						.   .   .   .   Child: 1  Const 0 of type int [line: 31]
.   .   Sibling: 3  Assign: = of type int [line: 33]						   |	.   .   Sibling: 3  Assign: := of type int [line: 33]
.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 33]		.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 33]
.   .   .   Child: 1  Const 1023 of type int [line: 33]							.   .   .   Child: 1  Const 1023 of type int [line: 33]
.   .   Sibling: 4  Assign: ++ of type int [line: 34]							.   .   Sibling: 4  Assign: ++ of type int [line: 34]
.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 34]		.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 34]
.   .   Sibling: 5  Call: output of type void [line: 35]						.   .   Sibling: 5  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 35]		.   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 35]
.   .   Sibling: 6  Call: output of type void [line: 36]						.   .   Sibling: 6  Call: output of type void [line: 36]
.   .   .   Child: 0  Assign: ++ of type int [line: 36]							.   .   .   Child: 0  Assign: ++ of type int [line: 36]
.   .   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 36]	.   .   .   .   Child: 0  Id: s of static type int [mem: LocalStatic loc: -1 size: 1] [line: 36]
.   .   Sibling: 7  Return [line: 38]									.   .   Sibling: 7  Return [line: 38]
.   .   .   Child: 0  Const 0 of type int [line: 38]							.   .   .   Child: 0  Const 0 of type int [line: 38]
Offset for end of global space: -2									Offset for end of global space: -2
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
inc.out ztmp23114.txt differ: byte 1, line 1
inc (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/inc.tm
Number of errors: 0										   |	667 667 778 778 889 889 1024 1025 667 1024 1025
------------------------------------								   <
Loading file: inc.tm										   <
Bye.													Bye.
====================================
FILE: initbig.c-
-rw-------. 1 corg7983 domain_users   735 Nov 17 15:35 initbig.c-
-rw-------. 1 corg7983 domain_users   735 Nov 17 15:35 initbig.c-.f21
-rw-------. 1 corg7983 domain_users   735 Nov 17 15:35 initbig.c-.f22
-rw-------. 1 corg7983 domain_users   210 Nov 17 15:35 initbig.expected
-rw-------. 1 corg7983 domain_users  6278 Nov 22 12:27 initbig.mem
-rw-------. 1 corg7983 domain_users     0 Nov 17 15:35 initbig.mem.diffs
-rw-------. 1 corg7983 domain_users  7120 Nov 17 15:35 initbig.mem.f21
-rw-------. 1 corg7983 domain_users   235 Nov 22 12:27 initbig.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 initbig.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 initbig.tm.diffs
-rw-------. 1 corg7983 domain_users 17368 Nov 17 15:35 initbig.tm.f21
TM CODE COMPARISON
initbig (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  initbig.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -20
												   >	 40:    LDC  3,666(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	 42:    LDC  3,97(6)	Load char constant 
												   >	 43:     ST  3,-3(1)	Store variable y
												   >	 44:    LDC  3,1(6)	Load Boolean constant 
												   >	 45:     ST  3,-4(1)	Store variable ba
												   >	 46:    LDC  3,1(6)	Load Boolean constant 
												   >	 47:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 48:    LDC  3,0(6)	Load Boolean constant 
												   >	 49:    LDC  4,1(6)	Load 1 
												   >	 50:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -20
												   >	 51:     LD  4,-20(1)	Pop left into ac1 
												   >	 52:    AND  3,4,3	Op AND 
												   >	 53:     ST  3,-5(1)	Store variable bb
												   >	 54:    LDC  3,5(6)	Load integer constant 
												   >	 55:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 56:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	 57:     LD  4,-20(1)	Pop left into ac1 
												   >	 58:    TGT  3,4,3	Op > 
												   >	 59:     ST  3,-6(1)	Store variable bc
												   >	 60:    LDC  3,10(6)	load size of array x
												   >	 61:     ST  3,-7(1)	save size of array x
												   >	 62:    LDC  3,4(6)	Load integer constant 
												   >	 63:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 64:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -20
												   >	 65:     LD  4,-20(1)	Pop left into ac1 
												   >	 66:    MUL  3,4,3	Op * 
												   >	 67:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 68:    LDC  3,3(6)	Load integer constant 
												   >	 69:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	 70:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	 71:     LD  4,-21(1)	Pop left into ac1 
												   >	 72:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -20
												   >	 73:     LD  4,-20(1)	Pop left into ac1 
												   >	 74:    ADD  3,4,3	Op + 
												   >	 75:     ST  3,-18(1)	Store variable k
												   >	 76:    LDC  3,46(6)	Load integer constant 
												   >	 77:    NEG  3,3,3	Op unary - 
												   >	 78:     ST  3,-19(1)	Store variable l
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 79:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	 80:     LD  3,0(0)	Load variable ga
												   >	 81:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	 82:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	 83:    LDA  3,1(7)	Return address in ac 
												   >	 84:    JMP  7,-79(7)	CALL output
												   >	 85:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 86:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	 87:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-56(7)	CALL outnl
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 91:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	 92:     LD  3,-1(0)	Load variable gb
												   >	 93:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	 94:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-80(7)	CALL outputb
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 98:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	 99:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-68(7)	CALL outnl
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	103:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	104:    LDA  3,-3(0)	Load address of base of array gc
												   >	105:     LD  3,1(3)	Load array size 
												   >	106:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	107:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-104(7)	CALL output
												   >	110:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	111:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	112:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	113:    LDA  3,1(7)	Return address in ac 
												   >	114:    JMP  7,-81(7)	CALL outnl
												   >	115:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	116:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	117:     LD  3,-2(1)	Load variable i
												   >	118:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	119:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-116(7)	CALL output
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	123:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	124:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	125:    LDA  3,1(7)	Return address in ac 
												   >	126:    JMP  7,-93(7)	CALL outnl
												   >	127:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	128:     ST  1,-20(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	129:     LD  3,-3(1)	Load variable y
												   >	130:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputc
												   >	131:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	132:    LDA  3,1(7)	Return address in ac 
												   >	133:    JMP  7,-106(7)	CALL outputc
												   >	134:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	135:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	136:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	137:    LDA  3,1(7)	Return address in ac 
												   >	138:    JMP  7,-105(7)	CALL outnl
												   >	139:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	140:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	141:     LD  3,-4(1)	Load variable ba
												   >	142:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	143:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	144:    LDA  3,1(7)	Return address in ac 
												   >	145:    JMP  7,-129(7)	CALL outputb
												   >	146:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	147:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	148:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-117(7)	CALL outnl
												   >	151:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	152:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	153:     LD  3,-5(1)	Load variable bb
												   >	154:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	155:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	156:    LDA  3,1(7)	Return address in ac 
												   >	157:    JMP  7,-141(7)	CALL outputb
												   >	158:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	159:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	160:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	161:    LDA  3,1(7)	Return address in ac 
												   >	162:    JMP  7,-129(7)	CALL outnl
												   >	163:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	164:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	165:     LD  3,-6(1)	Load variable bc
												   >	166:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	167:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	168:    LDA  3,1(7)	Return address in ac 
												   >	169:    JMP  7,-153(7)	CALL outputb
												   >	170:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	171:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	172:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-141(7)	CALL outnl
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	176:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	177:    LDA  3,-8(1)	Load address of base of array x
												   >	178:     LD  3,1(3)	Load array size 
												   >	179:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	180:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	181:    LDA  3,1(7)	Return address in ac 
												   >	182:    JMP  7,-177(7)	CALL output
												   >	183:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	184:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	185:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	186:    LDA  3,1(7)	Return address in ac 
												   >	187:    JMP  7,-154(7)	CALL outnl
												   >	188:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	189:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	190:     LD  3,-18(1)	Load variable k
												   >	191:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	192:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	193:    LDA  3,1(7)	Return address in ac 
												   >	194:    JMP  7,-189(7)	CALL output
												   >	195:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	196:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	197:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	198:    LDA  3,1(7)	Return address in ac 
												   >	199:    JMP  7,-166(7)	CALL outnl
												   >	200:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	201:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	202:     LD  3,-19(1)	Load variable l
												   >	203:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	204:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	205:    LDA  3,1(7)	Return address in ac 
												   >	206:    JMP  7,-201(7)	CALL output
												   >	207:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	208:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	209:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	210:    LDA  3,1(7)	Return address in ac 
												   >	211:    JMP  7,-178(7)	CALL outnl
												   >	212:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	213:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	214:     LD  3,-16(0)	Load variable sia
												   >	215:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	216:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	217:    LDA  3,1(7)	Return address in ac 
												   >	218:    JMP  7,-213(7)	CALL output
												   >	219:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	220:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	221:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-190(7)	CALL outnl
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL output
												   >	225:     ST  1,-20(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	226:    LDA  3,-18(0)	Load address of base of array sib
												   >	227:     LD  3,1(3)	Load array size 
												   >	228:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end output
												   >	229:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	230:    LDA  3,1(7)	Return address in ac 
												   >	231:    JMP  7,-226(7)	CALL output
												   >	232:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	233:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	234:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-203(7)	CALL outnl
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* COMPOUND
												   >	* TOFF set: -42
												   >	238:    LDC  3,20(6)	load size of array y
												   >	239:     ST  3,-20(1)	save size of array y
												   >	240:    LDC  3,1(6)	Load Boolean constant 
												   >	241:    LDC  4,1(6)	Load 1 
												   >	242:    XOR  3,3,4	Op XOR to get logical not 
												   >	243:     ST  3,-41(1)	Store variable t
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	244:     ST  1,-42(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -43
												   >	* TOFF dec: -44
												   >	* Param 1
												   >	245:    LDA  3,-21(1)	Load address of base of array y
												   >	246:     LD  3,1(3)	Load array size 
												   >	247:     ST  3,-44(1)	Push parameter 
												   >	* TOFF dec: -45
												   >	* Param end output
												   >	248:    LDA  1,-42(1)	Ghost frame becomes new active frame 
												   >	249:    LDA  3,1(7)	Return address in ac 
												   >	250:    JMP  7,-245(7)	CALL output
												   >	251:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -42
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	252:     ST  1,-42(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -43
												   >	* TOFF dec: -44
												   >	* Param end outnl
												   >	253:    LDA  1,-42(1)	Ghost frame becomes new active frame 
												   >	254:    LDA  3,1(7)	Return address in ac 
												   >	255:    JMP  7,-222(7)	CALL outnl
												   >	256:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -42
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	257:     ST  1,-42(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -43
												   >	* TOFF dec: -44
												   >	* Param 1
												   >	258:     LD  3,-41(1)	Load variable t
												   >	259:     ST  3,-44(1)	Push parameter 
												   >	* TOFF dec: -45
												   >	* Param end outputb
												   >	260:    LDA  1,-42(1)	Ghost frame becomes new active frame 
												   >	261:    LDA  3,1(7)	Return address in ac 
												   >	262:    JMP  7,-246(7)	CALL outputb
												   >	263:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -42
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	264:     ST  1,-42(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -43
												   >	* TOFF dec: -44
												   >	* Param end outnl
												   >	265:    LDA  1,-42(1)	Ghost frame becomes new active frame 
												   >	266:    LDA  3,1(7)	Return address in ac 
												   >	267:    JMP  7,-234(7)	CALL outnl
												   >	268:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -42
												   >	* TOFF set: -20
												   >	* END COMPOUND
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	269:    LDC  2,0(6)	Set return value to 0 
												   >	270:     LD  3,-1(1)	Load return address 
												   >	271:     LD  1,0(1)	Adjust fp 
												   >	272:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,272(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	273:    LDA  1,-33(0)	set first frame at end of globals 
												   >	274:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	275:    LDC  3,111(6)	Load integer constant 
												   >	276:     ST  3,0(0)	Store variable ga
												   >	277:    LDC  3,1(6)	Load Boolean constant 
												   >	278:     ST  3,-1(0)	Store variable gb
												   >	279:    LDC  3,13(6)	load size of array gc
												   >	280:     ST  3,-2(0)	save size of array gc
												   >	281:    LDC  3,666(6)	Load integer constant 
												   >	282:     ST  3,-16(0)	Store variable sia
												   >	283:    LDC  3,15(6)	load size of array sib
												   >	284:     ST  3,-17(0)	save size of array sib
												   >	* END INIT GLOBALS AND STATICS
												   >	285:    LDA  3,1(7)	Return address in ac 
												   >	286:    JMP  7,-248(7)	Jump to main 
												   >	287:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
initbig.mem initbig.mem.f21 differ: byte 127, line 3
initbig (MEM DIFF)
WARNING(31): Variable 'x' may be uninitialized when used here.						WARNING(31): Variable 'x' may be uninitialized when used here.
WARNING(46): Variable 'y' may be uninitialized when used here.						WARNING(46): Variable 'y' may be uninitialized when used here.
Var: ga of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: ga of type int [mem: Global loc: 0 size: 1] [line: 1]
.   Child: 0  Const 111 of type int [line: 1]								.   Child: 0  Const 111 of type int [line: 1]
Sibling: 1  Var: gb of type bool [mem: Global loc: -1 size: 1] [line: 2]			   |	Sibling: 8  Var: gb of type bool [mem: Global loc: -1 size: 1] [line: 2]
.   Child: 0  Const true of type bool [line: 2]								.   Child: 0  Const true of type bool [line: 2]
Sibling: 2  Var: gc of array of type char [mem: Global loc: -3 size: 14] [line: 3]		   |	Sibling: 9  Var: gc of array of type char [mem: Global loc: -3 size: 14] [line: 3]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 5]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 5]
.   Child: 1  Compound [mem: None loc: 0 size: -20] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -20] [line: 5]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 6]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   Child: 0  Const 666 of type int [line: 6]							.   .   .   Child: 0  Const 666 of type int [line: 6]
.   .   Sibling: 1  Var: y of type char [mem: Local loc: -3 size: 1] [line: 7]				.   .   Sibling: 1  Var: y of type char [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Child: 0  Const 'a' of type char [line: 7]							.   .   .   Child: 0  Const 'a' of type char [line: 7]
.   .   Sibling: 2  Var: ba of type bool [mem: Local loc: -4 size: 1] [line: 8]				.   .   Sibling: 2  Var: ba of type bool [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 0  Const true of type bool [line: 8]							.   .   .   Child: 0  Const true of type bool [line: 8]
.   .   Sibling: 3  Var: bb of type bool [mem: Local loc: -5 size: 1] [line: 8]				.   .   Sibling: 3  Var: bb of type bool [mem: Local loc: -5 size: 1] [line: 8]
.   .   .   Child: 0  Op: and of type bool [line: 8]							.   .   .   Child: 0  Op: and of type bool [line: 8]
.   .   .   .   Child: 0  Const true of type bool [line: 8]						.   .   .   .   Child: 0  Const true of type bool [line: 8]
.   .   .   .   Child: 1  Op: not of type bool [line: 8]						.   .   .   .   Child: 1  Op: not of type bool [line: 8]
.   .   .   .   .   Child: 0  Const false of type bool [line: 8]					.   .   .   .   .   Child: 0  Const false of type bool [line: 8]
.   .   Sibling: 4  Var: bc of type bool [mem: Local loc: -6 size: 1] [line: 8]				.   .   Sibling: 4  Var: bc of type bool [mem: Local loc: -6 size: 1] [line: 8]
.   .   .   Child: 0  Op: > of type bool [line: 8]							.   .   .   Child: 0  Op: > of type bool [line: 8]
.   .   .   .   Child: 0  Const 5 of type int [line: 8]							.   .   .   .   Child: 0  Const 5 of type int [line: 8]
.   .   .   .   Child: 1  Const 4 of type int [line: 8]							.   .   .   .   Child: 1  Const 4 of type int [line: 8]
.   .   Sibling: 5  Var: x of array of type int [mem: Local loc: -8 size: 11] [line: 9]			.   .   Sibling: 5  Var: x of array of type int [mem: Local loc: -8 size: 11] [line: 9]
.   .   Sibling: 6  Var: k of type int [mem: Local loc: -18 size: 1] [line: 10]				.   .   Sibling: 6  Var: k of type int [mem: Local loc: -18 size: 1] [line: 10]
.   .   .   Child: 0  Op: + of type int [line: 10]							.   .   .   Child: 0  Op: + of type int [line: 10]
.   .   .   .   Child: 0  Op: * of type int [line: 10]							.   .   .   .   Child: 0  Op: * of type int [line: 10]
.   .   .   .   .   Child: 0  Const 4 of type int [line: 10]						.   .   .   .   .   Child: 0  Const 4 of type int [line: 10]
.   .   .   .   .   Child: 1  Const 5 of type int [line: 10]						.   .   .   .   .   Child: 1  Const 5 of type int [line: 10]
.   .   .   .   Child: 1  Op: * of type int [line: 10]							.   .   .   .   Child: 1  Op: * of type int [line: 10]
.   .   .   .   .   Child: 0  Const 3 of type int [line: 10]						.   .   .   .   .   Child: 0  Const 3 of type int [line: 10]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 10]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 10]
.   .   Sibling: 7  Var: l of type int [mem: Local loc: -19 size: 1] [line: 10]				.   .   Sibling: 7  Var: l of type int [mem: Local loc: -19 size: 1] [line: 10]
.   .   .   Child: 0  Op: chsign of type int [line: 10]							.   .   .   Child: 0  Op: chsign of type int [line: 10]
.   .   .   .   Child: 0  Const 46 of type int [line: 10]						.   .   .   .   Child: 0  Const 46 of type int [line: 10]
.   .   Sibling: 8  Var: sia of static type int [mem: LocalStatic loc: -16 size: 1] [line: 12]		.   .   Sibling: 8  Var: sia of static type int [mem: LocalStatic loc: -16 size: 1] [line: 12]
.   .   .   Child: 0  Const 666 of type int [line: 12]							.   .   .   Child: 0  Const 666 of type int [line: 12]
.   .   Sibling: 9  Var: sib of static array of type int [mem: LocalStatic loc: -18 size: 16] [l	.   .   Sibling: 9  Var: sib of static array of type int [mem: LocalStatic loc: -18 size: 16] [l
.   .   Child: 1  Call: output of type void [line: 15]							.   .   Child: 1  Call: output of type void [line: 15]
.   .   .   Child: 0  Id: ga of type int [mem: Global loc: 0 size: 1] [line: 15]			.   .   .   Child: 0  Id: ga of type int [mem: Global loc: 0 size: 1] [line: 15]
.   .   Sibling: 1  Call: outnl of type void [line: 16]							.   .   Sibling: 1  Call: outnl of type void [line: 16]
.   .   Sibling: 2  Call: outputb of type void [line: 17]						.   .   Sibling: 2  Call: outputb of type void [line: 17]
.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -1 size: 1] [line: 17]			.   .   .   Child: 0  Id: gb of type bool [mem: Global loc: -1 size: 1] [line: 17]
.   .   Sibling: 3  Call: outnl of type void [line: 18]							.   .   Sibling: 3  Call: outnl of type void [line: 18]
.   .   Sibling: 4  Call: output of type void [line: 19]						.   .   Sibling: 4  Call: output of type void [line: 19]
.   .   .   Child: 0  Op: sizeof of type int [line: 19]							.   .   .   Child: 0  Op: sizeof of type int [line: 19]
.   .   .   .   Child: 0  Id: gc of array of type char [mem: Global loc: -3 size: 14] [line: 19]	.   .   .   .   Child: 0  Id: gc of array of type char [mem: Global loc: -3 size: 14] [line: 19]
.   .   Sibling: 5  Call: outnl of type void [line: 20]							.   .   Sibling: 5  Call: outnl of type void [line: 20]
.   .   Sibling: 6  Call: output of type void [line: 21]						.   .   Sibling: 6  Call: output of type void [line: 21]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 21]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   Sibling: 7  Call: outnl of type void [line: 22]							.   .   Sibling: 7  Call: outnl of type void [line: 22]
.   .   Sibling: 8  Call: outputc of type void [line: 23]						.   .   Sibling: 8  Call: outputc of type void [line: 23]
.   .   .   Child: 0  Id: y of type char [mem: Local loc: -3 size: 1] [line: 23]			.   .   .   Child: 0  Id: y of type char [mem: Local loc: -3 size: 1] [line: 23]
.   .   Sibling: 9  Call: outnl of type void [line: 24]							.   .   Sibling: 9  Call: outnl of type void [line: 24]
.   .   Sibling: 10  Call: outputb of type void [line: 25]						.   .   Sibling: 10  Call: outputb of type void [line: 25]
.   .   .   Child: 0  Id: ba of type bool [mem: Local loc: -4 size: 1] [line: 25]			.   .   .   Child: 0  Id: ba of type bool [mem: Local loc: -4 size: 1] [line: 25]
.   .   Sibling: 11  Call: outnl of type void [line: 26]						.   .   Sibling: 11  Call: outnl of type void [line: 26]
.   .   Sibling: 12  Call: outputb of type void [line: 27]						.   .   Sibling: 12  Call: outputb of type void [line: 27]
.   .   .   Child: 0  Id: bb of type bool [mem: Local loc: -5 size: 1] [line: 27]			.   .   .   Child: 0  Id: bb of type bool [mem: Local loc: -5 size: 1] [line: 27]
.   .   Sibling: 13  Call: outnl of type void [line: 28]						.   .   Sibling: 13  Call: outnl of type void [line: 28]
.   .   Sibling: 14  Call: outputb of type void [line: 29]						.   .   Sibling: 14  Call: outputb of type void [line: 29]
.   .   .   Child: 0  Id: bc of type bool [mem: Local loc: -6 size: 1] [line: 29]			.   .   .   Child: 0  Id: bc of type bool [mem: Local loc: -6 size: 1] [line: 29]
.   .   Sibling: 15  Call: outnl of type void [line: 30]						.   .   Sibling: 15  Call: outnl of type void [line: 30]
.   .   Sibling: 16  Call: output of type void [line: 31]						.   .   Sibling: 16  Call: output of type void [line: 31]
.   .   .   Child: 0  Op: sizeof of type int [line: 31]							.   .   .   Child: 0  Op: sizeof of type int [line: 31]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -8 size: 11] [line: 31]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -8 size: 11] [line: 31]
.   .   Sibling: 17  Call: outnl of type void [line: 32]						.   .   Sibling: 17  Call: outnl of type void [line: 32]
.   .   Sibling: 18  Call: output of type void [line: 33]						.   .   Sibling: 18  Call: output of type void [line: 33]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -18 size: 1] [line: 33]			.   .   .   Child: 0  Id: k of type int [mem: Local loc: -18 size: 1] [line: 33]
.   .   Sibling: 19  Call: outnl of type void [line: 34]						.   .   Sibling: 19  Call: outnl of type void [line: 34]
.   .   Sibling: 20  Call: output of type void [line: 35]						.   .   Sibling: 20  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: l of type int [mem: Local loc: -19 size: 1] [line: 35]			.   .   .   Child: 0  Id: l of type int [mem: Local loc: -19 size: 1] [line: 35]
.   .   Sibling: 21  Call: outnl of type void [line: 36]						.   .   Sibling: 21  Call: outnl of type void [line: 36]
.   .   Sibling: 22  Call: output of type void [line: 37]						.   .   Sibling: 22  Call: output of type void [line: 37]
.   .   .   Child: 0  Id: sia of static type int [mem: LocalStatic loc: -16 size: 1] [line: 37]		.   .   .   Child: 0  Id: sia of static type int [mem: LocalStatic loc: -16 size: 1] [line: 37]
.   .   Sibling: 23  Call: outnl of type void [line: 38]						.   .   Sibling: 23  Call: outnl of type void [line: 38]
.   .   Sibling: 24  Call: output of type void [line: 39]						.   .   Sibling: 24  Call: output of type void [line: 39]
.   .   .   Child: 0  Op: sizeof of type int [line: 39]							.   .   .   Child: 0  Op: sizeof of type int [line: 39]
.   .   .   .   Child: 0  Id: sib of static array of type int [mem: LocalStatic loc: -18 size: 1	.   .   .   .   Child: 0  Id: sib of static array of type int [mem: LocalStatic loc: -18 size: 1
.   .   Sibling: 25  Call: outnl of type void [line: 40]						.   .   Sibling: 25  Call: outnl of type void [line: 40]
.   .   Sibling: 26  Compound [mem: None loc: 0 size: -42] [line: 42]					.   .   Sibling: 26  Compound [mem: None loc: 0 size: -42] [line: 42]
.   .   .   Child: 0  Var: y of array of type int [mem: Local loc: -21 size: 21] [line: 43]		.   .   .   Child: 0  Var: y of array of type int [mem: Local loc: -21 size: 21] [line: 43]
.   .   .   Sibling: 1  Var: t of type bool [mem: Local loc: -41 size: 1] [line: 44]			.   .   .   Sibling: 1  Var: t of type bool [mem: Local loc: -41 size: 1] [line: 44]
.   .   .   .   Child: 0  Op: not of type bool [line: 44]						.   .   .   .   Child: 0  Op: not of type bool [line: 44]
.   .   .   .   .   Child: 0  Const true of type bool [line: 44]					.   .   .   .   .   Child: 0  Const true of type bool [line: 44]
.   .   .   Child: 1  Call: output of type void [line: 46]						.   .   .   Child: 1  Call: output of type void [line: 46]
.   .   .   .   Child: 0  Op: sizeof of type int [line: 46]						.   .   .   .   Child: 0  Op: sizeof of type int [line: 46]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -21 size: 21] [line: 4	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -21 size: 21] [line: 4
.   .   .   Sibling: 1  Call: outnl of type void [line: 47]						.   .   .   Sibling: 1  Call: outnl of type void [line: 47]
.   .   .   Sibling: 2  Call: outputb of type void [line: 48]						.   .   .   Sibling: 2  Call: outputb of type void [line: 48]
.   .   .   .   Child: 0  Id: t of type bool [mem: Local loc: -41 size: 1] [line: 48]			.   .   .   .   Child: 0  Id: t of type bool [mem: Local loc: -41 size: 1] [line: 48]
.   .   .   Sibling: 3  Call: outnl of type void [line: 49]						.   .   .   Sibling: 3  Call: outnl of type void [line: 49]
Offset for end of global space: -33									Offset for end of global space: -33
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
initbig.out ztmp23114.txt differ: byte 127, line 3
initbig (Output DIFF)
WARNING(31): Variable 'x' may be uninitialized when used here.						WARNING(31): Variable 'x' may be uninitialized when used here.
WARNING(46): Variable 'y' may be uninitialized when used here.						WARNING(46): Variable 'y' may be uninitialized when used here.
Number of warnings: 2										   |	Loading file: BroadTests/initbig.tm
Number of errors: 0										   |	111
------------------------------------								   |	T
Loading file: initbig.tm									   |	13
												   >	666
												   >	a
												   >	T
												   >	T
												   >	T
												   >	10
												   >	26
												   >	-46
												   >	666
												   >	15
												   >	20
												   >	F
Bye.													Bye.
====================================
FILE: io.c-
-rw-------. 1 corg7983 domain_users   617 Nov 17 15:35 io.c-
-rw-------. 1 corg7983 domain_users   620 Nov 17 15:35 io.c-.f21
-rw-------. 1 corg7983 domain_users   617 Nov 17 15:35 io.c-.f22
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 io.expected
-rw-------. 1 corg7983 domain_users    28 Nov 17 15:35 io.in
-rw-------. 1 corg7983 domain_users  3946 Nov 22 12:27 io.mem
-rw-------. 1 corg7983 domain_users   369 Nov 17 15:35 io.mem.diffs
-rw-------. 1 corg7983 domain_users  4790 Nov 17 15:35 io.mem.f21
-rw-------. 1 corg7983 domain_users   278 Nov 22 12:27 io.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 io.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 io.tm.diffs
-rw-------. 1 corg7983 domain_users 14071 Nov 17 15:35 io.tm.f21
TM CODE COMPARISON
io (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  io.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:    LDC  3,777(6)	Load integer constant 
												   >	 42:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 43:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 47:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 48:    LDC  3,0(6)	Load Boolean constant 
												   >	 49:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 50:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-36(7)	CALL outputb
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 54:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 55:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-24(7)	CALL outnl
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 59:    LDC  3,666(6)	Load integer constant 
												   >	 60:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 61:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 62:     LD  3,-2(1)	Load variable x
												   >	 63:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 64:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 65:    LDA  3,1(7)	Return address in ac 
												   >	 66:    JMP  7,-61(7)	CALL output
												   >	 67:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 68:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 69:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-38(7)	CALL outnl
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 73:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 74:     LD  3,-2(1)	Load variable x
												   >	 75:    NEG  3,3,3	Op unary - 
												   >	 76:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 77:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-74(7)	CALL output
												   >	 80:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 81:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 82:    LDC  3,1(6)	Load integer constant 
												   >	 83:    NEG  3,3,3	Op unary - 
												   >	 84:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 85:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -6
												   >	 86:     LD  4,-6(1)	Pop left into ac1 
												   >	 87:    MUL  3,4,3	Op * 
												   >	 88:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 89:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-86(7)	CALL output
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 93:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 94:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-63(7)	CALL outnl
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 98:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 99:    LDC  3,111(6)	Load integer constant 
												   >	100:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	101:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	102:     LD  4,-6(1)	Pop left into ac1 
												   >	103:    ADD  3,4,3	Op + 
												   >	104:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	105:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	106:     LD  4,-6(1)	Pop left into ac1 
												   >	107:    ADD  3,4,3	Op + 
												   >	108:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	109:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-106(7)	CALL output
												   >	112:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	113:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	114:    LDC  3,3(6)	Load integer constant 
												   >	115:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	116:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	117:     LD  4,-6(1)	Pop left into ac1 
												   >	118:    MUL  3,4,3	Op * 
												   >	119:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	120:    LDC  3,6(6)	Load integer constant 
												   >	121:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	122:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	123:     LD  4,-7(1)	Pop left into ac1 
												   >	124:    MUL  3,4,3	Op * 
												   >	125:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	126:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	127:     LD  4,-7(1)	Pop left into ac1 
												   >	128:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -6
												   >	129:     LD  4,-6(1)	Pop left into ac1 
												   >	130:    MUL  3,4,3	Op * 
												   >	131:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	132:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	133:    LDA  3,1(7)	Return address in ac 
												   >	134:    JMP  7,-129(7)	CALL output
												   >	135:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	136:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	137:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	138:    LDA  3,1(7)	Return address in ac 
												   >	139:    JMP  7,-106(7)	CALL outnl
												   >	140:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL input
												   >	141:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	142:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	143:    LDA  3,1(7)	Return address in ac 
												   >	144:    JMP  7,-144(7)	CALL input
												   >	145:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	146:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	147:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	148:     LD  3,-2(1)	Load variable x
												   >	149:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	150:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-147(7)	CALL output
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	154:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	155:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	156:    LDA  3,1(7)	Return address in ac 
												   >	157:    JMP  7,-124(7)	CALL outnl
												   >	158:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL inputb
												   >	159:     ST  1,-4(1)	Store fp in ghost frame for inputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end inputb
												   >	160:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	161:    LDA  3,1(7)	Return address in ac 
												   >	162:    JMP  7,-151(7)	CALL inputb
												   >	163:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputb
												   >	* TOFF set: -4
												   >	164:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	165:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	166:     LD  3,-3(1)	Load variable b
												   >	167:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	168:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-154(7)	CALL outputb
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	172:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	173:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-142(7)	CALL outnl
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	177:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	* CALL input
												   >	178:     ST  1,-6(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end input
												   >	179:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	180:    LDA  3,1(7)	Return address in ac 
												   >	181:    JMP  7,-181(7)	CALL input
												   >	182:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -6
												   >	183:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL input
												   >	184:     ST  1,-7(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end input
												   >	185:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	186:    LDA  3,1(7)	Return address in ac 
												   >	187:    JMP  7,-187(7)	CALL input
												   >	188:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	189:     LD  4,-6(1)	Pop left into ac1 
												   >	190:    MUL  3,4,3	Op * 
												   >	191:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	192:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	193:    LDA  3,1(7)	Return address in ac 
												   >	194:    JMP  7,-189(7)	CALL output
												   >	195:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	196:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	197:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	198:    LDA  3,1(7)	Return address in ac 
												   >	199:    JMP  7,-166(7)	CALL outnl
												   >	200:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	201:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	* CALL inputb
												   >	202:     ST  1,-6(1)	Store fp in ghost frame for inputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end inputb
												   >	203:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	204:    LDA  3,1(7)	Return address in ac 
												   >	205:    JMP  7,-194(7)	CALL inputb
												   >	206:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputb
												   >	* TOFF set: -6
												   >	207:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL inputb
												   >	208:     ST  1,-7(1)	Store fp in ghost frame for inputb
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end inputb
												   >	209:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	210:    LDA  3,1(7)	Return address in ac 
												   >	211:    JMP  7,-200(7)	CALL inputb
												   >	212:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputb
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	213:     LD  4,-6(1)	Pop left into ac1 
												   >	214:    AND  3,4,3	Op AND 
												   >	215:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	216:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	217:    LDA  3,1(7)	Return address in ac 
												   >	218:    JMP  7,-202(7)	CALL outputb
												   >	219:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	220:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	221:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-190(7)	CALL outnl
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	225:    LDC  2,0(6)	Set return value to 0 
												   >	226:     LD  3,-1(1)	Load return address 
												   >	227:     LD  1,0(1)	Adjust fp 
												   >	228:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,228(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	229:    LDA  1,0(0)	set first frame at end of globals 
												   >	230:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	231:    LDA  3,1(7)	Return address in ac 
												   >	232:    JMP  7,-194(7)	Jump to main 
												   >	233:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
io.mem io.mem.f21 differ: byte 7, line 1
io (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 7]				.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 7]
.   .   Child: 1  Call: output of type void [line: 9]							.   .   Child: 1  Call: output of type void [line: 9]
.   .   .   Child: 0  Const 777 of type int [line: 9]							.   .   .   Child: 0  Const 777 of type int [line: 9]
.   .   Sibling: 1  Call: outputb of type void [line: 10]						.   .   Sibling: 1  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Const false of type bool [line: 10]						.   .   .   Child: 0  Const false of type bool [line: 10]
.   .   Sibling: 2  Call: outnl of type void [line: 11]							.   .   Sibling: 2  Call: outnl of type void [line: 11]
.   .   Sibling: 3  Assign: = of type int [line: 13]						   |	.   .   Sibling: 3  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Const 666 of type int [line: 13]							.   .   .   Child: 1  Const 666 of type int [line: 13]
.   .   Sibling: 4  Call: output of type void [line: 14]						.   .   Sibling: 4  Call: output of type void [line: 14]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 14]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   Sibling: 5  Call: outnl of type void [line: 15]							.   .   Sibling: 5  Call: outnl of type void [line: 15]
.   .   Sibling: 6  Call: output of type void [line: 17]						.   .   Sibling: 6  Call: output of type void [line: 17]
.   .   .   Child: 0  Op: chsign of type int [line: 17]							.   .   .   Child: 0  Op: chsign of type int [line: 17]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 17]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 17]
.   .   Sibling: 7  Call: output of type void [line: 18]						.   .   Sibling: 7  Call: output of type void [line: 18]
.   .   .   Child: 0  Op: * of type int [line: 18]							.   .   .   Child: 0  Op: * of type int [line: 18]
.   .   .   .   Child: 0  Op: chsign of type int [line: 18]						.   .   .   .   Child: 0  Op: chsign of type int [line: 18]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 18]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 18]
.   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 8  Call: outnl of type void [line: 19]							.   .   Sibling: 8  Call: outnl of type void [line: 19]
.   .   Sibling: 9  Call: output of type void [line: 21]						.   .   Sibling: 9  Call: output of type void [line: 21]
.   .   .   Child: 0  Op: + of type int [line: 21]							.   .   .   Child: 0  Op: + of type int [line: 21]
.   .   .   .   Child: 0  Op: + of type int [line: 21]							.   .   .   .   Child: 0  Op: + of type int [line: 21]
.   .   .   .   .   Child: 0  Const 111 of type int [line: 21]						.   .   .   .   .   Child: 0  Const 111 of type int [line: 21]
.   .   .   .   .   Child: 1  Const 222 of type int [line: 21]						.   .   .   .   .   Child: 1  Const 222 of type int [line: 21]
.   .   .   .   Child: 1  Const 333 of type int [line: 21]						.   .   .   .   Child: 1  Const 333 of type int [line: 21]
.   .   Sibling: 10  Call: output of type void [line: 22]						.   .   Sibling: 10  Call: output of type void [line: 22]
.   .   .   Child: 0  Op: * of type int [line: 22]							.   .   .   Child: 0  Op: * of type int [line: 22]
.   .   .   .   Child: 0  Op: * of type int [line: 22]							.   .   .   .   Child: 0  Op: * of type int [line: 22]
.   .   .   .   .   Child: 0  Const 3 of type int [line: 22]						.   .   .   .   .   Child: 0  Const 3 of type int [line: 22]
.   .   .   .   .   Child: 1  Const 6 of type int [line: 22]						.   .   .   .   .   Child: 1  Const 6 of type int [line: 22]
.   .   .   .   Child: 1  Op: + of type int [line: 22]							.   .   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   .   Child: 0  Op: * of type int [line: 22]						.   .   .   .   .   Child: 0  Op: * of type int [line: 22]
.   .   .   .   .   .   Child: 0  Const 6 of type int [line: 22]					.   .   .   .   .   .   Child: 0  Const 6 of type int [line: 22]
.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 22]					.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 22]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 22]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   Sibling: 11  Call: outnl of type void [line: 23]						.   .   Sibling: 11  Call: outnl of type void [line: 23]
.   .   Sibling: 12  Assign: = of type int [line: 25]						   |	.   .   Sibling: 12  Assign: := of type int [line: 25]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 25]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 25]
.   .   .   Child: 1  Call: input of type int [line: 25]						.   .   .   Child: 1  Call: input of type int [line: 25]
.   .   Sibling: 13  Call: output of type void [line: 26]						.   .   Sibling: 13  Call: output of type void [line: 26]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 26]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   Sibling: 14  Call: outnl of type void [line: 27]						.   .   Sibling: 14  Call: outnl of type void [line: 27]
.   .   Sibling: 15  Assign: = of type bool [line: 29]						   |	.   .   Sibling: 15  Assign: := of type bool [line: 29]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 29]			.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 29]
.   .   .   Child: 1  Call: inputb of type bool [line: 29]						.   .   .   Child: 1  Call: inputb of type bool [line: 29]
.   .   Sibling: 16  Call: outputb of type void [line: 30]						.   .   Sibling: 16  Call: outputb of type void [line: 30]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 30]			.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 30]
.   .   Sibling: 17  Call: outnl of type void [line: 31]						.   .   Sibling: 17  Call: outnl of type void [line: 31]
.   .   Sibling: 18  Call: output of type void [line: 33]						.   .   Sibling: 18  Call: output of type void [line: 33]
.   .   .   Child: 0  Op: * of type int [line: 33]							.   .   .   Child: 0  Op: * of type int [line: 33]
.   .   .   .   Child: 0  Call: input of type int [line: 33]						.   .   .   .   Child: 0  Call: input of type int [line: 33]
.   .   .   .   Child: 1  Call: input of type int [line: 33]						.   .   .   .   Child: 1  Call: input of type int [line: 33]
.   .   Sibling: 19  Call: outnl of type void [line: 34]						.   .   Sibling: 19  Call: outnl of type void [line: 34]
.   .   Sibling: 20  Call: outputb of type void [line: 36]						.   .   Sibling: 20  Call: outputb of type void [line: 36]
.   .   .   Child: 0  Op: and of type bool [line: 36]							.   .   .   Child: 0  Op: and of type bool [line: 36]
.   .   .   .   Child: 0  Call: inputb of type bool [line: 36]						.   .   .   .   Child: 0  Call: inputb of type bool [line: 36]
.   .   .   .   Child: 1  Call: inputb of type bool [line: 36]						.   .   .   .   Child: 1  Call: inputb of type bool [line: 36]
.   .   Sibling: 21  Call: outnl of type void [line: 37]						.   .   Sibling: 21  Call: outnl of type void [line: 37]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
io.out ztmp23114.txt differ: byte 1, line 1
io (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/io.tm
Number of errors: 0										   |	777 F
------------------------------------								   |	666
Loading file: io.tm										   |	-666 -666
ERROR: TM Command 6 unknown.									   |	666 666
ERROR: TM Command T unknown.									   |	entered: 667
ERROR: TM Command 6 unknown.									   |	667
ERROR: TM Command 3 unknown.									   |	entered: T
ERROR: TM Command T unknown.									   |	T
ERROR: TM Command F unknown.									   |	entered: 6
												   >	entered: 36
												   >	216
												   >	entered: T
												   >	entered: F
												   >	F
Bye.													Bye.
====================================
FILE: localArray.c-
-rw-------. 1 corg7983 domain_users  128 Nov 17 15:35 localArray.c-
-rw-------. 1 corg7983 domain_users  130 Nov 17 15:35 localArray.c-.f21
-rw-------. 1 corg7983 domain_users  128 Nov 17 15:35 localArray.c-.f22
-rw-------. 1 corg7983 domain_users   50 Nov 17 15:35 localArray.expected
-rw-------. 1 corg7983 domain_users 1544 Nov 22 12:27 localArray.mem
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 localArray.mem.diffs
-rw-------. 1 corg7983 domain_users 2387 Nov 17 15:35 localArray.mem.f21
-rw-------. 1 corg7983 domain_users  112 Nov 22 12:27 localArray.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 localArray.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 localArray.tm.diffs
-rw-------. 1 corg7983 domain_users 5167 Nov 17 15:35 localArray.tm.f21
TM CODE COMPARISON
localArray (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  localArray.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -11
												   >	 40:    LDC  3,3(6)	load size of array x
												   >	 41:     ST  3,-2(1)	save size of array x
												   >	 42:    LDC  3,4(6)	load size of array b
												   >	 43:     ST  3,-6(1)	save size of array b
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 44:    LDC  3,2(6)	Load integer constant 
												   >	 45:     ST  3,-11(1)	Push index 
												   >	* TOFF dec: -12
												   >	 46:    LDC  3,666(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	 47:     LD  4,-11(1)	Pop index 
												   >	 48:    LDA  5,-3(1)	Load address of base of array x
												   >	 49:    SUB  5,5,4	Compute offset of value 
												   >	 50:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	 51:    LDC  3,3(6)	Load integer constant 
												   >	 52:     ST  3,-11(1)	Push index 
												   >	* TOFF dec: -12
												   >	 53:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -11
												   >	 54:     LD  4,-11(1)	Pop index 
												   >	 55:    LDA  5,-7(1)	Load address of base of array b
												   >	 56:    SUB  5,5,4	Compute offset of value 
												   >	 57:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	 58:     ST  1,-11(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	 59:    LDA  3,-3(1)	Load address of base of array x
												   >	 60:     ST  3,-13(1)	Push left side 
												   >	* TOFF dec: -14
												   >	 61:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -13
												   >	 62:     LD  4,-13(1)	Pop left into ac1 
												   >	 63:    SUB  3,4,3	compute location from index 
												   >	 64:     LD  3,0(3)	Load array element 
												   >	 65:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end output
												   >	 66:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-63(7)	CALL output
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -11
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 70:     ST  1,-11(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	 71:    LDA  3,-7(1)	Load address of base of array b
												   >	 72:     ST  3,-13(1)	Push left side 
												   >	* TOFF dec: -14
												   >	 73:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -13
												   >	 74:     LD  4,-13(1)	Pop left into ac1 
												   >	 75:    SUB  3,4,3	compute location from index 
												   >	 76:     LD  3,0(3)	Load array element 
												   >	 77:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end outputb
												   >	 78:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-64(7)	CALL outputb
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -11
												   >	* RETURN
												   >	 82:     LD  3,-1(1)	Load return address 
												   >	 83:     LD  1,0(1)	Adjust fp 
												   >	 84:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 85:    LDC  2,0(6)	Set return value to 0 
												   >	 86:     LD  3,-1(1)	Load return address 
												   >	 87:     LD  1,0(1)	Adjust fp 
												   >	 88:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,88(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 89:    LDA  1,0(0)	set first frame at end of globals 
												   >	 90:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-54(7)	Jump to main 
												   >	 93:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
localArray.mem localArray.mem.f21 differ: byte 7, line 1
localArray (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 2]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 4] [line: 3]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 4] [line: 3]
.   .   Sibling: 1  Var: b of array of type bool [mem: Local loc: -7 size: 5] [line: 4]			.   .   Sibling: 1  Var: b of array of type bool [mem: Local loc: -7 size: 5] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 4] [line: 6]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 4] [line: 6]
.   .   .   .   Child: 1  Const 2 of type int [line: 6]							.   .   .   .   Child: 1  Const 2 of type int [line: 6]
.   .   .   Child: 1  Const 666 of type int [line: 6]							.   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type bool [line: 7]						   |	.   .   Sibling: 1  Assign: := of type bool [line: 7]
.   .   .   Child: 0  Op: [ of type bool [line: 7]							.   .   .   Child: 0  Op: [ of type bool [line: 7]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -7 size: 5] [line: 7]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -7 size: 5] [line: 7]
.   .   .   .   Child: 1  Const 3 of type int [line: 7]							.   .   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   .   Child: 1  Const true of type bool [line: 7]							.   .   .   Child: 1  Const true of type bool [line: 7]
.   .   Sibling: 2  Call: output of type void [line: 9]							.   .   Sibling: 2  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 4] [line: 9]		.   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 4] [line: 9]
.   .   .   .   Child: 1  Const 2 of type int [line: 9]							.   .   .   .   Child: 1  Const 2 of type int [line: 9]
.   .   Sibling: 3  Call: outputb of type void [line: 10]						.   .   Sibling: 3  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: [ of type bool [line: 10]							.   .   .   Child: 0  Op: [ of type bool [line: 10]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -7 size: 5] [line: 10]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -7 size: 5] [line: 10]
.   .   .   .   Child: 1  Const 3 of type int [line: 10]						.   .   .   .   Child: 1  Const 3 of type int [line: 10]
.   .   Sibling: 4  Return [line: 12]									.   .   Sibling: 4  Return [line: 12]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
localArray.out ztmp23114.txt differ: byte 1, line 1
localArray (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/localArray.tm
Number of errors: 0										   |	666 T
------------------------------------								   <
Loading file: localArray.tm									   <
Bye.													Bye.
====================================
FILE: local.c-
-rw-------. 1 corg7983 domain_users  103 Nov 17 15:35 local.c-
-rw-------. 1 corg7983 domain_users  105 Nov 17 15:35 local.c-.f21
-rw-------. 1 corg7983 domain_users  103 Nov 17 15:35 local.c-.f22
-rw-------. 1 corg7983 domain_users   45 Nov 17 15:35 local.expected
-rw-------. 1 corg7983 domain_users 1045 Nov 22 12:27 local.mem
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 local.mem.diffs
-rw-------. 1 corg7983 domain_users 1888 Nov 17 15:35 local.mem.f21
-rw-------. 1 corg7983 domain_users  107 Nov 22 12:27 local.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 local.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 local.tm.diffs
-rw-------. 1 corg7983 domain_users 3989 Nov 17 15:35 local.tm.f21
TM CODE COMPARISON
local (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  local.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,666(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 42:    LDC  3,1(6)	Load Boolean constant 
												   >	 43:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	 44:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 45:     LD  3,-2(1)	Load variable x
												   >	 46:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 47:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-44(7)	CALL output
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 51:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 52:     LD  3,-3(1)	Load variable b
												   >	 53:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 54:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 55:    LDA  3,1(7)	Return address in ac 
												   >	 56:    JMP  7,-40(7)	CALL outputb
												   >	 57:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* RETURN
												   >	 58:     LD  3,-1(1)	Load return address 
												   >	 59:     LD  1,0(1)	Adjust fp 
												   >	 60:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 61:    LDC  2,0(6)	Set return value to 0 
												   >	 62:     LD  3,-1(1)	Load return address 
												   >	 63:     LD  1,0(1)	Adjust fp 
												   >	 64:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,64(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 65:    LDA  1,0(0)	set first frame at end of globals 
												   >	 66:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-30(7)	Jump to main 
												   >	 69:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
local.mem local.mem.f21 differ: byte 7, line 1
local (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 4]				.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 6]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   Child: 1  Const 666 of type int [line: 6]							.   .   .   Child: 1  Const 666 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type bool [line: 7]						   |	.   .   Sibling: 1  Assign: := of type bool [line: 7]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 7]				.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Child: 1  Const true of type bool [line: 7]							.   .   .   Child: 1  Const true of type bool [line: 7]
.   .   Sibling: 2  Call: output of type void [line: 9]							.   .   Sibling: 2  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   Sibling: 3  Call: outputb of type void [line: 10]						.   .   Sibling: 3  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 10]
.   .   Sibling: 4  Return [line: 12]									.   .   Sibling: 4  Return [line: 12]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
local.out ztmp23114.txt differ: byte 1, line 1
local (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/local.tm
Number of errors: 0										   |	666 T
------------------------------------								   <
Loading file: local.tm										   <
Bye.													Bye.
====================================
FILE: logic2.c-
-rw-------. 1 corg7983 domain_users   319 Nov 17 15:35 logic2.c-
-rw-------. 1 corg7983 domain_users   320 Nov 17 15:35 logic2.c-.f21
-rw-------. 1 corg7983 domain_users   319 Nov 17 15:35 logic2.c-.f22
-rw-------. 1 corg7983 domain_users    62 Nov 17 15:35 logic2.expected
-rw-------. 1 corg7983 domain_users  3172 Nov 22 12:27 logic2.mem
-rw-------. 1 corg7983 domain_users   489 Nov 17 15:35 logic2.mem.diffs
-rw-------. 1 corg7983 domain_users  4014 Nov 17 15:35 logic2.mem.f21
-rw-------. 1 corg7983 domain_users   108 Nov 22 12:27 logic2.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 logic2.tm
-rw-------. 1 corg7983 domain_users   280 Nov 17 15:35 logic2.tm.diffs
-rw-------. 1 corg7983 domain_users 10356 Nov 17 15:35 logic2.tm.f21
TM CODE COMPARISON
logic2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  logic2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:    LDC  3,1(6)	Load Boolean constant 
												   >	 42:     ST  3,-2(1)	Store variable a
												   >	 43:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 44:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 45:    LDA  3,1(7)	Return address in ac 
												   >	 46:    JMP  7,-30(7)	CALL outputb
												   >	 47:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 48:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 49:    LDC  3,0(6)	Load Boolean constant 
												   >	 50:     ST  3,-3(1)	Store variable b
												   >	 51:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 52:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 53:    LDA  3,1(7)	Return address in ac 
												   >	 54:    JMP  7,-38(7)	CALL outputb
												   >	 55:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 56:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 57:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 58:    LDA  3,1(7)	Return address in ac 
												   >	 59:    JMP  7,-26(7)	CALL outnl
												   >	 60:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 61:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 62:     LD  3,-2(1)	Load variable a
												   >	 63:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 64:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -6
												   >	 65:     LD  4,-6(1)	Pop left into ac1 
												   >	 66:    AND  3,4,3	Op AND 
												   >	 67:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 68:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 69:    LDA  3,1(7)	Return address in ac 
												   >	 70:    JMP  7,-54(7)	CALL outputb
												   >	 71:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 72:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 73:     LD  3,-2(1)	Load variable a
												   >	 74:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 75:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -6
												   >	 76:     LD  4,-6(1)	Pop left into ac1 
												   >	 77:     OR  3,4,3	Op OR 
												   >	 78:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 79:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 80:    LDA  3,1(7)	Return address in ac 
												   >	 81:    JMP  7,-65(7)	CALL outputb
												   >	 82:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 83:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 84:     LD  3,-2(1)	Load variable a
												   >	 85:    LDC  4,1(6)	Load 1 
												   >	 86:    XOR  3,3,4	Op XOR to get logical not 
												   >	 87:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	 88:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 89:    LDA  3,1(7)	Return address in ac 
												   >	 90:    JMP  7,-74(7)	CALL outputb
												   >	 91:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 92:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 93:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 94:    LDA  3,1(7)	Return address in ac 
												   >	 95:    JMP  7,-62(7)	CALL outnl
												   >	 96:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 97:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 98:    LDC  3,111(6)	Load integer constant 
												   >	 99:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	100:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	101:     LD  4,-6(1)	Pop left into ac1 
												   >	102:    TGT  3,4,3	Op > 
												   >	103:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	104:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	105:    LDA  3,1(7)	Return address in ac 
												   >	106:    JMP  7,-90(7)	CALL outputb
												   >	107:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	108:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	109:    LDC  3,111(6)	Load integer constant 
												   >	110:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	111:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	112:     LD  4,-6(1)	Pop left into ac1 
												   >	113:    TLT  3,4,3	Op < 
												   >	114:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	115:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	116:    LDA  3,1(7)	Return address in ac 
												   >	117:    JMP  7,-101(7)	CALL outputb
												   >	118:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	119:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	120:    LDC  3,111(6)	Load integer constant 
												   >	121:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	122:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	123:     LD  4,-6(1)	Pop left into ac1 
												   >	124:    TEQ  3,4,3	Op = 
												   >	125:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	126:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-112(7)	CALL outputb
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	130:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	131:    LDC  3,111(6)	Load integer constant 
												   >	132:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	133:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	134:     LD  4,-6(1)	Pop left into ac1 
												   >	135:    TGE  3,4,3	Op >= 
												   >	136:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	137:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	138:    LDA  3,1(7)	Return address in ac 
												   >	139:    JMP  7,-123(7)	CALL outputb
												   >	140:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	141:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	142:    LDC  3,111(6)	Load integer constant 
												   >	143:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	144:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	145:     LD  4,-6(1)	Pop left into ac1 
												   >	146:    TLE  3,4,3	Op <= 
												   >	147:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	148:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-134(7)	CALL outputb
												   >	151:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	152:     ST  1,-4(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	153:    LDC  3,111(6)	Load integer constant 
												   >	154:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	155:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	156:     LD  4,-6(1)	Pop left into ac1 
												   >	157:    TNE  3,4,3	Op >< 
												   >	158:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end outputb
												   >	159:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-145(7)	CALL outputb
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	163:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	164:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	165:    LDA  3,1(7)	Return address in ac 
												   >	166:    JMP  7,-133(7)	CALL outnl
												   >	167:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	168:    LDC  2,0(6)	Set return value to 0 
												   >	169:     LD  3,-1(1)	Load return address 
												   >	170:     LD  1,0(1)	Adjust fp 
												   >	171:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,171(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	172:    LDA  1,0(0)	set first frame at end of globals 
												   >	173:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-137(7)	Jump to main 
												   >	176:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
logic2.mem logic2.mem.f21 differ: byte 7, line 1
logic2 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]
.   .   Child: 0  Var: a of type bool [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: a of type bool [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 3]
.   .   Child: 1  Call: outputb of type void [line: 5]							.   .   Child: 1  Call: outputb of type void [line: 5]
.   .   .   Child: 0  Assign: = of type bool [line: 5]						   |	.   .   .   Child: 0  Assign: := of type bool [line: 5]
.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 5]			.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 5]
.   .   .   .   Child: 1  Const true of type bool [line: 5]						.   .   .   .   Child: 1  Const true of type bool [line: 5]
.   .   Sibling: 1  Call: outputb of type void [line: 6]						.   .   Sibling: 1  Call: outputb of type void [line: 6]
.   .   .   Child: 0  Assign: = of type bool [line: 6]						   |	.   .   .   Child: 0  Assign: := of type bool [line: 6]
.   .   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const false of type bool [line: 6]						.   .   .   .   Child: 1  Const false of type bool [line: 6]
.   .   Sibling: 2  Call: outnl of type void [line: 7]							.   .   Sibling: 2  Call: outnl of type void [line: 7]
.   .   Sibling: 3  Call: outputb of type void [line: 9]						.   .   Sibling: 3  Call: outputb of type void [line: 9]
.   .   .   Child: 0  Op: and of type bool [line: 9]							.   .   .   Child: 0  Op: and of type bool [line: 9]
.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   Child: 1  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 4  Call: outputb of type void [line: 10]						.   .   Sibling: 4  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: or of type bool [line: 10]							.   .   .   Child: 0  Op: or of type bool [line: 10]
.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   .   Child: 1  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   Child: 1  Id: b of type bool [mem: Local loc: -3 size: 1] [line: 10]
.   .   Sibling: 5  Call: outputb of type void [line: 11]						.   .   Sibling: 5  Call: outputb of type void [line: 11]
.   .   .   Child: 0  Op: not of type bool [line: 11]							.   .   .   Child: 0  Op: not of type bool [line: 11]
.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 11]
.   .   Sibling: 6  Call: outnl of type void [line: 12]							.   .   Sibling: 6  Call: outnl of type void [line: 12]
.   .   Sibling: 7  Call: outputb of type void [line: 14]						.   .   Sibling: 7  Call: outputb of type void [line: 14]
.   .   .   Child: 0  Op: > of type bool [line: 14]							.   .   .   Child: 0  Op: > of type bool [line: 14]
.   .   .   .   Child: 0  Const 111 of type int [line: 14]						.   .   .   .   Child: 0  Const 111 of type int [line: 14]
.   .   .   .   Child: 1  Const 222 of type int [line: 14]						.   .   .   .   Child: 1  Const 222 of type int [line: 14]
.   .   Sibling: 8  Call: outputb of type void [line: 15]						.   .   Sibling: 8  Call: outputb of type void [line: 15]
.   .   .   Child: 0  Op: < of type bool [line: 15]							.   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   Child: 0  Const 111 of type int [line: 15]						.   .   .   .   Child: 0  Const 111 of type int [line: 15]
.   .   .   .   Child: 1  Const 222 of type int [line: 15]						.   .   .   .   Child: 1  Const 222 of type int [line: 15]
.   .   Sibling: 9  Call: outputb of type void [line: 16]						.   .   Sibling: 9  Call: outputb of type void [line: 16]
.   .   .   Child: 0  Op: == of type bool [line: 16]						   |	.   .   .   Child: 0  Op: = of type bool [line: 16]
.   .   .   .   Child: 0  Const 111 of type int [line: 16]						.   .   .   .   Child: 0  Const 111 of type int [line: 16]
.   .   .   .   Child: 1  Const 222 of type int [line: 16]						.   .   .   .   Child: 1  Const 222 of type int [line: 16]
.   .   Sibling: 10  Call: outputb of type void [line: 17]						.   .   Sibling: 10  Call: outputb of type void [line: 17]
.   .   .   Child: 0  Op: >= of type bool [line: 17]							.   .   .   Child: 0  Op: >= of type bool [line: 17]
.   .   .   .   Child: 0  Const 111 of type int [line: 17]						.   .   .   .   Child: 0  Const 111 of type int [line: 17]
.   .   .   .   Child: 1  Const 222 of type int [line: 17]						.   .   .   .   Child: 1  Const 222 of type int [line: 17]
.   .   Sibling: 11  Call: outputb of type void [line: 18]						.   .   Sibling: 11  Call: outputb of type void [line: 18]
.   .   .   Child: 0  Op: <= of type bool [line: 18]							.   .   .   Child: 0  Op: <= of type bool [line: 18]
.   .   .   .   Child: 0  Const 111 of type int [line: 18]						.   .   .   .   Child: 0  Const 111 of type int [line: 18]
.   .   .   .   Child: 1  Const 222 of type int [line: 18]						.   .   .   .   Child: 1  Const 222 of type int [line: 18]
.   .   Sibling: 12  Call: outputb of type void [line: 19]						.   .   Sibling: 12  Call: outputb of type void [line: 19]
.   .   .   Child: 0  Op: != of type bool [line: 19]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 19]
.   .   .   .   Child: 0  Const 111 of type int [line: 19]						.   .   .   .   Child: 0  Const 111 of type int [line: 19]
.   .   .   .   Child: 1  Const 222 of type int [line: 19]						.   .   .   .   Child: 1  Const 222 of type int [line: 19]
.   .   Sibling: 13  Call: outnl of type void [line: 20]						.   .   Sibling: 13  Call: outnl of type void [line: 20]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
logic2.out ztmp23114.txt differ: byte 1, line 1
logic2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/logic2.tm
Number of errors: 0										   |	T F
------------------------------------								   |	F T F
Loading file: logic2.tm										   |	F T F F T T
Bye.													Bye.
====================================
FILE: logic.c-
-rw-------. 1 corg7983 domain_users  266 Nov 17 15:35 logic.c-
-rw-------. 1 corg7983 domain_users  266 Nov 17 15:35 logic.c-.f21
-rw-------. 1 corg7983 domain_users  266 Nov 17 15:35 logic.c-.f22
-rw-------. 1 corg7983 domain_users   55 Nov 17 15:35 logic.expected
-rw-------. 1 corg7983 domain_users 2171 Nov 22 12:27 logic.mem
-rw-------. 1 corg7983 domain_users    0 Nov 17 15:35 logic.mem.diffs
-rw-------. 1 corg7983 domain_users 3012 Nov 17 15:35 logic.mem.f21
-rw-------. 1 corg7983 domain_users  107 Nov 22 12:27 logic.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 logic.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 logic.tm.diffs
-rw-------. 1 corg7983 domain_users 8517 Nov 17 15:35 logic.tm.f21
TM CODE COMPARISON
logic (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  logic.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,0(6)	Load Boolean constant 
												   >	 42:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 43:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	 44:     LD  4,-4(1)	Pop left into ac1 
												   >	 45:    AND  3,4,3	Op AND 
												   >	 46:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 47:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-33(7)	CALL outputb
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 51:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 52:    LDC  3,0(6)	Load Boolean constant 
												   >	 53:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 54:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	 55:     LD  4,-4(1)	Pop left into ac1 
												   >	 56:    AND  3,4,3	Op AND 
												   >	 57:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 58:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-44(7)	CALL outputb
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 62:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 63:    LDC  3,1(6)	Load Boolean constant 
												   >	 64:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 65:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	 66:     LD  4,-4(1)	Pop left into ac1 
												   >	 67:    AND  3,4,3	Op AND 
												   >	 68:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 69:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-55(7)	CALL outputb
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 73:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 74:    LDC  3,1(6)	Load Boolean constant 
												   >	 75:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 76:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	 77:     LD  4,-4(1)	Pop left into ac1 
												   >	 78:    AND  3,4,3	Op AND 
												   >	 79:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 80:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-66(7)	CALL outputb
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 84:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 85:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-54(7)	CALL outnl
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 89:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 90:    LDC  3,0(6)	Load Boolean constant 
												   >	 91:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 92:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	 93:     LD  4,-4(1)	Pop left into ac1 
												   >	 94:     OR  3,4,3	Op OR 
												   >	 95:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 96:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 97:    LDA  3,1(7)	Return address in ac 
												   >	 98:    JMP  7,-82(7)	CALL outputb
												   >	 99:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	100:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	101:    LDC  3,0(6)	Load Boolean constant 
												   >	102:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	103:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	104:     LD  4,-4(1)	Pop left into ac1 
												   >	105:     OR  3,4,3	Op OR 
												   >	106:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	107:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-93(7)	CALL outputb
												   >	110:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	111:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	112:    LDC  3,1(6)	Load Boolean constant 
												   >	113:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	114:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	115:     LD  4,-4(1)	Pop left into ac1 
												   >	116:     OR  3,4,3	Op OR 
												   >	117:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	118:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	119:    LDA  3,1(7)	Return address in ac 
												   >	120:    JMP  7,-104(7)	CALL outputb
												   >	121:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	122:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	123:    LDC  3,1(6)	Load Boolean constant 
												   >	124:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	125:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	126:     LD  4,-4(1)	Pop left into ac1 
												   >	127:     OR  3,4,3	Op OR 
												   >	128:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	129:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	130:    LDA  3,1(7)	Return address in ac 
												   >	131:    JMP  7,-115(7)	CALL outputb
												   >	132:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	133:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	134:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	135:    LDA  3,1(7)	Return address in ac 
												   >	136:    JMP  7,-103(7)	CALL outnl
												   >	137:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	138:    LDC  2,0(6)	Set return value to 0 
												   >	139:     LD  3,-1(1)	Load return address 
												   >	140:     LD  1,0(1)	Adjust fp 
												   >	141:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,141(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	142:    LDA  1,0(0)	set first frame at end of globals 
												   >	143:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	144:    LDA  3,1(7)	Return address in ac 
												   >	145:    JMP  7,-107(7)	Jump to main 
												   >	146:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
logic.mem logic.mem.f21 differ: byte 7, line 1
logic (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: outputb of type void [line: 3]							.   .   Child: 1  Call: outputb of type void [line: 3]
.   .   .   Child: 0  Op: and of type bool [line: 3]							.   .   .   Child: 0  Op: and of type bool [line: 3]
.   .   .   .   Child: 0  Const false of type bool [line: 3]						.   .   .   .   Child: 0  Const false of type bool [line: 3]
.   .   .   .   Child: 1  Const false of type bool [line: 3]						.   .   .   .   Child: 1  Const false of type bool [line: 3]
.   .   Sibling: 1  Call: outputb of type void [line: 4]						.   .   Sibling: 1  Call: outputb of type void [line: 4]
.   .   .   Child: 0  Op: and of type bool [line: 4]							.   .   .   Child: 0  Op: and of type bool [line: 4]
.   .   .   .   Child: 0  Const false of type bool [line: 4]						.   .   .   .   Child: 0  Const false of type bool [line: 4]
.   .   .   .   Child: 1  Const true of type bool [line: 4]						.   .   .   .   Child: 1  Const true of type bool [line: 4]
.   .   Sibling: 2  Call: outputb of type void [line: 5]						.   .   Sibling: 2  Call: outputb of type void [line: 5]
.   .   .   Child: 0  Op: and of type bool [line: 5]							.   .   .   Child: 0  Op: and of type bool [line: 5]
.   .   .   .   Child: 0  Const true of type bool [line: 5]						.   .   .   .   Child: 0  Const true of type bool [line: 5]
.   .   .   .   Child: 1  Const false of type bool [line: 5]						.   .   .   .   Child: 1  Const false of type bool [line: 5]
.   .   Sibling: 3  Call: outputb of type void [line: 6]						.   .   Sibling: 3  Call: outputb of type void [line: 6]
.   .   .   Child: 0  Op: and of type bool [line: 6]							.   .   .   Child: 0  Op: and of type bool [line: 6]
.   .   .   .   Child: 0  Const true of type bool [line: 6]						.   .   .   .   Child: 0  Const true of type bool [line: 6]
.   .   .   .   Child: 1  Const true of type bool [line: 6]						.   .   .   .   Child: 1  Const true of type bool [line: 6]
.   .   Sibling: 4  Call: outnl of type void [line: 7]							.   .   Sibling: 4  Call: outnl of type void [line: 7]
.   .   Sibling: 5  Call: outputb of type void [line: 9]						.   .   Sibling: 5  Call: outputb of type void [line: 9]
.   .   .   Child: 0  Op: or of type bool [line: 9]							.   .   .   Child: 0  Op: or of type bool [line: 9]
.   .   .   .   Child: 0  Const false of type bool [line: 9]						.   .   .   .   Child: 0  Const false of type bool [line: 9]
.   .   .   .   Child: 1  Const false of type bool [line: 9]						.   .   .   .   Child: 1  Const false of type bool [line: 9]
.   .   Sibling: 6  Call: outputb of type void [line: 10]						.   .   Sibling: 6  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: or of type bool [line: 10]							.   .   .   Child: 0  Op: or of type bool [line: 10]
.   .   .   .   Child: 0  Const false of type bool [line: 10]						.   .   .   .   Child: 0  Const false of type bool [line: 10]
.   .   .   .   Child: 1  Const true of type bool [line: 10]						.   .   .   .   Child: 1  Const true of type bool [line: 10]
.   .   Sibling: 7  Call: outputb of type void [line: 11]						.   .   Sibling: 7  Call: outputb of type void [line: 11]
.   .   .   Child: 0  Op: or of type bool [line: 11]							.   .   .   Child: 0  Op: or of type bool [line: 11]
.   .   .   .   Child: 0  Const true of type bool [line: 11]						.   .   .   .   Child: 0  Const true of type bool [line: 11]
.   .   .   .   Child: 1  Const false of type bool [line: 11]						.   .   .   .   Child: 1  Const false of type bool [line: 11]
.   .   Sibling: 8  Call: outputb of type void [line: 12]						.   .   Sibling: 8  Call: outputb of type void [line: 12]
.   .   .   Child: 0  Op: or of type bool [line: 12]							.   .   .   Child: 0  Op: or of type bool [line: 12]
.   .   .   .   Child: 0  Const true of type bool [line: 12]						.   .   .   .   Child: 0  Const true of type bool [line: 12]
.   .   .   .   Child: 1  Const true of type bool [line: 12]						.   .   .   .   Child: 1  Const true of type bool [line: 12]
.   .   Sibling: 9  Call: outnl of type void [line: 13]							.   .   Sibling: 9  Call: outnl of type void [line: 13]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
logic.out ztmp23114.txt differ: byte 1, line 1
logic (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/logic.tm
Number of errors: 0										   |	F F F T
------------------------------------								   |	F T T T
Loading file: logic.tm										   <
Bye.													Bye.
====================================
FILE: main2.c-
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 main2.c-
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 main2.c-.f21
-rw-------. 1 corg7983 domain_users  101 Nov 17 15:35 main2.c-.f22
-rw-------. 1 corg7983 domain_users   69 Nov 17 15:35 main2.expected
-rw-------. 1 corg7983 domain_users   20 Nov 17 15:35 main2.in
-rw-------. 1 corg7983 domain_users  629 Nov 22 12:27 main2.mem
-rw-------. 1 corg7983 domain_users    0 Nov 17 15:35 main2.mem.diffs
-rw-------. 1 corg7983 domain_users 1470 Nov 17 15:35 main2.mem.f21
-rw-------. 1 corg7983 domain_users  165 Nov 22 12:27 main2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 main2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 main2.tm.diffs
-rw-------. 1 corg7983 domain_users 4832 Nov 17 15:35 main2.tm.f21
TM CODE COMPARISON
main2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  main2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,666(6)	Load integer constant 
												   >	 42:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 43:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 47:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 48:    LDC  3,1(6)	Load Boolean constant 
												   >	 49:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 50:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-36(7)	CALL outputb
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 54:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 55:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-24(7)	CALL outnl
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL input
												   >	 59:     ST  1,-2(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end input
												   >	 60:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-62(7)	CALL input
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL inputb
												   >	 64:     ST  1,-2(1)	Store fp in ghost frame for inputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end inputb
												   >	 65:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 66:    LDA  3,1(7)	Return address in ac 
												   >	 67:    JMP  7,-56(7)	CALL inputb
												   >	 68:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end inputb
												   >	* TOFF set: -2
												   >	* RETURN
												   >	 69:     LD  3,-1(1)	Load return address 
												   >	 70:     LD  1,0(1)	Adjust fp 
												   >	 71:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 72:    LDC  2,0(6)	Set return value to 0 
												   >	 73:     LD  3,-1(1)	Load return address 
												   >	 74:     LD  1,0(1)	Adjust fp 
												   >	 75:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,75(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 76:    LDA  1,0(0)	set first frame at end of globals 
												   >	 77:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-41(7)	Jump to main 
												   >	 80:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
main2.mem main2.mem.f21 differ: byte 7, line 1
main2 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Const 666 of type int [line: 3]							.   .   .   Child: 0  Const 666 of type int [line: 3]
.   .   Sibling: 1  Call: outputb of type void [line: 4]						.   .   Sibling: 1  Call: outputb of type void [line: 4]
.   .   .   Child: 0  Const true of type bool [line: 4]							.   .   .   Child: 0  Const true of type bool [line: 4]
.   .   Sibling: 2  Call: outnl of type void [line: 5]							.   .   Sibling: 2  Call: outnl of type void [line: 5]
.   .   Sibling: 3  Call: input of type int [line: 6]							.   .   Sibling: 3  Call: input of type int [line: 6]
.   .   Sibling: 4  Call: inputb of type bool [line: 7]							.   .   Sibling: 4  Call: inputb of type bool [line: 7]
.   .   Sibling: 5  Return [line: 9]									.   .   Sibling: 5  Return [line: 9]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
main2.out ztmp23114.txt differ: byte 1, line 1
main2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/main2.tm
Number of errors: 0										   |	666 T
------------------------------------								   |	entered: 666
Loading file: main2.tm										   |	entered: T
ERROR: TM Command 6 unknown.									   <
ERROR: TM Command T unknown.									   <
Bye.													Bye.
====================================
FILE: mastermind.c-
-rw-------. 1 corg7983 domain_users  4008 Nov 17 15:35 mastermind.c-
-rw-------. 1 corg7983 domain_users  4023 Nov 17 15:35 mastermind.c-.f21
-rw-------. 1 corg7983 domain_users  4008 Nov 17 15:35 mastermind.c-.f22
-rw-------. 1 corg7983 domain_users  1102 Nov 17 15:35 mastermind.expected
-rw-------. 1 corg7983 domain_users   252 Nov 17 15:35 mastermind.in
-rw-------. 1 corg7983 domain_users 18242 Nov 22 12:27 mastermind.mem
-rw-------. 1 corg7983 domain_users  2735 Nov 17 15:35 mastermind.mem.diffs
-rw-------. 1 corg7983 domain_users 19105 Nov 17 15:35 mastermind.mem.f21
-rw-------. 1 corg7983 domain_users  2461 Nov 22 12:27 mastermind.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 mastermind.tm
-rw-------. 1 corg7983 domain_users   346 Nov 17 15:35 mastermind.tm.diffs
-rw-------. 1 corg7983 domain_users 28232 Nov 17 15:35 mastermind.tm.f21
TM CODE COMPARISON
mastermind (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  mastermind.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION rand
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-1(0)	Load variable n
												   >	 41:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 42:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 43:     LD  4,-2(1)	Pop left into ac1 
												   >	 44:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* EXPRESSION
												   >	 46:     LD  3,-1(0)	Load variable n
												   >	 47:    NEG  3,3,3	Op unary - 
												   >	 48:     ST  3,-1(0)	Store variable n
												   >	 45:    JZR  3,3(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 49:     LD  3,-1(0)	Load variable n
												   >	 50:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 51:    LDC  3,128(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 52:     LD  4,-2(1)	Pop left into ac1 
												   >	 53:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	 55:     LD  3,-1(0)	Load variable n
												   >	 56:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 57:    LDC  3,128(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 58:     LD  4,-2(1)	Pop left into ac1 
												   >	 59:    MOD  3,4,3	Op % 
												   >	 60:     ST  3,-1(0)	Store variable n
												   >	 54:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 61:     LD  3,-1(0)	load lhs variable n
												   >	 62:    LDA  3,1(3)	increment value of n
												   >	 63:     ST  3,-1(0)	Store variable n
												   >	* EXPRESSION
												   >	 64:     LD  3,-1(0)	Load variable n
												   >	 65:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	 66:    LDC  3,1366(6)	Load integer constant 
												   >	 67:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 68:    LDA  3,-3(0)	Load address of base of array r
												   >	 69:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 70:     LD  3,-1(0)	Load variable n
												   >	 71:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 72:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 73:     LD  4,-5(1)	Pop left into ac1 
												   >	 74:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -4
												   >	 75:     LD  4,-4(1)	Pop left into ac1 
												   >	 76:    SUB  3,4,3	compute location from index 
												   >	 77:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -3
												   >	 78:     LD  4,-3(1)	Pop left into ac1 
												   >	 79:    MUL  3,4,3	Op * 
												   >	 80:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 81:    LDC  3,150889(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 82:     LD  4,-3(1)	Pop left into ac1 
												   >	 83:    ADD  3,4,3	Op + 
												   >	 84:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 85:    LDC  3,714025(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 86:     LD  4,-3(1)	Pop left into ac1 
												   >	 87:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -2
												   >	 88:     LD  4,-2(1)	Pop index 
												   >	 89:    LDA  5,-3(0)	Load address of base of array r
												   >	 90:    SUB  5,5,4	Compute offset of value 
												   >	 91:     ST  3,0(5)	Store variable r
												   >	* RETURN
												   >	 92:    LDA  3,-3(0)	Load address of base of array r
												   >	 93:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 94:     LD  3,-1(0)	Load variable n
												   >	* TOFF inc: -2
												   >	 95:     LD  4,-2(1)	Pop left into ac1 
												   >	 96:    SUB  3,4,3	compute location from index 
												   >	 97:     LD  3,0(3)	Load array element 
												   >	 98:    LDA  2,0(3)	Copy result to return register 
												   >	 99:     LD  3,-1(1)	Load return address 
												   >	100:     LD  1,0(1)	Adjust fp 
												   >	101:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	102:    LDC  2,0(6)	Set return value to 0 
												   >	103:     LD  3,-1(1)	Load return address 
												   >	104:     LD  1,0(1)	Adjust fp 
												   >	105:    JMP  7,0(3)	Return 
												   >	* END FUNCTION rand
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION search
												   >	* TOFF set: -4
												   >	106:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	107:    LDC  3,0(6)	Load integer constant 
												   >	108:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	109:     LD  3,-4(1)	Load variable i
												   >	110:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	111:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	112:     LD  4,-5(1)	Pop left into ac1 
												   >	113:    TLT  3,4,3	Op < 
												   >	114:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* IF
												   >	116:     LD  3,-2(1)	Load address of base of array a
												   >	117:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	118:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -5
												   >	119:     LD  4,-5(1)	Pop left into ac1 
												   >	120:    SUB  3,4,3	compute location from index 
												   >	121:     LD  3,0(3)	Load array element 
												   >	122:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	123:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -5
												   >	124:     LD  4,-5(1)	Pop left into ac1 
												   >	125:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	127:    LDC  3,1(6)	Load Boolean constant 
												   >	128:    LDA  2,0(3)	Copy result to return register 
												   >	129:     LD  3,-1(1)	Load return address 
												   >	130:     LD  1,0(1)	Adjust fp 
												   >	131:    JMP  7,0(3)	Return 
												   >	126:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	132:     LD  3,-4(1)	load lhs variable i
												   >	133:    LDA  3,1(3)	increment value of i
												   >	134:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	135:    JMP  7,-27(7)	go to beginning of loop 
												   >	115:    JMP  7,20(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	136:    LDC  3,0(6)	Load Boolean constant 
												   >	137:    LDA  2,0(3)	Copy result to return register 
												   >	138:     LD  3,-1(1)	Load return address 
												   >	139:     LD  1,0(1)	Adjust fp 
												   >	140:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	141:    LDC  2,0(6)	Set return value to 0 
												   >	142:     LD  3,-1(1)	Load return address 
												   >	143:     LD  1,0(1)	Adjust fp 
												   >	144:    JMP  7,0(3)	Return 
												   >	* END FUNCTION search
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION check
												   >	* TOFF set: -2
												   >	145:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	146:    LDC  3,0(6)	Load integer constant 
												   >	147:     ST  3,-4(1)	Store variable c2
												   >	148:     ST  3,-3(1)	Store variable c1
												   >	149:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	150:     LD  3,-2(1)	Load variable i
												   >	151:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	152:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	153:     LD  4,-5(1)	Pop left into ac1 
												   >	154:    TLT  3,4,3	Op < 
												   >	155:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* IF
												   >	157:    LDA  3,-132(0)	Load address of base of array known
												   >	158:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	159:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -5
												   >	160:     LD  4,-5(1)	Pop left into ac1 
												   >	161:    SUB  3,4,3	compute location from index 
												   >	162:     LD  3,0(3)	Load array element 
												   >	163:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	164:    LDA  3,-137(0)	Load address of base of array guess
												   >	165:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	166:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -6
												   >	167:     LD  4,-6(1)	Pop left into ac1 
												   >	168:    SUB  3,4,3	compute location from index 
												   >	169:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	170:     LD  4,-5(1)	Pop left into ac1 
												   >	171:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	173:     LD  3,-4(1)	load lhs variable c2
												   >	174:    LDA  3,1(3)	increment value of c2
												   >	175:     ST  3,-4(1)	Store variable c2
												   >	172:    JZR  3,4(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL search
												   >	177:     ST  1,-5(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	178:    LDA  3,-132(0)	Load address of base of array known
												   >	179:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	180:    LDA  3,-137(0)	Load address of base of array guess
												   >	181:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	182:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -8
												   >	183:     LD  4,-8(1)	Pop left into ac1 
												   >	184:    SUB  3,4,3	compute location from index 
												   >	185:     LD  3,0(3)	Load array element 
												   >	186:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end search
												   >	187:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-84(7)	CALL search
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -5
												   >	* THEN
												   >	* EXPRESSION
												   >	192:     LD  3,-3(1)	load lhs variable c1
												   >	193:    LDA  3,1(3)	increment value of c1
												   >	194:     ST  3,-3(1)	Store variable c1
												   >	191:    JZR  3,3(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	176:    JMP  7,18(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	195:     LD  3,-2(1)	load lhs variable i
												   >	196:    LDA  3,1(3)	increment value of i
												   >	197:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	198:    JMP  7,-49(7)	go to beginning of loop 
												   >	156:    JMP  7,42(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	199:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	200:     LD  3,-3(1)	Load variable c1
												   >	201:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	202:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	203:    LDA  3,1(7)	Return address in ac 
												   >	204:    JMP  7,-199(7)	CALL output
												   >	205:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	206:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	207:     LD  3,-4(1)	Load variable c2
												   >	208:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	209:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	210:    LDA  3,1(7)	Return address in ac 
												   >	211:    JMP  7,-206(7)	CALL output
												   >	212:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	213:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	214:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	215:    LDA  3,1(7)	Return address in ac 
												   >	216:    JMP  7,-183(7)	CALL outnl
												   >	217:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* IF
												   >	218:     LD  3,-4(1)	Load variable c2
												   >	219:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	220:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	221:     LD  4,-5(1)	Pop left into ac1 
												   >	222:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	224:    LDC  3,1(6)	Load Boolean constant 
												   >	225:    LDA  2,0(3)	Copy result to return register 
												   >	226:     LD  3,-1(1)	Load return address 
												   >	227:     LD  1,0(1)	Adjust fp 
												   >	228:    JMP  7,0(3)	Return 
												   >	223:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	230:    LDC  3,0(6)	Load Boolean constant 
												   >	231:    LDA  2,0(3)	Copy result to return register 
												   >	232:     LD  3,-1(1)	Load return address 
												   >	233:     LD  1,0(1)	Adjust fp 
												   >	234:    JMP  7,0(3)	Return 
												   >	229:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	235:    LDC  2,0(6)	Set return value to 0 
												   >	236:     LD  3,-1(1)	Load return address 
												   >	237:     LD  1,0(1)	Adjust fp 
												   >	238:    JMP  7,0(3)	Return 
												   >	* END FUNCTION check
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION turn
												   >	* TOFF set: -2
												   >	239:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	240:     LD  3,0(0)	load lhs variable turns
												   >	241:    LDA  3,1(3)	increment value of turns
												   >	242:     ST  3,0(0)	Store variable turns
												   >	* EXPRESSION
												   >	* CALL output
												   >	243:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	244:     LD  3,0(0)	Load variable turns
												   >	245:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	246:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	247:    LDA  3,1(7)	Return address in ac 
												   >	248:    JMP  7,-243(7)	CALL output
												   >	249:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	250:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	251:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	252:    LDA  3,1(7)	Return address in ac 
												   >	253:    JMP  7,-220(7)	CALL outnl
												   >	254:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* IF
												   >	255:     LD  3,0(0)	Load variable turns
												   >	256:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	257:    LDC  3,20(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	258:     LD  4,-3(1)	Pop left into ac1 
												   >	259:    TLE  3,4,3	Op <= 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	261:    LDC  3,0(6)	Load integer constant 
												   >	262:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	263:     LD  3,-2(1)	Load variable i
												   >	264:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	265:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	266:     LD  4,-3(1)	Pop left into ac1 
												   >	267:    TLT  3,4,3	Op < 
												   >	268:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	270:     LD  3,-2(1)	Load variable i
												   >	271:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	* CALL input
												   >	272:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	273:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	274:    LDA  3,1(7)	Return address in ac 
												   >	275:    JMP  7,-275(7)	CALL input
												   >	276:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	* TOFF inc: -3
												   >	277:     LD  4,-3(1)	Pop index 
												   >	278:    LDA  5,-137(0)	Load address of base of array guess
												   >	279:    SUB  5,5,4	Compute offset of value 
												   >	280:     ST  3,0(5)	Store variable guess
												   >	* IF
												   >	281:    LDA  3,-137(0)	Load address of base of array guess
												   >	282:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	283:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	284:     LD  4,-3(1)	Pop left into ac1 
												   >	285:    SUB  3,4,3	compute location from index 
												   >	286:     LD  3,0(3)	Load array element 
												   >	287:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	288:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	289:     LD  4,-3(1)	Pop left into ac1 
												   >	290:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* RETURN
												   >	292:    LDC  3,0(6)	Load Boolean constant 
												   >	293:    LDA  2,0(3)	Copy result to return register 
												   >	294:     LD  3,-1(1)	Load return address 
												   >	295:     LD  1,0(1)	Adjust fp 
												   >	296:    JMP  7,0(3)	Return 
												   >	291:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	297:    LDA  3,-137(0)	Load address of base of array guess
												   >	298:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	299:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	300:     LD  4,-3(1)	Pop left into ac1 
												   >	301:    SUB  3,4,3	compute location from index 
												   >	302:     LD  3,0(3)	Load array element 
												   >	303:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	304:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	305:     LD  4,-3(1)	Pop left into ac1 
												   >	306:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* EXPRESSION
												   >	308:     LD  3,-2(1)	Load variable i
												   >	309:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	310:    LDA  3,-137(0)	Load address of base of array guess
												   >	311:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	312:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -4
												   >	313:     LD  4,-4(1)	Pop left into ac1 
												   >	314:    SUB  3,4,3	compute location from index 
												   >	315:     LD  3,0(3)	Load array element 
												   >	316:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	317:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	318:     LD  4,-4(1)	Pop left into ac1 
												   >	319:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -3
												   >	320:     LD  4,-3(1)	Pop index 
												   >	321:    LDA  5,-137(0)	Load address of base of array guess
												   >	322:    SUB  5,5,4	Compute offset of value 
												   >	323:     ST  3,0(5)	Store variable guess
												   >	307:    JZR  3,16(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	324:     LD  3,-2(1)	load lhs variable i
												   >	325:    LDA  3,1(3)	increment value of i
												   >	326:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	327:    JMP  7,-65(7)	go to beginning of loop 
												   >	269:    JMP  7,58(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	* CALL check
												   >	328:     ST  1,-3(1)	Store fp in ghost frame for check
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end check
												   >	329:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	330:    LDA  3,1(7)	Return address in ac 
												   >	331:    JMP  7,-187(7)	CALL check
												   >	332:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end check
												   >	* TOFF set: -3
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	334:    LDC  3,0(6)	Load integer constant 
												   >	335:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	336:     LD  3,-2(1)	Load variable i
												   >	337:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	338:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	339:     LD  4,-3(1)	Pop left into ac1 
												   >	340:    TLT  3,4,3	Op < 
												   >	341:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	343:     ST  1,-3(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	344:    LDC  3,1(6)	Load Boolean constant 
												   >	345:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end outputb
												   >	346:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	347:    LDA  3,1(7)	Return address in ac 
												   >	348:    JMP  7,-332(7)	CALL outputb
												   >	349:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	350:     LD  3,-2(1)	load lhs variable i
												   >	351:    LDA  3,1(3)	increment value of i
												   >	352:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	353:    JMP  7,-18(7)	go to beginning of loop 
												   >	342:    JMP  7,11(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	354:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	355:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	356:    LDA  3,1(7)	Return address in ac 
												   >	357:    JMP  7,-324(7)	CALL outnl
												   >	358:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* RETURN
												   >	359:    LDC  3,0(6)	Load Boolean constant 
												   >	360:    LDA  2,0(3)	Copy result to return register 
												   >	361:     LD  3,-1(1)	Load return address 
												   >	362:     LD  1,0(1)	Adjust fp 
												   >	363:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	333:    JZR  3,31(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	365:    LDC  3,1(6)	Load Boolean constant 
												   >	366:    LDA  2,0(3)	Copy result to return register 
												   >	367:     LD  3,-1(1)	Load return address 
												   >	368:     LD  1,0(1)	Adjust fp 
												   >	369:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	364:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	260:    JZR  3,109(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	370:    LDC  3,0(6)	Load integer constant 
												   >	371:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	372:     LD  3,-2(1)	Load variable i
												   >	373:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	374:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	375:     LD  4,-3(1)	Pop left into ac1 
												   >	376:    TLT  3,4,3	Op < 
												   >	377:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	379:     ST  1,-3(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	380:    LDC  3,0(6)	Load Boolean constant 
												   >	381:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end outputb
												   >	382:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	383:    LDA  3,1(7)	Return address in ac 
												   >	384:    JMP  7,-368(7)	CALL outputb
												   >	385:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	386:     LD  3,-2(1)	load lhs variable i
												   >	387:    LDA  3,1(3)	increment value of i
												   >	388:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	389:    JMP  7,-18(7)	go to beginning of loop 
												   >	378:    JMP  7,11(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	390:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	391:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	392:    LDA  3,1(7)	Return address in ac 
												   >	393:    JMP  7,-360(7)	CALL outnl
												   >	394:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* RETURN
												   >	395:    LDC  3,0(6)	Load Boolean constant 
												   >	396:    LDA  2,0(3)	Copy result to return register 
												   >	397:     LD  3,-1(1)	Load return address 
												   >	398:     LD  1,0(1)	Adjust fp 
												   >	399:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	400:    LDC  2,0(6)	Set return value to 0 
												   >	401:     LD  3,-1(1)	Load return address 
												   >	402:     LD  1,0(1)	Adjust fp 
												   >	403:    JMP  7,0(3)	Return 
												   >	* END FUNCTION turn
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	404:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	405:    LDC  3,0(6)	Load integer constant 
												   >	406:     ST  3,-1(0)	Store variable n
												   >	* EXPRESSION
												   >	407:    LDC  3,0(6)	Load integer constant 
												   >	408:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	* CALL input
												   >	409:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	410:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	411:    LDA  3,1(7)	Return address in ac 
												   >	412:    JMP  7,-412(7)	CALL input
												   >	413:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	* TOFF inc: -3
												   >	414:     LD  4,-3(1)	Pop index 
												   >	415:    LDA  5,-3(0)	Load address of base of array r
												   >	416:    SUB  5,5,4	Compute offset of value 
												   >	417:     ST  3,0(5)	Store variable r
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	418:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	419:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	420:    LDA  3,1(7)	Return address in ac 
												   >	421:    JMP  7,-388(7)	CALL outnl
												   >	422:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	423:    LDC  3,0(6)	Load integer constant 
												   >	424:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	425:     LD  3,-2(1)	Load variable i
												   >	426:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	427:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	428:     LD  4,-3(1)	Pop left into ac1 
												   >	429:    TLT  3,4,3	Op < 
												   >	430:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	432:     LD  3,-2(1)	Load variable i
												   >	433:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	* CALL rand
												   >	434:     ST  1,-4(1)	Store fp in ghost frame for rand
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end rand
												   >	435:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	436:    LDA  3,1(7)	Return address in ac 
												   >	437:    JMP  7,-399(7)	CALL rand
												   >	438:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end rand
												   >	* TOFF set: -4
												   >	439:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	440:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	441:     LD  4,-4(1)	Pop left into ac1 
												   >	442:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -3
												   >	443:     LD  4,-3(1)	Pop index 
												   >	444:    LDA  5,-132(0)	Load address of base of array known
												   >	445:    SUB  5,5,4	Compute offset of value 
												   >	446:     ST  3,0(5)	Store variable known
												   >	* EXPRESSION
												   >	447:     LD  3,-2(1)	load lhs variable i
												   >	448:    LDA  3,1(3)	increment value of i
												   >	449:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	450:    JMP  7,-26(7)	go to beginning of loop 
												   >	431:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	451:    LDC  3,0(6)	Load integer constant 
												   >	452:     ST  3,0(0)	Store variable turns
												   >	* WHILE
												   >	* CALL turn
												   >	453:     ST  1,-3(1)	Store fp in ghost frame for turn
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end turn
												   >	454:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	455:    LDA  3,1(7)	Return address in ac 
												   >	456:    JMP  7,-218(7)	CALL turn
												   >	457:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end turn
												   >	* TOFF set: -3
												   >	458:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	460:    JMP  7,-8(7)	go to beginning of loop 
												   >	459:    JMP  7,1(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	461:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	462:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	463:    LDA  3,1(7)	Return address in ac 
												   >	464:    JMP  7,-431(7)	CALL outnl
												   >	465:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	466:    LDC  3,0(6)	Load integer constant 
												   >	467:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	468:     LD  3,-2(1)	Load variable i
												   >	469:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	470:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	471:     LD  4,-3(1)	Pop left into ac1 
												   >	472:    TLT  3,4,3	Op < 
												   >	473:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	475:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	476:    LDA  3,-132(0)	Load address of base of array known
												   >	477:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	478:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -5
												   >	479:     LD  4,-5(1)	Pop left into ac1 
												   >	480:    SUB  3,4,3	compute location from index 
												   >	481:     LD  3,0(3)	Load array element 
												   >	482:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	483:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	484:    LDA  3,1(7)	Return address in ac 
												   >	485:    JMP  7,-480(7)	CALL output
												   >	486:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	487:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	488:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	489:    LDA  3,1(7)	Return address in ac 
												   >	490:    JMP  7,-457(7)	CALL outnl
												   >	491:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	492:     LD  3,-2(1)	load lhs variable i
												   >	493:    LDA  3,1(3)	increment value of i
												   >	494:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	495:    JMP  7,-28(7)	go to beginning of loop 
												   >	474:    JMP  7,21(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	496:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	497:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	498:    LDA  3,1(7)	Return address in ac 
												   >	499:    JMP  7,-466(7)	CALL outnl
												   >	500:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	501:    LDC  2,0(6)	Set return value to 0 
												   >	502:     LD  3,-1(1)	Load return address 
												   >	503:     LD  1,0(1)	Adjust fp 
												   >	504:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,504(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	505:    LDA  1,-141(0)	set first frame at end of globals 
												   >	506:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	507:    LDC  3,4(6)	load size of array guess
												   >	508:     ST  3,-136(0)	save size of array guess
												   >	509:    LDC  3,4(6)	load size of array known
												   >	510:     ST  3,-131(0)	save size of array known
												   >	511:    LDC  3,128(6)	load size of array r
												   >	512:     ST  3,-2(0)	save size of array r
												   >	* END INIT GLOBALS AND STATICS
												   >	513:    LDA  3,1(7)	Return address in ac 
												   >	514:    JMP  7,-111(7)	Jump to main 
												   >	515:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
mastermind.mem mastermind.mem.f21 differ: byte 1, line 1
mastermind (MEM DIFF)
Var: turns of type int [mem: Global loc: 0 size: 1] [line: 30]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: n of type int [mem: Global loc: -1 size: 1] [line: 30]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: r of array of type int [mem: Global loc: -3 size: 129] [line: 30]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Var: known of array of type int [mem: Global loc: -132 size: 5] [line: 30]		   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 4  Var: guess of array of type int [mem: Global loc: -137 size: 5] [line: 30]		   |	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 5  Func: rand returns type int [mem: Global loc: 0 size: -2] [line: 38]		   |	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: turns of type int [mem: Global loc: 0 size: 1] [line: 30]
												   >	Sibling: 8  Var: n of type int [mem: Global loc: -1 size: 1] [line: 30]
												   >	Sibling: 9  Var: r of array of type int [mem: Global loc: -3 size: 129] [line: 30]
												   >	Sibling: 10  Var: known of array of type int [mem: Global loc: -132 size: 5] [line: 30]
												   >	Sibling: 11  Var: guess of array of type int [mem: Global loc: -137 size: 5] [line: 30]
												   >	Sibling: 12  Func: rand returns type int [mem: Global loc: 0 size: -2] [line: 38]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 39]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 39]
.   .   Child: 1  If [line: 40]										.   .   Child: 1  If [line: 40]
.   .   .   Child: 0  Op: < of type bool [line: 40]							.   .   .   Child: 0  Op: < of type bool [line: 40]
.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]			.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]
.   .   .   .   Child: 1  Const 0 of type int [line: 40]						.   .   .   .   Child: 1  Const 0 of type int [line: 40]
.   .   .   Child: 1  Assign: = of type int [line: 40]						   |	.   .   .   Child: 1  Assign: := of type int [line: 40]
.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]			.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]
.   .   .   .   Child: 1  Op: chsign of type int [line: 40]						.   .   .   .   Child: 1  Op: chsign of type int [line: 40]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 40]
.   .   Sibling: 1  If [line: 41]									.   .   Sibling: 1  If [line: 41]
.   .   .   Child: 0  Op: > of type bool [line: 41]							.   .   .   Child: 0  Op: > of type bool [line: 41]
.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]			.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]
.   .   .   .   Child: 1  Const 128 of type int [line: 41]						.   .   .   .   Child: 1  Const 128 of type int [line: 41]
.   .   .   Child: 1  Assign: = of type int [line: 41]						   |	.   .   .   Child: 1  Assign: := of type int [line: 41]
.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]			.   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]
.   .   .   .   Child: 1  Op: % of type int [line: 41]							.   .   .   .   Child: 1  Op: % of type int [line: 41]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 41]
.   .   .   .   .   Child: 1  Const 128 of type int [line: 41]						.   .   .   .   .   Child: 1  Const 128 of type int [line: 41]
.   .   Sibling: 2  Assign: ++ of type int [line: 42]							.   .   Sibling: 2  Assign: ++ of type int [line: 42]
.   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 42]			.   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 42]
.   .   Sibling: 3  Assign: = of type int [line: 43]						   |	.   .   Sibling: 3  Assign: := of type int [line: 43]
.   .   .   Child: 0  Op: [ of type int [line: 43]							.   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 43]		.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 43]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -1 size: 1] [line: 43]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -1 size: 1] [line: 43]
.   .   .   Child: 1  Op: % of type int [line: 43]							.   .   .   Child: 1  Op: % of type int [line: 43]
.   .   .   .   Child: 0  Op: + of type int [line: 43]							.   .   .   .   Child: 0  Op: + of type int [line: 43]
.   .   .   .   .   Child: 0  Op: * of type int [line: 43]						.   .   .   .   .   Child: 0  Op: * of type int [line: 43]
.   .   .   .   .   .   Child: 0  Const 1366 of type int [line: 43]					.   .   .   .   .   .   Child: 0  Const 1366 of type int [line: 43]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 43]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 43]
.   .   .   .   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129]	.   .   .   .   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129]
.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]					.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   Child: 1  Const 150889 of type int [line: 43]					.   .   .   .   .   Child: 1  Const 150889 of type int [line: 43]
.   .   .   .   Child: 1  Const 714025 of type int [line: 43]						.   .   .   .   Child: 1  Const 714025 of type int [line: 43]
.   .   Sibling: 4  Return [line: 44]									.   .   Sibling: 4  Return [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 44]		.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 44]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -1 size: 1] [line: 44]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -1 size: 1] [line: 44]
Sibling: 6  Func: search returns type bool [mem: Global loc: 0 size: -4] [line: 47]		   |	Sibling: 13  Func: search returns type bool [mem: Global loc: 0 size: -4] [line: 47]
.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 47]			.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 47]
.   Sibling: 1  Parm: k of type int [mem: Parameter loc: -3 size: 1] [line: 47]				.   Sibling: 1  Parm: k of type int [mem: Parameter loc: -3 size: 1] [line: 47]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 48]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 48]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 49]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 49]
.   .   Child: 1  Assign: = of type int [line: 52]						   |	.   .   Child: 1  Assign: := of type int [line: 52]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 52]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 52]
.   .   .   Child: 1  Const 0 of type int [line: 52]							.   .   .   Child: 1  Const 0 of type int [line: 52]
.   .   Sibling: 1  While [line: 53]									.   .   Sibling: 1  While [line: 53]
.   .   .   Child: 0  Op: < of type bool [line: 53]							.   .   .   Child: 0  Op: < of type bool [line: 53]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 53]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 53]
.   .   .   .   Child: 1  Const 4 of type int [line: 53]						.   .   .   .   Child: 1  Const 4 of type int [line: 53]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 53]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 53]
.   .   .   .   Child: 1  If [line: 54]									.   .   .   .   Child: 1  If [line: 54]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 54]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 54]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]
.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 54]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 54]
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Parameter loc: -3 size: 1] [line: 54]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Parameter loc: -3 size: 1] [line: 54]
.   .   .   .   .   Child: 1  Return [line: 54]								.   .   .   .   .   Child: 1  Return [line: 54]
.   .   .   .   .   .   Child: 0  Const true of type bool [line: 54]					.   .   .   .   .   .   Child: 0  Const true of type bool [line: 54]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 55]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 55]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 55]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 55]
.   .   Sibling: 2  Return [line: 58]									.   .   Sibling: 2  Return [line: 58]
.   .   .   Child: 0  Const false of type bool [line: 58]						.   .   .   Child: 0  Const false of type bool [line: 58]
Sibling: 7  Func: check returns type bool [mem: Global loc: 0 size: -2] [line: 61]		   |	Sibling: 14  Func: check returns type bool [mem: Global loc: 0 size: -2] [line: 61]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 62]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 62]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 63]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 63]
.   .   Sibling: 1  Var: c1 of type int [mem: Local loc: -3 size: 1] [line: 63]				.   .   Sibling: 1  Var: c1 of type int [mem: Local loc: -3 size: 1] [line: 63]
.   .   Sibling: 2  Var: c2 of type int [mem: Local loc: -4 size: 1] [line: 63]				.   .   Sibling: 2  Var: c2 of type int [mem: Local loc: -4 size: 1] [line: 63]
.   .   Child: 1  Assign: = of type int [line: 66]						   |	.   .   Child: 1  Assign: := of type int [line: 66]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 66]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 66]
.   .   .   Child: 1  Assign: = of type int [line: 66]						   |	.   .   .   Child: 1  Assign: := of type int [line: 66]
.   .   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 66]			.   .   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 66]
.   .   .   .   Child: 1  Assign: = of type int [line: 66]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 66]
.   .   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 66]		.   .   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 66]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 66]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 66]
.   .   Sibling: 1  While [line: 67]									.   .   Sibling: 1  While [line: 67]
.   .   .   Child: 0  Op: < of type bool [line: 67]							.   .   .   Child: 0  Op: < of type bool [line: 67]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 67]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 67]
.   .   .   .   Child: 1  Const 4 of type int [line: 67]						.   .   .   .   Child: 1  Const 4 of type int [line: 67]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 67]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 67]
.   .   .   .   Child: 1  If [line: 68]									.   .   .   .   Child: 1  If [line: 68]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 68]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 68]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 68]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 68]
.   .   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size	.   .   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 68]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 68]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 68]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 68]
.   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 size	.   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 size
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 68]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 68]
.   .   .   .   .   Child: 1  Assign: ++ of type int [line: 68]						.   .   .   .   .   Child: 1  Assign: ++ of type int [line: 68]
.   .   .   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 68]		.   .   .   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 68]
.   .   .   .   .   Child: 2  If [line: 69]								.   .   .   .   .   Child: 2  If [line: 69]
.   .   .   .   .   .   Child: 0  Call: search of type bool [line: 69]					.   .   .   .   .   .   Child: 0  Call: search of type bool [line: 69]
.   .   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size	.   .   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size
.   .   .   .   .   .   .   Sibling: 1  Op: [ of type int [line: 69]					.   .   .   .   .   .   .   Sibling: 1  Op: [ of type int [line: 69]
.   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 	.   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 69]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 69]
.   .   .   .   .   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 69]	.   .   .   .   .   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 69]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 70]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 70]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 70]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 70]
.   .   Sibling: 2  Call: output of type void [line: 73]						.   .   Sibling: 2  Call: output of type void [line: 73]
.   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 73]			.   .   .   Child: 0  Id: c1 of type int [mem: Local loc: -3 size: 1] [line: 73]
.   .   Sibling: 3  Call: output of type void [line: 74]						.   .   Sibling: 3  Call: output of type void [line: 74]
.   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 74]			.   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 74]
.   .   Sibling: 4  Call: outnl of type void [line: 75]							.   .   Sibling: 4  Call: outnl of type void [line: 75]
.   .   Sibling: 5  If [line: 77]									.   .   Sibling: 5  If [line: 77]
.   .   .   Child: 0  Op: == of type bool [line: 77]						   |	.   .   .   Child: 0  Op: = of type bool [line: 77]
.   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 77]			.   .   .   .   Child: 0  Id: c2 of type int [mem: Local loc: -4 size: 1] [line: 77]
.   .   .   .   Child: 1  Const 4 of type int [line: 77]						.   .   .   .   Child: 1  Const 4 of type int [line: 77]
.   .   .   Child: 1  Return [line: 78]									.   .   .   Child: 1  Return [line: 78]
.   .   .   .   Child: 0  Const true of type bool [line: 78]						.   .   .   .   Child: 0  Const true of type bool [line: 78]
.   .   .   Child: 2  Return [line: 80]									.   .   .   Child: 2  Return [line: 80]
.   .   .   .   Child: 0  Const false of type bool [line: 80]						.   .   .   .   Child: 0  Const false of type bool [line: 80]
Sibling: 8  Func: turn returns type bool [mem: Global loc: 0 size: -2] [line: 83]		   |	Sibling: 15  Func: turn returns type bool [mem: Global loc: 0 size: -2] [line: 83]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 84]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 84]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 85]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 85]
.   .   Child: 1  Assign: ++ of type int [line: 88]							.   .   Child: 1  Assign: ++ of type int [line: 88]
.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 88]			.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 88]
.   .   Sibling: 1  Call: output of type void [line: 89]						.   .   Sibling: 1  Call: output of type void [line: 89]
.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 89]			.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 89]
.   .   Sibling: 2  Call: outnl of type void [line: 90]							.   .   Sibling: 2  Call: outnl of type void [line: 90]
.   .   Sibling: 3  If [line: 92]									.   .   Sibling: 3  If [line: 92]
.   .   .   Child: 0  Op: <= of type bool [line: 92]							.   .   .   Child: 0  Op: <= of type bool [line: 92]
.   .   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 92]			.   .   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 92]
.   .   .   .   Child: 1  Const 20 of type int [line: 92]						.   .   .   .   Child: 1  Const 20 of type int [line: 92]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 92]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 92]
.   .   .   .   Child: 1  Assign: = of type int [line: 94]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 94]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 94]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 94]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 94]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 94]
.   .   .   .   Sibling: 1  While [line: 95]								.   .   .   .   Sibling: 1  While [line: 95]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 95]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 95]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 95]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 95]
.   .   .   .   .   .   Child: 1  Const 4 of type int [line: 95]					.   .   .   .   .   .   Child: 1  Const 4 of type int [line: 95]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 95]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 95]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 96]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 96]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 96]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 96]
.   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 	.   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -137 
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 96]				.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 96]
.   .   .   .   .   .   Sibling: 1  If [line: 97]							.   .   .   .   .   .   Sibling: 1  If [line: 97]
.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 97]					.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 97]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 97]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 97]
.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 97]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 97]
.   .   .   .   .   .   .   Child: 1  Return [line: 98]							.   .   .   .   .   .   .   Child: 1  Return [line: 98]
.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 98]				.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 98]
.   .   .   .   .   .   Sibling: 2  If [line: 99]							.   .   .   .   .   .   Sibling: 2  If [line: 99]
.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 99]					.   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 99]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]
.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 99]				.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 99]
.   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 99]				   |	.   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 99]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]
.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Child: 1  Op: % of type int [line: 99]					.   .   .   .   .   .   .   .   Child: 1  Op: % of type int [line: 99]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 99]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: guess of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 99]				.   .   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 99]
.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 100]					.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 100]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 100]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 100]
.   .   .   .   Sibling: 2  If [line: 104]								.   .   .   .   Sibling: 2  If [line: 104]
.   .   .   .   .   Child: 0  Call: check of type bool [line: 104]					.   .   .   .   .   Child: 0  Call: check of type bool [line: 104]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 104]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 104]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 105]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 105]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 105]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 105]
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 105]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 105]
.   .   .   .   .   .   Sibling: 1  While [line: 106]							.   .   .   .   .   .   Sibling: 1  While [line: 106]
.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 106]					.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 106]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 106]				.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 106]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 106]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 106]
.   .   .   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 107]			.   .   .   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 107]
.   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 107]			.   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 107]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 108]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 108]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 110]				.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 110]
.   .   .   .   .   .   Sibling: 3  Return [line: 111]							.   .   .   .   .   .   Sibling: 3  Return [line: 111]
.   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 111]				.   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 111]
.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 112]				.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 112]
.   .   .   .   .   .   Child: 1  Return [line: 113]							.   .   .   .   .   .   Child: 1  Return [line: 113]
.   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 113]				.   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 113]
.   .   Sibling: 4  Assign: = of type int [line: 118]						   |	.   .   Sibling: 4  Assign: := of type int [line: 118]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 118]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 118]
.   .   .   Child: 1  Const 0 of type int [line: 118]							.   .   .   Child: 1  Const 0 of type int [line: 118]
.   .   Sibling: 5  While [line: 119]									.   .   Sibling: 5  While [line: 119]
.   .   .   Child: 0  Op: < of type bool [line: 119]							.   .   .   Child: 0  Op: < of type bool [line: 119]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 119]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 119]
.   .   .   .   Child: 1  Const 10 of type int [line: 119]						.   .   .   .   Child: 1  Const 10 of type int [line: 119]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 119]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 119]
.   .   .   .   Child: 1  Call: outputb of type void [line: 120]					.   .   .   .   Child: 1  Call: outputb of type void [line: 120]
.   .   .   .   .   Child: 0  Const false of type bool [line: 120]					.   .   .   .   .   Child: 0  Const false of type bool [line: 120]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 121]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 121]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 121]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 121]
.   .   Sibling: 6  Call: outnl of type void [line: 123]						.   .   Sibling: 6  Call: outnl of type void [line: 123]
.   .   Sibling: 7  Return [line: 124]									.   .   Sibling: 7  Return [line: 124]
.   .   .   Child: 0  Const false of type bool [line: 124]						.   .   .   Child: 0  Const false of type bool [line: 124]
Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 127]		   |	Sibling: 16  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 127]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 128]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 128]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 129]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 129]
.   .   Child: 1  Assign: = of type int [line: 132]						   |	.   .   Child: 1  Assign: := of type int [line: 132]
.   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 132]			.   .   .   Child: 0  Id: n of type int [mem: Global loc: -1 size: 1] [line: 132]
.   .   .   Child: 1  Const 0 of type int [line: 132]							.   .   .   Child: 1  Const 0 of type int [line: 132]
.   .   Sibling: 1  Assign: = of type int [line: 133]						   |	.   .   Sibling: 1  Assign: := of type int [line: 133]
.   .   .   Child: 0  Op: [ of type int [line: 133]							.   .   .   Child: 0  Op: [ of type int [line: 133]
.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 133]	.   .   .   .   Child: 0  Id: r of array of type int [mem: Global loc: -3 size: 129] [line: 133]
.   .   .   .   Child: 1  Const 0 of type int [line: 133]						.   .   .   .   Child: 1  Const 0 of type int [line: 133]
.   .   .   Child: 1  Call: input of type int [line: 133]						.   .   .   Child: 1  Call: input of type int [line: 133]
.   .   Sibling: 2  Call: outnl of type void [line: 134]						.   .   Sibling: 2  Call: outnl of type void [line: 134]
.   .   Sibling: 3  Assign: = of type int [line: 137]						   |	.   .   Sibling: 3  Assign: := of type int [line: 137]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 137]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 137]
.   .   .   Child: 1  Const 0 of type int [line: 137]							.   .   .   Child: 1  Const 0 of type int [line: 137]
.   .   Sibling: 4  While [line: 138]									.   .   Sibling: 4  While [line: 138]
.   .   .   Child: 0  Op: < of type bool [line: 138]							.   .   .   Child: 0  Op: < of type bool [line: 138]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 138]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 138]
.   .   .   .   Child: 1  Const 4 of type int [line: 138]						.   .   .   .   Child: 1  Const 4 of type int [line: 138]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 138]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 138]
.   .   .   .   Child: 1  Assign: = of type int [line: 139]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 139]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 139]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 139]
.   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size: 5]	.   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size: 5]
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 139]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 139]
.   .   .   .   .   Child: 1  Op: % of type int [line: 139]						.   .   .   .   .   Child: 1  Op: % of type int [line: 139]
.   .   .   .   .   .   Child: 0  Call: rand of type int [line: 139]					.   .   .   .   .   .   Child: 0  Call: rand of type int [line: 139]
.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 139]					.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 139]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 140]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 140]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 140]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 140]
.   .   Sibling: 5  Assign: = of type int [line: 144]						   |	.   .   Sibling: 5  Assign: := of type int [line: 144]
.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 144]			.   .   .   Child: 0  Id: turns of type int [mem: Global loc: 0 size: 1] [line: 144]
.   .   .   Child: 1  Const 0 of type int [line: 144]							.   .   .   Child: 1  Const 0 of type int [line: 144]
.   .   Sibling: 6  While [line: 145]									.   .   Sibling: 6  While [line: 145]
.   .   .   Child: 0  Call: turn of type bool [line: 145]						.   .   .   Child: 0  Call: turn of type bool [line: 145]
.   .   Sibling: 7  Call: outnl of type void [line: 148]						.   .   Sibling: 7  Call: outnl of type void [line: 148]
.   .   Sibling: 8  Assign: = of type int [line: 149]						   |	.   .   Sibling: 8  Assign: := of type int [line: 149]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 149]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 149]
.   .   .   Child: 1  Const 0 of type int [line: 149]							.   .   .   Child: 1  Const 0 of type int [line: 149]
.   .   Sibling: 9  While [line: 150]									.   .   Sibling: 9  While [line: 150]
.   .   .   Child: 0  Op: < of type bool [line: 150]							.   .   .   Child: 0  Op: < of type bool [line: 150]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 150]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 150]
.   .   .   .   Child: 1  Const 4 of type int [line: 150]						.   .   .   .   Child: 1  Const 4 of type int [line: 150]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 150]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 150]
.   .   .   .   Child: 1  Call: output of type void [line: 151]						.   .   .   .   Child: 1  Call: output of type void [line: 151]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 151]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 151]
.   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size: 5]	.   .   .   .   .   .   Child: 0  Id: known of array of type int [mem: Global loc: -132 size: 5]
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 151]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 151]
.   .   .   .   Sibling: 1  Call: outnl of type void [line: 152]					.   .   .   .   Sibling: 1  Call: outnl of type void [line: 152]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 153]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 153]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 153]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 153]
.   .   Sibling: 10  Call: outnl of type void [line: 155]						.   .   Sibling: 10  Call: outnl of type void [line: 155]
Offset for end of global space: -141									Offset for end of global space: -141
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
mastermind.out ztmp23114.txt differ: byte 1, line 1
mastermind (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/mastermind.tm
Number of errors: 0										   |	entered: 333331
------------------------------------								   |	1
Loading file: mastermind.tm									   |	entered: 1
ERROR: TM Command 3 unknown.									   |	entered: 2
ERROR: TM Command 1 unknown.									   |	entered: 3
ERROR: TM Command 2 unknown.									   |	entered: 4
ERROR: TM Command 3 unknown.									   |	1 1
ERROR: TM Command 4 unknown.									   |	2
ERROR: TM Command 2 unknown.									   |	entered: 2
ERROR: TM Command 3 unknown.									   |	entered: 3
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 5 unknown.									   |	entered: 5
ERROR: TM Command 3 unknown.									   |	2 0
ERROR: TM Command 4 unknown.									   |	3
ERROR: TM Command 5 unknown.									   |	entered: 3
ERROR: TM Command 6 unknown.									   |	entered: 4
ERROR: TM Command 7 unknown.									   |	entered: 5
ERROR: TM Command 8 unknown.									   |	entered: 6
ERROR: TM Command 9 unknown.									   |	1 0
ERROR: TM Command 0 unknown.									   |	4
ERROR: TM Command 1 unknown.									   |	entered: 7
ERROR: TM Command 2 unknown.									   |	entered: 8
ERROR: TM Command 3 unknown.									   |	entered: 9
ERROR: TM Command 4 unknown.									   |	entered: 0
ERROR: TM Command 2 unknown.									   |	2 0
ERROR: TM Command 3 unknown.									   |	5
ERROR: TM Command 4 unknown.									   |	entered: 1
ERROR: TM Command 5 unknown.									   |	entered: 2
ERROR: TM Command 3 unknown.									   |	entered: 3
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 5 unknown.									   |	1 1
ERROR: TM Command 6 unknown.									   |	6
ERROR: TM Command 7 unknown.									   |	entered: 2
ERROR: TM Command 8 unknown.									   |	entered: 3
ERROR: TM Command 9 unknown.									   |	entered: 4
ERROR: TM Command 0 unknown.									   |	entered: 5
ERROR: TM Command 1 unknown.									   |	2 0
ERROR: TM Command 2 unknown.									   |	7
ERROR: TM Command 3 unknown.									   |	entered: 3
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 2 unknown.									   |	entered: 5
ERROR: TM Command 3 unknown.									   |	entered: 6
ERROR: TM Command 4 unknown.									   |	1 0
ERROR: TM Command 5 unknown.									   |	8
ERROR: TM Command 3 unknown.									   |	entered: 7
ERROR: TM Command 4 unknown.									   |	entered: 8
ERROR: TM Command 5 unknown.									   |	entered: 9
ERROR: TM Command 6 unknown.									   |	entered: 0
ERROR: TM Command 7 unknown.									   |	2 0
ERROR: TM Command 8 unknown.									   |	9
ERROR: TM Command 9 unknown.									   |	entered: 1
ERROR: TM Command 0 unknown.									   |	entered: 2
ERROR: TM Command 1 unknown.									   |	entered: 3
ERROR: TM Command 2 unknown.									   |	entered: 4
ERROR: TM Command 3 unknown.									   |	1 1
ERROR: TM Command 4 unknown.									   |	10
ERROR: TM Command 2 unknown.									   |	entered: 2
ERROR: TM Command 3 unknown.									   |	entered: 3
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 5 unknown.									   |	entered: 5
ERROR: TM Command 3 unknown.									   |	2 0
ERROR: TM Command 4 unknown.									   |	11
ERROR: TM Command 5 unknown.									   |	entered: 3
ERROR: TM Command 6 unknown.									   |	entered: 4
ERROR: TM Command 7 unknown.									   |	entered: 5
ERROR: TM Command 8 unknown.									   |	entered: 6
ERROR: TM Command 9 unknown.									   |	1 0
ERROR: TM Command 0 unknown.									   |	12
ERROR: TM Command 1 unknown.									   |	entered: 7
ERROR: TM Command 2 unknown.									   |	entered: 8
ERROR: TM Command 3 unknown.									   |	entered: 9
ERROR: TM Command 4 unknown.									   |	entered: 0
ERROR: TM Command 2 unknown.									   |	2 0
ERROR: TM Command 3 unknown.									   |	13
ERROR: TM Command 4 unknown.									   |	entered: 1
ERROR: TM Command 5 unknown.									   |	entered: 2
ERROR: TM Command 3 unknown.									   |	entered: 3
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 5 unknown.									   |	1 1
ERROR: TM Command 6 unknown.									   |	14
ERROR: TM Command 7 unknown.									   |	entered: 2
ERROR: TM Command 8 unknown.									   |	entered: 3
ERROR: TM Command 9 unknown.									   |	entered: 4
ERROR: TM Command 0 unknown.									   |	entered: 5
												   >	2 0
												   >	15
												   >	entered: 3
												   >	entered: 4
												   >	entered: 5
												   >	entered: 6
												   >	1 0
												   >	16
												   >	entered: 7
												   >	entered: 8
												   >	entered: 9
												   >	entered: 0
												   >	2 0
												   >	17
												   >	entered: 1
												   >	entered: 2
												   >	entered: 3
												   >	entered: 4
												   >	1 1
												   >	18
												   >	entered: 2
												   >	entered: 3
												   >	entered: 4
												   >	entered: 5
												   >	2 0
												   >	19
												   >	entered: 3
												   >	entered: 4
												   >	entered: 5
												   >	entered: 6
												   >	1 0
												   >	20
												   >	entered: 7
												   >	entered: 8
												   >	entered: 9
												   >	entered: 0
												   >	2 0
												   >	21
												   >	F F F F F F F F F F
												   >	0
												   >	9
												   >	3
												   >	2
Bye.													Bye.
====================================
FILE: miller.c-
-rw-------. 1 corg7983 domain_users  1606 Nov 17 15:35 miller.c-
-rw-------. 1 corg7983 domain_users  1652 Nov 17 15:35 miller.c-.f21
-rw-------. 1 corg7983 domain_users  1606 Nov 17 15:35 miller.c-.f22
-rw-------. 1 corg7983 domain_users   119 Nov 17 15:35 miller.expected
-rw-------. 1 corg7983 domain_users 26127 Nov 22 12:27 miller.mem
-rw-------. 1 corg7983 domain_users  5758 Nov 17 15:35 miller.mem.diffs
-rw-------. 1 corg7983 domain_users 27017 Nov 17 15:35 miller.mem.f21
-rw-------. 1 corg7983 domain_users   108 Nov 22 12:27 miller.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 miller.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 miller.tm.diffs
-rw-------. 1 corg7983 domain_users 38393 Nov 17 15:35 miller.tm.f21
TM CODE COMPARISON
miller (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  miller.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION showIntArray
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-4(1)	Load variable i
												   >	 43:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 44:     LD  3,-3(1)	Load variable size
												   >	* TOFF inc: -5
												   >	 45:     LD  4,-5(1)	Pop left into ac1 
												   >	 46:    TLT  3,4,3	Op < 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 49:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 50:     LD  3,-2(1)	Load address of base of array x
												   >	 51:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 52:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -7
												   >	 53:     LD  4,-7(1)	Pop left into ac1 
												   >	 54:    SUB  3,4,3	compute location from index 
												   >	 55:     LD  3,0(3)	Load array element 
												   >	 56:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 57:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 58:    LDA  3,1(7)	Return address in ac 
												   >	 59:    JMP  7,-54(7)	CALL output
												   >	 60:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 61:     LD  3,-4(1)	Load variable i
												   >	 62:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 63:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 64:     LD  4,-5(1)	Pop left into ac1 
												   >	 65:    ADD  3,4,3	Op + 
												   >	 66:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 67:    JMP  7,-26(7)	go to beginning of loop 
												   >	 48:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 68:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	 69:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-38(7)	CALL outnl
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 73:    LDC  2,0(6)	Set return value to 0 
												   >	 74:     LD  3,-1(1)	Load return address 
												   >	 75:     LD  1,0(1)	Adjust fp 
												   >	 76:    JMP  7,0(3)	Return 
												   >	* END FUNCTION showIntArray
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 77:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 78:     LD  3,-2(1)	Load variable a
												   >	 79:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 80:    LDC  3,7(6)	Load integer constant 
												   >	 81:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	 82:     LD  3,-3(1)	Load address of base of array b
												   >	 83:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 84:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 85:     LD  4,-5(1)	Pop left into ac1 
												   >	 86:    SUB  3,4,3	compute location from index 
												   >	 87:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	 88:     LD  4,-4(1)	Pop index 
												   >	 89:     LD  5,-3(1)	Load address of base of array b
												   >	 90:    SUB  5,5,4	Compute offset of value 
												   >	 91:     ST  3,0(5)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	 92:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 93:     LD  3,-2(1)	Load variable a
												   >	 94:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 95:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 96:    LDA  3,1(7)	Return address in ac 
												   >	 97:    JMP  7,-92(7)	CALL output
												   >	 98:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 99:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	100:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-69(7)	CALL outnl
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	104:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	105:     LD  3,-3(1)	Load address of base of array b
												   >	106:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	107:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	108:     LD  4,-6(1)	Pop left into ac1 
												   >	109:    SUB  3,4,3	compute location from index 
												   >	110:     LD  3,0(3)	Load array element 
												   >	111:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	112:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	113:    LDA  3,1(7)	Return address in ac 
												   >	114:    JMP  7,-109(7)	CALL output
												   >	115:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	116:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	117:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	118:    LDA  3,1(7)	Return address in ac 
												   >	119:    JMP  7,-86(7)	CALL outnl
												   >	120:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	121:    LDC  2,0(6)	Set return value to 0 
												   >	122:     LD  3,-1(1)	Load return address 
												   >	123:     LD  1,0(1)	Adjust fp 
												   >	124:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getnxtindex
												   >	* TOFF set: -3
												   >	125:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	126:     LD  3,-2(1)	Load variable x
												   >	127:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	128:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	129:     LD  4,-3(1)	Pop left into ac1 
												   >	130:    ADD  3,4,3	Op + 
												   >	131:    LDA  2,0(3)	Copy result to return register 
												   >	132:     LD  3,-1(1)	Load return address 
												   >	133:     LD  1,0(1)	Adjust fp 
												   >	134:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	135:    LDC  2,0(6)	Set return value to 0 
												   >	136:     LD  3,-1(1)	Load return address 
												   >	137:     LD  1,0(1)	Adjust fp 
												   >	138:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getnxtindex
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	139:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -58
												   >	140:    LDC  3,10(6)	load size of array c
												   >	141:     ST  3,-3(1)	save size of array c
												   >	142:    LDC  3,10(6)	load size of array d
												   >	143:     ST  3,-14(1)	save size of array d
												   >	144:    LDC  3,10(6)	load size of array y
												   >	145:     ST  3,-25(1)	save size of array y
												   >	146:    LDC  3,10(6)	load size of array z
												   >	147:     ST  3,-36(1)	save size of array z
												   >	148:    LDC  3,10(6)	load size of array w
												   >	149:     ST  3,-47(1)	save size of array w
												   >	* Compound Body
												   >	* EXPRESSION
												   >	150:    LDC  3,0(6)	Load integer constant 
												   >	151:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	152:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	153:     LD  4,-58(1)	Pop index 
												   >	154:    LDA  5,-4(1)	Load address of base of array c
												   >	155:    SUB  5,5,4	Compute offset of value 
												   >	156:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	157:    LDC  3,3(6)	Load integer constant 
												   >	158:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	159:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	160:     LD  4,-58(1)	Pop index 
												   >	161:    LDA  5,-15(1)	Load address of base of array d
												   >	162:    SUB  5,5,4	Compute offset of value 
												   >	163:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	164:    LDC  3,4(6)	Load integer constant 
												   >	165:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	166:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	167:     LD  4,-58(1)	Pop index 
												   >	168:    LDA  5,-15(1)	Load address of base of array d
												   >	169:    SUB  5,5,4	Compute offset of value 
												   >	170:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	171:    LDC  3,5(6)	Load integer constant 
												   >	172:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	173:    LDC  3,100(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	174:     LD  4,-58(1)	Pop index 
												   >	175:    LDA  5,-26(1)	Load address of base of array y
												   >	176:    SUB  5,5,4	Compute offset of value 
												   >	177:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	178:    LDC  3,9(6)	Load integer constant 
												   >	179:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	180:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	181:     LD  4,-58(1)	Pop index 
												   >	182:    LDA  5,-48(1)	Load address of base of array w
												   >	183:    SUB  5,5,4	Compute offset of value 
												   >	184:     ST  3,0(5)	Store variable w
												   >	* EXPRESSION
												   >	* CALL dog
												   >	185:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	186:    LDA  3,-26(1)	Load address of base of array y
												   >	187:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	188:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -60
												   >	189:     LD  4,-60(1)	Pop left into ac1 
												   >	190:    SUB  3,4,3	compute location from index 
												   >	191:     LD  3,0(3)	Load array element 
												   >	192:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	193:    LDA  3,-48(1)	Load address of base of array w
												   >	194:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	195:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	196:    LDA  3,1(7)	Return address in ac 
												   >	197:    JMP  7,-121(7)	CALL dog
												   >	198:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	199:    LDC  3,9(6)	Load integer constant 
												   >	200:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	201:    LDC  3,12(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	202:     LD  4,-58(1)	Pop index 
												   >	203:    LDA  5,-48(1)	Load address of base of array w
												   >	204:    SUB  5,5,4	Compute offset of value 
												   >	205:     ST  3,0(5)	Store variable w
												   >	* EXPRESSION
												   >	* CALL dog
												   >	206:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	207:    LDA  3,-26(1)	Load address of base of array y
												   >	208:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	209:    LDA  3,-15(1)	Load address of base of array d
												   >	210:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	211:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -61
												   >	212:     LD  4,-61(1)	Pop left into ac1 
												   >	213:    SUB  3,4,3	compute location from index 
												   >	214:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	215:     LD  4,-60(1)	Pop left into ac1 
												   >	216:    SUB  3,4,3	compute location from index 
												   >	217:     LD  3,0(3)	Load array element 
												   >	218:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	219:    LDA  3,-48(1)	Load address of base of array w
												   >	220:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	221:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-147(7)	CALL dog
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	225:    LDC  3,8(6)	Load integer constant 
												   >	226:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	227:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	228:     LD  4,-58(1)	Pop index 
												   >	229:    LDA  5,-4(1)	Load address of base of array c
												   >	230:    SUB  5,5,4	Compute offset of value 
												   >	231:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	232:    LDC  3,9(6)	Load integer constant 
												   >	233:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	234:    LDC  3,25(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	235:     LD  4,-58(1)	Pop index 
												   >	236:    LDA  5,-4(1)	Load address of base of array c
												   >	237:    SUB  5,5,4	Compute offset of value 
												   >	238:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	239:    LDC  3,9(6)	Load integer constant 
												   >	240:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	241:    LDC  3,66(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	242:     LD  4,-58(1)	Pop index 
												   >	243:    LDA  5,-26(1)	Load address of base of array y
												   >	244:    SUB  5,5,4	Compute offset of value 
												   >	245:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL dog
												   >	246:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	247:    LDA  3,-26(1)	Load address of base of array y
												   >	248:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	249:    LDA  3,-15(1)	Load address of base of array d
												   >	250:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	251:    LDA  3,-4(1)	Load address of base of array c
												   >	252:     ST  3,-62(1)	Push left side 
												   >	* TOFF dec: -63
												   >	253:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -62
												   >	254:     LD  4,-62(1)	Pop left into ac1 
												   >	255:    SUB  3,4,3	compute location from index 
												   >	256:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -61
												   >	257:     LD  4,-61(1)	Pop left into ac1 
												   >	258:    SUB  3,4,3	compute location from index 
												   >	259:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	260:     LD  4,-60(1)	Pop left into ac1 
												   >	261:    SUB  3,4,3	compute location from index 
												   >	262:     LD  3,0(3)	Load array element 
												   >	263:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	264:    LDA  3,-4(1)	Load address of base of array c
												   >	265:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	266:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	267:    LDA  3,1(7)	Return address in ac 
												   >	268:    JMP  7,-192(7)	CALL dog
												   >	269:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	270:    LDC  3,777(6)	Load integer constant 
												   >	271:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	272:    LDC  3,7(6)	Load integer constant 
												   >	273:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	274:    LDC  3,123(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	275:     LD  4,-58(1)	Pop index 
												   >	276:    LDA  5,-26(1)	Load address of base of array y
												   >	277:    SUB  5,5,4	Compute offset of value 
												   >	278:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	279:    LDC  3,9(6)	Load integer constant 
												   >	280:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	281:    LDA  3,-26(1)	Load address of base of array y
												   >	282:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	283:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	284:     LD  4,-59(1)	Pop left into ac1 
												   >	285:    SUB  3,4,3	compute location from index 
												   >	286:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	287:     LD  4,-58(1)	Pop index 
												   >	288:    LDA  5,-26(1)	Load address of base of array y
												   >	289:    SUB  5,5,4	Compute offset of value 
												   >	290:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL dog
												   >	291:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	292:     LD  3,-2(1)	Load variable x
												   >	293:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	294:    LDA  3,-26(1)	Load address of base of array y
												   >	295:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	296:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	297:    LDA  3,1(7)	Return address in ac 
												   >	298:    JMP  7,-222(7)	CALL dog
												   >	299:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	300:     LD  3,-2(1)	Load variable x
												   >	301:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	302:    LDC  3,9(6)	Load integer constant 
												   >	303:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	304:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -58
												   >	305:     LD  4,-58(1)	Pop index 
												   >	306:    LDA  5,-4(1)	Load address of base of array c
												   >	307:    SUB  5,5,4	Compute offset of value 
												   >	308:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	309:    LDC  3,888(6)	Load integer constant 
												   >	310:     ST  3,-11(0)	Store variable glx
												   >	* EXPRESSION
												   >	311:    LDC  3,7(6)	Load integer constant 
												   >	312:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	313:     LD  3,-11(0)	Load variable glx
												   >	* TOFF inc: -58
												   >	314:     LD  4,-58(1)	Pop index 
												   >	315:    LDA  5,-26(1)	Load address of base of array y
												   >	316:    SUB  5,5,4	Compute offset of value 
												   >	317:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	318:    LDC  3,6(6)	Load integer constant 
												   >	319:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	320:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	321:     LD  4,-58(1)	Pop index 
												   >	322:    LDA  5,-15(1)	Load address of base of array d
												   >	323:    SUB  5,5,4	Compute offset of value 
												   >	324:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	325:    LDC  3,2(6)	Load integer constant 
												   >	326:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	327:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	328:     LD  4,-58(1)	Pop index 
												   >	329:    LDA  5,-4(1)	Load address of base of array c
												   >	330:    SUB  5,5,4	Compute offset of value 
												   >	331:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	332:    LDC  3,4(6)	Load integer constant 
												   >	333:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	334:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	335:     LD  4,-58(1)	Pop index 
												   >	336:    LDA  5,-15(1)	Load address of base of array d
												   >	337:    SUB  5,5,4	Compute offset of value 
												   >	338:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	339:    LDC  3,2(6)	Load integer constant 
												   >	340:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	341:    LDA  3,-26(1)	Load address of base of array y
												   >	342:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	343:    LDA  3,-15(1)	Load address of base of array d
												   >	344:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	345:    LDA  3,-4(1)	Load address of base of array c
												   >	346:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	347:    LDA  3,-15(1)	Load address of base of array d
												   >	348:     ST  3,-62(1)	Push left side 
												   >	* TOFF dec: -63
												   >	349:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -62
												   >	350:     LD  4,-62(1)	Pop left into ac1 
												   >	351:    SUB  3,4,3	compute location from index 
												   >	352:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -61
												   >	353:     LD  4,-61(1)	Pop left into ac1 
												   >	354:    SUB  3,4,3	compute location from index 
												   >	355:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	356:     LD  4,-60(1)	Pop left into ac1 
												   >	357:    SUB  3,4,3	compute location from index 
												   >	358:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -59
												   >	359:     LD  4,-59(1)	Pop left into ac1 
												   >	360:    SUB  3,4,3	compute location from index 
												   >	361:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	362:     LD  4,-58(1)	Pop index 
												   >	363:    LDA  5,-15(1)	Load address of base of array d
												   >	364:    SUB  5,5,4	Compute offset of value 
												   >	365:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	* CALL dog
												   >	366:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	367:    LDA  3,-26(1)	Load address of base of array y
												   >	368:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	369:    LDA  3,-15(1)	Load address of base of array d
												   >	370:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	371:    LDA  3,-4(1)	Load address of base of array c
												   >	372:     ST  3,-62(1)	Push left side 
												   >	* TOFF dec: -63
												   >	373:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -62
												   >	374:     LD  4,-62(1)	Pop left into ac1 
												   >	375:    SUB  3,4,3	compute location from index 
												   >	376:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -61
												   >	377:     LD  4,-61(1)	Pop left into ac1 
												   >	378:    SUB  3,4,3	compute location from index 
												   >	379:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	380:     LD  4,-60(1)	Pop left into ac1 
												   >	381:    SUB  3,4,3	compute location from index 
												   >	382:     LD  3,0(3)	Load array element 
												   >	383:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	384:    LDA  3,-4(1)	Load address of base of array c
												   >	385:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	386:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	387:    LDA  3,1(7)	Return address in ac 
												   >	388:    JMP  7,-312(7)	CALL dog
												   >	389:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	390:    LDC  3,2(6)	Load integer constant 
												   >	391:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	392:    LDA  3,-4(1)	Load address of base of array c
												   >	393:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	394:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	395:     LD  4,-59(1)	Pop left into ac1 
												   >	396:    SUB  3,4,3	compute location from index 
												   >	397:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	398:     LD  4,-58(1)	Pop index 
												   >	399:    LDA  5,-15(1)	Load address of base of array d
												   >	400:    SUB  5,5,4	Compute offset of value 
												   >	401:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	402:    LDC  3,7(6)	Load integer constant 
												   >	403:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	404:    LDA  3,-26(1)	Load address of base of array y
												   >	405:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	406:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	407:     LD  4,-59(1)	Pop left into ac1 
												   >	408:    SUB  3,4,3	compute location from index 
												   >	409:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	410:     LD  4,-58(1)	Pop index 
												   >	411:    LDA  5,-26(1)	Load address of base of array y
												   >	412:    SUB  5,5,4	Compute offset of value 
												   >	413:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	414:    LDC  3,2(6)	Load integer constant 
												   >	415:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	416:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	417:     LD  4,-58(1)	Pop index 
												   >	418:    LDA  5,-1(0)	Load address of base of array gl
												   >	419:    SUB  5,5,4	Compute offset of value 
												   >	420:     ST  3,0(5)	Store variable gl
												   >	* EXPRESSION
												   >	421:    LDA  3,-1(0)	Load address of base of array gl
												   >	422:     ST  3,-58(1)	Push left side 
												   >	* TOFF dec: -59
												   >	423:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	424:     LD  4,-58(1)	Pop left into ac1 
												   >	425:    SUB  3,4,3	compute location from index 
												   >	426:     LD  3,0(3)	Load array element 
												   >	427:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	428:    LDC  3,7(6)	Load integer constant 
												   >	429:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	430:    LDA  3,-1(0)	Load address of base of array gl
												   >	431:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	432:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	433:     LD  4,-59(1)	Pop left into ac1 
												   >	434:    SUB  3,4,3	compute location from index 
												   >	435:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	436:     LD  4,-58(1)	Pop index 
												   >	437:    LDA  5,-26(1)	Load address of base of array y
												   >	438:    SUB  5,5,4	Compute offset of value 
												   >	439:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	440:    LDC  3,7(6)	Load integer constant 
												   >	441:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	442:    LDA  3,-26(1)	Load address of base of array y
												   >	443:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	444:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	445:     LD  4,-59(1)	Pop left into ac1 
												   >	446:    SUB  3,4,3	compute location from index 
												   >	447:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	448:     LD  4,-58(1)	Pop index 
												   >	449:    LDA  5,-1(0)	Load address of base of array gl
												   >	450:    SUB  5,5,4	Compute offset of value 
												   >	451:     ST  3,0(5)	Store variable gl
												   >	* EXPRESSION
												   >	452:    LDC  3,0(6)	Load integer constant 
												   >	453:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	454:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	455:     LD  4,-58(1)	Pop index 
												   >	456:    LDA  5,-26(1)	Load address of base of array y
												   >	457:    SUB  5,5,4	Compute offset of value 
												   >	458:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	459:    LDC  3,5(6)	Load integer constant 
												   >	460:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	461:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	462:     LD  4,-58(1)	Pop index 
												   >	463:    LDA  5,-15(1)	Load address of base of array d
												   >	464:    SUB  5,5,4	Compute offset of value 
												   >	465:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	466:    LDC  3,8(6)	Load integer constant 
												   >	467:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	468:    LDA  3,-15(1)	Load address of base of array d
												   >	469:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	470:    LDA  3,-26(1)	Load address of base of array y
												   >	471:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	472:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -60
												   >	473:     LD  4,-60(1)	Pop left into ac1 
												   >	474:    SUB  3,4,3	compute location from index 
												   >	475:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -59
												   >	476:     LD  4,-59(1)	Pop left into ac1 
												   >	477:    SUB  3,4,3	compute location from index 
												   >	478:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	479:     LD  4,-58(1)	Pop index 
												   >	480:    LDA  5,-4(1)	Load address of base of array c
												   >	481:    SUB  5,5,4	Compute offset of value 
												   >	482:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	* CALL output
												   >	483:     ST  1,-58(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	484:    LDA  3,-4(1)	Load address of base of array c
												   >	485:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	486:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -60
												   >	487:     LD  4,-60(1)	Pop left into ac1 
												   >	488:    SUB  3,4,3	compute location from index 
												   >	489:     LD  3,0(3)	Load array element 
												   >	490:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param end output
												   >	491:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	492:    LDA  3,1(7)	Return address in ac 
												   >	493:    JMP  7,-488(7)	CALL output
												   >	494:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	495:     ST  1,-58(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param end outnl
												   >	496:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	497:    LDA  3,1(7)	Return address in ac 
												   >	498:    JMP  7,-465(7)	CALL outnl
												   >	499:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	500:    LDC  3,3(6)	Load integer constant 
												   >	501:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	502:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	503:     LD  4,-58(1)	Pop index 
												   >	504:    LDA  5,-15(1)	Load address of base of array d
												   >	505:    SUB  5,5,4	Compute offset of value 
												   >	506:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	507:    LDC  3,4(6)	Load integer constant 
												   >	508:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	509:    LDC  3,987(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	510:     LD  4,-58(1)	Pop index 
												   >	511:    LDA  5,-26(1)	Load address of base of array y
												   >	512:    SUB  5,5,4	Compute offset of value 
												   >	513:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	514:    LDC  3,9(6)	Load integer constant 
												   >	515:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	516:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	517:     LD  4,-58(1)	Pop index 
												   >	518:    LDA  5,-4(1)	Load address of base of array c
												   >	519:    SUB  5,5,4	Compute offset of value 
												   >	520:     LD  4,0(5)	load lhs variable c
												   >	521:    SUB  3,4,3	op -= 
												   >	522:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	* CALL dog
												   >	523:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	524:    LDA  3,-26(1)	Load address of base of array y
												   >	525:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	526:    LDA  3,-15(1)	Load address of base of array d
												   >	527:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	528:    LDA  3,-4(1)	Load address of base of array c
												   >	529:     ST  3,-62(1)	Push left side 
												   >	* TOFF dec: -63
												   >	530:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -62
												   >	531:     LD  4,-62(1)	Pop left into ac1 
												   >	532:    SUB  3,4,3	compute location from index 
												   >	533:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -61
												   >	534:     LD  4,-61(1)	Pop left into ac1 
												   >	535:    SUB  3,4,3	compute location from index 
												   >	536:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	537:     LD  4,-60(1)	Pop left into ac1 
												   >	538:    SUB  3,4,3	compute location from index 
												   >	539:     LD  3,0(3)	Load array element 
												   >	540:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	541:    LDA  3,-4(1)	Load address of base of array c
												   >	542:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	543:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	544:    LDA  3,1(7)	Return address in ac 
												   >	545:    JMP  7,-469(7)	CALL dog
												   >	546:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	547:    LDA  3,-4(1)	Load address of base of array c
												   >	548:     ST  3,-58(1)	Push left side 
												   >	* TOFF dec: -59
												   >	549:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	550:     LD  4,-58(1)	Pop left into ac1 
												   >	551:    SUB  3,4,3	compute location from index 
												   >	552:     LD  3,0(3)	Load array element 
												   >	553:     LD  4,-2(1)	load lhs variable x
												   >	554:    ADD  3,4,3	op += 
												   >	555:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	556:    LDA  3,-4(1)	Load address of base of array c
												   >	557:     ST  3,-58(1)	Push left side 
												   >	* TOFF dec: -59
												   >	558:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	559:     LD  4,-58(1)	Pop left into ac1 
												   >	560:    SUB  3,4,3	compute location from index 
												   >	561:     LD  3,0(3)	Load array element 
												   >	562:     LD  4,-2(1)	load lhs variable x
												   >	563:    SUB  3,4,3	op -= 
												   >	564:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	565:    LDC  3,8(6)	Load integer constant 
												   >	566:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	567:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	568:     LD  4,-58(1)	Pop index 
												   >	569:    LDA  5,-26(1)	Load address of base of array y
												   >	570:    SUB  5,5,4	Compute offset of value 
												   >	571:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	572:    LDC  3,9(6)	Load integer constant 
												   >	573:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	574:    LDA  3,-26(1)	Load address of base of array y
												   >	575:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	* CALL getnxtindex
												   >	576:     ST  1,-60(1)	Store fp in ghost frame for getnxtindex
												   >	* TOFF dec: -61
												   >	* TOFF dec: -62
												   >	* Param 1
												   >	577:    LDC  3,7(6)	Load integer constant 
												   >	578:     ST  3,-62(1)	Push parameter 
												   >	* TOFF dec: -63
												   >	* Param end getnxtindex
												   >	579:    LDA  1,-60(1)	Ghost frame becomes new active frame 
												   >	580:    LDA  3,1(7)	Return address in ac 
												   >	581:    JMP  7,-457(7)	CALL getnxtindex
												   >	582:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getnxtindex
												   >	* TOFF set: -60
												   >	* TOFF inc: -59
												   >	583:     LD  4,-59(1)	Pop left into ac1 
												   >	584:    SUB  3,4,3	compute location from index 
												   >	585:     LD  3,0(3)	Load array element 
												   >	586:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	587:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	588:     LD  4,-59(1)	Pop left into ac1 
												   >	589:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -58
												   >	590:     LD  4,-58(1)	Pop index 
												   >	591:    LDA  5,-26(1)	Load address of base of array y
												   >	592:    SUB  5,5,4	Compute offset of value 
												   >	593:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	* CALL dog
												   >	594:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	595:    LDA  3,-26(1)	Load address of base of array y
												   >	596:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	597:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -60
												   >	598:     LD  4,-60(1)	Pop left into ac1 
												   >	599:    SUB  3,4,3	compute location from index 
												   >	600:     LD  3,0(3)	Load array element 
												   >	601:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	602:    LDA  3,-26(1)	Load address of base of array y
												   >	603:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	604:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	605:    LDA  3,1(7)	Return address in ac 
												   >	606:    JMP  7,-530(7)	CALL dog
												   >	607:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* EXPRESSION
												   >	608:    LDC  3,5(6)	Load integer constant 
												   >	609:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	610:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	611:     LD  4,-58(1)	Pop index 
												   >	612:    LDA  5,-4(1)	Load address of base of array c
												   >	613:    SUB  5,5,4	Compute offset of value 
												   >	614:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	615:    LDC  3,0(6)	Load integer constant 
												   >	616:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	617:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	618:     LD  4,-58(1)	Pop index 
												   >	619:    LDA  5,-48(1)	Load address of base of array w
												   >	620:    SUB  5,5,4	Compute offset of value 
												   >	621:     ST  3,0(5)	Store variable w
												   >	* EXPRESSION
												   >	622:    LDC  3,3(6)	Load integer constant 
												   >	623:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	624:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	625:     LD  4,-58(1)	Pop index 
												   >	626:    LDA  5,-37(1)	Load address of base of array z
												   >	627:    SUB  5,5,4	Compute offset of value 
												   >	628:     ST  3,0(5)	Store variable z
												   >	* EXPRESSION
												   >	629:    LDC  3,9(6)	Load integer constant 
												   >	630:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	631:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	632:     LD  4,-58(1)	Pop index 
												   >	633:    LDA  5,-26(1)	Load address of base of array y
												   >	634:    SUB  5,5,4	Compute offset of value 
												   >	635:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	636:    LDA  3,-26(1)	Load address of base of array y
												   >	637:     ST  3,-58(1)	Push left side 
												   >	* TOFF dec: -59
												   >	638:    LDA  3,-37(1)	Load address of base of array z
												   >	639:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	640:    LDA  3,-48(1)	Load address of base of array w
												   >	641:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	642:    LDA  3,-4(1)	Load address of base of array c
												   >	643:     ST  3,-61(1)	Push left side 
												   >	* TOFF dec: -62
												   >	644:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -61
												   >	645:     LD  4,-61(1)	Pop left into ac1 
												   >	646:    SUB  3,4,3	compute location from index 
												   >	647:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -60
												   >	648:     LD  4,-60(1)	Pop left into ac1 
												   >	649:    SUB  3,4,3	compute location from index 
												   >	650:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -59
												   >	651:     LD  4,-59(1)	Pop left into ac1 
												   >	652:    SUB  3,4,3	compute location from index 
												   >	653:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	654:     LD  4,-58(1)	Pop left into ac1 
												   >	655:    SUB  3,4,3	compute location from index 
												   >	656:     LD  3,0(3)	Load array element 
												   >	657:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	658:    LDC  3,77(6)	Load integer constant 
												   >	* TOFF inc: -58
												   >	659:     LD  4,-58(1)	Pop index 
												   >	660:    LDA  5,-15(1)	Load address of base of array d
												   >	661:    SUB  5,5,4	Compute offset of value 
												   >	662:     ST  3,0(5)	Store variable d
												   >	* EXPRESSION
												   >	663:    LDC  3,9(6)	Load integer constant 
												   >	664:     ST  3,-58(1)	Push index 
												   >	* TOFF dec: -59
												   >	665:    LDA  3,-15(1)	Load address of base of array d
												   >	666:     ST  3,-59(1)	Push left side 
												   >	* TOFF dec: -60
												   >	667:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -59
												   >	668:     LD  4,-59(1)	Pop left into ac1 
												   >	669:    SUB  3,4,3	compute location from index 
												   >	670:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -58
												   >	671:     LD  4,-58(1)	Pop index 
												   >	672:    LDA  5,-4(1)	Load address of base of array c
												   >	673:    SUB  5,5,4	Compute offset of value 
												   >	674:     ST  3,0(5)	Store variable c
												   >	* EXPRESSION
												   >	* CALL dog
												   >	675:     ST  1,-58(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	676:    LDC  3,66(6)	Load integer constant 
												   >	677:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	678:    LDA  3,-4(1)	Load address of base of array c
												   >	679:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end dog
												   >	680:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	681:    LDA  3,1(7)	Return address in ac 
												   >	682:    JMP  7,-606(7)	CALL dog
												   >	683:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -58
												   >	* COMPOUND
												   >	* TOFF set: -60
												   >	* Compound Body
												   >	* EXPRESSION
												   >	684:    LDC  3,0(6)	Load integer constant 
												   >	685:     ST  3,-58(1)	Store variable p
												   >	* WHILE
												   >	686:     LD  3,-58(1)	Load variable p
												   >	687:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	688:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -60
												   >	689:     LD  4,-60(1)	Pop left into ac1 
												   >	690:    TLT  3,4,3	Op < 
												   >	691:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -60
												   >	* Compound Body
												   >	* EXPRESSION
												   >	693:     LD  3,-58(1)	Load variable p
												   >	694:     ST  3,-59(1)	Store variable q
												   >	* EXPRESSION
												   >	695:    LDC  3,9(6)	Load integer constant 
												   >	696:     ST  3,-60(1)	Push left side 
												   >	* TOFF dec: -61
												   >	697:     LD  3,-59(1)	Load variable q
												   >	* TOFF inc: -60
												   >	698:     LD  4,-60(1)	Pop left into ac1 
												   >	699:    SUB  3,4,3	Op - 
												   >	700:     ST  3,-60(1)	Push index 
												   >	* TOFF dec: -61
												   >	701:    LDC  3,1(6)	Load integer constant 
												   >	702:     LD  4,-58(1)	load lhs variable p
												   >	703:    ADD  3,4,3	op += 
												   >	704:     ST  3,-58(1)	Store variable p
												   >	* TOFF inc: -60
												   >	705:     LD  4,-60(1)	Pop index 
												   >	706:    LDA  5,-4(1)	Load address of base of array c
												   >	707:    SUB  5,5,4	Compute offset of value 
												   >	708:     ST  3,0(5)	Store variable c
												   >	* TOFF set: -60
												   >	* END COMPOUND
												   >	709:    JMP  7,-24(7)	go to beginning of loop 
												   >	692:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -58
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL showIntArray
												   >	710:     ST  1,-58(1)	Store fp in ghost frame for showIntArray
												   >	* TOFF dec: -59
												   >	* TOFF dec: -60
												   >	* Param 1
												   >	711:    LDA  3,-4(1)	Load address of base of array c
												   >	712:     ST  3,-60(1)	Push parameter 
												   >	* TOFF dec: -61
												   >	* Param 2
												   >	713:    LDC  3,10(6)	Load integer constant 
												   >	714:     ST  3,-61(1)	Push parameter 
												   >	* TOFF dec: -62
												   >	* Param end showIntArray
												   >	715:    LDA  1,-58(1)	Ghost frame becomes new active frame 
												   >	716:    LDA  3,1(7)	Return address in ac 
												   >	717:    JMP  7,-679(7)	CALL showIntArray
												   >	718:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end showIntArray
												   >	* TOFF set: -58
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	719:    LDC  2,0(6)	Set return value to 0 
												   >	720:     LD  3,-1(1)	Load return address 
												   >	721:     LD  1,0(1)	Adjust fp 
												   >	722:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,722(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	723:    LDA  1,-12(0)	set first frame at end of globals 
												   >	724:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	725:    LDC  3,10(6)	load size of array gl
												   >	726:     ST  3,0(0)	save size of array gl
												   >	* END INIT GLOBALS AND STATICS
												   >	727:    LDA  3,1(7)	Return address in ac 
												   >	728:    JMP  7,-590(7)	Jump to main 
												   >	729:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
miller.mem miller.mem.f21 differ: byte 1, line 1
miller (MEM DIFF)
Var: gl of array of type int [mem: Global loc: -1 size: 11] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: glx of type int [mem: Global loc: -11 size: 1] [line: 2]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: showIntArray returns type void [mem: Global loc: 0 size: -4] [line: 4]	   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: gl of array of type int [mem: Global loc: -1 size: 11] [line: 1]
												   >	Sibling: 8  Var: glx of type int [mem: Global loc: -11 size: 1] [line: 2]
												   >	Sibling: 9  Func: showIntArray returns type void [mem: Global loc: 0 size: -4] [line: 4]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 4]			.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 5]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   Child: 1  Const 0 of type int [line: 7]							.   .   .   Child: 1  Const 0 of type int [line: 7]
.   .   Sibling: 1  While [line: 8]									.   .   Sibling: 1  While [line: 8]
.   .   .   Child: 0  Op: < of type bool [line: 8]							.   .   .   Child: 0  Op: < of type bool [line: 8]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 8]		.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 8]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 8]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 8]
.   .   .   .   Child: 1  Call: output of type void [line: 9]						.   .   .   .   Child: 1  Call: output of type void [line: 9]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 9]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 9]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 10]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 10]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Op: + of type int [line: 10]						.   .   .   .   .   Child: 1  Op: + of type int [line: 10]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 10]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 10]
.   .   Sibling: 2  Call: outnl of type void [line: 12]							.   .   Sibling: 2  Call: outnl of type void [line: 12]
Sibling: 3  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 15]		   |	Sibling: 10  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 15]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 15]
.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 15]		.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 15]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 16]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 16]
.   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 17]			.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 17]
.   .   .   Child: 1  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 17]			.   .   .   Child: 1  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 17]
.   .   Sibling: 1  Assign: = of type int [line: 18]						   |	.   .   Sibling: 1  Assign: := of type int [line: 18]
.   .   .   Child: 0  Op: [ of type int [line: 18]							.   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 18]	.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 18]
.   .   .   .   Child: 1  Const 7 of type int [line: 18]						.   .   .   .   Child: 1  Const 7 of type int [line: 18]
.   .   .   Child: 1  Op: [ of type int [line: 18]							.   .   .   Child: 1  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 18]	.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 18]
.   .   .   .   Child: 1  Const 9 of type int [line: 18]						.   .   .   .   Child: 1  Const 9 of type int [line: 18]
.   .   Sibling: 2  Call: output of type void [line: 19]						.   .   Sibling: 2  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 19]			.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 19]
.   .   Sibling: 3  Call: outnl of type void [line: 20]							.   .   Sibling: 3  Call: outnl of type void [line: 20]
.   .   Sibling: 4  Call: output of type void [line: 21]						.   .   Sibling: 4  Call: output of type void [line: 21]
.   .   .   Child: 0  Op: [ of type int [line: 21]							.   .   .   Child: 0  Op: [ of type int [line: 21]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 21]	.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 21]
.   .   .   .   Child: 1  Const 7 of type int [line: 21]						.   .   .   .   Child: 1  Const 7 of type int [line: 21]
.   .   Sibling: 5  Call: outnl of type void [line: 22]							.   .   Sibling: 5  Call: outnl of type void [line: 22]
Sibling: 4  Func: getnxtindex returns type int [mem: Global loc: 0 size: -3] [line: 25]		   |	Sibling: 11  Func: getnxtindex returns type int [mem: Global loc: 0 size: -3] [line: 25]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 25]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 25]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 26]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 26]
.   .   Child: 1  Return [line: 27]									.   .   Child: 1  Return [line: 27]
.   .   .   Child: 0  Op: + of type int [line: 27]							.   .   .   Child: 0  Op: + of type int [line: 27]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 27]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 27]
.   .   .   .   Child: 1  Const 1 of type int [line: 27]						.   .   .   .   Child: 1  Const 1 of type int [line: 27]
Sibling: 5  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 30]		   |	Sibling: 12  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 30]
.   Child: 1  Compound [mem: None loc: 0 size: -58] [line: 31]						.   Child: 1  Compound [mem: None loc: 0 size: -58] [line: 31]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 32]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 32]
.   .   Sibling: 1  Var: c of array of type int [mem: Local loc: -4 size: 11] [line: 33]		.   .   Sibling: 1  Var: c of array of type int [mem: Local loc: -4 size: 11] [line: 33]
.   .   Sibling: 2  Var: d of array of type int [mem: Local loc: -15 size: 11] [line: 34]		.   .   Sibling: 2  Var: d of array of type int [mem: Local loc: -15 size: 11] [line: 34]
.   .   Sibling: 3  Var: y of array of type int [mem: Local loc: -26 size: 11] [line: 35]		.   .   Sibling: 3  Var: y of array of type int [mem: Local loc: -26 size: 11] [line: 35]
.   .   Sibling: 4  Var: z of array of type int [mem: Local loc: -37 size: 11] [line: 36]		.   .   Sibling: 4  Var: z of array of type int [mem: Local loc: -37 size: 11] [line: 36]
.   .   Sibling: 5  Var: w of array of type int [mem: Local loc: -48 size: 11] [line: 37]		.   .   Sibling: 5  Var: w of array of type int [mem: Local loc: -48 size: 11] [line: 37]
.   .   Child: 1  Assign: = of type int [line: 39]						   |	.   .   Child: 1  Assign: := of type int [line: 39]
.   .   .   Child: 0  Op: [ of type int [line: 39]							.   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 39]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 39]
.   .   .   .   Child: 1  Const 0 of type int [line: 39]						.   .   .   .   Child: 1  Const 0 of type int [line: 39]
.   .   .   Child: 1  Const 3 of type int [line: 39]							.   .   .   Child: 1  Const 3 of type int [line: 39]
.   .   Sibling: 1  Assign: = of type int [line: 40]						   |	.   .   Sibling: 1  Assign: := of type int [line: 40]
.   .   .   Child: 0  Op: [ of type int [line: 40]							.   .   .   Child: 0  Op: [ of type int [line: 40]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 40]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 40]
.   .   .   .   Child: 1  Const 3 of type int [line: 40]						.   .   .   .   Child: 1  Const 3 of type int [line: 40]
.   .   .   Child: 1  Const 5 of type int [line: 40]							.   .   .   Child: 1  Const 5 of type int [line: 40]
.   .   Sibling: 2  Assign: = of type int [line: 41]						   |	.   .   Sibling: 2  Assign: := of type int [line: 41]
.   .   .   Child: 0  Op: [ of type int [line: 41]							.   .   .   Child: 0  Op: [ of type int [line: 41]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 41]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 41]
.   .   .   .   Child: 1  Const 4 of type int [line: 41]						.   .   .   .   Child: 1  Const 4 of type int [line: 41]
.   .   .   Child: 1  Const 9 of type int [line: 41]							.   .   .   Child: 1  Const 9 of type int [line: 41]
.   .   Sibling: 3  Assign: = of type int [line: 42]						   |	.   .   Sibling: 3  Assign: := of type int [line: 42]
.   .   .   Child: 0  Op: [ of type int [line: 42]							.   .   .   Child: 0  Op: [ of type int [line: 42]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 42]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 42]
.   .   .   .   Child: 1  Const 5 of type int [line: 42]						.   .   .   .   Child: 1  Const 5 of type int [line: 42]
.   .   .   Child: 1  Const 100 of type int [line: 42]							.   .   .   Child: 1  Const 100 of type int [line: 42]
.   .   Sibling: 4  Assign: = of type int [line: 43]						   |	.   .   Sibling: 4  Assign: := of type int [line: 43]
.   .   .   Child: 0  Op: [ of type int [line: 43]							.   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 43]		.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 43]
.   .   .   .   Child: 1  Const 9 of type int [line: 43]						.   .   .   .   Child: 1  Const 9 of type int [line: 43]
.   .   .   Child: 1  Const 50 of type int [line: 43]							.   .   .   Child: 1  Const 50 of type int [line: 43]
.   .   Sibling: 5  Call: dog of type void [line: 44]							.   .   Sibling: 5  Call: dog of type void [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 44]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 44]
.   .   .   .   Child: 1  Const 5 of type int [line: 44]						.   .   .   .   Child: 1  Const 5 of type int [line: 44]
.   .   .   Sibling: 1  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 44]		.   .   .   Sibling: 1  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 44]
.   .   Sibling: 6  Assign: = of type int [line: 46]						   |	.   .   Sibling: 6  Assign: := of type int [line: 46]
.   .   .   Child: 0  Op: [ of type int [line: 46]							.   .   .   Child: 0  Op: [ of type int [line: 46]
.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 46]		.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 46]
.   .   .   .   Child: 1  Const 9 of type int [line: 46]						.   .   .   .   Child: 1  Const 9 of type int [line: 46]
.   .   .   Child: 1  Const 12 of type int [line: 46]							.   .   .   Child: 1  Const 12 of type int [line: 46]
.   .   Sibling: 7  Call: dog of type void [line: 47]							.   .   Sibling: 7  Call: dog of type void [line: 47]
.   .   .   Child: 0  Op: [ of type int [line: 47]							.   .   .   Child: 0  Op: [ of type int [line: 47]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 47]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 47]
.   .   .   .   Child: 1  Op: [ of type int [line: 47]							.   .   .   .   Child: 1  Op: [ of type int [line: 47]
.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 4	.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 4
.   .   .   .   .   Child: 1  Const 3 of type int [line: 47]						.   .   .   .   .   Child: 1  Const 3 of type int [line: 47]
.   .   .   Sibling: 1  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 47]		.   .   .   Sibling: 1  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 47]
.   .   Sibling: 8  Assign: = of type int [line: 49]						   |	.   .   Sibling: 8  Assign: := of type int [line: 49]
.   .   .   Child: 0  Op: [ of type int [line: 49]							.   .   .   Child: 0  Op: [ of type int [line: 49]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 49]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 49]
.   .   .   .   Child: 1  Const 8 of type int [line: 49]						.   .   .   .   Child: 1  Const 8 of type int [line: 49]
.   .   .   Child: 1  Const 4 of type int [line: 49]							.   .   .   Child: 1  Const 4 of type int [line: 49]
.   .   Sibling: 9  Assign: = of type int [line: 50]						   |	.   .   Sibling: 9  Assign: := of type int [line: 50]
.   .   .   Child: 0  Op: [ of type int [line: 50]							.   .   .   Child: 0  Op: [ of type int [line: 50]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 50]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 50]
.   .   .   .   Child: 1  Const 9 of type int [line: 50]						.   .   .   .   Child: 1  Const 9 of type int [line: 50]
.   .   .   Child: 1  Const 25 of type int [line: 50]							.   .   .   Child: 1  Const 25 of type int [line: 50]
.   .   Sibling: 10  Assign: = of type int [line: 51]						   |	.   .   Sibling: 10  Assign: := of type int [line: 51]
.   .   .   Child: 0  Op: [ of type int [line: 51]							.   .   .   Child: 0  Op: [ of type int [line: 51]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 51]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 51]
.   .   .   .   Child: 1  Const 9 of type int [line: 51]						.   .   .   .   Child: 1  Const 9 of type int [line: 51]
.   .   .   Child: 1  Const 66 of type int [line: 51]							.   .   .   Child: 1  Const 66 of type int [line: 51]
.   .   Sibling: 11  Call: dog of type void [line: 52]							.   .   Sibling: 11  Call: dog of type void [line: 52]
.   .   .   Child: 0  Op: [ of type int [line: 52]							.   .   .   Child: 0  Op: [ of type int [line: 52]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 52]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 52]
.   .   .   .   Child: 1  Op: [ of type int [line: 52]							.   .   .   .   Child: 1  Op: [ of type int [line: 52]
.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 5	.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 5
.   .   .   .   .   Child: 1  Op: [ of type int [line: 52]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 52]
.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 52]					.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 52]
.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 52]		.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 52]
.   .   Sibling: 12  Assign: = of type int [line: 54]						   |	.   .   Sibling: 12  Assign: := of type int [line: 54]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 54]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 54]
.   .   .   Child: 1  Const 777 of type int [line: 54]							.   .   .   Child: 1  Const 777 of type int [line: 54]
.   .   Sibling: 13  Assign: = of type int [line: 55]						   |	.   .   Sibling: 13  Assign: := of type int [line: 55]
.   .   .   Child: 0  Op: [ of type int [line: 55]							.   .   .   Child: 0  Op: [ of type int [line: 55]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 55]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 55]
.   .   .   .   Child: 1  Const 7 of type int [line: 55]						.   .   .   .   Child: 1  Const 7 of type int [line: 55]
.   .   .   Child: 1  Const 123 of type int [line: 55]							.   .   .   Child: 1  Const 123 of type int [line: 55]
.   .   Sibling: 14  Assign: = of type int [line: 56]						   |	.   .   Sibling: 14  Assign: := of type int [line: 56]
.   .   .   Child: 0  Op: [ of type int [line: 56]							.   .   .   Child: 0  Op: [ of type int [line: 56]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 56]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 56]
.   .   .   .   Child: 1  Const 9 of type int [line: 56]						.   .   .   .   Child: 1  Const 9 of type int [line: 56]
.   .   .   Child: 1  Op: [ of type int [line: 56]							.   .   .   Child: 1  Op: [ of type int [line: 56]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 56]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 56]
.   .   .   .   Child: 1  Const 7 of type int [line: 56]						.   .   .   .   Child: 1  Const 7 of type int [line: 56]
.   .   Sibling: 15  Call: dog of type void [line: 57]							.   .   Sibling: 15  Call: dog of type void [line: 57]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 57]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 57]
.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 57]		.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 57]
.   .   Sibling: 16  Assign: = of type int [line: 59]						   |	.   .   Sibling: 16  Assign: := of type int [line: 59]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 59]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 59]
.   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 59]				.   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 59]
.   .   Sibling: 17  Assign: = of type int [line: 61]						   |	.   .   Sibling: 17  Assign: := of type int [line: 61]
.   .   .   Child: 0  Op: [ of type int [line: 61]							.   .   .   Child: 0  Op: [ of type int [line: 61]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 61]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 61]
.   .   .   .   Child: 1  Const 9 of type int [line: 61]						.   .   .   .   Child: 1  Const 9 of type int [line: 61]
.   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 61]				.   .   .   Child: 1  Id: x of type int [mem: Local loc: -2 size: 1] [line: 61]
.   .   Sibling: 18  Assign: = of type int [line: 62]						   |	.   .   Sibling: 18  Assign: := of type int [line: 62]
.   .   .   Child: 0  Id: glx of type int [mem: Global loc: -11 size: 1] [line: 62]			.   .   .   Child: 0  Id: glx of type int [mem: Global loc: -11 size: 1] [line: 62]
.   .   .   Child: 1  Const 888 of type int [line: 62]							.   .   .   Child: 1  Const 888 of type int [line: 62]
.   .   Sibling: 19  Assign: = of type int [line: 63]						   |	.   .   Sibling: 19  Assign: := of type int [line: 63]
.   .   .   Child: 0  Op: [ of type int [line: 63]							.   .   .   Child: 0  Op: [ of type int [line: 63]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 63]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 63]
.   .   .   .   Child: 1  Const 7 of type int [line: 63]						.   .   .   .   Child: 1  Const 7 of type int [line: 63]
.   .   .   Child: 1  Id: glx of type int [mem: Global loc: -11 size: 1] [line: 63]			.   .   .   Child: 1  Id: glx of type int [mem: Global loc: -11 size: 1] [line: 63]
.   .   Sibling: 20  Assign: = of type int [line: 64]						   |	.   .   Sibling: 20  Assign: := of type int [line: 64]
.   .   .   Child: 0  Op: [ of type int [line: 64]							.   .   .   Child: 0  Op: [ of type int [line: 64]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 64]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 64]
.   .   .   .   Child: 1  Const 6 of type int [line: 64]						.   .   .   .   Child: 1  Const 6 of type int [line: 64]
.   .   .   Child: 1  Const 2 of type int [line: 64]							.   .   .   Child: 1  Const 2 of type int [line: 64]
.   .   Sibling: 21  Assign: = of type int [line: 65]						   |	.   .   Sibling: 21  Assign: := of type int [line: 65]
.   .   .   Child: 0  Op: [ of type int [line: 65]							.   .   .   Child: 0  Op: [ of type int [line: 65]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 65]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 65]
.   .   .   .   Child: 1  Const 2 of type int [line: 65]						.   .   .   .   Child: 1  Const 2 of type int [line: 65]
.   .   .   Child: 1  Const 4 of type int [line: 65]							.   .   .   Child: 1  Const 4 of type int [line: 65]
.   .   Sibling: 22  Assign: = of type int [line: 66]						   |	.   .   Sibling: 22  Assign: := of type int [line: 66]
.   .   .   Child: 0  Op: [ of type int [line: 66]							.   .   .   Child: 0  Op: [ of type int [line: 66]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 66]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 66]
.   .   .   .   Child: 1  Const 4 of type int [line: 66]						.   .   .   .   Child: 1  Const 4 of type int [line: 66]
.   .   .   Child: 1  Const 7 of type int [line: 66]							.   .   .   Child: 1  Const 7 of type int [line: 66]
.   .   Sibling: 23  Assign: = of type int [line: 67]						   |	.   .   Sibling: 23  Assign: := of type int [line: 67]
.   .   .   Child: 0  Op: [ of type int [line: 67]							.   .   .   Child: 0  Op: [ of type int [line: 67]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 67]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 67]
.   .   .   .   Child: 1  Const 2 of type int [line: 67]						.   .   .   .   Child: 1  Const 2 of type int [line: 67]
.   .   .   Child: 1  Op: [ of type int [line: 67]							.   .   .   Child: 1  Op: [ of type int [line: 67]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 67]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 67]
.   .   .   .   Child: 1  Op: [ of type int [line: 67]							.   .   .   .   Child: 1  Op: [ of type int [line: 67]
.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 6	.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 6
.   .   .   .   .   Child: 1  Op: [ of type int [line: 67]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 67]
.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 67]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 67]
.   .   .   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] 	.   .   .   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] 
.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 67]					.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 67]
.   .   Sibling: 24  Call: dog of type void [line: 68]							.   .   Sibling: 24  Call: dog of type void [line: 68]
.   .   .   Child: 0  Op: [ of type int [line: 68]							.   .   .   Child: 0  Op: [ of type int [line: 68]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 68]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 68]
.   .   .   .   Child: 1  Op: [ of type int [line: 68]							.   .   .   .   Child: 1  Op: [ of type int [line: 68]
.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 6	.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 6
.   .   .   .   .   Child: 1  Op: [ of type int [line: 68]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 68]
.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 68]					.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 68]
.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 68]		.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 68]
.   .   Sibling: 25  Assign: = of type int [line: 70]						   |	.   .   Sibling: 25  Assign: := of type int [line: 70]
.   .   .   Child: 0  Op: [ of type int [line: 70]							.   .   .   Child: 0  Op: [ of type int [line: 70]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 70]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 70]
.   .   .   .   Child: 1  Const 2 of type int [line: 70]						.   .   .   .   Child: 1  Const 2 of type int [line: 70]
.   .   .   Child: 1  Op: [ of type int [line: 70]							.   .   .   Child: 1  Op: [ of type int [line: 70]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 70]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 70]
.   .   .   .   Child: 1  Const 3 of type int [line: 70]						.   .   .   .   Child: 1  Const 3 of type int [line: 70]
.   .   Sibling: 26  Assign: = of type int [line: 71]						   |	.   .   Sibling: 26  Assign: := of type int [line: 71]
.   .   .   Child: 0  Op: [ of type int [line: 71]							.   .   .   Child: 0  Op: [ of type int [line: 71]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 71]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 71]
.   .   .   .   Child: 1  Const 7 of type int [line: 71]						.   .   .   .   Child: 1  Const 7 of type int [line: 71]
.   .   .   Child: 1  Op: [ of type int [line: 71]							.   .   .   Child: 1  Op: [ of type int [line: 71]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 71]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 71]
.   .   .   .   Child: 1  Const 9 of type int [line: 71]						.   .   .   .   Child: 1  Const 9 of type int [line: 71]
.   .   Sibling: 27  Assign: = of type int [line: 72]						   |	.   .   Sibling: 27  Assign: := of type int [line: 72]
.   .   .   Child: 0  Op: [ of type int [line: 72]							.   .   .   Child: 0  Op: [ of type int [line: 72]
.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 72]		.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 72]
.   .   .   .   Child: 1  Const 2 of type int [line: 72]						.   .   .   .   Child: 1  Const 2 of type int [line: 72]
.   .   .   Child: 1  Const 3 of type int [line: 72]							.   .   .   Child: 1  Const 3 of type int [line: 72]
.   .   Sibling: 28  Assign: = of type int [line: 73]						   |	.   .   Sibling: 28  Assign: := of type int [line: 73]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 73]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 73]
.   .   .   Child: 1  Op: [ of type int [line: 73]							.   .   .   Child: 1  Op: [ of type int [line: 73]
.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 73]		.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 73]
.   .   .   .   Child: 1  Const 2 of type int [line: 73]						.   .   .   .   Child: 1  Const 2 of type int [line: 73]
.   .   Sibling: 29  Assign: = of type int [line: 74]						   |	.   .   Sibling: 29  Assign: := of type int [line: 74]
.   .   .   Child: 0  Op: [ of type int [line: 74]							.   .   .   Child: 0  Op: [ of type int [line: 74]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 74]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 74]
.   .   .   .   Child: 1  Const 7 of type int [line: 74]						.   .   .   .   Child: 1  Const 7 of type int [line: 74]
.   .   .   Child: 1  Op: [ of type int [line: 74]							.   .   .   Child: 1  Op: [ of type int [line: 74]
.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 74]		.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 74]
.   .   .   .   Child: 1  Const 9 of type int [line: 74]						.   .   .   .   Child: 1  Const 9 of type int [line: 74]
.   .   Sibling: 30  Assign: = of type int [line: 75]						   |	.   .   Sibling: 30  Assign: := of type int [line: 75]
.   .   .   Child: 0  Op: [ of type int [line: 75]							.   .   .   Child: 0  Op: [ of type int [line: 75]
.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 75]		.   .   .   .   Child: 0  Id: gl of array of type int [mem: Global loc: -1 size: 11] [line: 75]
.   .   .   .   Child: 1  Const 7 of type int [line: 75]						.   .   .   .   Child: 1  Const 7 of type int [line: 75]
.   .   .   Child: 1  Op: [ of type int [line: 75]							.   .   .   Child: 1  Op: [ of type int [line: 75]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 75]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 75]
.   .   .   .   Child: 1  Const 9 of type int [line: 75]						.   .   .   .   Child: 1  Const 9 of type int [line: 75]
.   .   Sibling: 31  Assign: = of type int [line: 76]						   |	.   .   Sibling: 31  Assign: := of type int [line: 76]
.   .   .   Child: 0  Op: [ of type int [line: 76]							.   .   .   Child: 0  Op: [ of type int [line: 76]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 76]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 76]
.   .   .   .   Child: 1  Const 0 of type int [line: 76]						.   .   .   .   Child: 1  Const 0 of type int [line: 76]
.   .   .   Child: 1  Const 5 of type int [line: 76]							.   .   .   Child: 1  Const 5 of type int [line: 76]
.   .   Sibling: 32  Assign: = of type int [line: 77]						   |	.   .   Sibling: 32  Assign: := of type int [line: 77]
.   .   .   Child: 0  Op: [ of type int [line: 77]							.   .   .   Child: 0  Op: [ of type int [line: 77]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 77]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 77]
.   .   .   .   Child: 1  Const 5 of type int [line: 77]						.   .   .   .   Child: 1  Const 5 of type int [line: 77]
.   .   .   Child: 1  Const 3 of type int [line: 77]							.   .   .   Child: 1  Const 3 of type int [line: 77]
.   .   Sibling: 33  Assign: = of type int [line: 78]						   |	.   .   Sibling: 33  Assign: := of type int [line: 78]
.   .   .   Child: 0  Op: [ of type int [line: 78]							.   .   .   Child: 0  Op: [ of type int [line: 78]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 78]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 78]
.   .   .   .   Child: 1  Const 8 of type int [line: 78]						.   .   .   .   Child: 1  Const 8 of type int [line: 78]
.   .   .   Child: 1  Op: [ of type int [line: 78]							.   .   .   Child: 1  Op: [ of type int [line: 78]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 78]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 78]
.   .   .   .   Child: 1  Op: [ of type int [line: 78]							.   .   .   .   Child: 1  Op: [ of type int [line: 78]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 7	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 7
.   .   .   .   .   Child: 1  Const 0 of type int [line: 78]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 78]
.   .   Sibling: 34  Call: output of type void [line: 79]						.   .   Sibling: 34  Call: output of type void [line: 79]
.   .   .   Child: 0  Op: [ of type int [line: 79]							.   .   .   Child: 0  Op: [ of type int [line: 79]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 79]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 79]
.   .   .   .   Child: 1  Const 8 of type int [line: 79]						.   .   .   .   Child: 1  Const 8 of type int [line: 79]
.   .   Sibling: 35  Call: outnl of type void [line: 79]						.   .   Sibling: 35  Call: outnl of type void [line: 79]
.   .   Sibling: 36  Assign: = of type int [line: 80]						   |	.   .   Sibling: 36  Assign: := of type int [line: 80]
.   .   .   Child: 0  Op: [ of type int [line: 80]							.   .   .   Child: 0  Op: [ of type int [line: 80]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 80]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 80]
.   .   .   .   Child: 1  Const 3 of type int [line: 80]						.   .   .   .   Child: 1  Const 3 of type int [line: 80]
.   .   .   Child: 1  Const 4 of type int [line: 80]							.   .   .   Child: 1  Const 4 of type int [line: 80]
.   .   Sibling: 37  Assign: = of type int [line: 81]						   |	.   .   Sibling: 37  Assign: := of type int [line: 81]
.   .   .   Child: 0  Op: [ of type int [line: 81]							.   .   .   Child: 0  Op: [ of type int [line: 81]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 81]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 81]
.   .   .   .   Child: 1  Const 4 of type int [line: 81]						.   .   .   .   Child: 1  Const 4 of type int [line: 81]
.   .   .   Child: 1  Const 987 of type int [line: 81]							.   .   .   Child: 1  Const 987 of type int [line: 81]
.   .   Sibling: 38  Assign: -= of type int [line: 82]							.   .   Sibling: 38  Assign: -= of type int [line: 82]
.   .   .   Child: 0  Op: [ of type int [line: 82]							.   .   .   Child: 0  Op: [ of type int [line: 82]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 82]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 82]
.   .   .   .   Child: 1  Const 9 of type int [line: 82]						.   .   .   .   Child: 1  Const 9 of type int [line: 82]
.   .   .   Child: 1  Const 3 of type int [line: 82]							.   .   .   Child: 1  Const 3 of type int [line: 82]
.   .   Sibling: 39  Call: dog of type void [line: 84]							.   .   Sibling: 39  Call: dog of type void [line: 84]
.   .   .   Child: 0  Op: [ of type int [line: 84]							.   .   .   Child: 0  Op: [ of type int [line: 84]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 84]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 84]
.   .   .   .   Child: 1  Op: [ of type int [line: 84]							.   .   .   .   Child: 1  Op: [ of type int [line: 84]
.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 8	.   .   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 8
.   .   .   .   .   Child: 1  Op: [ of type int [line: 84]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 84]
.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line	.   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line
.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 84]					.   .   .   .   .   .   Child: 1  Const 8 of type int [line: 84]
.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 84]		.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 84]
.   .   Sibling: 40  Assign: += of type int [line: 86]							.   .   Sibling: 40  Assign: += of type int [line: 86]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 86]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 86]
.   .   .   Child: 1  Op: [ of type int [line: 86]							.   .   .   Child: 1  Op: [ of type int [line: 86]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 86]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 86]
.   .   .   .   Child: 1  Const 9 of type int [line: 86]						.   .   .   .   Child: 1  Const 9 of type int [line: 86]
.   .   Sibling: 41  Assign: -= of type int [line: 87]							.   .   Sibling: 41  Assign: -= of type int [line: 87]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 87]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 87]
.   .   .   Child: 1  Op: [ of type int [line: 87]							.   .   .   Child: 1  Op: [ of type int [line: 87]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 87]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 87]
.   .   .   .   Child: 1  Const 9 of type int [line: 87]						.   .   .   .   Child: 1  Const 9 of type int [line: 87]
.   .   Sibling: 42  Assign: = of type int [line: 88]						   |	.   .   Sibling: 42  Assign: := of type int [line: 88]
.   .   .   Child: 0  Op: [ of type int [line: 88]							.   .   .   Child: 0  Op: [ of type int [line: 88]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 88]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 88]
.   .   .   .   Child: 1  Const 8 of type int [line: 88]						.   .   .   .   Child: 1  Const 8 of type int [line: 88]
.   .   .   Child: 1  Const 8 of type int [line: 88]							.   .   .   Child: 1  Const 8 of type int [line: 88]
.   .   Sibling: 43  Assign: = of type int [line: 89]						   |	.   .   Sibling: 43  Assign: := of type int [line: 89]
.   .   .   Child: 0  Op: [ of type int [line: 89]							.   .   .   Child: 0  Op: [ of type int [line: 89]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 89]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 89]
.   .   .   .   Child: 1  Const 9 of type int [line: 89]						.   .   .   .   Child: 1  Const 9 of type int [line: 89]
.   .   .   Child: 1  Op: + of type int [line: 89]							.   .   .   Child: 1  Op: + of type int [line: 89]
.   .   .   .   Child: 0  Op: [ of type int [line: 89]							.   .   .   .   Child: 0  Op: [ of type int [line: 89]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 8	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 8
.   .   .   .   .   Child: 1  Call: getnxtindex of type int [line: 89]					.   .   .   .   .   Child: 1  Call: getnxtindex of type int [line: 89]
.   .   .   .   .   .   Child: 0  Const 7 of type int [line: 89]					.   .   .   .   .   .   Child: 0  Const 7 of type int [line: 89]
.   .   .   .   Child: 1  Const 1 of type int [line: 89]						.   .   .   .   Child: 1  Const 1 of type int [line: 89]
.   .   Sibling: 44  Call: dog of type void [line: 91]							.   .   Sibling: 44  Call: dog of type void [line: 91]
.   .   .   Child: 0  Op: [ of type int [line: 91]							.   .   .   Child: 0  Op: [ of type int [line: 91]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 91]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 91]
.   .   .   .   Child: 1  Const 4 of type int [line: 91]						.   .   .   .   Child: 1  Const 4 of type int [line: 91]
.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 91]		.   .   .   Sibling: 1  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 91]
.   .   Sibling: 45  Assign: = of type int [line: 93]						   |	.   .   Sibling: 45  Assign: := of type int [line: 93]
.   .   .   Child: 0  Op: [ of type int [line: 93]							.   .   .   Child: 0  Op: [ of type int [line: 93]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 93]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 93]
.   .   .   .   Child: 1  Const 5 of type int [line: 93]						.   .   .   .   Child: 1  Const 5 of type int [line: 93]
.   .   .   Child: 1  Const 0 of type int [line: 93]							.   .   .   Child: 1  Const 0 of type int [line: 93]
.   .   Sibling: 46  Assign: = of type int [line: 94]						   |	.   .   Sibling: 46  Assign: := of type int [line: 94]
.   .   .   Child: 0  Op: [ of type int [line: 94]							.   .   .   Child: 0  Op: [ of type int [line: 94]
.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 94]		.   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] [line: 94]
.   .   .   .   Child: 1  Const 0 of type int [line: 94]						.   .   .   .   Child: 1  Const 0 of type int [line: 94]
.   .   .   Child: 1  Const 3 of type int [line: 94]							.   .   .   Child: 1  Const 3 of type int [line: 94]
.   .   Sibling: 47  Assign: = of type int [line: 95]						   |	.   .   Sibling: 47  Assign: := of type int [line: 95]
.   .   .   Child: 0  Op: [ of type int [line: 95]							.   .   .   Child: 0  Op: [ of type int [line: 95]
.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -37 size: 11] [line: 95]		.   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -37 size: 11] [line: 95]
.   .   .   .   Child: 1  Const 3 of type int [line: 95]						.   .   .   .   Child: 1  Const 3 of type int [line: 95]
.   .   .   Child: 1  Const 9 of type int [line: 95]							.   .   .   Child: 1  Const 9 of type int [line: 95]
.   .   Sibling: 48  Assign: = of type int [line: 96]						   |	.   .   Sibling: 48  Assign: := of type int [line: 96]
.   .   .   Child: 0  Op: [ of type int [line: 96]							.   .   .   Child: 0  Op: [ of type int [line: 96]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 96]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 96]
.   .   .   .   Child: 1  Const 9 of type int [line: 96]						.   .   .   .   Child: 1  Const 9 of type int [line: 96]
.   .   .   Child: 1  Const 1 of type int [line: 96]							.   .   .   Child: 1  Const 1 of type int [line: 96]
.   .   Sibling: 49  Assign: = of type int [line: 98]						   |	.   .   Sibling: 49  Assign: := of type int [line: 98]
.   .   .   Child: 0  Op: [ of type int [line: 98]							.   .   .   Child: 0  Op: [ of type int [line: 98]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 98]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 98]
.   .   .   .   Child: 1  Op: [ of type int [line: 98]							.   .   .   .   Child: 1  Op: [ of type int [line: 98]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 9	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -26 size: 11] [line: 9
.   .   .   .   .   Child: 1  Op: [ of type int [line: 98]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 98]
.   .   .   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -37 size: 11] [lin	.   .   .   .   .   .   Child: 0  Id: z of array of type int [mem: Local loc: -37 size: 11] [lin
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 98]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 98]
.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] 	.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Local loc: -48 size: 11] 
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 98]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 98]
.   .   .   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 1	.   .   .   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 1
.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 98]				.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 98]
.   .   .   Child: 1  Const 77 of type int [line: 98]							.   .   .   Child: 1  Const 77 of type int [line: 98]
.   .   Sibling: 50  Assign: = of type int [line: 99]						   |	.   .   Sibling: 50  Assign: := of type int [line: 99]
.   .   .   Child: 0  Op: [ of type int [line: 99]							.   .   .   Child: 0  Op: [ of type int [line: 99]
.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 99]		.   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 99]
.   .   .   .   Child: 1  Const 9 of type int [line: 99]						.   .   .   .   Child: 1  Const 9 of type int [line: 99]
.   .   .   Child: 1  Op: [ of type int [line: 99]							.   .   .   Child: 1  Op: [ of type int [line: 99]
.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 99]		.   .   .   .   Child: 0  Id: d of array of type int [mem: Local loc: -15 size: 11] [line: 99]
.   .   .   .   Child: 1  Const 1 of type int [line: 99]						.   .   .   .   Child: 1  Const 1 of type int [line: 99]
.   .   Sibling: 51  Call: dog of type void [line: 101]							.   .   Sibling: 51  Call: dog of type void [line: 101]
.   .   .   Child: 0  Const 66 of type int [line: 101]							.   .   .   Child: 0  Const 66 of type int [line: 101]
.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 101]		.   .   .   Sibling: 1  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 101]
.   .   Sibling: 52  Compound [mem: None loc: 0 size: -60] [line: 103]					.   .   Sibling: 52  Compound [mem: None loc: 0 size: -60] [line: 103]
.   .   .   Child: 0  Var: p of type int [mem: Local loc: -58 size: 1] [line: 104]			.   .   .   Child: 0  Var: p of type int [mem: Local loc: -58 size: 1] [line: 104]
.   .   .   Sibling: 1  Var: q of type int [mem: Local loc: -59 size: 1] [line: 104]			.   .   .   Sibling: 1  Var: q of type int [mem: Local loc: -59 size: 1] [line: 104]
.   .   .   Child: 1  Assign: = of type int [line: 106]						   |	.   .   .   Child: 1  Assign: := of type int [line: 106]
.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 106]			.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 106]
.   .   .   .   Child: 1  Const 0 of type int [line: 106]						.   .   .   .   Child: 1  Const 0 of type int [line: 106]
.   .   .   Sibling: 1  While [line: 107]								.   .   .   Sibling: 1  While [line: 107]
.   .   .   .   Child: 0  Op: < of type bool [line: 107]						.   .   .   .   Child: 0  Op: < of type bool [line: 107]
.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 107]		.   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 107]
.   .   .   .   .   Child: 1  Const 10 of type int [line: 107]						.   .   .   .   .   Child: 1  Const 10 of type int [line: 107]
.   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -60] [line: 107]				.   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -60] [line: 107]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 108]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 108]
.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -59 size: 1] [line: 108]		.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -59 size: 1] [line: 108]
.   .   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -58 size: 1] [line: 108]		.   .   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -58 size: 1] [line: 108]
.   .   .   .   .   Sibling: 1  Assign: = of type int [line: 109]				   |	.   .   .   .   .   Sibling: 1  Assign: := of type int [line: 109]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 109]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 109]
.   .   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [	.   .   .   .   .   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [
.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 109]					.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 109]
.   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 109]				.   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 109]
.   .   .   .   .   .   .   .   Child: 1  Id: q of type int [mem: Local loc: -59 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 1  Id: q of type int [mem: Local loc: -59 size: 1] [line:
.   .   .   .   .   .   Child: 1  Assign: += of type int [line: 109]					.   .   .   .   .   .   Child: 1  Assign: += of type int [line: 109]
.   .   .   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 109	.   .   .   .   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -58 size: 1] [line: 109
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 109]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 109]
.   .   Sibling: 53  Call: showIntArray of type void [line: 113]					.   .   Sibling: 53  Call: showIntArray of type void [line: 113]
.   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 113]		.   .   .   Child: 0  Id: c of array of type int [mem: Local loc: -4 size: 11] [line: 113]
.   .   .   Sibling: 1  Const 10 of type int [line: 113]						.   .   .   Sibling: 1  Const 10 of type int [line: 113]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
miller.out ztmp23114.txt differ: byte 1, line 1
miller (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/miller.tm
Number of errors: 0										   |	100
------------------------------------								   |	50
Loading file: miller.tm										   |	100
												   >	12
												   >	66
												   >	25
												   >	777
												   >	123
												   >	888
												   >	777
												   >	3
												   >	987
												   >	774
												   >	987
												   >	9
												   >	66
												   >	77
												   >	10 9 8 7 6 5 4 3 2 1
Bye.													Bye.
====================================
FILE: nest.c-
-rw-------. 1 corg7983 domain_users  1333 Nov 17 15:35 nest.c-
-rw-------. 1 corg7983 domain_users  1360 Nov 17 15:35 nest.c-.f21
-rw-------. 1 corg7983 domain_users  1333 Nov 17 15:35 nest.c-.f22
-rw-------. 1 corg7983 domain_users   158 Nov 17 15:35 nest.expected
-rw-------. 1 corg7983 domain_users 12588 Nov 22 12:27 nest.mem
-rw-------. 1 corg7983 domain_users  3433 Nov 17 15:35 nest.mem.diffs
-rw-------. 1 corg7983 domain_users 13458 Nov 17 15:35 nest.mem.f21
-rw-------. 1 corg7983 domain_users   106 Nov 22 12:27 nest.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 nest.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 nest.tm.diffs
-rw-------. 1 corg7983 domain_users 24085 Nov 17 15:35 nest.tm.f21
TM CODE COMPARISON
nest (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  nest.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION agamemnon
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,666(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 42:    LDC  3,666(6)	Load integer constant 
												   >	 43:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 44:    LDC  3,666(6)	Load integer constant 
												   >	 45:     ST  3,-4(1)	Store variable x
												   >	* EXPRESSION
												   >	 46:    LDC  3,666(6)	Load integer constant 
												   >	 47:     ST  3,-2(0)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	 48:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 49:     LD  3,-2(1)	Load variable a
												   >	 50:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 51:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 52:    LDA  3,1(7)	Return address in ac 
												   >	 53:    JMP  7,-48(7)	CALL output
												   >	 54:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 55:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 56:     LD  3,-3(1)	Load variable b
												   >	 57:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 58:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-55(7)	CALL output
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 62:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 63:     LD  3,-4(1)	Load variable x
												   >	 64:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 65:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 66:    LDA  3,1(7)	Return address in ac 
												   >	 67:    JMP  7,-62(7)	CALL output
												   >	 68:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 69:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 70:     LD  3,-1(0)	Load variable y
												   >	 71:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 72:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-69(7)	CALL output
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 76:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 77:     LD  3,-2(0)	Load variable z
												   >	 78:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 79:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 80:    LDA  3,1(7)	Return address in ac 
												   >	 81:    JMP  7,-76(7)	CALL output
												   >	 82:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	 83:    LDC  3,1(6)	Load integer constant 
												   >	 84:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 85:    LDC  3,2(6)	Load integer constant 
												   >	 86:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 87:    LDC  3,3(6)	Load integer constant 
												   >	 88:     ST  3,-4(1)	Store variable x
												   >	* EXPRESSION
												   >	 89:    LDC  3,4(6)	Load integer constant 
												   >	 90:     ST  3,-1(0)	Store variable y
												   >	* EXPRESSION
												   >	 91:    LDC  3,5(6)	Load integer constant 
												   >	 92:     ST  3,-2(0)	Store variable z
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 93:    LDC  2,0(6)	Set return value to 0 
												   >	 94:     LD  3,-1(1)	Load return address 
												   >	 95:     LD  1,0(1)	Adjust fp 
												   >	 96:    JMP  7,0(3)	Return 
												   >	* END FUNCTION agamemnon
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 97:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 98:    LDC  3,6(6)	Load integer constant 
												   >	 99:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	100:    LDC  3,7(6)	Load integer constant 
												   >	101:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	102:    LDC  3,8(6)	Load integer constant 
												   >	103:     ST  3,0(0)	Store variable x
												   >	* EXPRESSION
												   >	104:    LDC  3,9(6)	Load integer constant 
												   >	105:     ST  3,-1(0)	Store variable y
												   >	* EXPRESSION
												   >	106:    LDC  3,10(6)	Load integer constant 
												   >	107:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	108:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	109:     LD  3,-2(1)	Load variable a
												   >	110:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	111:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	112:    LDA  3,1(7)	Return address in ac 
												   >	113:    JMP  7,-108(7)	CALL output
												   >	114:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	115:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	116:     LD  3,-3(1)	Load variable b
												   >	117:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	118:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	119:    LDA  3,1(7)	Return address in ac 
												   >	120:    JMP  7,-115(7)	CALL output
												   >	121:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	122:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	123:     LD  3,0(0)	Load variable x
												   >	124:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	125:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-122(7)	CALL output
												   >	128:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	129:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	130:     LD  3,-1(0)	Load variable y
												   >	131:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	132:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	133:    LDA  3,1(7)	Return address in ac 
												   >	134:    JMP  7,-129(7)	CALL output
												   >	135:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	136:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	137:     LD  3,-4(1)	Load variable z
												   >	138:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	139:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	140:    LDA  3,1(7)	Return address in ac 
												   >	141:    JMP  7,-136(7)	CALL output
												   >	142:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	143:    LDC  3,666(6)	Load integer constant 
												   >	144:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	145:    LDC  3,666(6)	Load integer constant 
												   >	146:     ST  3,-6(1)	Store variable b
												   >	* EXPRESSION
												   >	147:    LDC  3,666(6)	Load integer constant 
												   >	148:     ST  3,-7(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	149:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	150:     LD  3,-5(1)	Load variable a
												   >	151:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	152:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	153:    LDA  3,1(7)	Return address in ac 
												   >	154:    JMP  7,-149(7)	CALL output
												   >	155:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	156:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	157:     LD  3,-6(1)	Load variable b
												   >	158:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	159:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-156(7)	CALL output
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	163:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	164:     LD  3,0(0)	Load variable x
												   >	165:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	166:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	167:    LDA  3,1(7)	Return address in ac 
												   >	168:    JMP  7,-163(7)	CALL output
												   >	169:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	170:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	171:     LD  3,-1(0)	Load variable y
												   >	172:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	173:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-170(7)	CALL output
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	177:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	178:     LD  3,-7(1)	Load variable z
												   >	179:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	180:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	181:    LDA  3,1(7)	Return address in ac 
												   >	182:    JMP  7,-177(7)	CALL output
												   >	183:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	184:    LDC  3,11(6)	Load integer constant 
												   >	185:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	186:    LDC  3,12(6)	Load integer constant 
												   >	187:     ST  3,-6(1)	Store variable b
												   >	* EXPRESSION
												   >	188:    LDC  3,13(6)	Load integer constant 
												   >	189:     ST  3,0(0)	Store variable x
												   >	* EXPRESSION
												   >	190:    LDC  3,14(6)	Load integer constant 
												   >	191:     ST  3,-1(0)	Store variable y
												   >	* EXPRESSION
												   >	192:    LDC  3,15(6)	Load integer constant 
												   >	193:     ST  3,-7(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	194:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	195:     LD  3,-5(1)	Load variable a
												   >	196:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	197:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	198:    LDA  3,1(7)	Return address in ac 
												   >	199:    JMP  7,-194(7)	CALL output
												   >	200:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	201:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	202:     LD  3,-6(1)	Load variable b
												   >	203:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	204:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	205:    LDA  3,1(7)	Return address in ac 
												   >	206:    JMP  7,-201(7)	CALL output
												   >	207:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	208:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	209:     LD  3,0(0)	Load variable x
												   >	210:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	211:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	212:    LDA  3,1(7)	Return address in ac 
												   >	213:    JMP  7,-208(7)	CALL output
												   >	214:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	215:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	216:     LD  3,-1(0)	Load variable y
												   >	217:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	218:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	219:    LDA  3,1(7)	Return address in ac 
												   >	220:    JMP  7,-215(7)	CALL output
												   >	221:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	222:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	223:     LD  3,-7(1)	Load variable z
												   >	224:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	225:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	226:    LDA  3,1(7)	Return address in ac 
												   >	227:    JMP  7,-222(7)	CALL output
												   >	228:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	229:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	230:     LD  3,-5(1)	Load variable a
												   >	231:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	232:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	233:    LDA  3,1(7)	Return address in ac 
												   >	234:    JMP  7,-229(7)	CALL output
												   >	235:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	236:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	237:     LD  3,-6(1)	Load variable b
												   >	238:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	239:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	240:    LDA  3,1(7)	Return address in ac 
												   >	241:    JMP  7,-236(7)	CALL output
												   >	242:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	243:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	244:     LD  3,0(0)	Load variable x
												   >	245:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	246:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	247:    LDA  3,1(7)	Return address in ac 
												   >	248:    JMP  7,-243(7)	CALL output
												   >	249:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	250:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	251:     LD  3,-1(0)	Load variable y
												   >	252:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	253:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	254:    LDA  3,1(7)	Return address in ac 
												   >	255:    JMP  7,-250(7)	CALL output
												   >	256:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	257:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	258:     LD  3,-7(1)	Load variable z
												   >	259:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	260:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	261:    LDA  3,1(7)	Return address in ac 
												   >	262:    JMP  7,-257(7)	CALL output
												   >	263:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	264:    LDC  3,16(6)	Load integer constant 
												   >	265:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	266:    LDC  3,17(6)	Load integer constant 
												   >	267:     ST  3,-6(1)	Store variable b
												   >	* EXPRESSION
												   >	268:    LDC  3,18(6)	Load integer constant 
												   >	269:     ST  3,0(0)	Store variable x
												   >	* EXPRESSION
												   >	270:    LDC  3,19(6)	Load integer constant 
												   >	271:     ST  3,-1(0)	Store variable y
												   >	* EXPRESSION
												   >	272:    LDC  3,20(6)	Load integer constant 
												   >	273:     ST  3,-7(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	274:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	275:     LD  3,-5(1)	Load variable a
												   >	276:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	277:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	278:    LDA  3,1(7)	Return address in ac 
												   >	279:    JMP  7,-274(7)	CALL output
												   >	280:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	281:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	282:     LD  3,-6(1)	Load variable b
												   >	283:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	284:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	285:    LDA  3,1(7)	Return address in ac 
												   >	286:    JMP  7,-281(7)	CALL output
												   >	287:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	288:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	289:     LD  3,0(0)	Load variable x
												   >	290:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	291:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	292:    LDA  3,1(7)	Return address in ac 
												   >	293:    JMP  7,-288(7)	CALL output
												   >	294:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	295:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	296:     LD  3,-1(0)	Load variable y
												   >	297:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	298:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	299:    LDA  3,1(7)	Return address in ac 
												   >	300:    JMP  7,-295(7)	CALL output
												   >	301:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	302:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	303:     LD  3,-7(1)	Load variable z
												   >	304:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	305:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	306:    LDA  3,1(7)	Return address in ac 
												   >	307:    JMP  7,-302(7)	CALL output
												   >	308:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	309:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	310:     LD  3,-5(1)	Load variable a
												   >	311:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	312:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	313:    LDA  3,1(7)	Return address in ac 
												   >	314:    JMP  7,-309(7)	CALL output
												   >	315:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	316:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	317:     LD  3,-6(1)	Load variable b
												   >	318:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	319:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	320:    LDA  3,1(7)	Return address in ac 
												   >	321:    JMP  7,-316(7)	CALL output
												   >	322:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	323:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	324:     LD  3,0(0)	Load variable x
												   >	325:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	326:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	327:    LDA  3,1(7)	Return address in ac 
												   >	328:    JMP  7,-323(7)	CALL output
												   >	329:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	330:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	331:     LD  3,-1(0)	Load variable y
												   >	332:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	333:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	334:    LDA  3,1(7)	Return address in ac 
												   >	335:    JMP  7,-330(7)	CALL output
												   >	336:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	337:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	338:     LD  3,-7(1)	Load variable z
												   >	339:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	340:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	341:    LDA  3,1(7)	Return address in ac 
												   >	342:    JMP  7,-337(7)	CALL output
												   >	343:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL agamemnon
												   >	344:     ST  1,-8(1)	Store fp in ghost frame for agamemnon
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end agamemnon
												   >	345:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	346:    LDA  3,1(7)	Return address in ac 
												   >	347:    JMP  7,-309(7)	CALL agamemnon
												   >	348:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end agamemnon
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	349:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	350:     LD  3,-5(1)	Load variable a
												   >	351:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	352:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	353:    LDA  3,1(7)	Return address in ac 
												   >	354:    JMP  7,-349(7)	CALL output
												   >	355:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	356:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	357:     LD  3,-6(1)	Load variable b
												   >	358:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	359:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	360:    LDA  3,1(7)	Return address in ac 
												   >	361:    JMP  7,-356(7)	CALL output
												   >	362:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	363:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	364:     LD  3,0(0)	Load variable x
												   >	365:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	366:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	367:    LDA  3,1(7)	Return address in ac 
												   >	368:    JMP  7,-363(7)	CALL output
												   >	369:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	370:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	371:     LD  3,-1(0)	Load variable y
												   >	372:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	373:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	374:    LDA  3,1(7)	Return address in ac 
												   >	375:    JMP  7,-370(7)	CALL output
												   >	376:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	377:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	378:     LD  3,-7(1)	Load variable z
												   >	379:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	380:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	381:    LDA  3,1(7)	Return address in ac 
												   >	382:    JMP  7,-377(7)	CALL output
												   >	383:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	384:    LDC  2,0(6)	Set return value to 0 
												   >	385:     LD  3,-1(1)	Load return address 
												   >	386:     LD  1,0(1)	Adjust fp 
												   >	387:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,387(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	388:    LDA  1,-3(0)	set first frame at end of globals 
												   >	389:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	390:    LDA  3,1(7)	Return address in ac 
												   >	391:    JMP  7,-295(7)	Jump to main 
												   >	392:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
nest.mem nest.mem.f21 differ: byte 1, line 1
nest (MEM DIFF)
Var: x of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: y of type int [mem: Global loc: -1 size: 1] [line: 2]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: z of type int [mem: Global loc: -2 size: 1] [line: 3]				   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Func: agamemnon returns type void [mem: Global loc: 0 size: -2] [line: 5]		   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: x of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: y of type int [mem: Global loc: -1 size: 1] [line: 2]
												   >	Sibling: 9  Var: z of type int [mem: Global loc: -2 size: 1] [line: 3]
												   >	Sibling: 10  Func: agamemnon returns type void [mem: Global loc: 0 size: -2] [line: 5]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 6]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 8]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   Sibling: 2  Var: x of type int [mem: Local loc: -4 size: 1] [line: 9]				.   .   Sibling: 2  Var: x of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Child: 1  Assign: = of type int [line: 11]						   |	.   .   Child: 1  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   Child: 1  Const 666 of type int [line: 11]							.   .   .   Child: 1  Const 666 of type int [line: 11]
.   .   Sibling: 1  Assign: = of type int [line: 12]						   |	.   .   Sibling: 1  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 12]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   Child: 1  Const 666 of type int [line: 12]							.   .   .   Child: 1  Const 666 of type int [line: 12]
.   .   Sibling: 2  Assign: = of type int [line: 13]						   |	.   .   Sibling: 2  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 13]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   Child: 1  Const 666 of type int [line: 13]							.   .   .   Child: 1  Const 666 of type int [line: 13]
.   .   Sibling: 3  Assign: = of type int [line: 14]						   |	.   .   Sibling: 3  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 14]			.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 14]
.   .   .   Child: 1  Const 666 of type int [line: 14]							.   .   .   Child: 1  Const 666 of type int [line: 14]
.   .   Sibling: 4  Call: output of type void [line: 16]						.   .   Sibling: 4  Call: output of type void [line: 16]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   Sibling: 5  Call: output of type void [line: 17]						.   .   Sibling: 5  Call: output of type void [line: 17]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   Sibling: 6  Call: output of type void [line: 18]						.   .   Sibling: 6  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 18]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   Sibling: 7  Call: output of type void [line: 19]						.   .   Sibling: 7  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 19]			.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 19]
.   .   Sibling: 8  Call: output of type void [line: 20]						.   .   Sibling: 8  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 20]			.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 20]
.   .   Sibling: 9  Assign: = of type int [line: 21]						   |	.   .   Sibling: 9  Assign: := of type int [line: 21]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 21]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 21]
.   .   .   Child: 1  Const 1 of type int [line: 21]							.   .   .   Child: 1  Const 1 of type int [line: 21]
.   .   Sibling: 10  Assign: = of type int [line: 22]						   |	.   .   Sibling: 10  Assign: := of type int [line: 22]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 22]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   .   Child: 1  Const 2 of type int [line: 22]							.   .   .   Child: 1  Const 2 of type int [line: 22]
.   .   Sibling: 11  Assign: = of type int [line: 23]						   |	.   .   Sibling: 11  Assign: := of type int [line: 23]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 23]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 23]
.   .   .   Child: 1  Const 3 of type int [line: 23]							.   .   .   Child: 1  Const 3 of type int [line: 23]
.   .   Sibling: 12  Assign: = of type int [line: 24]						   |	.   .   Sibling: 12  Assign: := of type int [line: 24]
.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 24]			.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 24]
.   .   .   Child: 1  Const 4 of type int [line: 24]							.   .   .   Child: 1  Const 4 of type int [line: 24]
.   .   Sibling: 13  Assign: = of type int [line: 25]						   |	.   .   Sibling: 13  Assign: := of type int [line: 25]
.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 25]			.   .   .   Child: 0  Id: z of type int [mem: Global loc: -2 size: 1] [line: 25]
.   .   .   Child: 1  Const 5 of type int [line: 25]							.   .   .   Child: 1  Const 5 of type int [line: 25]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 28]		   |	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 28]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 29]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 30]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 30]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 31]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 31]
.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 32]				.   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 32]
.   .   Child: 1  Assign: = of type int [line: 34]						   |	.   .   Child: 1  Assign: := of type int [line: 34]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 34]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 34]
.   .   .   Child: 1  Const 6 of type int [line: 34]							.   .   .   Child: 1  Const 6 of type int [line: 34]
.   .   Sibling: 1  Assign: = of type int [line: 35]						   |	.   .   Sibling: 1  Assign: := of type int [line: 35]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 35]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 35]
.   .   .   Child: 1  Const 7 of type int [line: 35]							.   .   .   Child: 1  Const 7 of type int [line: 35]
.   .   Sibling: 2  Assign: = of type int [line: 36]						   |	.   .   Sibling: 2  Assign: := of type int [line: 36]
.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 36]				.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 36]
.   .   .   Child: 1  Const 8 of type int [line: 36]							.   .   .   Child: 1  Const 8 of type int [line: 36]
.   .   Sibling: 3  Assign: = of type int [line: 37]						   |	.   .   Sibling: 3  Assign: := of type int [line: 37]
.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 37]			.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 37]
.   .   .   Child: 1  Const 9 of type int [line: 37]							.   .   .   Child: 1  Const 9 of type int [line: 37]
.   .   Sibling: 4  Assign: = of type int [line: 38]						   |	.   .   Sibling: 4  Assign: := of type int [line: 38]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 38]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 38]
.   .   .   Child: 1  Const 10 of type int [line: 38]							.   .   .   Child: 1  Const 10 of type int [line: 38]
.   .   Sibling: 5  Call: output of type void [line: 40]						.   .   Sibling: 5  Call: output of type void [line: 40]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 40]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 40]
.   .   Sibling: 6  Call: output of type void [line: 41]						.   .   Sibling: 6  Call: output of type void [line: 41]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 41]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 41]
.   .   Sibling: 7  Call: output of type void [line: 42]						.   .   Sibling: 7  Call: output of type void [line: 42]
.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 42]				.   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 42]
.   .   Sibling: 8  Call: output of type void [line: 43]						.   .   Sibling: 8  Call: output of type void [line: 43]
.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 43]			.   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 43]
.   .   Sibling: 9  Call: output of type void [line: 44]						.   .   Sibling: 9  Call: output of type void [line: 44]
.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 44]				.   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 44]
.   .   Sibling: 10  Compound [mem: None loc: 0 size: -8] [line: 45]					.   .   Sibling: 10  Compound [mem: None loc: 0 size: -8] [line: 45]
.   .   .   Child: 0  Var: a of type int [mem: Local loc: -5 size: 1] [line: 46]			.   .   .   Child: 0  Var: a of type int [mem: Local loc: -5 size: 1] [line: 46]
.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 47]			.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 47]
.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -7 size: 1] [line: 48]			.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -7 size: 1] [line: 48]
.   .   .   Child: 1  Assign: = of type int [line: 50]						   |	.   .   .   Child: 1  Assign: := of type int [line: 50]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 50]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 50]
.   .   .   .   Child: 1  Const 666 of type int [line: 50]						.   .   .   .   Child: 1  Const 666 of type int [line: 50]
.   .   .   Sibling: 1  Assign: = of type int [line: 51]					   |	.   .   .   Sibling: 1  Assign: := of type int [line: 51]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 51]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 51]
.   .   .   .   Child: 1  Const 666 of type int [line: 51]						.   .   .   .   Child: 1  Const 666 of type int [line: 51]
.   .   .   Sibling: 2  Assign: = of type int [line: 52]					   |	.   .   .   Sibling: 2  Assign: := of type int [line: 52]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 52]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 52]
.   .   .   .   Child: 1  Const 666 of type int [line: 52]						.   .   .   .   Child: 1  Const 666 of type int [line: 52]
.   .   .   Sibling: 3  Call: output of type void [line: 54]						.   .   .   Sibling: 3  Call: output of type void [line: 54]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 54]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 54]
.   .   .   Sibling: 4  Call: output of type void [line: 55]						.   .   .   Sibling: 4  Call: output of type void [line: 55]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 55]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 55]
.   .   .   Sibling: 5  Call: output of type void [line: 56]						.   .   .   Sibling: 5  Call: output of type void [line: 56]
.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 56]			.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 56]
.   .   .   Sibling: 6  Call: output of type void [line: 57]						.   .   .   Sibling: 6  Call: output of type void [line: 57]
.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 57]			.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 57]
.   .   .   Sibling: 7  Call: output of type void [line: 58]						.   .   .   Sibling: 7  Call: output of type void [line: 58]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 58]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 58]
.   .   .   Sibling: 8  Assign: = of type int [line: 60]					   |	.   .   .   Sibling: 8  Assign: := of type int [line: 60]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 60]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 60]
.   .   .   .   Child: 1  Const 11 of type int [line: 60]						.   .   .   .   Child: 1  Const 11 of type int [line: 60]
.   .   .   Sibling: 9  Assign: = of type int [line: 61]					   |	.   .   .   Sibling: 9  Assign: := of type int [line: 61]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 61]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 61]
.   .   .   .   Child: 1  Const 12 of type int [line: 61]						.   .   .   .   Child: 1  Const 12 of type int [line: 61]
.   .   .   Sibling: 10  Assign: = of type int [line: 62]					   |	.   .   .   Sibling: 10  Assign: := of type int [line: 62]
.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 62]			.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 62]
.   .   .   .   Child: 1  Const 13 of type int [line: 62]						.   .   .   .   Child: 1  Const 13 of type int [line: 62]
.   .   .   Sibling: 11  Assign: = of type int [line: 63]					   |	.   .   .   Sibling: 11  Assign: := of type int [line: 63]
.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 63]			.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 63]
.   .   .   .   Child: 1  Const 14 of type int [line: 63]						.   .   .   .   Child: 1  Const 14 of type int [line: 63]
.   .   .   Sibling: 12  Assign: = of type int [line: 64]					   |	.   .   .   Sibling: 12  Assign: := of type int [line: 64]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 64]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 64]
.   .   .   .   Child: 1  Const 15 of type int [line: 64]						.   .   .   .   Child: 1  Const 15 of type int [line: 64]
.   .   .   Sibling: 13  Call: output of type void [line: 65]						.   .   .   Sibling: 13  Call: output of type void [line: 65]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 65]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 65]
.   .   .   Sibling: 14  Call: output of type void [line: 66]						.   .   .   Sibling: 14  Call: output of type void [line: 66]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 66]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 66]
.   .   .   Sibling: 15  Call: output of type void [line: 67]						.   .   .   Sibling: 15  Call: output of type void [line: 67]
.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 67]			.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 67]
.   .   .   Sibling: 16  Call: output of type void [line: 68]						.   .   .   Sibling: 16  Call: output of type void [line: 68]
.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 68]			.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 68]
.   .   .   Sibling: 17  Call: output of type void [line: 69]						.   .   .   Sibling: 17  Call: output of type void [line: 69]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 69]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 69]
.   .   .   Sibling: 18  Compound [mem: None loc: 0 size: -8] [line: 70]				.   .   .   Sibling: 18  Compound [mem: None loc: 0 size: -8] [line: 70]
.   .   .   .   Child: 1  Call: output of type void [line: 71]						.   .   .   .   Child: 1  Call: output of type void [line: 71]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 71]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 71]
.   .   .   .   Sibling: 1  Call: output of type void [line: 72]					.   .   .   .   Sibling: 1  Call: output of type void [line: 72]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 72]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 72]
.   .   .   .   Sibling: 2  Call: output of type void [line: 73]					.   .   .   .   Sibling: 2  Call: output of type void [line: 73]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 73]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 73]
.   .   .   .   Sibling: 3  Call: output of type void [line: 74]					.   .   .   .   Sibling: 3  Call: output of type void [line: 74]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 74]		.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 74]
.   .   .   .   Sibling: 4  Call: output of type void [line: 75]					.   .   .   .   Sibling: 4  Call: output of type void [line: 75]
.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 75]			.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 75]
.   .   .   .   Sibling: 5  Assign: = of type int [line: 77]					   |	.   .   .   .   Sibling: 5  Assign: := of type int [line: 77]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 77]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 77]
.   .   .   .   .   Child: 1  Const 16 of type int [line: 77]						.   .   .   .   .   Child: 1  Const 16 of type int [line: 77]
.   .   .   .   Sibling: 6  Assign: = of type int [line: 78]					   |	.   .   .   .   Sibling: 6  Assign: := of type int [line: 78]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 78]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 78]
.   .   .   .   .   Child: 1  Const 17 of type int [line: 78]						.   .   .   .   .   Child: 1  Const 17 of type int [line: 78]
.   .   .   .   Sibling: 7  Assign: = of type int [line: 79]					   |	.   .   .   .   Sibling: 7  Assign: := of type int [line: 79]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 79]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 79]
.   .   .   .   .   Child: 1  Const 18 of type int [line: 79]						.   .   .   .   .   Child: 1  Const 18 of type int [line: 79]
.   .   .   .   Sibling: 8  Assign: = of type int [line: 80]					   |	.   .   .   .   Sibling: 8  Assign: := of type int [line: 80]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 80]		.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 80]
.   .   .   .   .   Child: 1  Const 19 of type int [line: 80]						.   .   .   .   .   Child: 1  Const 19 of type int [line: 80]
.   .   .   .   Sibling: 9  Assign: = of type int [line: 81]					   |	.   .   .   .   Sibling: 9  Assign: := of type int [line: 81]
.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 81]			.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 81]
.   .   .   .   .   Child: 1  Const 20 of type int [line: 81]						.   .   .   .   .   Child: 1  Const 20 of type int [line: 81]
.   .   .   .   Sibling: 10  Call: output of type void [line: 82]					.   .   .   .   Sibling: 10  Call: output of type void [line: 82]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 82]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 82]
.   .   .   .   Sibling: 11  Call: output of type void [line: 83]					.   .   .   .   Sibling: 11  Call: output of type void [line: 83]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 83]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 83]
.   .   .   .   Sibling: 12  Call: output of type void [line: 84]					.   .   .   .   Sibling: 12  Call: output of type void [line: 84]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 84]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 84]
.   .   .   .   Sibling: 13  Call: output of type void [line: 85]					.   .   .   .   Sibling: 13  Call: output of type void [line: 85]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 85]		.   .   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 85]
.   .   .   .   Sibling: 14  Call: output of type void [line: 86]					.   .   .   .   Sibling: 14  Call: output of type void [line: 86]
.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 86]			.   .   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 86]
.   .   .   Sibling: 19  Call: output of type void [line: 88]						.   .   .   Sibling: 19  Call: output of type void [line: 88]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 88]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 88]
.   .   .   Sibling: 20  Call: output of type void [line: 89]						.   .   .   Sibling: 20  Call: output of type void [line: 89]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 89]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 89]
.   .   .   Sibling: 21  Call: output of type void [line: 90]						.   .   .   Sibling: 21  Call: output of type void [line: 90]
.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 90]			.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 90]
.   .   .   Sibling: 22  Call: output of type void [line: 91]						.   .   .   Sibling: 22  Call: output of type void [line: 91]
.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 91]			.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 91]
.   .   .   Sibling: 23  Call: output of type void [line: 92]						.   .   .   Sibling: 23  Call: output of type void [line: 92]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 92]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 92]
.   .   .   Sibling: 24  Call: agamemnon of type void [line: 94]					.   .   .   Sibling: 24  Call: agamemnon of type void [line: 94]
.   .   .   Sibling: 25  Call: output of type void [line: 96]						.   .   .   Sibling: 25  Call: output of type void [line: 96]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 96]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 96]
.   .   .   Sibling: 26  Call: output of type void [line: 97]						.   .   .   Sibling: 26  Call: output of type void [line: 97]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 97]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 97]
.   .   .   Sibling: 27  Call: output of type void [line: 98]						.   .   .   Sibling: 27  Call: output of type void [line: 98]
.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 98]			.   .   .   .   Child: 0  Id: x of type int [mem: Global loc: 0 size: 1] [line: 98]
.   .   .   Sibling: 28  Call: output of type void [line: 99]						.   .   .   Sibling: 28  Call: output of type void [line: 99]
.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 99]			.   .   .   .   Child: 0  Id: y of type int [mem: Global loc: -1 size: 1] [line: 99]
.   .   .   Sibling: 29  Call: output of type void [line: 100]						.   .   .   Sibling: 29  Call: output of type void [line: 100]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 100]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -7 size: 1] [line: 100]
Offset for end of global space: -3									Offset for end of global space: -3
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
nest.out ztmp23114.txt differ: byte 1, line 1
nest (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/nest.tm
Number of errors: 0										   |	6 7 8 9 10 666 666 8 9 666 11 12 13 14 15 11 12 13 14 15 16 17 18 19 20 16 17 18 19 20 666 666 6
------------------------------------								   <
Loading file: nest.tm										   <
Bye.													Bye.
====================================
FILE: op1.c-
-rw-------. 1 corg7983 domain_users  1058 Nov 17 15:35 op1.c-
-rw-------. 1 corg7983 domain_users  1055 Nov 17 15:35 op1.c-.f21
-rw-------. 1 corg7983 domain_users  1058 Nov 17 15:35 op1.c-.f22
-rw-------. 1 corg7983 domain_users   126 Nov 17 15:35 op1.expected
-rw-------. 1 corg7983 domain_users  9148 Nov 22 12:27 op1.mem
-rw-------. 1 corg7983 domain_users  1079 Nov 17 15:35 op1.mem.diffs
-rw-------. 1 corg7983 domain_users  9986 Nov 17 15:35 op1.mem.f21
-rw-------. 1 corg7983 domain_users   105 Nov 22 12:27 op1.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 op1.tm
-rw-------. 1 corg7983 domain_users   754 Nov 17 15:35 op1.tm.diffs
-rw-------. 1 corg7983 domain_users 29320 Nov 17 15:35 op1.tm.f21
TM CODE COMPARISON
op1 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  op1.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 40:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 41:    LDC  3,111(6)	Load integer constant 
												   >	 42:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 43:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 44:     LD  4,-4(1)	Pop left into ac1 
												   >	 45:    TLE  3,4,3	Op <= 
												   >	 46:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 47:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 48:    LDA  3,1(7)	Return address in ac 
												   >	 49:    JMP  7,-33(7)	CALL outputb
												   >	 50:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 51:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 52:    LDC  3,222(6)	Load integer constant 
												   >	 53:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 54:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 55:     LD  4,-4(1)	Pop left into ac1 
												   >	 56:    TLE  3,4,3	Op <= 
												   >	 57:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 58:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 59:    LDA  3,1(7)	Return address in ac 
												   >	 60:    JMP  7,-44(7)	CALL outputb
												   >	 61:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 62:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 63:    LDC  3,111(6)	Load integer constant 
												   >	 64:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 65:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 66:     LD  4,-4(1)	Pop left into ac1 
												   >	 67:    TLE  3,4,3	Op <= 
												   >	 68:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 69:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 70:    LDA  3,1(7)	Return address in ac 
												   >	 71:    JMP  7,-55(7)	CALL outputb
												   >	 72:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 73:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	 74:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-43(7)	CALL outnl
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 78:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 79:    LDC  3,111(6)	Load integer constant 
												   >	 80:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 81:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 82:     LD  4,-4(1)	Pop left into ac1 
												   >	 83:    TLT  3,4,3	Op < 
												   >	 84:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 85:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-71(7)	CALL outputb
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 89:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	 90:    LDC  3,222(6)	Load integer constant 
												   >	 91:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 92:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 93:     LD  4,-4(1)	Pop left into ac1 
												   >	 94:    TLT  3,4,3	Op < 
												   >	 95:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	 96:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 97:    LDA  3,1(7)	Return address in ac 
												   >	 98:    JMP  7,-82(7)	CALL outputb
												   >	 99:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	100:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	101:    LDC  3,111(6)	Load integer constant 
												   >	102:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	103:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	104:     LD  4,-4(1)	Pop left into ac1 
												   >	105:    TLT  3,4,3	Op < 
												   >	106:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	107:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-93(7)	CALL outputb
												   >	110:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	111:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	112:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	113:    LDA  3,1(7)	Return address in ac 
												   >	114:    JMP  7,-81(7)	CALL outnl
												   >	115:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	116:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	117:    LDC  3,111(6)	Load integer constant 
												   >	118:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	119:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	120:     LD  4,-4(1)	Pop left into ac1 
												   >	121:    TGT  3,4,3	Op > 
												   >	122:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	123:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	124:    LDA  3,1(7)	Return address in ac 
												   >	125:    JMP  7,-109(7)	CALL outputb
												   >	126:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	127:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	128:    LDC  3,222(6)	Load integer constant 
												   >	129:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	130:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	131:     LD  4,-4(1)	Pop left into ac1 
												   >	132:    TGT  3,4,3	Op > 
												   >	133:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	134:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	135:    LDA  3,1(7)	Return address in ac 
												   >	136:    JMP  7,-120(7)	CALL outputb
												   >	137:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	138:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	139:    LDC  3,111(6)	Load integer constant 
												   >	140:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	141:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	142:     LD  4,-4(1)	Pop left into ac1 
												   >	143:    TGT  3,4,3	Op > 
												   >	144:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	145:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	146:    LDA  3,1(7)	Return address in ac 
												   >	147:    JMP  7,-131(7)	CALL outputb
												   >	148:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	149:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	150:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-119(7)	CALL outnl
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	154:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	155:    LDC  3,111(6)	Load integer constant 
												   >	156:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	157:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	158:     LD  4,-4(1)	Pop left into ac1 
												   >	159:    TGE  3,4,3	Op >= 
												   >	160:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	161:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	162:    LDA  3,1(7)	Return address in ac 
												   >	163:    JMP  7,-147(7)	CALL outputb
												   >	164:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	165:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	166:    LDC  3,222(6)	Load integer constant 
												   >	167:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	168:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	169:     LD  4,-4(1)	Pop left into ac1 
												   >	170:    TGE  3,4,3	Op >= 
												   >	171:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	172:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-158(7)	CALL outputb
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	176:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	177:    LDC  3,111(6)	Load integer constant 
												   >	178:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	179:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	180:     LD  4,-4(1)	Pop left into ac1 
												   >	181:    TGE  3,4,3	Op >= 
												   >	182:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	183:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	184:    LDA  3,1(7)	Return address in ac 
												   >	185:    JMP  7,-169(7)	CALL outputb
												   >	186:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	187:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	188:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	189:    LDA  3,1(7)	Return address in ac 
												   >	190:    JMP  7,-157(7)	CALL outnl
												   >	191:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	192:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	193:    LDC  3,111(6)	Load integer constant 
												   >	194:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	195:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	196:     LD  4,-4(1)	Pop left into ac1 
												   >	197:    TEQ  3,4,3	Op = 
												   >	198:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	199:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-185(7)	CALL outputb
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	203:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	204:    LDC  3,222(6)	Load integer constant 
												   >	205:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	206:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	207:     LD  4,-4(1)	Pop left into ac1 
												   >	208:    TEQ  3,4,3	Op = 
												   >	209:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	210:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	211:    LDA  3,1(7)	Return address in ac 
												   >	212:    JMP  7,-196(7)	CALL outputb
												   >	213:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	214:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	215:    LDC  3,111(6)	Load integer constant 
												   >	216:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	217:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	218:     LD  4,-4(1)	Pop left into ac1 
												   >	219:    TEQ  3,4,3	Op = 
												   >	220:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	221:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-207(7)	CALL outputb
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	225:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	226:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	227:    LDA  3,1(7)	Return address in ac 
												   >	228:    JMP  7,-195(7)	CALL outnl
												   >	229:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	230:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	231:    LDC  3,111(6)	Load integer constant 
												   >	232:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	233:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	234:     LD  4,-4(1)	Pop left into ac1 
												   >	235:    TNE  3,4,3	Op >< 
												   >	236:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	237:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	238:    LDA  3,1(7)	Return address in ac 
												   >	239:    JMP  7,-223(7)	CALL outputb
												   >	240:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	241:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	242:    LDC  3,222(6)	Load integer constant 
												   >	243:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	244:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	245:     LD  4,-4(1)	Pop left into ac1 
												   >	246:    TNE  3,4,3	Op >< 
												   >	247:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	248:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	249:    LDA  3,1(7)	Return address in ac 
												   >	250:    JMP  7,-234(7)	CALL outputb
												   >	251:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	252:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	253:    LDC  3,111(6)	Load integer constant 
												   >	254:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	255:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	256:     LD  4,-4(1)	Pop left into ac1 
												   >	257:    TNE  3,4,3	Op >< 
												   >	258:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	259:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	260:    LDA  3,1(7)	Return address in ac 
												   >	261:    JMP  7,-245(7)	CALL outputb
												   >	262:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	263:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	264:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	265:    LDA  3,1(7)	Return address in ac 
												   >	266:    JMP  7,-233(7)	CALL outnl
												   >	267:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	268:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	269:    LDC  3,111(6)	Load integer constant 
												   >	270:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	271:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	272:     LD  4,-4(1)	Pop left into ac1 
												   >	273:    TNE  3,4,3	Op >< 
												   >	274:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	275:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	276:    LDA  3,1(7)	Return address in ac 
												   >	277:    JMP  7,-261(7)	CALL outputb
												   >	278:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	279:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	280:    LDC  3,222(6)	Load integer constant 
												   >	281:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	282:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	283:     LD  4,-4(1)	Pop left into ac1 
												   >	284:    TNE  3,4,3	Op >< 
												   >	285:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	286:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	287:    LDA  3,1(7)	Return address in ac 
												   >	288:    JMP  7,-272(7)	CALL outputb
												   >	289:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	290:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	291:    LDC  3,111(6)	Load integer constant 
												   >	292:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	293:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	294:     LD  4,-4(1)	Pop left into ac1 
												   >	295:    TNE  3,4,3	Op >< 
												   >	296:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	297:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	298:    LDA  3,1(7)	Return address in ac 
												   >	299:    JMP  7,-283(7)	CALL outputb
												   >	300:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	301:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	302:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	303:    LDA  3,1(7)	Return address in ac 
												   >	304:    JMP  7,-271(7)	CALL outnl
												   >	305:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	306:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	307:    LDC  3,0(6)	Load Boolean constant 
												   >	308:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	309:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	310:     LD  4,-4(1)	Pop left into ac1 
												   >	311:    AND  3,4,3	Op AND 
												   >	312:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	313:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	314:    LDA  3,1(7)	Return address in ac 
												   >	315:    JMP  7,-299(7)	CALL outputb
												   >	316:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	317:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	318:    LDC  3,0(6)	Load Boolean constant 
												   >	319:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	320:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	321:     LD  4,-4(1)	Pop left into ac1 
												   >	322:    AND  3,4,3	Op AND 
												   >	323:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	324:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	325:    LDA  3,1(7)	Return address in ac 
												   >	326:    JMP  7,-310(7)	CALL outputb
												   >	327:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	328:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	329:    LDC  3,1(6)	Load Boolean constant 
												   >	330:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	331:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	332:     LD  4,-4(1)	Pop left into ac1 
												   >	333:    AND  3,4,3	Op AND 
												   >	334:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	335:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	336:    LDA  3,1(7)	Return address in ac 
												   >	337:    JMP  7,-321(7)	CALL outputb
												   >	338:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	339:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	340:    LDC  3,1(6)	Load Boolean constant 
												   >	341:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	342:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	343:     LD  4,-4(1)	Pop left into ac1 
												   >	344:    AND  3,4,3	Op AND 
												   >	345:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	346:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	347:    LDA  3,1(7)	Return address in ac 
												   >	348:    JMP  7,-332(7)	CALL outputb
												   >	349:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	350:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	351:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	352:    LDA  3,1(7)	Return address in ac 
												   >	353:    JMP  7,-320(7)	CALL outnl
												   >	354:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	355:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	356:    LDC  3,0(6)	Load Boolean constant 
												   >	357:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	358:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	359:     LD  4,-4(1)	Pop left into ac1 
												   >	360:     OR  3,4,3	Op OR 
												   >	361:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	362:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	363:    LDA  3,1(7)	Return address in ac 
												   >	364:    JMP  7,-348(7)	CALL outputb
												   >	365:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	366:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	367:    LDC  3,0(6)	Load Boolean constant 
												   >	368:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	369:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	370:     LD  4,-4(1)	Pop left into ac1 
												   >	371:     OR  3,4,3	Op OR 
												   >	372:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	373:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	374:    LDA  3,1(7)	Return address in ac 
												   >	375:    JMP  7,-359(7)	CALL outputb
												   >	376:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	377:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	378:    LDC  3,1(6)	Load Boolean constant 
												   >	379:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	380:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	381:     LD  4,-4(1)	Pop left into ac1 
												   >	382:     OR  3,4,3	Op OR 
												   >	383:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	384:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	385:    LDA  3,1(7)	Return address in ac 
												   >	386:    JMP  7,-370(7)	CALL outputb
												   >	387:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	388:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	389:    LDC  3,1(6)	Load Boolean constant 
												   >	390:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	391:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	392:     LD  4,-4(1)	Pop left into ac1 
												   >	393:     OR  3,4,3	Op OR 
												   >	394:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	395:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	396:    LDA  3,1(7)	Return address in ac 
												   >	397:    JMP  7,-381(7)	CALL outputb
												   >	398:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	399:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	400:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	401:    LDA  3,1(7)	Return address in ac 
												   >	402:    JMP  7,-369(7)	CALL outnl
												   >	403:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	404:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	405:    LDC  3,0(6)	Load Boolean constant 
												   >	406:    LDC  4,1(6)	Load 1 
												   >	407:    XOR  3,3,4	Op XOR to get logical not 
												   >	408:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	409:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	410:    LDA  3,1(7)	Return address in ac 
												   >	411:    JMP  7,-395(7)	CALL outputb
												   >	412:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	413:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	414:    LDC  3,1(6)	Load Boolean constant 
												   >	415:    LDC  4,1(6)	Load 1 
												   >	416:    XOR  3,3,4	Op XOR to get logical not 
												   >	417:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	418:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	419:    LDA  3,1(7)	Return address in ac 
												   >	420:    JMP  7,-404(7)	CALL outputb
												   >	421:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	422:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	423:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	424:    LDA  3,1(7)	Return address in ac 
												   >	425:    JMP  7,-392(7)	CALL outnl
												   >	426:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	427:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	428:    LDC  3,333(6)	Load integer constant 
												   >	429:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	430:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	431:     LD  4,-4(1)	Pop left into ac1 
												   >	432:    ADD  3,4,3	Op + 
												   >	433:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	434:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	435:    LDA  3,1(7)	Return address in ac 
												   >	436:    JMP  7,-431(7)	CALL output
												   >	437:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	438:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	439:    LDC  3,333(6)	Load integer constant 
												   >	440:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	441:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	442:     LD  4,-4(1)	Pop left into ac1 
												   >	443:    SUB  3,4,3	Op - 
												   >	444:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	445:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	446:    LDA  3,1(7)	Return address in ac 
												   >	447:    JMP  7,-442(7)	CALL output
												   >	448:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	449:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	450:    LDC  3,333(6)	Load integer constant 
												   >	451:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	452:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	453:     LD  4,-4(1)	Pop left into ac1 
												   >	454:    MUL  3,4,3	Op * 
												   >	455:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	456:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	457:    LDA  3,1(7)	Return address in ac 
												   >	458:    JMP  7,-453(7)	CALL output
												   >	459:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	460:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	461:    LDC  3,333(6)	Load integer constant 
												   >	462:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	463:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	464:     LD  4,-4(1)	Pop left into ac1 
												   >	465:    DIV  3,4,3	Op / 
												   >	466:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	467:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	468:    LDA  3,1(7)	Return address in ac 
												   >	469:    JMP  7,-464(7)	CALL output
												   >	470:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	471:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	472:    LDC  3,3333(6)	Load integer constant 
												   >	473:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	474:    LDC  3,444(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	475:     LD  4,-4(1)	Pop left into ac1 
												   >	476:    MOD  3,4,3	Op % 
												   >	477:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	478:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	479:    LDA  3,1(7)	Return address in ac 
												   >	480:    JMP  7,-475(7)	CALL output
												   >	481:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL output
												   >	482:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	483:    LDC  3,444(6)	Load integer constant 
												   >	484:    NEG  3,3,3	Op unary - 
												   >	485:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	486:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	487:    LDA  3,1(7)	Return address in ac 
												   >	488:    JMP  7,-483(7)	CALL output
												   >	489:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* RETURN
												   >	490:     LD  3,-1(1)	Load return address 
												   >	491:     LD  1,0(1)	Adjust fp 
												   >	492:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	493:    LDC  2,0(6)	Set return value to 0 
												   >	494:     LD  3,-1(1)	Load return address 
												   >	495:     LD  1,0(1)	Adjust fp 
												   >	496:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,496(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	497:    LDA  1,0(0)	set first frame at end of globals 
												   >	498:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	499:    LDA  3,1(7)	Return address in ac 
												   >	500:    JMP  7,-462(7)	Jump to main 
												   >	501:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
op1.mem op1.mem.f21 differ: byte 7, line 1
op1 (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Call: outputb of type void [line: 3]							.   .   Child: 1  Call: outputb of type void [line: 3]
.   .   .   Child: 0  Op: <= of type bool [line: 3]							.   .   .   Child: 0  Op: <= of type bool [line: 3]
.   .   .   .   Child: 0  Const 111 of type int [line: 3]						.   .   .   .   Child: 0  Const 111 of type int [line: 3]
.   .   .   .   Child: 1  Const 222 of type int [line: 3]						.   .   .   .   Child: 1  Const 222 of type int [line: 3]
.   .   Sibling: 1  Call: outputb of type void [line: 4]						.   .   Sibling: 1  Call: outputb of type void [line: 4]
.   .   .   Child: 0  Op: <= of type bool [line: 4]							.   .   .   Child: 0  Op: <= of type bool [line: 4]
.   .   .   .   Child: 0  Const 222 of type int [line: 4]						.   .   .   .   Child: 0  Const 222 of type int [line: 4]
.   .   .   .   Child: 1  Const 111 of type int [line: 4]						.   .   .   .   Child: 1  Const 111 of type int [line: 4]
.   .   Sibling: 2  Call: outputb of type void [line: 5]						.   .   Sibling: 2  Call: outputb of type void [line: 5]
.   .   .   Child: 0  Op: <= of type bool [line: 5]							.   .   .   Child: 0  Op: <= of type bool [line: 5]
.   .   .   .   Child: 0  Const 111 of type int [line: 5]						.   .   .   .   Child: 0  Const 111 of type int [line: 5]
.   .   .   .   Child: 1  Const 111 of type int [line: 5]						.   .   .   .   Child: 1  Const 111 of type int [line: 5]
.   .   Sibling: 3  Call: outnl of type void [line: 6]							.   .   Sibling: 3  Call: outnl of type void [line: 6]
.   .   Sibling: 4  Call: outputb of type void [line: 8]						.   .   Sibling: 4  Call: outputb of type void [line: 8]
.   .   .   Child: 0  Op: < of type bool [line: 8]							.   .   .   Child: 0  Op: < of type bool [line: 8]
.   .   .   .   Child: 0  Const 111 of type int [line: 8]						.   .   .   .   Child: 0  Const 111 of type int [line: 8]
.   .   .   .   Child: 1  Const 222 of type int [line: 8]						.   .   .   .   Child: 1  Const 222 of type int [line: 8]
.   .   Sibling: 5  Call: outputb of type void [line: 9]						.   .   Sibling: 5  Call: outputb of type void [line: 9]
.   .   .   Child: 0  Op: < of type bool [line: 9]							.   .   .   Child: 0  Op: < of type bool [line: 9]
.   .   .   .   Child: 0  Const 222 of type int [line: 9]						.   .   .   .   Child: 0  Const 222 of type int [line: 9]
.   .   .   .   Child: 1  Const 111 of type int [line: 9]						.   .   .   .   Child: 1  Const 111 of type int [line: 9]
.   .   Sibling: 6  Call: outputb of type void [line: 10]						.   .   Sibling: 6  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: < of type bool [line: 10]							.   .   .   Child: 0  Op: < of type bool [line: 10]
.   .   .   .   Child: 0  Const 111 of type int [line: 10]						.   .   .   .   Child: 0  Const 111 of type int [line: 10]
.   .   .   .   Child: 1  Const 111 of type int [line: 10]						.   .   .   .   Child: 1  Const 111 of type int [line: 10]
.   .   Sibling: 7  Call: outnl of type void [line: 11]							.   .   Sibling: 7  Call: outnl of type void [line: 11]
.   .   Sibling: 8  Call: outputb of type void [line: 13]						.   .   Sibling: 8  Call: outputb of type void [line: 13]
.   .   .   Child: 0  Op: > of type bool [line: 13]							.   .   .   Child: 0  Op: > of type bool [line: 13]
.   .   .   .   Child: 0  Const 111 of type int [line: 13]						.   .   .   .   Child: 0  Const 111 of type int [line: 13]
.   .   .   .   Child: 1  Const 222 of type int [line: 13]						.   .   .   .   Child: 1  Const 222 of type int [line: 13]
.   .   Sibling: 9  Call: outputb of type void [line: 14]						.   .   Sibling: 9  Call: outputb of type void [line: 14]
.   .   .   Child: 0  Op: > of type bool [line: 14]							.   .   .   Child: 0  Op: > of type bool [line: 14]
.   .   .   .   Child: 0  Const 222 of type int [line: 14]						.   .   .   .   Child: 0  Const 222 of type int [line: 14]
.   .   .   .   Child: 1  Const 111 of type int [line: 14]						.   .   .   .   Child: 1  Const 111 of type int [line: 14]
.   .   Sibling: 10  Call: outputb of type void [line: 15]						.   .   Sibling: 10  Call: outputb of type void [line: 15]
.   .   .   Child: 0  Op: > of type bool [line: 15]							.   .   .   Child: 0  Op: > of type bool [line: 15]
.   .   .   .   Child: 0  Const 111 of type int [line: 15]						.   .   .   .   Child: 0  Const 111 of type int [line: 15]
.   .   .   .   Child: 1  Const 111 of type int [line: 15]						.   .   .   .   Child: 1  Const 111 of type int [line: 15]
.   .   Sibling: 11  Call: outnl of type void [line: 16]						.   .   Sibling: 11  Call: outnl of type void [line: 16]
.   .   Sibling: 12  Call: outputb of type void [line: 18]						.   .   Sibling: 12  Call: outputb of type void [line: 18]
.   .   .   Child: 0  Op: >= of type bool [line: 18]							.   .   .   Child: 0  Op: >= of type bool [line: 18]
.   .   .   .   Child: 0  Const 111 of type int [line: 18]						.   .   .   .   Child: 0  Const 111 of type int [line: 18]
.   .   .   .   Child: 1  Const 222 of type int [line: 18]						.   .   .   .   Child: 1  Const 222 of type int [line: 18]
.   .   Sibling: 13  Call: outputb of type void [line: 19]						.   .   Sibling: 13  Call: outputb of type void [line: 19]
.   .   .   Child: 0  Op: >= of type bool [line: 19]							.   .   .   Child: 0  Op: >= of type bool [line: 19]
.   .   .   .   Child: 0  Const 222 of type int [line: 19]						.   .   .   .   Child: 0  Const 222 of type int [line: 19]
.   .   .   .   Child: 1  Const 111 of type int [line: 19]						.   .   .   .   Child: 1  Const 111 of type int [line: 19]
.   .   Sibling: 14  Call: outputb of type void [line: 20]						.   .   Sibling: 14  Call: outputb of type void [line: 20]
.   .   .   Child: 0  Op: >= of type bool [line: 20]							.   .   .   Child: 0  Op: >= of type bool [line: 20]
.   .   .   .   Child: 0  Const 111 of type int [line: 20]						.   .   .   .   Child: 0  Const 111 of type int [line: 20]
.   .   .   .   Child: 1  Const 111 of type int [line: 20]						.   .   .   .   Child: 1  Const 111 of type int [line: 20]
.   .   Sibling: 15  Call: outnl of type void [line: 21]						.   .   Sibling: 15  Call: outnl of type void [line: 21]
.   .   Sibling: 16  Call: outputb of type void [line: 23]						.   .   Sibling: 16  Call: outputb of type void [line: 23]
.   .   .   Child: 0  Op: == of type bool [line: 23]						   |	.   .   .   Child: 0  Op: = of type bool [line: 23]
.   .   .   .   Child: 0  Const 111 of type int [line: 23]						.   .   .   .   Child: 0  Const 111 of type int [line: 23]
.   .   .   .   Child: 1  Const 222 of type int [line: 23]						.   .   .   .   Child: 1  Const 222 of type int [line: 23]
.   .   Sibling: 17  Call: outputb of type void [line: 24]						.   .   Sibling: 17  Call: outputb of type void [line: 24]
.   .   .   Child: 0  Op: == of type bool [line: 24]						   |	.   .   .   Child: 0  Op: = of type bool [line: 24]
.   .   .   .   Child: 0  Const 222 of type int [line: 24]						.   .   .   .   Child: 0  Const 222 of type int [line: 24]
.   .   .   .   Child: 1  Const 111 of type int [line: 24]						.   .   .   .   Child: 1  Const 111 of type int [line: 24]
.   .   Sibling: 18  Call: outputb of type void [line: 25]						.   .   Sibling: 18  Call: outputb of type void [line: 25]
.   .   .   Child: 0  Op: == of type bool [line: 25]						   |	.   .   .   Child: 0  Op: = of type bool [line: 25]
.   .   .   .   Child: 0  Const 111 of type int [line: 25]						.   .   .   .   Child: 0  Const 111 of type int [line: 25]
.   .   .   .   Child: 1  Const 111 of type int [line: 25]						.   .   .   .   Child: 1  Const 111 of type int [line: 25]
.   .   Sibling: 19  Call: outnl of type void [line: 26]						.   .   Sibling: 19  Call: outnl of type void [line: 26]
.   .   Sibling: 20  Call: outputb of type void [line: 28]						.   .   Sibling: 20  Call: outputb of type void [line: 28]
.   .   .   Child: 0  Op: != of type bool [line: 28]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 28]
.   .   .   .   Child: 0  Const 111 of type int [line: 28]						.   .   .   .   Child: 0  Const 111 of type int [line: 28]
.   .   .   .   Child: 1  Const 222 of type int [line: 28]						.   .   .   .   Child: 1  Const 222 of type int [line: 28]
.   .   Sibling: 21  Call: outputb of type void [line: 29]						.   .   Sibling: 21  Call: outputb of type void [line: 29]
.   .   .   Child: 0  Op: != of type bool [line: 29]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 29]
.   .   .   .   Child: 0  Const 222 of type int [line: 29]						.   .   .   .   Child: 0  Const 222 of type int [line: 29]
.   .   .   .   Child: 1  Const 111 of type int [line: 29]						.   .   .   .   Child: 1  Const 111 of type int [line: 29]
.   .   Sibling: 22  Call: outputb of type void [line: 30]						.   .   Sibling: 22  Call: outputb of type void [line: 30]
.   .   .   Child: 0  Op: != of type bool [line: 30]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 30]
.   .   .   .   Child: 0  Const 111 of type int [line: 30]						.   .   .   .   Child: 0  Const 111 of type int [line: 30]
.   .   .   .   Child: 1  Const 111 of type int [line: 30]						.   .   .   .   Child: 1  Const 111 of type int [line: 30]
.   .   Sibling: 23  Call: outnl of type void [line: 31]						.   .   Sibling: 23  Call: outnl of type void [line: 31]
.   .   Sibling: 24  Call: outputb of type void [line: 33]						.   .   Sibling: 24  Call: outputb of type void [line: 33]
.   .   .   Child: 0  Op: != of type bool [line: 33]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 33]
.   .   .   .   Child: 0  Const 111 of type int [line: 33]						.   .   .   .   Child: 0  Const 111 of type int [line: 33]
.   .   .   .   Child: 1  Const 222 of type int [line: 33]						.   .   .   .   Child: 1  Const 222 of type int [line: 33]
.   .   Sibling: 25  Call: outputb of type void [line: 34]						.   .   Sibling: 25  Call: outputb of type void [line: 34]
.   .   .   Child: 0  Op: != of type bool [line: 34]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 34]
.   .   .   .   Child: 0  Const 222 of type int [line: 34]						.   .   .   .   Child: 0  Const 222 of type int [line: 34]
.   .   .   .   Child: 1  Const 111 of type int [line: 34]						.   .   .   .   Child: 1  Const 111 of type int [line: 34]
.   .   Sibling: 26  Call: outputb of type void [line: 35]						.   .   Sibling: 26  Call: outputb of type void [line: 35]
.   .   .   Child: 0  Op: != of type bool [line: 35]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 35]
.   .   .   .   Child: 0  Const 111 of type int [line: 35]						.   .   .   .   Child: 0  Const 111 of type int [line: 35]
.   .   .   .   Child: 1  Const 111 of type int [line: 35]						.   .   .   .   Child: 1  Const 111 of type int [line: 35]
.   .   Sibling: 27  Call: outnl of type void [line: 36]						.   .   Sibling: 27  Call: outnl of type void [line: 36]
.   .   Sibling: 28  Call: outputb of type void [line: 38]						.   .   Sibling: 28  Call: outputb of type void [line: 38]
.   .   .   Child: 0  Op: and of type bool [line: 38]							.   .   .   Child: 0  Op: and of type bool [line: 38]
.   .   .   .   Child: 0  Const false of type bool [line: 38]						.   .   .   .   Child: 0  Const false of type bool [line: 38]
.   .   .   .   Child: 1  Const false of type bool [line: 38]						.   .   .   .   Child: 1  Const false of type bool [line: 38]
.   .   Sibling: 29  Call: outputb of type void [line: 39]						.   .   Sibling: 29  Call: outputb of type void [line: 39]
.   .   .   Child: 0  Op: and of type bool [line: 39]							.   .   .   Child: 0  Op: and of type bool [line: 39]
.   .   .   .   Child: 0  Const false of type bool [line: 39]						.   .   .   .   Child: 0  Const false of type bool [line: 39]
.   .   .   .   Child: 1  Const true of type bool [line: 39]						.   .   .   .   Child: 1  Const true of type bool [line: 39]
.   .   Sibling: 30  Call: outputb of type void [line: 40]						.   .   Sibling: 30  Call: outputb of type void [line: 40]
.   .   .   Child: 0  Op: and of type bool [line: 40]							.   .   .   Child: 0  Op: and of type bool [line: 40]
.   .   .   .   Child: 0  Const true of type bool [line: 40]						.   .   .   .   Child: 0  Const true of type bool [line: 40]
.   .   .   .   Child: 1  Const false of type bool [line: 40]						.   .   .   .   Child: 1  Const false of type bool [line: 40]
.   .   Sibling: 31  Call: outputb of type void [line: 41]						.   .   Sibling: 31  Call: outputb of type void [line: 41]
.   .   .   Child: 0  Op: and of type bool [line: 41]							.   .   .   Child: 0  Op: and of type bool [line: 41]
.   .   .   .   Child: 0  Const true of type bool [line: 41]						.   .   .   .   Child: 0  Const true of type bool [line: 41]
.   .   .   .   Child: 1  Const true of type bool [line: 41]						.   .   .   .   Child: 1  Const true of type bool [line: 41]
.   .   Sibling: 32  Call: outnl of type void [line: 42]						.   .   Sibling: 32  Call: outnl of type void [line: 42]
.   .   Sibling: 33  Call: outputb of type void [line: 44]						.   .   Sibling: 33  Call: outputb of type void [line: 44]
.   .   .   Child: 0  Op: or of type bool [line: 44]							.   .   .   Child: 0  Op: or of type bool [line: 44]
.   .   .   .   Child: 0  Const false of type bool [line: 44]						.   .   .   .   Child: 0  Const false of type bool [line: 44]
.   .   .   .   Child: 1  Const false of type bool [line: 44]						.   .   .   .   Child: 1  Const false of type bool [line: 44]
.   .   Sibling: 34  Call: outputb of type void [line: 45]						.   .   Sibling: 34  Call: outputb of type void [line: 45]
.   .   .   Child: 0  Op: or of type bool [line: 45]							.   .   .   Child: 0  Op: or of type bool [line: 45]
.   .   .   .   Child: 0  Const false of type bool [line: 45]						.   .   .   .   Child: 0  Const false of type bool [line: 45]
.   .   .   .   Child: 1  Const true of type bool [line: 45]						.   .   .   .   Child: 1  Const true of type bool [line: 45]
.   .   Sibling: 35  Call: outputb of type void [line: 46]						.   .   Sibling: 35  Call: outputb of type void [line: 46]
.   .   .   Child: 0  Op: or of type bool [line: 46]							.   .   .   Child: 0  Op: or of type bool [line: 46]
.   .   .   .   Child: 0  Const true of type bool [line: 46]						.   .   .   .   Child: 0  Const true of type bool [line: 46]
.   .   .   .   Child: 1  Const false of type bool [line: 46]						.   .   .   .   Child: 1  Const false of type bool [line: 46]
.   .   Sibling: 36  Call: outputb of type void [line: 47]						.   .   Sibling: 36  Call: outputb of type void [line: 47]
.   .   .   Child: 0  Op: or of type bool [line: 47]							.   .   .   Child: 0  Op: or of type bool [line: 47]
.   .   .   .   Child: 0  Const true of type bool [line: 47]						.   .   .   .   Child: 0  Const true of type bool [line: 47]
.   .   .   .   Child: 1  Const true of type bool [line: 47]						.   .   .   .   Child: 1  Const true of type bool [line: 47]
.   .   Sibling: 37  Call: outnl of type void [line: 48]						.   .   Sibling: 37  Call: outnl of type void [line: 48]
.   .   Sibling: 38  Call: outputb of type void [line: 50]						.   .   Sibling: 38  Call: outputb of type void [line: 50]
.   .   .   Child: 0  Op: not of type bool [line: 50]							.   .   .   Child: 0  Op: not of type bool [line: 50]
.   .   .   .   Child: 0  Const false of type bool [line: 50]						.   .   .   .   Child: 0  Const false of type bool [line: 50]
.   .   Sibling: 39  Call: outputb of type void [line: 51]						.   .   Sibling: 39  Call: outputb of type void [line: 51]
.   .   .   Child: 0  Op: not of type bool [line: 51]							.   .   .   Child: 0  Op: not of type bool [line: 51]
.   .   .   .   Child: 0  Const true of type bool [line: 51]						.   .   .   .   Child: 0  Const true of type bool [line: 51]
.   .   Sibling: 40  Call: outnl of type void [line: 52]						.   .   Sibling: 40  Call: outnl of type void [line: 52]
.   .   Sibling: 41  Call: output of type void [line: 54]						.   .   Sibling: 41  Call: output of type void [line: 54]
.   .   .   Child: 0  Op: + of type int [line: 54]							.   .   .   Child: 0  Op: + of type int [line: 54]
.   .   .   .   Child: 0  Const 333 of type int [line: 54]						.   .   .   .   Child: 0  Const 333 of type int [line: 54]
.   .   .   .   Child: 1  Const 444 of type int [line: 54]						.   .   .   .   Child: 1  Const 444 of type int [line: 54]
.   .   Sibling: 42  Call: output of type void [line: 55]						.   .   Sibling: 42  Call: output of type void [line: 55]
.   .   .   Child: 0  Op: - of type int [line: 55]							.   .   .   Child: 0  Op: - of type int [line: 55]
.   .   .   .   Child: 0  Const 333 of type int [line: 55]						.   .   .   .   Child: 0  Const 333 of type int [line: 55]
.   .   .   .   Child: 1  Const 444 of type int [line: 55]						.   .   .   .   Child: 1  Const 444 of type int [line: 55]
.   .   Sibling: 43  Call: output of type void [line: 56]						.   .   Sibling: 43  Call: output of type void [line: 56]
.   .   .   Child: 0  Op: * of type int [line: 56]							.   .   .   Child: 0  Op: * of type int [line: 56]
.   .   .   .   Child: 0  Const 333 of type int [line: 56]						.   .   .   .   Child: 0  Const 333 of type int [line: 56]
.   .   .   .   Child: 1  Const 444 of type int [line: 56]						.   .   .   .   Child: 1  Const 444 of type int [line: 56]
.   .   Sibling: 44  Call: output of type void [line: 57]						.   .   Sibling: 44  Call: output of type void [line: 57]
.   .   .   Child: 0  Op: / of type int [line: 57]							.   .   .   Child: 0  Op: / of type int [line: 57]
.   .   .   .   Child: 0  Const 333 of type int [line: 57]						.   .   .   .   Child: 0  Const 333 of type int [line: 57]
.   .   .   .   Child: 1  Const 444 of type int [line: 57]						.   .   .   .   Child: 1  Const 444 of type int [line: 57]
.   .   Sibling: 45  Call: output of type void [line: 58]						.   .   Sibling: 45  Call: output of type void [line: 58]
.   .   .   Child: 0  Op: % of type int [line: 58]							.   .   .   Child: 0  Op: % of type int [line: 58]
.   .   .   .   Child: 0  Const 3333 of type int [line: 58]						.   .   .   .   Child: 0  Const 3333 of type int [line: 58]
.   .   .   .   Child: 1  Const 444 of type int [line: 58]						.   .   .   .   Child: 1  Const 444 of type int [line: 58]
.   .   Sibling: 46  Call: output of type void [line: 59]						.   .   Sibling: 46  Call: output of type void [line: 59]
.   .   .   Child: 0  Op: chsign of type int [line: 59]							.   .   .   Child: 0  Op: chsign of type int [line: 59]
.   .   .   .   Child: 0  Const 444 of type int [line: 59]						.   .   .   .   Child: 0  Const 444 of type int [line: 59]
.   .   Sibling: 47  Return [line: 61]									.   .   Sibling: 47  Return [line: 61]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
op1.out ztmp23114.txt differ: byte 1, line 1
op1 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/op1.tm
Number of errors: 0										   |	T F T
------------------------------------								   |	T F F
Loading file: op1.tm										   |	F T F
												   >	F T T
												   >	F F T
												   >	T T F
												   >	T T F
												   >	F F F T
												   >	F T T T
												   >	T F
												   >	777 -111 147852 0 225 -444
Bye.													Bye.
====================================
FILE: ops.c-
-rw-------. 1 corg7983 domain_users  2931 Nov 17 15:35 ops.c-
-rw-------. 1 corg7983 domain_users  2944 Nov 17 15:35 ops.c-.f21
-rw-------. 1 corg7983 domain_users  2931 Nov 17 15:35 ops.c-.f22
-rw-------. 1 corg7983 domain_users   185 Nov 17 15:35 ops.expected
-rw-------. 1 corg7983 domain_users 22244 Nov 22 12:27 ops.mem
-rw-------. 1 corg7983 domain_users  2885 Nov 17 15:35 ops.mem.diffs
-rw-------. 1 corg7983 domain_users 23098 Nov 17 15:35 ops.mem.f21
-rw-------. 1 corg7983 domain_users   105 Nov 22 12:27 ops.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 ops.tm
-rw-------. 1 corg7983 domain_users   618 Nov 17 15:35 ops.tm.diffs
-rw-------. 1 corg7983 domain_users 52229 Nov 17 15:35 ops.tm.f21
TM CODE COMPARISON
ops (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  ops.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 42:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 43:     LD  4,-6(1)	Pop index 
												   >	 44:    LDA  5,-1(0)	Load address of base of array y
												   >	 45:    SUB  5,5,4	Compute offset of value 
												   >	 46:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	 47:    LDC  3,5(6)	Load integer constant 
												   >	 48:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 49:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 50:     LD  4,-6(1)	Pop index 
												   >	 51:    LDA  5,-1(0)	Load address of base of array y
												   >	 52:    SUB  5,5,4	Compute offset of value 
												   >	 53:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	 54:    LDC  3,8(6)	Load integer constant 
												   >	 55:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 56:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 57:     LD  4,-6(1)	Pop index 
												   >	 58:    LDA  5,-1(0)	Load address of base of array y
												   >	 59:    SUB  5,5,4	Compute offset of value 
												   >	 60:     ST  3,0(5)	Store variable y
												   >	* EXPRESSION
												   >	 61:    LDC  3,50(6)	Load integer constant 
												   >	 62:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 63:    LDC  3,1(6)	Load integer constant 
												   >	 64:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 65:    LDC  3,8(6)	Load integer constant 
												   >	 66:     ST  3,-4(1)	Store variable c
												   >	* EXPRESSION
												   >	 67:    LDC  3,0(6)	Load Boolean constant 
												   >	 68:     ST  3,-11(0)	Store variable x
												   >	* EXPRESSION
												   >	 69:    LDC  3,1(6)	Load Boolean constant 
												   >	 70:     ST  3,-5(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 71:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 72:     LD  3,-2(1)	Load variable a
												   >	 73:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 74:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 75:     LD  4,-8(1)	Pop left into ac1 
												   >	 76:    TLE  3,4,3	Op <= 
												   >	 77:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	 78:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-64(7)	CALL outputb
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 82:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 83:     LD  3,-3(1)	Load variable b
												   >	 84:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 85:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 86:     LD  4,-8(1)	Pop left into ac1 
												   >	 87:    TLE  3,4,3	Op <= 
												   >	 88:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	 89:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-75(7)	CALL outputb
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 93:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 94:    LDC  3,50(6)	Load integer constant 
												   >	 95:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 96:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 97:     LD  4,-8(1)	Pop left into ac1 
												   >	 98:    TLE  3,4,3	Op <= 
												   >	 99:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	100:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-86(7)	CALL outputb
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	104:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	105:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	106:    LDA  3,1(7)	Return address in ac 
												   >	107:    JMP  7,-74(7)	CALL outnl
												   >	108:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	109:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	110:    LDC  3,50(6)	Load integer constant 
												   >	111:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	112:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	113:     LD  4,-8(1)	Pop left into ac1 
												   >	114:    TLT  3,4,3	Op < 
												   >	115:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	116:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	117:    LDA  3,1(7)	Return address in ac 
												   >	118:    JMP  7,-102(7)	CALL outputb
												   >	119:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	120:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	121:     LD  3,-3(1)	Load variable b
												   >	122:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	123:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -8
												   >	124:     LD  4,-8(1)	Pop left into ac1 
												   >	125:    TLT  3,4,3	Op < 
												   >	126:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	127:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	128:    LDA  3,1(7)	Return address in ac 
												   >	129:    JMP  7,-113(7)	CALL outputb
												   >	130:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	131:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	132:     LD  3,-2(1)	Load variable a
												   >	133:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	134:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -8
												   >	135:     LD  4,-8(1)	Pop left into ac1 
												   >	136:    TLT  3,4,3	Op < 
												   >	137:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	138:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	139:    LDA  3,1(7)	Return address in ac 
												   >	140:    JMP  7,-124(7)	CALL outputb
												   >	141:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	142:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	143:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	144:    LDA  3,1(7)	Return address in ac 
												   >	145:    JMP  7,-112(7)	CALL outnl
												   >	146:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	147:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	148:    LDC  3,50(6)	Load integer constant 
												   >	149:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	150:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	151:     LD  4,-8(1)	Pop left into ac1 
												   >	152:    TGT  3,4,3	Op > 
												   >	153:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	154:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-140(7)	CALL outputb
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	158:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	159:    LDC  3,1(6)	Load integer constant 
												   >	160:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	161:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	162:     LD  4,-8(1)	Pop left into ac1 
												   >	163:    TGT  3,4,3	Op > 
												   >	164:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	165:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-151(7)	CALL outputb
												   >	168:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	169:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	170:    LDC  3,50(6)	Load integer constant 
												   >	171:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	172:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	173:     LD  4,-8(1)	Pop left into ac1 
												   >	174:    TGT  3,4,3	Op > 
												   >	175:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	176:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	177:    LDA  3,1(7)	Return address in ac 
												   >	178:    JMP  7,-162(7)	CALL outputb
												   >	179:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	180:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	181:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	182:    LDA  3,1(7)	Return address in ac 
												   >	183:    JMP  7,-150(7)	CALL outnl
												   >	184:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	185:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	186:    LDC  3,50(6)	Load integer constant 
												   >	187:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	188:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	189:     LD  4,-8(1)	Pop left into ac1 
												   >	190:    TGE  3,4,3	Op >= 
												   >	191:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	192:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	193:    LDA  3,1(7)	Return address in ac 
												   >	194:    JMP  7,-178(7)	CALL outputb
												   >	195:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	196:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	197:    LDC  3,1(6)	Load integer constant 
												   >	198:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	199:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	200:     LD  4,-8(1)	Pop left into ac1 
												   >	201:    TGE  3,4,3	Op >= 
												   >	202:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	203:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	204:    LDA  3,1(7)	Return address in ac 
												   >	205:    JMP  7,-189(7)	CALL outputb
												   >	206:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	207:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	208:    LDC  3,50(6)	Load integer constant 
												   >	209:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	210:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	211:     LD  4,-8(1)	Pop left into ac1 
												   >	212:    TGE  3,4,3	Op >= 
												   >	213:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	214:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	215:    LDA  3,1(7)	Return address in ac 
												   >	216:    JMP  7,-200(7)	CALL outputb
												   >	217:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	218:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	219:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	220:    LDA  3,1(7)	Return address in ac 
												   >	221:    JMP  7,-188(7)	CALL outnl
												   >	222:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	223:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	224:    LDA  3,-1(0)	Load address of base of array y
												   >	225:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	226:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	227:     LD  4,-8(1)	Pop left into ac1 
												   >	228:    SUB  3,4,3	compute location from index 
												   >	229:     LD  3,0(3)	Load array element 
												   >	230:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	231:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	232:     LD  4,-8(1)	Pop left into ac1 
												   >	233:    TEQ  3,4,3	Op = 
												   >	234:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	235:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	236:    LDA  3,1(7)	Return address in ac 
												   >	237:    JMP  7,-221(7)	CALL outputb
												   >	238:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	239:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	240:     LD  3,-2(1)	Load variable a
												   >	241:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	242:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	243:     LD  4,-8(1)	Pop left into ac1 
												   >	244:    TEQ  3,4,3	Op = 
												   >	245:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	246:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	247:    LDA  3,1(7)	Return address in ac 
												   >	248:    JMP  7,-232(7)	CALL outputb
												   >	249:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	250:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	251:     LD  3,-3(1)	Load variable b
												   >	252:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	253:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	254:     LD  4,-8(1)	Pop left into ac1 
												   >	255:    TEQ  3,4,3	Op = 
												   >	256:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	257:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	258:    LDA  3,1(7)	Return address in ac 
												   >	259:    JMP  7,-243(7)	CALL outputb
												   >	260:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	261:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	262:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	263:    LDA  3,1(7)	Return address in ac 
												   >	264:    JMP  7,-231(7)	CALL outnl
												   >	265:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	266:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	267:    LDA  3,-1(0)	Load address of base of array y
												   >	268:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	269:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	270:     LD  4,-8(1)	Pop left into ac1 
												   >	271:    SUB  3,4,3	compute location from index 
												   >	272:     LD  3,0(3)	Load array element 
												   >	273:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	274:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -8
												   >	275:     LD  4,-8(1)	Pop left into ac1 
												   >	276:    TNE  3,4,3	Op >< 
												   >	277:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	278:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	279:    LDA  3,1(7)	Return address in ac 
												   >	280:    JMP  7,-264(7)	CALL outputb
												   >	281:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	282:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	283:    LDA  3,-1(0)	Load address of base of array y
												   >	284:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	285:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	286:     LD  4,-8(1)	Pop left into ac1 
												   >	287:    SUB  3,4,3	compute location from index 
												   >	288:     LD  3,0(3)	Load array element 
												   >	289:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	290:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	291:     LD  4,-8(1)	Pop left into ac1 
												   >	292:    TNE  3,4,3	Op >< 
												   >	293:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	294:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	295:    LDA  3,1(7)	Return address in ac 
												   >	296:    JMP  7,-280(7)	CALL outputb
												   >	297:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	298:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	299:     LD  3,-2(1)	Load variable a
												   >	300:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	301:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	302:     LD  4,-8(1)	Pop left into ac1 
												   >	303:    TNE  3,4,3	Op >< 
												   >	304:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	305:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	306:    LDA  3,1(7)	Return address in ac 
												   >	307:    JMP  7,-291(7)	CALL outputb
												   >	308:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	309:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	310:     LD  3,-3(1)	Load variable b
												   >	311:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	312:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	313:     LD  4,-8(1)	Pop left into ac1 
												   >	314:    TNE  3,4,3	Op >< 
												   >	315:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	316:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	317:    LDA  3,1(7)	Return address in ac 
												   >	318:    JMP  7,-302(7)	CALL outputb
												   >	319:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	320:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	321:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	322:    LDA  3,1(7)	Return address in ac 
												   >	323:    JMP  7,-290(7)	CALL outnl
												   >	324:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	325:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	326:    LDC  3,1(6)	Load Boolean constant 
												   >	327:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	328:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	329:     LD  4,-8(1)	Pop left into ac1 
												   >	330:    AND  3,4,3	Op AND 
												   >	331:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	332:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	333:    LDA  3,1(7)	Return address in ac 
												   >	334:    JMP  7,-318(7)	CALL outputb
												   >	335:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	336:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	337:    LDC  3,1(6)	Load Boolean constant 
												   >	338:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	339:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	340:     LD  4,-8(1)	Pop left into ac1 
												   >	341:    AND  3,4,3	Op AND 
												   >	342:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	343:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	344:    LDA  3,1(7)	Return address in ac 
												   >	345:    JMP  7,-329(7)	CALL outputb
												   >	346:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	347:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	348:    LDC  3,0(6)	Load Boolean constant 
												   >	349:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	350:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	351:     LD  4,-8(1)	Pop left into ac1 
												   >	352:    AND  3,4,3	Op AND 
												   >	353:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	354:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	355:    LDA  3,1(7)	Return address in ac 
												   >	356:    JMP  7,-340(7)	CALL outputb
												   >	357:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	358:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	359:    LDC  3,0(6)	Load Boolean constant 
												   >	360:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	361:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	362:     LD  4,-8(1)	Pop left into ac1 
												   >	363:    AND  3,4,3	Op AND 
												   >	364:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	365:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	366:    LDA  3,1(7)	Return address in ac 
												   >	367:    JMP  7,-351(7)	CALL outputb
												   >	368:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	369:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	370:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	371:    LDA  3,1(7)	Return address in ac 
												   >	372:    JMP  7,-339(7)	CALL outnl
												   >	373:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	374:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	375:    LDC  3,1(6)	Load Boolean constant 
												   >	376:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	377:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	378:     LD  4,-8(1)	Pop left into ac1 
												   >	379:     OR  3,4,3	Op OR 
												   >	380:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	381:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	382:    LDA  3,1(7)	Return address in ac 
												   >	383:    JMP  7,-367(7)	CALL outputb
												   >	384:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	385:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	386:     LD  3,-5(1)	Load variable z
												   >	387:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	388:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	389:     LD  4,-8(1)	Pop left into ac1 
												   >	390:     OR  3,4,3	Op OR 
												   >	391:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	392:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	393:    LDA  3,1(7)	Return address in ac 
												   >	394:    JMP  7,-378(7)	CALL outputb
												   >	395:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	396:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	397:    LDC  3,0(6)	Load Boolean constant 
												   >	398:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	399:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	400:     LD  4,-8(1)	Pop left into ac1 
												   >	401:     OR  3,4,3	Op OR 
												   >	402:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	403:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	404:    LDA  3,1(7)	Return address in ac 
												   >	405:    JMP  7,-389(7)	CALL outputb
												   >	406:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	407:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	408:    LDC  3,0(6)	Load Boolean constant 
												   >	409:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	410:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	411:     LD  4,-8(1)	Pop left into ac1 
												   >	412:     OR  3,4,3	Op OR 
												   >	413:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	414:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	415:    LDA  3,1(7)	Return address in ac 
												   >	416:    JMP  7,-400(7)	CALL outputb
												   >	417:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	418:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	419:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	420:    LDA  3,1(7)	Return address in ac 
												   >	421:    JMP  7,-388(7)	CALL outnl
												   >	422:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	423:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	424:    LDC  3,1(6)	Load Boolean constant 
												   >	425:    LDC  4,1(6)	Load 1 
												   >	426:    XOR  3,3,4	Op XOR to get logical not 
												   >	427:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	428:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	429:    LDA  3,1(7)	Return address in ac 
												   >	430:    JMP  7,-414(7)	CALL outputb
												   >	431:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	432:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	433:     LD  3,-11(0)	Load variable x
												   >	434:    LDC  4,1(6)	Load 1 
												   >	435:    XOR  3,3,4	Op XOR to get logical not 
												   >	436:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	437:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	438:    LDA  3,1(7)	Return address in ac 
												   >	439:    JMP  7,-423(7)	CALL outputb
												   >	440:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	441:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	442:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	443:    LDA  3,1(7)	Return address in ac 
												   >	444:    JMP  7,-411(7)	CALL outnl
												   >	445:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	446:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	447:    LDC  3,5(6)	Load integer constant 
												   >	448:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	449:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	450:     LD  4,-8(1)	Pop left into ac1 
												   >	451:    ADD  3,4,3	Op + 
												   >	452:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	453:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	454:    LDA  3,1(7)	Return address in ac 
												   >	455:    JMP  7,-450(7)	CALL output
												   >	456:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	457:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	458:    LDA  3,-1(0)	Load address of base of array y
												   >	459:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	460:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -8
												   >	461:     LD  4,-8(1)	Pop left into ac1 
												   >	462:    SUB  3,4,3	compute location from index 
												   >	463:     LD  3,0(3)	Load array element 
												   >	464:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	465:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	466:     LD  4,-8(1)	Pop left into ac1 
												   >	467:    ADD  3,4,3	Op + 
												   >	468:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	469:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	470:    LDA  3,1(7)	Return address in ac 
												   >	471:    JMP  7,-466(7)	CALL output
												   >	472:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	473:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	474:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	475:    LDA  3,1(7)	Return address in ac 
												   >	476:    JMP  7,-443(7)	CALL outnl
												   >	477:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	478:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	479:    LDC  3,5(6)	Load integer constant 
												   >	480:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	481:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	482:     LD  4,-8(1)	Pop left into ac1 
												   >	483:    SUB  3,4,3	Op - 
												   >	484:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	485:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	486:    LDA  3,1(7)	Return address in ac 
												   >	487:    JMP  7,-482(7)	CALL output
												   >	488:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	489:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	490:    LDC  3,30(6)	Load integer constant 
												   >	491:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	492:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	493:     LD  4,-8(1)	Pop left into ac1 
												   >	494:    SUB  3,4,3	Op - 
												   >	495:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	496:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	497:     LD  4,-8(1)	Pop left into ac1 
												   >	498:    SUB  3,4,3	Op - 
												   >	499:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	500:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	501:    LDA  3,1(7)	Return address in ac 
												   >	502:    JMP  7,-497(7)	CALL output
												   >	503:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	504:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	505:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	506:    LDA  3,1(7)	Return address in ac 
												   >	507:    JMP  7,-474(7)	CALL outnl
												   >	508:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	509:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	510:     LD  3,-2(1)	Load variable a
												   >	511:    NEG  3,3,3	Op unary - 
												   >	512:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	513:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	514:    LDA  3,1(7)	Return address in ac 
												   >	515:    JMP  7,-510(7)	CALL output
												   >	516:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	517:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	518:    LDC  3,0(6)	Load integer constant 
												   >	519:    NEG  3,3,3	Op unary - 
												   >	520:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	521:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	522:    LDA  3,1(7)	Return address in ac 
												   >	523:    JMP  7,-518(7)	CALL output
												   >	524:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	525:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	526:    LDC  3,1(6)	Load integer constant 
												   >	527:    NEG  3,3,3	Op unary - 
												   >	528:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	529:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	530:    LDA  3,1(7)	Return address in ac 
												   >	531:    JMP  7,-526(7)	CALL output
												   >	532:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	533:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	534:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	535:    LDA  3,1(7)	Return address in ac 
												   >	536:    JMP  7,-503(7)	CALL outnl
												   >	537:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	538:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	539:    LDC  3,2(6)	Load integer constant 
												   >	540:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	541:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	542:     LD  4,-8(1)	Pop left into ac1 
												   >	543:    MUL  3,4,3	Op * 
												   >	544:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	545:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	546:     LD  4,-8(1)	Pop left into ac1 
												   >	547:    MUL  3,4,3	Op * 
												   >	548:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	549:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	550:     LD  4,-8(1)	Pop left into ac1 
												   >	551:    MUL  3,4,3	Op * 
												   >	552:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	553:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	554:     LD  4,-8(1)	Pop left into ac1 
												   >	555:    MUL  3,4,3	Op * 
												   >	556:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	557:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	558:    LDA  3,1(7)	Return address in ac 
												   >	559:    JMP  7,-554(7)	CALL output
												   >	560:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	561:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	562:    LDC  3,50(6)	Load integer constant 
												   >	563:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	564:    LDA  3,-1(0)	Load address of base of array y
												   >	565:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	566:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	567:     LD  4,-9(1)	Pop left into ac1 
												   >	568:    SUB  3,4,3	compute location from index 
												   >	569:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -8
												   >	570:     LD  4,-8(1)	Pop left into ac1 
												   >	571:    MUL  3,4,3	Op * 
												   >	572:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	573:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	574:    LDA  3,1(7)	Return address in ac 
												   >	575:    JMP  7,-570(7)	CALL output
												   >	576:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	577:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	578:    LDA  3,-1(0)	Load address of base of array y
												   >	579:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	580:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	581:     LD  4,-8(1)	Pop left into ac1 
												   >	582:    SUB  3,4,3	compute location from index 
												   >	583:     LD  3,0(3)	Load array element 
												   >	584:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	585:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	586:     LD  4,-8(1)	Pop left into ac1 
												   >	587:    MUL  3,4,3	Op * 
												   >	588:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	589:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	590:    LDA  3,1(7)	Return address in ac 
												   >	591:    JMP  7,-586(7)	CALL output
												   >	592:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	593:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	594:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	595:    LDA  3,1(7)	Return address in ac 
												   >	596:    JMP  7,-563(7)	CALL outnl
												   >	597:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	598:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	599:    LDC  3,50(6)	Load integer constant 
												   >	600:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	601:    LDA  3,-1(0)	Load address of base of array y
												   >	602:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	603:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	604:     LD  4,-9(1)	Pop left into ac1 
												   >	605:    SUB  3,4,3	compute location from index 
												   >	606:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -8
												   >	607:     LD  4,-8(1)	Pop left into ac1 
												   >	608:    DIV  3,4,3	Op / 
												   >	609:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	610:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	611:    LDA  3,1(7)	Return address in ac 
												   >	612:    JMP  7,-607(7)	CALL output
												   >	613:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	614:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	615:    LDA  3,-1(0)	Load address of base of array y
												   >	616:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	617:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	618:     LD  4,-8(1)	Pop left into ac1 
												   >	619:    SUB  3,4,3	compute location from index 
												   >	620:     LD  3,0(3)	Load array element 
												   >	621:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	622:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	623:     LD  4,-8(1)	Pop left into ac1 
												   >	624:    DIV  3,4,3	Op / 
												   >	625:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	626:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	627:    LDA  3,1(7)	Return address in ac 
												   >	628:    JMP  7,-623(7)	CALL output
												   >	629:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	630:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	631:    LDA  3,-1(0)	Load address of base of array y
												   >	632:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	633:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	634:     LD  4,-8(1)	Pop left into ac1 
												   >	635:    SUB  3,4,3	compute location from index 
												   >	636:     LD  3,0(3)	Load array element 
												   >	637:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	638:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	639:     LD  4,-8(1)	Pop left into ac1 
												   >	640:    DIV  3,4,3	Op / 
												   >	641:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	642:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	643:    LDA  3,1(7)	Return address in ac 
												   >	644:    JMP  7,-639(7)	CALL output
												   >	645:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	646:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	647:    LDC  3,210(6)	Load integer constant 
												   >	648:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	649:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	650:     LD  4,-8(1)	Pop left into ac1 
												   >	651:    DIV  3,4,3	Op / 
												   >	652:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	653:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	654:     LD  4,-8(1)	Pop left into ac1 
												   >	655:    DIV  3,4,3	Op / 
												   >	656:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	657:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	658:    LDA  3,1(7)	Return address in ac 
												   >	659:    JMP  7,-654(7)	CALL output
												   >	660:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	661:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	662:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	663:    LDA  3,1(7)	Return address in ac 
												   >	664:    JMP  7,-631(7)	CALL outnl
												   >	665:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	666:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	667:    LDC  3,211(6)	Load integer constant 
												   >	668:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	669:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	670:     LD  4,-8(1)	Pop left into ac1 
												   >	671:    MOD  3,4,3	Op % 
												   >	672:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	673:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	674:    LDA  3,1(7)	Return address in ac 
												   >	675:    JMP  7,-670(7)	CALL output
												   >	676:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	677:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	678:    LDC  3,211(6)	Load integer constant 
												   >	679:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	680:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	681:     LD  4,-8(1)	Pop left into ac1 
												   >	682:    MOD  3,4,3	Op % 
												   >	683:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	684:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	685:    LDA  3,1(7)	Return address in ac 
												   >	686:    JMP  7,-681(7)	CALL output
												   >	687:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	688:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	689:    LDC  3,211(6)	Load integer constant 
												   >	690:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	691:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	692:     LD  4,-8(1)	Pop left into ac1 
												   >	693:    MOD  3,4,3	Op % 
												   >	694:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	695:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	696:    LDA  3,1(7)	Return address in ac 
												   >	697:    JMP  7,-692(7)	CALL output
												   >	698:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	699:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	700:    LDC  3,211(6)	Load integer constant 
												   >	701:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	702:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	703:     LD  4,-8(1)	Pop left into ac1 
												   >	704:    MOD  3,4,3	Op % 
												   >	705:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	706:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	707:    LDA  3,1(7)	Return address in ac 
												   >	708:    JMP  7,-703(7)	CALL output
												   >	709:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	710:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	711:    LDC  3,211(6)	Load integer constant 
												   >	712:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	713:    LDC  3,100(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	714:     LD  4,-8(1)	Pop left into ac1 
												   >	715:    MOD  3,4,3	Op % 
												   >	716:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	717:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	718:     LD  4,-8(1)	Pop left into ac1 
												   >	719:    MOD  3,4,3	Op % 
												   >	720:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	721:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	722:    LDA  3,1(7)	Return address in ac 
												   >	723:    JMP  7,-718(7)	CALL output
												   >	724:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	725:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	726:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	727:    LDA  3,1(7)	Return address in ac 
												   >	728:    JMP  7,-695(7)	CALL outnl
												   >	729:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	730:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	731:    LDC  3,43(6)	Load integer constant 
												   >	732:     ST  3,-4(1)	Store variable c
												   >	733:     ST  3,-3(1)	Store variable b
												   >	734:     ST  3,-2(1)	Store variable a
												   >	735:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	736:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	737:    LDA  3,1(7)	Return address in ac 
												   >	738:    JMP  7,-733(7)	CALL output
												   >	739:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	740:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	741:     LD  3,-2(1)	Load variable a
												   >	742:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	743:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	744:    LDA  3,1(7)	Return address in ac 
												   >	745:    JMP  7,-740(7)	CALL output
												   >	746:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	747:    LDC  3,3(6)	Load integer constant 
												   >	748:     ST  3,-3(1)	Store variable b
												   >	749:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	750:    LDC  3,4(6)	Load integer constant 
												   >	751:     ST  3,-4(1)	Store variable c
												   >	* TOFF inc: -6
												   >	752:     LD  4,-6(1)	Pop left into ac1 
												   >	753:    MUL  3,4,3	Op * 
												   >	754:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL output
												   >	755:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	756:     LD  3,-2(1)	Load variable a
												   >	757:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	758:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	759:    LDA  3,1(7)	Return address in ac 
												   >	760:    JMP  7,-755(7)	CALL output
												   >	761:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	762:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	763:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	764:    LDA  3,1(7)	Return address in ac 
												   >	765:    JMP  7,-732(7)	CALL outnl
												   >	766:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	767:    LDC  3,44(6)	Load integer constant 
												   >	768:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	769:    LDC  3,2(6)	Load integer constant 
												   >	770:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	* CALL output
												   >	771:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	772:     LD  3,-3(1)	Load variable b
												   >	773:     LD  4,-2(1)	load lhs variable a
												   >	774:    ADD  3,4,3	op += 
												   >	775:     ST  3,-2(1)	Store variable a
												   >	776:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	777:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	778:    LDA  3,1(7)	Return address in ac 
												   >	779:    JMP  7,-774(7)	CALL output
												   >	780:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	781:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	782:     LD  3,-3(1)	Load variable b
												   >	783:     LD  4,-2(1)	load lhs variable a
												   >	784:    SUB  3,4,3	op -= 
												   >	785:     ST  3,-2(1)	Store variable a
												   >	786:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	787:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	788:    LDA  3,1(7)	Return address in ac 
												   >	789:    JMP  7,-784(7)	CALL output
												   >	790:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	791:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	792:     LD  3,-2(1)	Load variable a
												   >	793:     LD  4,-2(1)	load lhs variable a
												   >	794:    SUB  3,4,3	op -= 
												   >	795:     ST  3,-2(1)	Store variable a
												   >	796:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	797:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	798:    LDA  3,1(7)	Return address in ac 
												   >	799:    JMP  7,-794(7)	CALL output
												   >	800:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	801:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	802:    LDC  3,10(6)	Load integer constant 
												   >	803:     LD  4,-3(1)	load lhs variable b
												   >	804:    ADD  3,4,3	op += 
												   >	805:     ST  3,-3(1)	Store variable b
												   >	806:     LD  4,-2(1)	load lhs variable a
												   >	807:    ADD  3,4,3	op += 
												   >	808:     ST  3,-2(1)	Store variable a
												   >	809:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	810:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	811:    LDA  3,1(7)	Return address in ac 
												   >	812:    JMP  7,-807(7)	CALL output
												   >	813:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	814:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	815:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	816:    LDA  3,1(7)	Return address in ac 
												   >	817:    JMP  7,-784(7)	CALL outnl
												   >	818:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	819:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	820:    LDC  3,3(6)	Load integer constant 
												   >	821:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	822:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	823:     LD  4,-8(1)	Pop left into ac1 
												   >	824:    SUB  3,4,3	Op - 
												   >	825:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	826:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	827:     LD  4,-8(1)	Pop left into ac1 
												   >	828:    SUB  3,4,3	Op - 
												   >	829:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	830:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	831:    LDA  3,1(7)	Return address in ac 
												   >	832:    JMP  7,-827(7)	CALL output
												   >	833:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	834:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	835:    LDC  3,211(6)	Load integer constant 
												   >	836:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	837:    LDC  3,17(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	838:     LD  4,-8(1)	Pop left into ac1 
												   >	839:    DIV  3,4,3	Op / 
												   >	840:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	841:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	842:     LD  4,-8(1)	Pop left into ac1 
												   >	843:    DIV  3,4,3	Op / 
												   >	844:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	845:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	846:    LDA  3,1(7)	Return address in ac 
												   >	847:    JMP  7,-842(7)	CALL output
												   >	848:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	849:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	850:    LDC  3,211(6)	Load integer constant 
												   >	851:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	852:    LDC  3,17(6)	Load integer constant 
												   >	853:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	854:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	855:     LD  4,-9(1)	Pop left into ac1 
												   >	856:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -8
												   >	857:     LD  4,-8(1)	Pop left into ac1 
												   >	858:    DIV  3,4,3	Op / 
												   >	859:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	860:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	861:    LDA  3,1(7)	Return address in ac 
												   >	862:    JMP  7,-857(7)	CALL output
												   >	863:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	864:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	865:    LDC  3,1(6)	Load Boolean constant 
												   >	866:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	867:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	868:     LD  4,-8(1)	Pop left into ac1 
												   >	869:     OR  3,4,3	Op OR 
												   >	870:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	871:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	872:     LD  4,-8(1)	Pop left into ac1 
												   >	873:    AND  3,4,3	Op AND 
												   >	874:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	875:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	876:    LDA  3,1(7)	Return address in ac 
												   >	877:    JMP  7,-861(7)	CALL outputb
												   >	878:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	879:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	880:    LDC  3,1(6)	Load Boolean constant 
												   >	881:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	882:    LDC  3,0(6)	Load Boolean constant 
												   >	883:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	884:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -9
												   >	885:     LD  4,-9(1)	Pop left into ac1 
												   >	886:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	887:     LD  4,-8(1)	Pop left into ac1 
												   >	888:     OR  3,4,3	Op OR 
												   >	889:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	890:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	891:    LDA  3,1(7)	Return address in ac 
												   >	892:    JMP  7,-876(7)	CALL outputb
												   >	893:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	894:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	895:    LDC  3,1(6)	Load Boolean constant 
												   >	896:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	897:    LDC  3,0(6)	Load Boolean constant 
												   >	898:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	899:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -9
												   >	900:     LD  4,-9(1)	Pop left into ac1 
												   >	901:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	902:     LD  4,-8(1)	Pop left into ac1 
												   >	903:     OR  3,4,3	Op OR 
												   >	904:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	905:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	906:    LDA  3,1(7)	Return address in ac 
												   >	907:    JMP  7,-891(7)	CALL outputb
												   >	908:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	909:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	910:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	911:    LDA  3,1(7)	Return address in ac 
												   >	912:    JMP  7,-879(7)	CALL outnl
												   >	913:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	914:    LDC  2,0(6)	Set return value to 0 
												   >	915:     LD  3,-1(1)	Load return address 
												   >	916:     LD  1,0(1)	Adjust fp 
												   >	917:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,917(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	918:    LDA  1,-12(0)	set first frame at end of globals 
												   >	919:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	920:    LDC  3,10(6)	load size of array y
												   >	921:     ST  3,0(0)	save size of array y
												   >	* END INIT GLOBALS AND STATICS
												   >	922:    LDA  3,1(7)	Return address in ac 
												   >	923:    JMP  7,-885(7)	Jump to main 
												   >	924:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
ops.mem ops.mem.f21 differ: byte 1, line 1
ops (MEM DIFF)
Var: y of array of type int [mem: Global loc: -1 size: 11] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: x of type bool [mem: Global loc: -11 size: 1] [line: 4]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: y of array of type int [mem: Global loc: -1 size: 11] [line: 3]
												   >	Sibling: 8  Var: x of type bool [mem: Global loc: -11 size: 1] [line: 4]
												   >	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 9]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 10]				.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   Sibling: 3  Var: z of type bool [mem: Local loc: -5 size: 1] [line: 11]				.   .   Sibling: 3  Var: z of type bool [mem: Local loc: -5 size: 1] [line: 11]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 13]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 13]
.   .   .   .   Child: 1  Const 0 of type int [line: 13]						.   .   .   .   Child: 1  Const 0 of type int [line: 13]
.   .   .   Child: 1  Const 50 of type int [line: 13]							.   .   .   Child: 1  Const 50 of type int [line: 13]
.   .   Sibling: 1  Assign: = of type int [line: 14]						   |	.   .   Sibling: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 14]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 14]
.   .   .   .   Child: 1  Const 5 of type int [line: 14]						.   .   .   .   Child: 1  Const 5 of type int [line: 14]
.   .   .   Child: 1  Const 1 of type int [line: 14]							.   .   .   Child: 1  Const 1 of type int [line: 14]
.   .   Sibling: 2  Assign: = of type int [line: 15]						   |	.   .   Sibling: 2  Assign: := of type int [line: 15]
.   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 15]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 15]
.   .   .   .   Child: 1  Const 8 of type int [line: 15]						.   .   .   .   Child: 1  Const 8 of type int [line: 15]
.   .   .   Child: 1  Const 2 of type int [line: 15]							.   .   .   Child: 1  Const 2 of type int [line: 15]
.   .   Sibling: 3  Assign: = of type int [line: 17]						   |	.   .   Sibling: 3  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 17]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 17]
.   .   .   Child: 1  Const 50 of type int [line: 17]							.   .   .   Child: 1  Const 50 of type int [line: 17]
.   .   Sibling: 4  Assign: = of type int [line: 18]						   |	.   .   Sibling: 4  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 18]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   Child: 1  Const 1 of type int [line: 18]							.   .   .   Child: 1  Const 1 of type int [line: 18]
.   .   Sibling: 5  Assign: = of type int [line: 19]						   |	.   .   Sibling: 5  Assign: := of type int [line: 19]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 19]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 19]
.   .   .   Child: 1  Const 8 of type int [line: 19]							.   .   .   Child: 1  Const 8 of type int [line: 19]
.   .   Sibling: 6  Assign: = of type bool [line: 21]						   |	.   .   Sibling: 6  Assign: := of type bool [line: 21]
.   .   .   Child: 0  Id: x of type bool [mem: Global loc: -11 size: 1] [line: 21]			.   .   .   Child: 0  Id: x of type bool [mem: Global loc: -11 size: 1] [line: 21]
.   .   .   Child: 1  Const false of type bool [line: 21]						.   .   .   Child: 1  Const false of type bool [line: 21]
.   .   Sibling: 7  Assign: = of type bool [line: 22]						   |	.   .   Sibling: 7  Assign: := of type bool [line: 22]
.   .   .   Child: 0  Id: z of type bool [mem: Local loc: -5 size: 1] [line: 22]			.   .   .   Child: 0  Id: z of type bool [mem: Local loc: -5 size: 1] [line: 22]
.   .   .   Child: 1  Const true of type bool [line: 22]						.   .   .   Child: 1  Const true of type bool [line: 22]
.   .   Sibling: 8  Call: outputb of type void [line: 24]						.   .   Sibling: 8  Call: outputb of type void [line: 24]
.   .   .   Child: 0  Op: <= of type bool [line: 24]							.   .   .   Child: 0  Op: <= of type bool [line: 24]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 24]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 24]
.   .   .   .   Child: 1  Const 1 of type int [line: 24]						.   .   .   .   Child: 1  Const 1 of type int [line: 24]
.   .   Sibling: 9  Call: outputb of type void [line: 25]						.   .   Sibling: 9  Call: outputb of type void [line: 25]
.   .   .   Child: 0  Op: <= of type bool [line: 25]							.   .   .   Child: 0  Op: <= of type bool [line: 25]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 25]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 25]
.   .   .   .   Child: 1  Const 50 of type int [line: 25]						.   .   .   .   Child: 1  Const 50 of type int [line: 25]
.   .   Sibling: 10  Call: outputb of type void [line: 26]						.   .   Sibling: 10  Call: outputb of type void [line: 26]
.   .   .   Child: 0  Op: <= of type bool [line: 26]							.   .   .   Child: 0  Op: <= of type bool [line: 26]
.   .   .   .   Child: 0  Const 50 of type int [line: 26]						.   .   .   .   Child: 0  Const 50 of type int [line: 26]
.   .   .   .   Child: 1  Const 50 of type int [line: 26]						.   .   .   .   Child: 1  Const 50 of type int [line: 26]
.   .   Sibling: 11  Call: outnl of type void [line: 27]						.   .   Sibling: 11  Call: outnl of type void [line: 27]
.   .   Sibling: 12  Call: outputb of type void [line: 29]						.   .   Sibling: 12  Call: outputb of type void [line: 29]
.   .   .   Child: 0  Op: < of type bool [line: 29]							.   .   .   Child: 0  Op: < of type bool [line: 29]
.   .   .   .   Child: 0  Const 50 of type int [line: 29]						.   .   .   .   Child: 0  Const 50 of type int [line: 29]
.   .   .   .   Child: 1  Const 1 of type int [line: 29]						.   .   .   .   Child: 1  Const 1 of type int [line: 29]
.   .   Sibling: 13  Call: outputb of type void [line: 30]						.   .   Sibling: 13  Call: outputb of type void [line: 30]
.   .   .   Child: 0  Op: < of type bool [line: 30]							.   .   .   Child: 0  Op: < of type bool [line: 30]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 30]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 30]
.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 30]			.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 30]
.   .   Sibling: 14  Call: outputb of type void [line: 31]						.   .   Sibling: 14  Call: outputb of type void [line: 31]
.   .   .   Child: 0  Op: < of type bool [line: 31]							.   .   .   Child: 0  Op: < of type bool [line: 31]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 31]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 31]
.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 31]			.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 31]
.   .   Sibling: 15  Call: outnl of type void [line: 32]						.   .   Sibling: 15  Call: outnl of type void [line: 32]
.   .   Sibling: 16  Call: outputb of type void [line: 34]						.   .   Sibling: 16  Call: outputb of type void [line: 34]
.   .   .   Child: 0  Op: > of type bool [line: 34]							.   .   .   Child: 0  Op: > of type bool [line: 34]
.   .   .   .   Child: 0  Const 50 of type int [line: 34]						.   .   .   .   Child: 0  Const 50 of type int [line: 34]
.   .   .   .   Child: 1  Const 1 of type int [line: 34]						.   .   .   .   Child: 1  Const 1 of type int [line: 34]
.   .   Sibling: 17  Call: outputb of type void [line: 35]						.   .   Sibling: 17  Call: outputb of type void [line: 35]
.   .   .   Child: 0  Op: > of type bool [line: 35]							.   .   .   Child: 0  Op: > of type bool [line: 35]
.   .   .   .   Child: 0  Const 1 of type int [line: 35]						.   .   .   .   Child: 0  Const 1 of type int [line: 35]
.   .   .   .   Child: 1  Const 50 of type int [line: 35]						.   .   .   .   Child: 1  Const 50 of type int [line: 35]
.   .   Sibling: 18  Call: outputb of type void [line: 36]						.   .   Sibling: 18  Call: outputb of type void [line: 36]
.   .   .   Child: 0  Op: > of type bool [line: 36]							.   .   .   Child: 0  Op: > of type bool [line: 36]
.   .   .   .   Child: 0  Const 50 of type int [line: 36]						.   .   .   .   Child: 0  Const 50 of type int [line: 36]
.   .   .   .   Child: 1  Const 50 of type int [line: 36]						.   .   .   .   Child: 1  Const 50 of type int [line: 36]
.   .   Sibling: 19  Call: outnl of type void [line: 37]						.   .   Sibling: 19  Call: outnl of type void [line: 37]
.   .   Sibling: 20  Call: outputb of type void [line: 39]						.   .   Sibling: 20  Call: outputb of type void [line: 39]
.   .   .   Child: 0  Op: >= of type bool [line: 39]							.   .   .   Child: 0  Op: >= of type bool [line: 39]
.   .   .   .   Child: 0  Const 50 of type int [line: 39]						.   .   .   .   Child: 0  Const 50 of type int [line: 39]
.   .   .   .   Child: 1  Const 1 of type int [line: 39]						.   .   .   .   Child: 1  Const 1 of type int [line: 39]
.   .   Sibling: 21  Call: outputb of type void [line: 40]						.   .   Sibling: 21  Call: outputb of type void [line: 40]
.   .   .   Child: 0  Op: >= of type bool [line: 40]							.   .   .   Child: 0  Op: >= of type bool [line: 40]
.   .   .   .   Child: 0  Const 1 of type int [line: 40]						.   .   .   .   Child: 0  Const 1 of type int [line: 40]
.   .   .   .   Child: 1  Const 50 of type int [line: 40]						.   .   .   .   Child: 1  Const 50 of type int [line: 40]
.   .   Sibling: 22  Call: outputb of type void [line: 41]						.   .   Sibling: 22  Call: outputb of type void [line: 41]
.   .   .   Child: 0  Op: >= of type bool [line: 41]							.   .   .   Child: 0  Op: >= of type bool [line: 41]
.   .   .   .   Child: 0  Const 50 of type int [line: 41]						.   .   .   .   Child: 0  Const 50 of type int [line: 41]
.   .   .   .   Child: 1  Const 50 of type int [line: 41]						.   .   .   .   Child: 1  Const 50 of type int [line: 41]
.   .   Sibling: 23  Call: outnl of type void [line: 42]						.   .   Sibling: 23  Call: outnl of type void [line: 42]
.   .   Sibling: 24  Call: outputb of type void [line: 44]						.   .   Sibling: 24  Call: outputb of type void [line: 44]
.   .   .   Child: 0  Op: == of type bool [line: 44]						   |	.   .   .   Child: 0  Op: = of type bool [line: 44]
.   .   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 4	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 4
.   .   .   .   .   Child: 1  Const 0 of type int [line: 44]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 44]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 44]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 44]
.   .   Sibling: 25  Call: outputb of type void [line: 45]						.   .   Sibling: 25  Call: outputb of type void [line: 45]
.   .   .   Child: 0  Op: == of type bool [line: 45]						   |	.   .   .   Child: 0  Op: = of type bool [line: 45]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 45]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 45]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 45]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 45]
.   .   Sibling: 26  Call: outputb of type void [line: 46]						.   .   Sibling: 26  Call: outputb of type void [line: 46]
.   .   .   Child: 0  Op: == of type bool [line: 46]						   |	.   .   .   Child: 0  Op: = of type bool [line: 46]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 46]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 46]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 46]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 46]
.   .   Sibling: 27  Call: outnl of type void [line: 47]						.   .   Sibling: 27  Call: outnl of type void [line: 47]
.   .   Sibling: 28  Call: outputb of type void [line: 49]						.   .   Sibling: 28  Call: outputb of type void [line: 49]
.   .   .   Child: 0  Op: != of type bool [line: 49]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 49]
.   .   .   .   Child: 0  Op: [ of type int [line: 49]							.   .   .   .   Child: 0  Op: [ of type int [line: 49]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 4	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 4
.   .   .   .   .   Child: 1  Const 0 of type int [line: 49]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 49]
.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 49]			.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 49]
.   .   Sibling: 29  Call: outputb of type void [line: 50]						.   .   Sibling: 29  Call: outputb of type void [line: 50]
.   .   .   Child: 0  Op: != of type bool [line: 50]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 50]
.   .   .   .   Child: 0  Op: [ of type int [line: 50]							.   .   .   .   Child: 0  Op: [ of type int [line: 50]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 5	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 5
.   .   .   .   .   Child: 1  Const 0 of type int [line: 50]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 50]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 50]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 50]
.   .   Sibling: 30  Call: outputb of type void [line: 51]						.   .   Sibling: 30  Call: outputb of type void [line: 51]
.   .   .   Child: 0  Op: != of type bool [line: 51]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 51]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 51]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 51]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 51]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 51]
.   .   Sibling: 31  Call: outputb of type void [line: 52]						.   .   Sibling: 31  Call: outputb of type void [line: 52]
.   .   .   Child: 0  Op: != of type bool [line: 52]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 52]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 52]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 52]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 52]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 52]
.   .   Sibling: 32  Call: outnl of type void [line: 53]						.   .   Sibling: 32  Call: outnl of type void [line: 53]
.   .   Sibling: 33  Call: outputb of type void [line: 55]						.   .   Sibling: 33  Call: outputb of type void [line: 55]
.   .   .   Child: 0  Op: and of type bool [line: 55]							.   .   .   Child: 0  Op: and of type bool [line: 55]
.   .   .   .   Child: 0  Const true of type bool [line: 55]						.   .   .   .   Child: 0  Const true of type bool [line: 55]
.   .   .   .   Child: 1  Const true of type bool [line: 55]						.   .   .   .   Child: 1  Const true of type bool [line: 55]
.   .   Sibling: 34  Call: outputb of type void [line: 56]						.   .   Sibling: 34  Call: outputb of type void [line: 56]
.   .   .   Child: 0  Op: and of type bool [line: 56]							.   .   .   Child: 0  Op: and of type bool [line: 56]
.   .   .   .   Child: 0  Const true of type bool [line: 56]						.   .   .   .   Child: 0  Const true of type bool [line: 56]
.   .   .   .   Child: 1  Const false of type bool [line: 56]						.   .   .   .   Child: 1  Const false of type bool [line: 56]
.   .   Sibling: 35  Call: outputb of type void [line: 57]						.   .   Sibling: 35  Call: outputb of type void [line: 57]
.   .   .   Child: 0  Op: and of type bool [line: 57]							.   .   .   Child: 0  Op: and of type bool [line: 57]
.   .   .   .   Child: 0  Const false of type bool [line: 57]						.   .   .   .   Child: 0  Const false of type bool [line: 57]
.   .   .   .   Child: 1  Const true of type bool [line: 57]						.   .   .   .   Child: 1  Const true of type bool [line: 57]
.   .   Sibling: 36  Call: outputb of type void [line: 58]						.   .   Sibling: 36  Call: outputb of type void [line: 58]
.   .   .   Child: 0  Op: and of type bool [line: 58]							.   .   .   Child: 0  Op: and of type bool [line: 58]
.   .   .   .   Child: 0  Const false of type bool [line: 58]						.   .   .   .   Child: 0  Const false of type bool [line: 58]
.   .   .   .   Child: 1  Const false of type bool [line: 58]						.   .   .   .   Child: 1  Const false of type bool [line: 58]
.   .   Sibling: 37  Call: outnl of type void [line: 59]						.   .   Sibling: 37  Call: outnl of type void [line: 59]
.   .   Sibling: 38  Call: outputb of type void [line: 61]						.   .   Sibling: 38  Call: outputb of type void [line: 61]
.   .   .   Child: 0  Op: or of type bool [line: 61]							.   .   .   Child: 0  Op: or of type bool [line: 61]
.   .   .   .   Child: 0  Const true of type bool [line: 61]						.   .   .   .   Child: 0  Const true of type bool [line: 61]
.   .   .   .   Child: 1  Const true of type bool [line: 61]						.   .   .   .   Child: 1  Const true of type bool [line: 61]
.   .   Sibling: 39  Call: outputb of type void [line: 62]						.   .   Sibling: 39  Call: outputb of type void [line: 62]
.   .   .   Child: 0  Op: or of type bool [line: 62]							.   .   .   Child: 0  Op: or of type bool [line: 62]
.   .   .   .   Child: 0  Id: z of type bool [mem: Local loc: -5 size: 1] [line: 62]			.   .   .   .   Child: 0  Id: z of type bool [mem: Local loc: -5 size: 1] [line: 62]
.   .   .   .   Child: 1  Const false of type bool [line: 62]						.   .   .   .   Child: 1  Const false of type bool [line: 62]
.   .   Sibling: 40  Call: outputb of type void [line: 63]						.   .   Sibling: 40  Call: outputb of type void [line: 63]
.   .   .   Child: 0  Op: or of type bool [line: 63]							.   .   .   Child: 0  Op: or of type bool [line: 63]
.   .   .   .   Child: 0  Const false of type bool [line: 63]						.   .   .   .   Child: 0  Const false of type bool [line: 63]
.   .   .   .   Child: 1  Const true of type bool [line: 63]						.   .   .   .   Child: 1  Const true of type bool [line: 63]
.   .   Sibling: 41  Call: outputb of type void [line: 64]						.   .   Sibling: 41  Call: outputb of type void [line: 64]
.   .   .   Child: 0  Op: or of type bool [line: 64]							.   .   .   Child: 0  Op: or of type bool [line: 64]
.   .   .   .   Child: 0  Const false of type bool [line: 64]						.   .   .   .   Child: 0  Const false of type bool [line: 64]
.   .   .   .   Child: 1  Const false of type bool [line: 64]						.   .   .   .   Child: 1  Const false of type bool [line: 64]
.   .   Sibling: 42  Call: outnl of type void [line: 65]						.   .   Sibling: 42  Call: outnl of type void [line: 65]
.   .   Sibling: 43  Call: outputb of type void [line: 67]						.   .   Sibling: 43  Call: outputb of type void [line: 67]
.   .   .   Child: 0  Op: not of type bool [line: 67]							.   .   .   Child: 0  Op: not of type bool [line: 67]
.   .   .   .   Child: 0  Const true of type bool [line: 67]						.   .   .   .   Child: 0  Const true of type bool [line: 67]
.   .   Sibling: 44  Call: outputb of type void [line: 68]						.   .   Sibling: 44  Call: outputb of type void [line: 68]
.   .   .   Child: 0  Op: not of type bool [line: 68]							.   .   .   Child: 0  Op: not of type bool [line: 68]
.   .   .   .   Child: 0  Id: x of type bool [mem: Global loc: -11 size: 1] [line: 68]			.   .   .   .   Child: 0  Id: x of type bool [mem: Global loc: -11 size: 1] [line: 68]
.   .   Sibling: 45  Call: outnl of type void [line: 69]						.   .   Sibling: 45  Call: outnl of type void [line: 69]
.   .   Sibling: 46  Call: output of type void [line: 71]						.   .   Sibling: 46  Call: output of type void [line: 71]
.   .   .   Child: 0  Op: + of type int [line: 71]							.   .   .   Child: 0  Op: + of type int [line: 71]
.   .   .   .   Child: 0  Const 5 of type int [line: 71]						.   .   .   .   Child: 0  Const 5 of type int [line: 71]
.   .   .   .   Child: 1  Const 50 of type int [line: 71]						.   .   .   .   Child: 1  Const 50 of type int [line: 71]
.   .   Sibling: 47  Call: output of type void [line: 72]						.   .   Sibling: 47  Call: output of type void [line: 72]
.   .   .   Child: 0  Op: + of type int [line: 72]							.   .   .   Child: 0  Op: + of type int [line: 72]
.   .   .   .   Child: 0  Op: [ of type int [line: 72]							.   .   .   .   Child: 0  Op: [ of type int [line: 72]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 7	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 7
.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 72]			.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 72]
.   .   .   .   Child: 1  Const 50 of type int [line: 72]						.   .   .   .   Child: 1  Const 50 of type int [line: 72]
.   .   Sibling: 48  Call: outnl of type void [line: 73]						.   .   Sibling: 48  Call: outnl of type void [line: 73]
.   .   Sibling: 49  Call: output of type void [line: 75]						.   .   Sibling: 49  Call: output of type void [line: 75]
.   .   .   Child: 0  Op: - of type int [line: 75]							.   .   .   Child: 0  Op: - of type int [line: 75]
.   .   .   .   Child: 0  Const 5 of type int [line: 75]						.   .   .   .   Child: 0  Const 5 of type int [line: 75]
.   .   .   .   Child: 1  Const 50 of type int [line: 75]						.   .   .   .   Child: 1  Const 50 of type int [line: 75]
.   .   Sibling: 50  Call: output of type void [line: 76]						.   .   Sibling: 50  Call: output of type void [line: 76]
.   .   .   Child: 0  Op: - of type int [line: 76]							.   .   .   Child: 0  Op: - of type int [line: 76]
.   .   .   .   Child: 0  Op: - of type int [line: 76]							.   .   .   .   Child: 0  Op: - of type int [line: 76]
.   .   .   .   .   Child: 0  Const 30 of type int [line: 76]						.   .   .   .   .   Child: 0  Const 30 of type int [line: 76]
.   .   .   .   .   Child: 1  Const 5 of type int [line: 76]						.   .   .   .   .   Child: 1  Const 5 of type int [line: 76]
.   .   .   .   Child: 1  Const 50 of type int [line: 76]						.   .   .   .   Child: 1  Const 50 of type int [line: 76]
.   .   Sibling: 51  Call: outnl of type void [line: 77]						.   .   Sibling: 51  Call: outnl of type void [line: 77]
.   .   Sibling: 52  Call: output of type void [line: 79]						.   .   Sibling: 52  Call: output of type void [line: 79]
.   .   .   Child: 0  Op: chsign of type int [line: 79]							.   .   .   Child: 0  Op: chsign of type int [line: 79]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 79]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 79]
.   .   Sibling: 53  Call: output of type void [line: 80]						.   .   Sibling: 53  Call: output of type void [line: 80]
.   .   .   Child: 0  Op: chsign of type int [line: 80]							.   .   .   Child: 0  Op: chsign of type int [line: 80]
.   .   .   .   Child: 0  Const 0 of type int [line: 80]						.   .   .   .   Child: 0  Const 0 of type int [line: 80]
.   .   Sibling: 54  Call: output of type void [line: 81]						.   .   Sibling: 54  Call: output of type void [line: 81]
.   .   .   Child: 0  Op: chsign of type int [line: 81]							.   .   .   Child: 0  Op: chsign of type int [line: 81]
.   .   .   .   Child: 0  Const 1 of type int [line: 81]						.   .   .   .   Child: 0  Const 1 of type int [line: 81]
.   .   Sibling: 55  Call: outnl of type void [line: 82]						.   .   Sibling: 55  Call: outnl of type void [line: 82]
.   .   Sibling: 56  Call: output of type void [line: 84]						.   .   Sibling: 56  Call: output of type void [line: 84]
.   .   .   Child: 0  Op: * of type int [line: 84]							.   .   .   Child: 0  Op: * of type int [line: 84]
.   .   .   .   Child: 0  Op: * of type int [line: 84]							.   .   .   .   Child: 0  Op: * of type int [line: 84]
.   .   .   .   .   Child: 0  Op: * of type int [line: 84]						.   .   .   .   .   Child: 0  Op: * of type int [line: 84]
.   .   .   .   .   .   Child: 0  Op: * of type int [line: 84]						.   .   .   .   .   .   Child: 0  Op: * of type int [line: 84]
.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 84]					.   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 84]
.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 84]					.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 84]
.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 84]					.   .   .   .   .   .   Child: 1  Const 5 of type int [line: 84]
.   .   .   .   .   Child: 1  Const 7 of type int [line: 84]						.   .   .   .   .   Child: 1  Const 7 of type int [line: 84]
.   .   .   .   Child: 1  Const 11 of type int [line: 84]						.   .   .   .   Child: 1  Const 11 of type int [line: 84]
.   .   Sibling: 57  Call: output of type void [line: 85]						.   .   Sibling: 57  Call: output of type void [line: 85]
.   .   .   Child: 0  Op: * of type int [line: 85]							.   .   .   Child: 0  Op: * of type int [line: 85]
.   .   .   .   Child: 0  Const 50 of type int [line: 85]						.   .   .   .   Child: 0  Const 50 of type int [line: 85]
.   .   .   .   Child: 1  Op: [ of type int [line: 85]							.   .   .   .   Child: 1  Op: [ of type int [line: 85]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8
.   .   .   .   .   Child: 1  Const 8 of type int [line: 85]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 85]
.   .   Sibling: 58  Call: output of type void [line: 86]						.   .   Sibling: 58  Call: output of type void [line: 86]
.   .   .   Child: 0  Op: * of type int [line: 86]							.   .   .   Child: 0  Op: * of type int [line: 86]
.   .   .   .   Child: 0  Op: [ of type int [line: 86]							.   .   .   .   Child: 0  Op: [ of type int [line: 86]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8
.   .   .   .   .   Child: 1  Const 8 of type int [line: 86]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 86]
.   .   .   .   Child: 1  Const 50 of type int [line: 86]						.   .   .   .   Child: 1  Const 50 of type int [line: 86]
.   .   Sibling: 59  Call: outnl of type void [line: 87]						.   .   Sibling: 59  Call: outnl of type void [line: 87]
.   .   Sibling: 60  Call: output of type void [line: 89]						.   .   Sibling: 60  Call: output of type void [line: 89]
.   .   .   Child: 0  Op: / of type int [line: 89]							.   .   .   Child: 0  Op: / of type int [line: 89]
.   .   .   .   Child: 0  Const 50 of type int [line: 89]						.   .   .   .   Child: 0  Const 50 of type int [line: 89]
.   .   .   .   Child: 1  Op: [ of type int [line: 89]							.   .   .   .   Child: 1  Op: [ of type int [line: 89]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 8
.   .   .   .   .   Child: 1  Const 8 of type int [line: 89]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 89]
.   .   Sibling: 61  Call: output of type void [line: 90]						.   .   Sibling: 61  Call: output of type void [line: 90]
.   .   .   Child: 0  Op: / of type int [line: 90]							.   .   .   Child: 0  Op: / of type int [line: 90]
.   .   .   .   Child: 0  Op: [ of type int [line: 90]							.   .   .   .   Child: 0  Op: [ of type int [line: 90]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 9	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 9
.   .   .   .   .   Child: 1  Const 8 of type int [line: 90]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 90]
.   .   .   .   Child: 1  Const 50 of type int [line: 90]						.   .   .   .   Child: 1  Const 50 of type int [line: 90]
.   .   Sibling: 62  Call: output of type void [line: 91]						.   .   Sibling: 62  Call: output of type void [line: 91]
.   .   .   Child: 0  Op: / of type int [line: 91]							.   .   .   Child: 0  Op: / of type int [line: 91]
.   .   .   .   Child: 0  Op: [ of type int [line: 91]							.   .   .   .   Child: 0  Op: [ of type int [line: 91]
.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 9	.   .   .   .   .   Child: 0  Id: y of array of type int [mem: Global loc: -1 size: 11] [line: 9
.   .   .   .   .   Child: 1  Const 8 of type int [line: 91]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 91]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 91]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 91]
.   .   Sibling: 63  Call: output of type void [line: 92]						.   .   Sibling: 63  Call: output of type void [line: 92]
.   .   .   Child: 0  Op: / of type int [line: 92]							.   .   .   Child: 0  Op: / of type int [line: 92]
.   .   .   .   Child: 0  Op: / of type int [line: 92]							.   .   .   .   Child: 0  Op: / of type int [line: 92]
.   .   .   .   .   Child: 0  Const 210 of type int [line: 92]						.   .   .   .   .   Child: 0  Const 210 of type int [line: 92]
.   .   .   .   .   Child: 1  Const 7 of type int [line: 92]						.   .   .   .   .   Child: 1  Const 7 of type int [line: 92]
.   .   .   .   Child: 1  Const 3 of type int [line: 92]						.   .   .   .   Child: 1  Const 3 of type int [line: 92]
.   .   Sibling: 64  Call: outnl of type void [line: 93]						.   .   Sibling: 64  Call: outnl of type void [line: 93]
.   .   Sibling: 65  Call: output of type void [line: 95]						.   .   Sibling: 65  Call: output of type void [line: 95]
.   .   .   Child: 0  Op: % of type int [line: 95]							.   .   .   Child: 0  Op: % of type int [line: 95]
.   .   .   .   Child: 0  Const 211 of type int [line: 95]						.   .   .   .   Child: 0  Const 211 of type int [line: 95]
.   .   .   .   Child: 1  Const 7 of type int [line: 95]						.   .   .   .   Child: 1  Const 7 of type int [line: 95]
.   .   Sibling: 66  Call: output of type void [line: 96]						.   .   Sibling: 66  Call: output of type void [line: 96]
.   .   .   Child: 0  Op: % of type int [line: 96]							.   .   .   Child: 0  Op: % of type int [line: 96]
.   .   .   .   Child: 0  Const 211 of type int [line: 96]						.   .   .   .   Child: 0  Const 211 of type int [line: 96]
.   .   .   .   Child: 1  Const 6 of type int [line: 96]						.   .   .   .   Child: 1  Const 6 of type int [line: 96]
.   .   Sibling: 67  Call: output of type void [line: 97]						.   .   Sibling: 67  Call: output of type void [line: 97]
.   .   .   Child: 0  Op: % of type int [line: 97]							.   .   .   Child: 0  Op: % of type int [line: 97]
.   .   .   .   Child: 0  Const 211 of type int [line: 97]						.   .   .   .   Child: 0  Const 211 of type int [line: 97]
.   .   .   .   Child: 1  Const 5 of type int [line: 97]						.   .   .   .   Child: 1  Const 5 of type int [line: 97]
.   .   Sibling: 68  Call: output of type void [line: 98]						.   .   Sibling: 68  Call: output of type void [line: 98]
.   .   .   Child: 0  Op: % of type int [line: 98]							.   .   .   Child: 0  Op: % of type int [line: 98]
.   .   .   .   Child: 0  Const 211 of type int [line: 98]						.   .   .   .   Child: 0  Const 211 of type int [line: 98]
.   .   .   .   Child: 1  Const 4 of type int [line: 98]						.   .   .   .   Child: 1  Const 4 of type int [line: 98]
.   .   Sibling: 69  Call: output of type void [line: 99]						.   .   Sibling: 69  Call: output of type void [line: 99]
.   .   .   Child: 0  Op: % of type int [line: 99]							.   .   .   Child: 0  Op: % of type int [line: 99]
.   .   .   .   Child: 0  Op: % of type int [line: 99]							.   .   .   .   Child: 0  Op: % of type int [line: 99]
.   .   .   .   .   Child: 0  Const 211 of type int [line: 99]						.   .   .   .   .   Child: 0  Const 211 of type int [line: 99]
.   .   .   .   .   Child: 1  Const 100 of type int [line: 99]						.   .   .   .   .   Child: 1  Const 100 of type int [line: 99]
.   .   .   .   Child: 1  Const 3 of type int [line: 99]						.   .   .   .   Child: 1  Const 3 of type int [line: 99]
.   .   Sibling: 70  Call: outnl of type void [line: 100]						.   .   Sibling: 70  Call: outnl of type void [line: 100]
.   .   Sibling: 71  Call: output of type void [line: 102]						.   .   Sibling: 71  Call: output of type void [line: 102]
.   .   .   Child: 0  Assign: = of type int [line: 102]						   |	.   .   .   Child: 0  Assign: := of type int [line: 102]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 102]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 102]
.   .   .   .   Child: 1  Assign: = of type int [line: 102]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 102]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 102]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 102]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 102]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 102]
.   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 102]		.   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 102]
.   .   .   .   .   .   Child: 1  Const 43 of type int [line: 102]					.   .   .   .   .   .   Child: 1  Const 43 of type int [line: 102]
.   .   Sibling: 72  Call: output of type void [line: 103]						.   .   Sibling: 72  Call: output of type void [line: 103]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 103]			.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 103]
.   .   Sibling: 73  Assign: = of type int [line: 104]						   |	.   .   Sibling: 73  Assign: := of type int [line: 104]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 104]			.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 104]
.   .   .   Child: 1  Op: * of type int [line: 104]							.   .   .   Child: 1  Op: * of type int [line: 104]
.   .   .   .   Child: 0  Assign: = of type int [line: 104]					   |	.   .   .   .   Child: 0  Assign: := of type int [line: 104]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 104]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 104]
.   .   .   .   .   Child: 1  Const 3 of type int [line: 104]						.   .   .   .   .   Child: 1  Const 3 of type int [line: 104]
.   .   .   .   Child: 1  Assign: = of type int [line: 104]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 104]
.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 104]		.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 104]
.   .   .   .   .   Child: 1  Const 4 of type int [line: 104]						.   .   .   .   .   Child: 1  Const 4 of type int [line: 104]
.   .   Sibling: 74  Call: output of type void [line: 105]						.   .   Sibling: 74  Call: output of type void [line: 105]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 105]			.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 105]
.   .   Sibling: 75  Call: outnl of type void [line: 106]						.   .   Sibling: 75  Call: outnl of type void [line: 106]
.   .   Sibling: 76  Assign: = of type int [line: 108]						   |	.   .   Sibling: 76  Assign: := of type int [line: 108]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 108]			.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 108]
.   .   .   Child: 1  Const 44 of type int [line: 108]							.   .   .   Child: 1  Const 44 of type int [line: 108]
.   .   Sibling: 77  Assign: = of type int [line: 109]						   |	.   .   Sibling: 77  Assign: := of type int [line: 109]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 109]			.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 109]
.   .   .   Child: 1  Const 2 of type int [line: 109]							.   .   .   Child: 1  Const 2 of type int [line: 109]
.   .   Sibling: 78  Call: output of type void [line: 110]						.   .   Sibling: 78  Call: output of type void [line: 110]
.   .   .   Child: 0  Assign: += of type int [line: 110]						.   .   .   Child: 0  Assign: += of type int [line: 110]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 110]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 110]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 110]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 110]
.   .   Sibling: 79  Call: output of type void [line: 111]						.   .   Sibling: 79  Call: output of type void [line: 111]
.   .   .   Child: 0  Assign: -= of type int [line: 111]						.   .   .   Child: 0  Assign: -= of type int [line: 111]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 111]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 111]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 111]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 111]
.   .   Sibling: 80  Call: output of type void [line: 112]						.   .   Sibling: 80  Call: output of type void [line: 112]
.   .   .   Child: 0  Assign: -= of type int [line: 112]						.   .   .   Child: 0  Assign: -= of type int [line: 112]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 112]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 112]
.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 112]			.   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 112]
.   .   Sibling: 81  Call: output of type void [line: 113]						.   .   Sibling: 81  Call: output of type void [line: 113]
.   .   .   Child: 0  Assign: += of type int [line: 113]						.   .   .   Child: 0  Assign: += of type int [line: 113]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 113]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 113]
.   .   .   .   Child: 1  Assign: += of type int [line: 113]						.   .   .   .   Child: 1  Assign: += of type int [line: 113]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 113]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 113]
.   .   .   .   .   Child: 1  Const 10 of type int [line: 113]						.   .   .   .   .   Child: 1  Const 10 of type int [line: 113]
.   .   Sibling: 82  Call: outnl of type void [line: 114]						.   .   Sibling: 82  Call: outnl of type void [line: 114]
.   .   Sibling: 83  Call: output of type void [line: 116]						.   .   Sibling: 83  Call: output of type void [line: 116]
.   .   .   Child: 0  Op: - of type int [line: 116]							.   .   .   Child: 0  Op: - of type int [line: 116]
.   .   .   .   Child: 0  Op: - of type int [line: 116]							.   .   .   .   Child: 0  Op: - of type int [line: 116]
.   .   .   .   .   Child: 0  Const 3 of type int [line: 116]						.   .   .   .   .   Child: 0  Const 3 of type int [line: 116]
.   .   .   .   .   Child: 1  Const 4 of type int [line: 116]						.   .   .   .   .   Child: 1  Const 4 of type int [line: 116]
.   .   .   .   Child: 1  Const 5 of type int [line: 116]						.   .   .   .   Child: 1  Const 5 of type int [line: 116]
.   .   Sibling: 84  Call: output of type void [line: 117]						.   .   Sibling: 84  Call: output of type void [line: 117]
.   .   .   Child: 0  Op: / of type int [line: 117]							.   .   .   Child: 0  Op: / of type int [line: 117]
.   .   .   .   Child: 0  Op: / of type int [line: 117]							.   .   .   .   Child: 0  Op: / of type int [line: 117]
.   .   .   .   .   Child: 0  Const 211 of type int [line: 117]						.   .   .   .   .   Child: 0  Const 211 of type int [line: 117]
.   .   .   .   .   Child: 1  Const 17 of type int [line: 117]						.   .   .   .   .   Child: 1  Const 17 of type int [line: 117]
.   .   .   .   Child: 1  Const 5 of type int [line: 117]						.   .   .   .   Child: 1  Const 5 of type int [line: 117]
.   .   Sibling: 85  Call: output of type void [line: 118]						.   .   Sibling: 85  Call: output of type void [line: 118]
.   .   .   Child: 0  Op: / of type int [line: 118]							.   .   .   Child: 0  Op: / of type int [line: 118]
.   .   .   .   Child: 0  Const 211 of type int [line: 118]						.   .   .   .   Child: 0  Const 211 of type int [line: 118]
.   .   .   .   Child: 1  Op: / of type int [line: 118]							.   .   .   .   Child: 1  Op: / of type int [line: 118]
.   .   .   .   .   Child: 0  Const 17 of type int [line: 118]						.   .   .   .   .   Child: 0  Const 17 of type int [line: 118]
.   .   .   .   .   Child: 1  Const 5 of type int [line: 118]						.   .   .   .   .   Child: 1  Const 5 of type int [line: 118]
.   .   Sibling: 86  Call: outputb of type void [line: 119]						.   .   Sibling: 86  Call: outputb of type void [line: 119]
.   .   .   Child: 0  Op: and of type bool [line: 119]							.   .   .   Child: 0  Op: and of type bool [line: 119]
.   .   .   .   Child: 0  Op: or of type bool [line: 119]						.   .   .   .   Child: 0  Op: or of type bool [line: 119]
.   .   .   .   .   Child: 0  Const true of type bool [line: 119]					.   .   .   .   .   Child: 0  Const true of type bool [line: 119]
.   .   .   .   .   Child: 1  Const false of type bool [line: 119]					.   .   .   .   .   Child: 1  Const false of type bool [line: 119]
.   .   .   .   Child: 1  Const false of type bool [line: 119]						.   .   .   .   Child: 1  Const false of type bool [line: 119]
.   .   Sibling: 87  Call: outputb of type void [line: 120]						.   .   Sibling: 87  Call: outputb of type void [line: 120]
.   .   .   Child: 0  Op: or of type bool [line: 120]							.   .   .   Child: 0  Op: or of type bool [line: 120]
.   .   .   .   Child: 0  Const true of type bool [line: 120]						.   .   .   .   Child: 0  Const true of type bool [line: 120]
.   .   .   .   Child: 1  Op: and of type bool [line: 120]						.   .   .   .   Child: 1  Op: and of type bool [line: 120]
.   .   .   .   .   Child: 0  Const false of type bool [line: 120]					.   .   .   .   .   Child: 0  Const false of type bool [line: 120]
.   .   .   .   .   Child: 1  Const false of type bool [line: 120]					.   .   .   .   .   Child: 1  Const false of type bool [line: 120]
.   .   Sibling: 88  Call: outputb of type void [line: 121]						.   .   Sibling: 88  Call: outputb of type void [line: 121]
.   .   .   Child: 0  Op: or of type bool [line: 121]							.   .   .   Child: 0  Op: or of type bool [line: 121]
.   .   .   .   Child: 0  Const true of type bool [line: 121]						.   .   .   .   Child: 0  Const true of type bool [line: 121]
.   .   .   .   Child: 1  Op: and of type bool [line: 121]						.   .   .   .   Child: 1  Op: and of type bool [line: 121]
.   .   .   .   .   Child: 0  Const false of type bool [line: 121]					.   .   .   .   .   Child: 0  Const false of type bool [line: 121]
.   .   .   .   .   Child: 1  Const false of type bool [line: 121]					.   .   .   .   .   Child: 1  Const false of type bool [line: 121]
.   .   Sibling: 89  Call: outnl of type void [line: 122]						.   .   Sibling: 89  Call: outnl of type void [line: 122]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
ops.out ztmp23114.txt differ: byte 1, line 1
ops (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/ops.tm
Number of errors: 0										   |	F T T
------------------------------------								   |	F T F
Loading file: ops.tm										   |	T F F
												   >	T F T
												   >	F F T
												   >	F T T F
												   >	T F F F
												   >	T T T F
												   >	F T
												   >	55 52
												   >	-45 -25
												   >	-50 0 -1
												   >	2310 100 100
												   >	25 0 2 10
												   >	1 1 1 3 2
												   >	43 43 12
												   >	46 44 0 12
												   >	-6 2 70 F T T
Bye.													Bye.
====================================
FILE: permlist.c-
-rw-------. 1 corg7983 domain_users   795 Nov 17 15:35 permlist.c-
-rw-------. 1 corg7983 domain_users   818 Nov 17 15:35 permlist.c-.f21
-rw-------. 1 corg7983 domain_users   795 Nov 17 15:35 permlist.c-.f22
-rw-------. 1 corg7983 domain_users   773 Nov 17 15:35 permlist.expected
-rw-------. 1 corg7983 domain_users    19 Nov 17 15:35 permlist.in
-rw-------. 1 corg7983 domain_users 12884 Nov 22 12:27 permlist.mem
-rw-------. 1 corg7983 domain_users  3161 Nov 17 15:35 permlist.mem.diffs
-rw-------. 1 corg7983 domain_users 13748 Nov 17 15:35 permlist.mem.f21
-rw-------. 1 corg7983 domain_users   139 Nov 22 12:27 permlist.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 permlist.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 permlist.tm.diffs
-rw-------. 1 corg7983 domain_users 15070 Nov 17 15:35 permlist.tm.f21
TM CODE COMPARISON
permlist (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  permlist.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION put
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-2(1)	Load address of base of array p
												   >	 41:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 42:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 43:     LD  4,-5(1)	Pop left into ac1 
												   >	 44:    SUB  3,4,3	compute location from index 
												   >	 45:     LD  3,0(3)	Load array element 
												   >	 46:     ST  3,-4(1)	Store variable sum
												   >	* EXPRESSION
												   >	 47:    LDC  3,2(6)	Load integer constant 
												   >	 48:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	 49:     LD  3,-3(1)	Load variable j
												   >	 50:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 51:     LD  3,0(0)	Load variable n
												   >	* TOFF inc: -5
												   >	 52:     LD  4,-5(1)	Pop left into ac1 
												   >	 53:    TLE  3,4,3	Op <= 
												   >	 54:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 56:     LD  3,-4(1)	Load variable sum
												   >	 57:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 58:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 59:     LD  4,-5(1)	Pop left into ac1 
												   >	 60:    MUL  3,4,3	Op * 
												   >	 61:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 62:     LD  3,-2(1)	Load address of base of array p
												   >	 63:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 64:     LD  3,-3(1)	Load variable j
												   >	* TOFF inc: -6
												   >	 65:     LD  4,-6(1)	Pop left into ac1 
												   >	 66:    SUB  3,4,3	compute location from index 
												   >	 67:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	 68:     LD  4,-5(1)	Pop left into ac1 
												   >	 69:    ADD  3,4,3	Op + 
												   >	 70:     ST  3,-4(1)	Store variable sum
												   >	* EXPRESSION
												   >	 71:     LD  3,-3(1)	Load variable j
												   >	 72:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 73:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 74:     LD  4,-5(1)	Pop left into ac1 
												   >	 75:    ADD  3,4,3	Op + 
												   >	 76:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	 77:    JMP  7,-29(7)	go to beginning of loop 
												   >	 55:    JMP  7,22(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	 78:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 79:     LD  3,-4(1)	Load variable sum
												   >	 80:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 81:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 82:    LDA  3,1(7)	Return address in ac 
												   >	 83:    JMP  7,-78(7)	CALL output
												   >	 84:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 85:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	 86:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-55(7)	CALL outnl
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 90:    LDC  2,0(6)	Set return value to 0 
												   >	 91:     LD  3,-1(1)	Load return address 
												   >	 92:     LD  1,0(1)	Adjust fp 
												   >	 93:    JMP  7,0(3)	Return 
												   >	* END FUNCTION put
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 94:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -25
												   >	 95:    LDC  3,20(6)	load size of array p
												   >	 96:     ST  3,-2(1)	save size of array p
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	 97:     ST  1,-25(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -26
												   >	* TOFF dec: -27
												   >	* Param end input
												   >	 98:    LDA  1,-25(1)	Ghost frame becomes new active frame 
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-100(7)	CALL input
												   >	101:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -25
												   >	102:     ST  3,0(0)	Store variable n
												   >	* EXPRESSION
												   >	103:    LDC  3,0(6)	Load integer constant 
												   >	104:     ST  3,-24(1)	Store variable j
												   >	* WHILE
												   >	105:     LD  3,-24(1)	Load variable j
												   >	106:     ST  3,-25(1)	Push left side 
												   >	* TOFF dec: -26
												   >	107:     LD  3,0(0)	Load variable n
												   >	* TOFF inc: -25
												   >	108:     LD  4,-25(1)	Pop left into ac1 
												   >	109:    TLE  3,4,3	Op <= 
												   >	110:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -25
												   >	* Compound Body
												   >	* EXPRESSION
												   >	112:     LD  3,-24(1)	Load variable j
												   >	113:     ST  3,-25(1)	Push index 
												   >	* TOFF dec: -26
												   >	114:     LD  3,-24(1)	Load variable j
												   >	* TOFF inc: -25
												   >	115:     LD  4,-25(1)	Pop index 
												   >	116:    LDA  5,-3(1)	Load address of base of array p
												   >	117:    SUB  5,5,4	Compute offset of value 
												   >	118:     ST  3,0(5)	Store variable p
												   >	* EXPRESSION
												   >	119:     LD  3,-24(1)	Load variable j
												   >	120:     ST  3,-25(1)	Push left side 
												   >	* TOFF dec: -26
												   >	121:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -25
												   >	122:     LD  4,-25(1)	Pop left into ac1 
												   >	123:    ADD  3,4,3	Op + 
												   >	124:     ST  3,-24(1)	Store variable j
												   >	* TOFF set: -25
												   >	* END COMPOUND
												   >	125:    JMP  7,-21(7)	go to beginning of loop 
												   >	111:    JMP  7,14(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	126:    LDC  3,1(6)	Load integer constant 
												   >	127:     ST  3,-23(1)	Store variable i
												   >	* WHILE
												   >	128:     LD  3,-23(1)	Load variable i
												   >	129:     ST  3,-25(1)	Push left side 
												   >	* TOFF dec: -26
												   >	130:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -25
												   >	131:     LD  4,-25(1)	Pop left into ac1 
												   >	132:    TGT  3,4,3	Op > 
												   >	133:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -28
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL put
												   >	135:     ST  1,-28(1)	Store fp in ghost frame for put
												   >	* TOFF dec: -29
												   >	* TOFF dec: -30
												   >	* Param 1
												   >	136:    LDA  3,-3(1)	Load address of base of array p
												   >	137:     ST  3,-30(1)	Push parameter 
												   >	* TOFF dec: -31
												   >	* Param end put
												   >	138:    LDA  1,-28(1)	Ghost frame becomes new active frame 
												   >	139:    LDA  3,1(7)	Return address in ac 
												   >	140:    JMP  7,-102(7)	CALL put
												   >	141:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end put
												   >	* TOFF set: -28
												   >	* EXPRESSION
												   >	142:     LD  3,0(0)	Load variable n
												   >	143:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	144:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	145:     LD  4,-28(1)	Pop left into ac1 
												   >	146:    SUB  3,4,3	Op - 
												   >	147:     ST  3,-23(1)	Store variable i
												   >	* WHILE
												   >	148:    LDA  3,-3(1)	Load address of base of array p
												   >	149:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	150:     LD  3,-23(1)	Load variable i
												   >	* TOFF inc: -28
												   >	151:     LD  4,-28(1)	Pop left into ac1 
												   >	152:    SUB  3,4,3	compute location from index 
												   >	153:     LD  3,0(3)	Load array element 
												   >	154:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	155:    LDA  3,-3(1)	Load address of base of array p
												   >	156:     ST  3,-29(1)	Push left side 
												   >	* TOFF dec: -30
												   >	157:     LD  3,-23(1)	Load variable i
												   >	158:     ST  3,-30(1)	Push left side 
												   >	* TOFF dec: -31
												   >	159:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -30
												   >	160:     LD  4,-30(1)	Pop left into ac1 
												   >	161:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -29
												   >	162:     LD  4,-29(1)	Pop left into ac1 
												   >	163:    SUB  3,4,3	compute location from index 
												   >	164:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -28
												   >	165:     LD  4,-28(1)	Pop left into ac1 
												   >	166:    TGT  3,4,3	Op > 
												   >	167:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* EXPRESSION
												   >	169:     LD  3,-23(1)	Load variable i
												   >	170:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	171:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	172:     LD  4,-28(1)	Pop left into ac1 
												   >	173:    SUB  3,4,3	Op - 
												   >	174:     ST  3,-23(1)	Store variable i
												   >	175:    JMP  7,-28(7)	go to beginning of loop 
												   >	168:    JMP  7,7(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	176:     LD  3,0(0)	Load variable n
												   >	177:     ST  3,-24(1)	Store variable j
												   >	* WHILE
												   >	178:    LDA  3,-3(1)	Load address of base of array p
												   >	179:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	180:     LD  3,-23(1)	Load variable i
												   >	* TOFF inc: -28
												   >	181:     LD  4,-28(1)	Pop left into ac1 
												   >	182:    SUB  3,4,3	compute location from index 
												   >	183:     LD  3,0(3)	Load array element 
												   >	184:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	185:    LDA  3,-3(1)	Load address of base of array p
												   >	186:     ST  3,-29(1)	Push left side 
												   >	* TOFF dec: -30
												   >	187:     LD  3,-24(1)	Load variable j
												   >	* TOFF inc: -29
												   >	188:     LD  4,-29(1)	Pop left into ac1 
												   >	189:    SUB  3,4,3	compute location from index 
												   >	190:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -28
												   >	191:     LD  4,-28(1)	Pop left into ac1 
												   >	192:    TGT  3,4,3	Op > 
												   >	193:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* EXPRESSION
												   >	195:     LD  3,-24(1)	Load variable j
												   >	196:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	197:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	198:     LD  4,-28(1)	Pop left into ac1 
												   >	199:    SUB  3,4,3	Op - 
												   >	200:     ST  3,-24(1)	Store variable j
												   >	201:    JMP  7,-24(7)	go to beginning of loop 
												   >	194:    JMP  7,7(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	202:    LDA  3,-3(1)	Load address of base of array p
												   >	203:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	204:     LD  3,-23(1)	Load variable i
												   >	* TOFF inc: -28
												   >	205:     LD  4,-28(1)	Pop left into ac1 
												   >	206:    SUB  3,4,3	compute location from index 
												   >	207:     LD  3,0(3)	Load array element 
												   >	208:     ST  3,-27(1)	Store variable tmp
												   >	* EXPRESSION
												   >	209:     LD  3,-23(1)	Load variable i
												   >	210:     ST  3,-28(1)	Push index 
												   >	* TOFF dec: -29
												   >	211:    LDA  3,-3(1)	Load address of base of array p
												   >	212:     ST  3,-29(1)	Push left side 
												   >	* TOFF dec: -30
												   >	213:     LD  3,-24(1)	Load variable j
												   >	* TOFF inc: -29
												   >	214:     LD  4,-29(1)	Pop left into ac1 
												   >	215:    SUB  3,4,3	compute location from index 
												   >	216:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -28
												   >	217:     LD  4,-28(1)	Pop index 
												   >	218:    LDA  5,-3(1)	Load address of base of array p
												   >	219:    SUB  5,5,4	Compute offset of value 
												   >	220:     ST  3,0(5)	Store variable p
												   >	* EXPRESSION
												   >	221:     LD  3,-24(1)	Load variable j
												   >	222:     ST  3,-28(1)	Push index 
												   >	* TOFF dec: -29
												   >	223:     LD  3,-27(1)	Load variable tmp
												   >	* TOFF inc: -28
												   >	224:     LD  4,-28(1)	Pop index 
												   >	225:    LDA  5,-3(1)	Load address of base of array p
												   >	226:    SUB  5,5,4	Compute offset of value 
												   >	227:     ST  3,0(5)	Store variable p
												   >	* EXPRESSION
												   >	228:     LD  3,0(0)	Load variable n
												   >	229:     ST  3,-25(1)	Store variable r
												   >	* EXPRESSION
												   >	230:     LD  3,-23(1)	Load variable i
												   >	231:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	232:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	233:     LD  4,-28(1)	Pop left into ac1 
												   >	234:    ADD  3,4,3	Op + 
												   >	235:     ST  3,-26(1)	Store variable s
												   >	* WHILE
												   >	236:     LD  3,-25(1)	Load variable r
												   >	237:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	238:     LD  3,-26(1)	Load variable s
												   >	* TOFF inc: -28
												   >	239:     LD  4,-28(1)	Pop left into ac1 
												   >	240:    TGT  3,4,3	Op > 
												   >	241:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -28
												   >	* Compound Body
												   >	* EXPRESSION
												   >	243:    LDA  3,-3(1)	Load address of base of array p
												   >	244:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	245:     LD  3,-25(1)	Load variable r
												   >	* TOFF inc: -28
												   >	246:     LD  4,-28(1)	Pop left into ac1 
												   >	247:    SUB  3,4,3	compute location from index 
												   >	248:     LD  3,0(3)	Load array element 
												   >	249:     ST  3,-27(1)	Store variable tmp
												   >	* EXPRESSION
												   >	250:     LD  3,-25(1)	Load variable r
												   >	251:     ST  3,-28(1)	Push index 
												   >	* TOFF dec: -29
												   >	252:    LDA  3,-3(1)	Load address of base of array p
												   >	253:     ST  3,-29(1)	Push left side 
												   >	* TOFF dec: -30
												   >	254:     LD  3,-26(1)	Load variable s
												   >	* TOFF inc: -29
												   >	255:     LD  4,-29(1)	Pop left into ac1 
												   >	256:    SUB  3,4,3	compute location from index 
												   >	257:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -28
												   >	258:     LD  4,-28(1)	Pop index 
												   >	259:    LDA  5,-3(1)	Load address of base of array p
												   >	260:    SUB  5,5,4	Compute offset of value 
												   >	261:     ST  3,0(5)	Store variable p
												   >	* EXPRESSION
												   >	262:     LD  3,-26(1)	Load variable s
												   >	263:     ST  3,-28(1)	Push index 
												   >	* TOFF dec: -29
												   >	264:     LD  3,-27(1)	Load variable tmp
												   >	* TOFF inc: -28
												   >	265:     LD  4,-28(1)	Pop index 
												   >	266:    LDA  5,-3(1)	Load address of base of array p
												   >	267:    SUB  5,5,4	Compute offset of value 
												   >	268:     ST  3,0(5)	Store variable p
												   >	* EXPRESSION
												   >	269:     LD  3,-25(1)	Load variable r
												   >	270:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	271:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	272:     LD  4,-28(1)	Pop left into ac1 
												   >	273:    SUB  3,4,3	Op - 
												   >	274:     ST  3,-25(1)	Store variable r
												   >	* EXPRESSION
												   >	275:     LD  3,-26(1)	Load variable s
												   >	276:     ST  3,-28(1)	Push left side 
												   >	* TOFF dec: -29
												   >	277:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -28
												   >	278:     LD  4,-28(1)	Pop left into ac1 
												   >	279:    ADD  3,4,3	Op + 
												   >	280:     ST  3,-26(1)	Store variable s
												   >	* TOFF set: -28
												   >	* END COMPOUND
												   >	281:    JMP  7,-46(7)	go to beginning of loop 
												   >	242:    JMP  7,39(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -25
												   >	* END COMPOUND
												   >	282:    JMP  7,-155(7)	go to beginning of loop 
												   >	134:    JMP  7,148(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	283:    LDC  2,0(6)	Set return value to 0 
												   >	284:     LD  3,-1(1)	Load return address 
												   >	285:     LD  1,0(1)	Adjust fp 
												   >	286:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,286(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	287:    LDA  1,-1(0)	set first frame at end of globals 
												   >	288:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	289:    LDA  3,1(7)	Return address in ac 
												   >	290:    JMP  7,-197(7)	Jump to main 
												   >	291:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
permlist.mem permlist.mem.f21 differ: byte 1, line 1
permlist (MEM DIFF)
Var: n of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: put returns type void [mem: Global loc: 0 size: -3] [line: 3]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: n of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: put returns type void [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: p of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   Child: 0  Parm: p of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 4]
.   .   Child: 0  Var: j of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   Child: 0  Var: j of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Sibling: 1  Var: sum of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   Sibling: 1  Var: sum of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 1  Op: [ of type int [line: 8]							.   .   .   Child: 1  Op: [ of type int [line: 8]
.   .   .   .   Child: 0  Id: p of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]		.   .   .   .   Child: 0  Id: p of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 1 of type int [line: 8]							.   .   .   .   Child: 1  Const 1 of type int [line: 8]
.   .   Sibling: 1  Assign: = of type int [line: 9]						   |	.   .   Sibling: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 9]				.   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   Child: 1  Const 2 of type int [line: 9]							.   .   .   Child: 1  Const 2 of type int [line: 9]
.   .   Sibling: 2  While [line: 10]									.   .   Sibling: 2  While [line: 10]
.   .   .   Child: 0  Op: <= of type bool [line: 10]							.   .   .   Child: 0  Op: <= of type bool [line: 10]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 10]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 10]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]
.   .   .   .   Child: 1  Assign: = of type int [line: 11]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 11]
.   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 11]		.   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Op: + of type int [line: 11]						.   .   .   .   .   Child: 1  Op: + of type int [line: 11]
.   .   .   .   .   .   Child: 0  Op: * of type int [line: 11]						.   .   .   .   .   .   Child: 0  Op: * of type int [line: 11]
.   .   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 11	.   .   .   .   .   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 11
.   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 11]					.   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 11]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 11]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 11]
.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 12]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 12]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   .   Child: 1  Op: + of type int [line: 12]						.   .   .   .   .   Child: 1  Op: + of type int [line: 12]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 12]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   Sibling: 3  Call: output of type void [line: 14]						.   .   Sibling: 3  Call: output of type void [line: 14]
.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 14]			.   .   .   Child: 0  Id: sum of type int [mem: Local loc: -4 size: 1] [line: 14]
.   .   Sibling: 4  Call: outnl of type void [line: 15]							.   .   Sibling: 4  Call: outnl of type void [line: 15]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 19]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 19]
.   Child: 1  Compound [mem: None loc: 0 size: -25] [line: 20]						.   Child: 1  Compound [mem: None loc: 0 size: -25] [line: 20]
.   .   Child: 0  Var: p of array of type int [mem: Local loc: -3 size: 21] [line: 21]			.   .   Child: 0  Var: p of array of type int [mem: Local loc: -3 size: 21] [line: 21]
.   .   Sibling: 1  Var: i of type int [mem: Local loc: -23 size: 1] [line: 22]				.   .   Sibling: 1  Var: i of type int [mem: Local loc: -23 size: 1] [line: 22]
.   .   Sibling: 2  Var: j of type int [mem: Local loc: -24 size: 1] [line: 23]				.   .   Sibling: 2  Var: j of type int [mem: Local loc: -24 size: 1] [line: 23]
.   .   Child: 1  Assign: = of type int [line: 25]						   |	.   .   Child: 1  Assign: := of type int [line: 25]
.   .   .   Child: 0  Id: n of type int [mem: Global loc: 0 size: 1] [line: 25]				.   .   .   Child: 0  Id: n of type int [mem: Global loc: 0 size: 1] [line: 25]
.   .   .   Child: 1  Call: input of type int [line: 25]						.   .   .   Child: 1  Call: input of type int [line: 25]
.   .   Sibling: 1  Assign: = of type int [line: 27]						   |	.   .   Sibling: 1  Assign: := of type int [line: 27]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 27]			.   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 27]
.   .   .   Child: 1  Const 0 of type int [line: 27]							.   .   .   Child: 1  Const 0 of type int [line: 27]
.   .   Sibling: 2  While [line: 28]									.   .   Sibling: 2  While [line: 28]
.   .   .   Child: 0  Op: <= of type bool [line: 28]							.   .   .   Child: 0  Op: <= of type bool [line: 28]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 28]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 28]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 28]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 28]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -25] [line: 28]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -25] [line: 28]
.   .   .   .   Child: 1  Assign: = of type int [line: 29]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 29]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 29]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line	.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line
.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 29]		.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 29]
.   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 29]		.   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 29]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 30]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 30]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 30]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 30]
.   .   .   .   .   Child: 1  Op: + of type int [line: 30]						.   .   .   .   .   Child: 1  Op: + of type int [line: 30]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 30]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 30]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 30]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 30]
.   .   Sibling: 3  Assign: = of type int [line: 33]						   |	.   .   Sibling: 3  Assign: := of type int [line: 33]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 33]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 33]
.   .   .   Child: 1  Const 1 of type int [line: 33]							.   .   .   Child: 1  Const 1 of type int [line: 33]
.   .   Sibling: 4  While [line: 34]									.   .   Sibling: 4  While [line: 34]
.   .   .   Child: 0  Op: > of type bool [line: 34]							.   .   .   Child: 0  Op: > of type bool [line: 34]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 34]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 34]
.   .   .   .   Child: 1  Const 0 of type int [line: 34]						.   .   .   .   Child: 1  Const 0 of type int [line: 34]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -28] [line: 34]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -28] [line: 34]
.   .   .   .   Child: 0  Var: r of type int [mem: Local loc: -25 size: 1] [line: 35]			.   .   .   .   Child: 0  Var: r of type int [mem: Local loc: -25 size: 1] [line: 35]
.   .   .   .   Sibling: 1  Var: s of type int [mem: Local loc: -26 size: 1] [line: 36]			.   .   .   .   Sibling: 1  Var: s of type int [mem: Local loc: -26 size: 1] [line: 36]
.   .   .   .   Sibling: 2  Var: tmp of type int [mem: Local loc: -27 size: 1] [line: 37]		.   .   .   .   Sibling: 2  Var: tmp of type int [mem: Local loc: -27 size: 1] [line: 37]
.   .   .   .   Child: 1  Call: put of type void [line: 39]						.   .   .   .   Child: 1  Call: put of type void [line: 39]
.   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line: 39	.   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line: 39
.   .   .   .   Sibling: 1  Assign: = of type int [line: 42]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 42]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 42]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 42]
.   .   .   .   .   Child: 1  Op: - of type int [line: 42]						.   .   .   .   .   Child: 1  Op: - of type int [line: 42]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: 0 size: 1] [line: 42]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc: 0 size: 1] [line: 42]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 42]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 42]
.   .   .   .   Sibling: 2  While [line: 43]								.   .   .   .   Sibling: 2  While [line: 43]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 43]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 43]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 43]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [	.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]	.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 43]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 43]
.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [	.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 43]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 43]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 43]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 43]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]
.   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]						.   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 43]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 45]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 45]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 45]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 45]
.   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 45]			.   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 45]
.   .   .   .   Sibling: 4  While [line: 46]								.   .   .   .   Sibling: 4  While [line: 46]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 46]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 46]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 46]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 46]
.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [	.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 46]	.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 46]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 46]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 46]
.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [	.   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [
.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]	.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 46]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 46]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]
.   .   .   .   .   .   Child: 1  Op: - of type int [line: 46]						.   .   .   .   .   .   Child: 1  Op: - of type int [line: 46]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -24 size: 1] [line: 46]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 46]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 46]
.   .   .   .   Sibling: 5  Assign: = of type int [line: 48]					   |	.   .   .   .   Sibling: 5  Assign: := of type int [line: 48]
.   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 48]		.   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 48]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 48]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 48]
.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line	.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 48]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 48]
.   .   .   .   Sibling: 6  Assign: = of type int [line: 48]					   |	.   .   .   .   Sibling: 6  Assign: := of type int [line: 48]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 48]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 48]
.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line	.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 48]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 48]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 48]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 48]
.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line	.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line
.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 48]		.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 48]
.   .   .   .   Sibling: 7  Assign: = of type int [line: 48]					   |	.   .   .   .   Sibling: 7  Assign: := of type int [line: 48]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 48]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 48]
.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line	.   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 21] [line
.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 48]		.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -24 size: 1] [line: 48]
.   .   .   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 48]		.   .   .   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 48]
.   .   .   .   Sibling: 8  Assign: = of type int [line: 50]					   |	.   .   .   .   Sibling: 8  Assign: := of type int [line: 50]
.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 50]		.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 50]
.   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 50]			.   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: 0 size: 1] [line: 50]
.   .   .   .   Sibling: 9  Assign: = of type int [line: 51]					   |	.   .   .   .   Sibling: 9  Assign: := of type int [line: 51]
.   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line: 51]		.   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line: 51]
.   .   .   .   .   Child: 1  Op: + of type int [line: 51]						.   .   .   .   .   Child: 1  Op: + of type int [line: 51]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 51]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -23 size: 1] [line: 51]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 51]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 51]
.   .   .   .   Sibling: 10  While [line: 52]								.   .   .   .   Sibling: 10  While [line: 52]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 52]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 52]
.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 52]		.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 52]
.   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line: 52]		.   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line: 52]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -28] [line: 52]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -28] [line: 52]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 53]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 53]
.   .   .   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 5	.   .   .   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 5
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 53]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 53]
.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2	.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2
.   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -25 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -25 size: 1] [line:
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 53]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 53]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 53]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 53]
.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2	.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2
.   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -25 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -25 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 53]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 53]
.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2	.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2
.   .   .   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line:
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 53]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 53]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 53]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 53]
.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2	.   .   .   .   .   .   .   .   Child: 0  Id: p of array of type int [mem: Local loc: -3 size: 2
.   .   .   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 1  Id: s of type int [mem: Local loc: -26 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 5	.   .   .   .   .   .   .   Child: 1  Id: tmp of type int [mem: Local loc: -27 size: 1] [line: 5
.   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 54]				   |	.   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 54]
.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 54]	.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line: 54]
.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 54]					.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -25 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]
.   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 55]				   |	.   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 55]
.   .   .   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line: 55]	.   .   .   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line: 55]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 55]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 55]
.   .   .   .   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: s of type int [mem: Local loc: -26 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 55]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 55]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
permlist.out ztmp23114.txt differ: byte 1, line 1
permlist (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/permlist.tm
Number of errors: 0										   |	entered: 5
------------------------------------								   |	12345
Loading file: permlist.tm									   |	12354
ERROR: TM Command 5 unknown.									   |	12435
												   >	12453
												   >	12534
												   >	12543
												   >	13245
												   >	13254
												   >	13425
												   >	13452
												   >	13524
												   >	13542
												   >	14235
												   >	14253
												   >	14325
												   >	14352
												   >	14523
												   >	14532
												   >	15234
												   >	15243
												   >	15324
												   >	15342
												   >	15423
												   >	15432
												   >	21345
												   >	21354
												   >	21435
												   >	21453
												   >	21534
												   >	21543
												   >	23145
												   >	23154
												   >	23415
												   >	23451
												   >	23514
												   >	23541
												   >	24135
												   >	24153
												   >	24315
												   >	24351
												   >	24513
												   >	24531
												   >	25134
												   >	25143
												   >	25314
												   >	25341
												   >	25413
												   >	25431
												   >	31245
												   >	31254
												   >	31425
												   >	31452
												   >	31524
												   >	31542
												   >	32145
												   >	32154
												   >	32415
												   >	32451
												   >	32514
												   >	32541
												   >	34125
												   >	34152
												   >	34215
												   >	34251
												   >	34512
												   >	34521
												   >	35124
												   >	35142
												   >	35214
												   >	35241
												   >	35412
												   >	35421
												   >	41235
												   >	41253
												   >	41325
												   >	41352
												   >	41523
												   >	41532
												   >	42135
												   >	42153
												   >	42315
												   >	42351
												   >	42513
												   >	42531
												   >	43125
												   >	43152
												   >	43215
												   >	43251
												   >	43512
												   >	43521
												   >	45123
												   >	45132
												   >	45213
												   >	45231
												   >	45312
												   >	45321
												   >	51234
												   >	51243
												   >	51324
												   >	51342
												   >	51423
												   >	51432
												   >	52134
												   >	52143
												   >	52314
												   >	52341
												   >	52413
												   >	52431
												   >	53124
												   >	53142
												   >	53214
												   >	53241
												   >	53412
												   >	53421
												   >	54123
												   >	54132
												   >	54213
												   >	54231
												   >	54312
												   >	54321
Bye.													Bye.
====================================
FILE: pi.c-
-rw-------. 1 corg7983 domain_users  1058 Nov 17 15:35 pi.c-
-rw-------. 1 corg7983 domain_users  1072 Nov 17 15:35 pi.c-.f21
-rw-------. 1 corg7983 domain_users  1058 Nov 17 15:35 pi.c-.f22
-rw-------. 1 corg7983 domain_users   289 Nov 17 15:35 pi.expected
-rw-------. 1 corg7983 domain_users    17 Nov 17 15:35 pi.in
-rw-------. 1 corg7983 domain_users 12919 Nov 22 12:27 pi.mem
-rw-------. 1 corg7983 domain_users  2488 Nov 17 15:35 pi.mem.diffs
-rw-------. 1 corg7983 domain_users 13774 Nov 17 15:35 pi.mem.f21
-rw-------. 1 corg7983 domain_users   155 Nov 22 12:27 pi.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 pi.tm
-rw-------. 1 corg7983 domain_users   279 Nov 17 15:35 pi.tm.diffs
-rw-------. 1 corg7983 domain_users 16512 Nov 17 15:35 pi.tm.f21
TM CODE COMPARISON
pi (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pi.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	 40:    LDC  3,340(6)	load size of array a
												   >	 41:     ST  3,-11(1)	save size of array a
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:    LDC  3,100(6)	Load integer constant 
												   >	 43:     ST  3,-2(1)	Store variable N
												   >	* EXPRESSION
												   >	 44:     LD  3,-2(1)	Load variable N
												   >	 45:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	 46:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	 47:     LD  4,-352(1)	Pop left into ac1 
												   >	 48:    MUL  3,4,3	Op * 
												   >	 49:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	 50:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	 51:     LD  4,-352(1)	Pop left into ac1 
												   >	 52:    DIV  3,4,3	Op / 
												   >	 53:     ST  3,-3(1)	Store variable LEN
												   >	* EXPRESSION
												   >	 54:    LDC  3,0(6)	Load integer constant 
												   >	 55:     ST  3,-5(1)	Store variable j
												   >	* WHILE
												   >	 56:     LD  3,-5(1)	Load variable j
												   >	 57:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	 58:     LD  3,-3(1)	Load variable LEN
												   >	* TOFF inc: -352
												   >	 59:     LD  4,-352(1)	Pop left into ac1 
												   >	 60:    TLT  3,4,3	Op < 
												   >	 61:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 63:     LD  3,-5(1)	Load variable j
												   >	 64:     ST  3,-352(1)	Push index 
												   >	* TOFF dec: -353
												   >	 65:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	 66:     LD  4,-352(1)	Pop index 
												   >	 67:    LDA  5,-12(1)	Load address of base of array a
												   >	 68:    SUB  5,5,4	Compute offset of value 
												   >	 69:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	 70:     LD  3,-5(1)	load lhs variable j
												   >	 71:    LDA  3,1(3)	increment value of j
												   >	 72:     ST  3,-5(1)	Store variable j
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	 73:    JMP  7,-18(7)	go to beginning of loop 
												   >	 62:    JMP  7,11(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	 74:    LDC  3,0(6)	Load integer constant 
												   >	 75:     ST  3,-9(1)	Store variable nines
												   >	* EXPRESSION
												   >	 76:    LDC  3,0(6)	Load integer constant 
												   >	 77:     ST  3,-10(1)	Store variable predigit
												   >	* EXPRESSION
												   >	 78:    LDC  3,0(6)	Load integer constant 
												   >	 79:     ST  3,-5(1)	Store variable j
												   >	* WHILE
												   >	 80:     LD  3,-5(1)	Load variable j
												   >	 81:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	 82:     LD  3,-2(1)	Load variable N
												   >	* TOFF inc: -352
												   >	 83:     LD  4,-352(1)	Pop left into ac1 
												   >	 84:    TLT  3,4,3	Op < 
												   >	 85:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 87:    LDC  3,0(6)	Load integer constant 
												   >	 88:     ST  3,-7(1)	Store variable q
												   >	* EXPRESSION
												   >	 89:     LD  3,-3(1)	Load variable LEN
												   >	 90:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	 91:     LD  3,-4(1)	Load variable i
												   >	 92:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	 93:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	 94:     LD  4,-352(1)	Pop left into ac1 
												   >	 95:    TGT  3,4,3	Op > 
												   >	 96:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 98:    LDC  3,10(6)	Load integer constant 
												   >	 99:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	100:    LDA  3,-12(1)	Load address of base of array a
												   >	101:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	102:     LD  3,-4(1)	Load variable i
												   >	103:     ST  3,-354(1)	Push left side 
												   >	* TOFF dec: -355
												   >	104:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -354
												   >	105:     LD  4,-354(1)	Pop left into ac1 
												   >	106:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -353
												   >	107:     LD  4,-353(1)	Pop left into ac1 
												   >	108:    SUB  3,4,3	compute location from index 
												   >	109:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -352
												   >	110:     LD  4,-352(1)	Pop left into ac1 
												   >	111:    MUL  3,4,3	Op * 
												   >	112:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	113:     LD  3,-7(1)	Load variable q
												   >	114:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	115:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -353
												   >	116:     LD  4,-353(1)	Pop left into ac1 
												   >	117:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -352
												   >	118:     LD  4,-352(1)	Pop left into ac1 
												   >	119:    ADD  3,4,3	Op + 
												   >	120:     ST  3,-8(1)	Store variable x
												   >	* EXPRESSION
												   >	121:     LD  3,-4(1)	Load variable i
												   >	122:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	123:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	124:     LD  4,-352(1)	Pop left into ac1 
												   >	125:    SUB  3,4,3	Op - 
												   >	126:     ST  3,-352(1)	Push index 
												   >	* TOFF dec: -353
												   >	127:     LD  3,-8(1)	Load variable x
												   >	128:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	129:    LDC  3,2(6)	Load integer constant 
												   >	130:     ST  3,-354(1)	Push left side 
												   >	* TOFF dec: -355
												   >	131:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -354
												   >	132:     LD  4,-354(1)	Pop left into ac1 
												   >	133:    MUL  3,4,3	Op * 
												   >	134:     ST  3,-354(1)	Push left side 
												   >	* TOFF dec: -355
												   >	135:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -354
												   >	136:     LD  4,-354(1)	Pop left into ac1 
												   >	137:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -353
												   >	138:     LD  4,-353(1)	Pop left into ac1 
												   >	139:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -352
												   >	140:     LD  4,-352(1)	Pop index 
												   >	141:    LDA  5,-12(1)	Load address of base of array a
												   >	142:    SUB  5,5,4	Compute offset of value 
												   >	143:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	144:     LD  3,-8(1)	Load variable x
												   >	145:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	146:    LDC  3,2(6)	Load integer constant 
												   >	147:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	148:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -353
												   >	149:     LD  4,-353(1)	Pop left into ac1 
												   >	150:    MUL  3,4,3	Op * 
												   >	151:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	152:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -353
												   >	153:     LD  4,-353(1)	Pop left into ac1 
												   >	154:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -352
												   >	155:     LD  4,-352(1)	Pop left into ac1 
												   >	156:    DIV  3,4,3	Op / 
												   >	157:     ST  3,-7(1)	Store variable q
												   >	* EXPRESSION
												   >	158:    LDC  3,1(6)	Load integer constant 
												   >	159:     LD  4,-4(1)	load lhs variable i
												   >	160:    SUB  3,4,3	op -= 
												   >	161:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	162:    JMP  7,-72(7)	go to beginning of loop 
												   >	 97:    JMP  7,65(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	163:    LDC  3,0(6)	Load integer constant 
												   >	164:     ST  3,-352(1)	Push index 
												   >	* TOFF dec: -353
												   >	165:     LD  3,-7(1)	Load variable q
												   >	166:     ST  3,-353(1)	Push left side 
												   >	* TOFF dec: -354
												   >	167:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -353
												   >	168:     LD  4,-353(1)	Pop left into ac1 
												   >	169:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -352
												   >	170:     LD  4,-352(1)	Pop index 
												   >	171:    LDA  5,-12(1)	Load address of base of array a
												   >	172:    SUB  5,5,4	Compute offset of value 
												   >	173:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	174:     LD  3,-7(1)	Load variable q
												   >	175:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	176:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	177:     LD  4,-352(1)	Pop left into ac1 
												   >	178:    DIV  3,4,3	Op / 
												   >	179:     ST  3,-7(1)	Store variable q
												   >	* IF
												   >	180:     LD  3,-7(1)	Load variable q
												   >	181:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	182:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	183:     LD  4,-352(1)	Pop left into ac1 
												   >	184:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	186:     LD  3,-9(1)	load lhs variable nines
												   >	187:    LDA  3,1(3)	increment value of nines
												   >	188:     ST  3,-9(1)	Store variable nines
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	185:    JZR  3,4(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* IF
												   >	190:     LD  3,-7(1)	Load variable q
												   >	191:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	192:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	193:     LD  4,-352(1)	Pop left into ac1 
												   >	194:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	196:     ST  1,-352(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param 1
												   >	197:     LD  3,-10(1)	Load variable predigit
												   >	198:     ST  3,-354(1)	Push left side 
												   >	* TOFF dec: -355
												   >	199:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -354
												   >	200:     LD  4,-354(1)	Pop left into ac1 
												   >	201:    ADD  3,4,3	Op + 
												   >	202:     ST  3,-354(1)	Push parameter 
												   >	* TOFF dec: -355
												   >	* Param end output
												   >	203:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	204:    LDA  3,1(7)	Return address in ac 
												   >	205:    JMP  7,-200(7)	CALL output
												   >	206:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	207:     ST  1,-352(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param end outnl
												   >	208:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-177(7)	CALL outnl
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	212:    LDC  3,0(6)	Load integer constant 
												   >	213:     ST  3,-10(1)	Store variable predigit
												   >	* WHILE
												   >	214:     LD  3,-9(1)	Load variable nines
												   >	215:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	216:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	217:     LD  4,-352(1)	Pop left into ac1 
												   >	218:    TGT  3,4,3	Op > 
												   >	219:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	221:     ST  1,-352(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param 1
												   >	222:    LDC  3,0(6)	Load integer constant 
												   >	223:     ST  3,-354(1)	Push parameter 
												   >	* TOFF dec: -355
												   >	* Param end output
												   >	224:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	225:    LDA  3,1(7)	Return address in ac 
												   >	226:    JMP  7,-221(7)	CALL output
												   >	227:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	228:     ST  1,-352(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param end outnl
												   >	229:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	230:    LDA  3,1(7)	Return address in ac 
												   >	231:    JMP  7,-198(7)	CALL outnl
												   >	232:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	233:     LD  3,-9(1)	load lhs variable nines
												   >	234:    LDA  3,-1(3)	decrement value of nines
												   >	235:     ST  3,-9(1)	Store variable nines
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	236:    JMP  7,-23(7)	go to beginning of loop 
												   >	220:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	195:    JZR  3,42(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	238:     ST  1,-352(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param 1
												   >	239:     LD  3,-10(1)	Load variable predigit
												   >	240:     ST  3,-354(1)	Push parameter 
												   >	* TOFF dec: -355
												   >	* Param end output
												   >	241:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	242:    LDA  3,1(7)	Return address in ac 
												   >	243:    JMP  7,-238(7)	CALL output
												   >	244:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	245:     ST  1,-352(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param end outnl
												   >	246:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	247:    LDA  3,1(7)	Return address in ac 
												   >	248:    JMP  7,-215(7)	CALL outnl
												   >	249:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	250:     LD  3,-7(1)	Load variable q
												   >	251:     ST  3,-10(1)	Store variable predigit
												   >	* WHILE
												   >	252:     LD  3,-9(1)	Load variable nines
												   >	253:     ST  3,-352(1)	Push left side 
												   >	* TOFF dec: -353
												   >	254:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -352
												   >	255:     LD  4,-352(1)	Pop left into ac1 
												   >	256:    TGT  3,4,3	Op > 
												   >	257:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -352
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	259:     ST  1,-352(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param 1
												   >	260:    LDC  3,9(6)	Load integer constant 
												   >	261:     ST  3,-354(1)	Push parameter 
												   >	* TOFF dec: -355
												   >	* Param end output
												   >	262:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	263:    LDA  3,1(7)	Return address in ac 
												   >	264:    JMP  7,-259(7)	CALL output
												   >	265:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	266:     ST  1,-352(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param end outnl
												   >	267:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	268:    LDA  3,1(7)	Return address in ac 
												   >	269:    JMP  7,-236(7)	CALL outnl
												   >	270:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	271:     LD  3,-9(1)	load lhs variable nines
												   >	272:    LDA  3,-1(3)	decrement value of nines
												   >	273:     ST  3,-9(1)	Store variable nines
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	274:    JMP  7,-23(7)	go to beginning of loop 
												   >	258:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	237:    JMP  7,37(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	189:    JMP  7,85(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	275:     LD  3,-5(1)	load lhs variable j
												   >	276:    LDA  3,1(3)	increment value of j
												   >	277:     ST  3,-5(1)	Store variable j
												   >	* TOFF set: -352
												   >	* END COMPOUND
												   >	278:    JMP  7,-199(7)	go to beginning of loop 
												   >	 86:    JMP  7,192(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	279:     ST  1,-352(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param 1
												   >	280:     LD  3,-10(1)	Load variable predigit
												   >	281:     ST  3,-354(1)	Push parameter 
												   >	* TOFF dec: -355
												   >	* Param end output
												   >	282:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	283:    LDA  3,1(7)	Return address in ac 
												   >	284:    JMP  7,-279(7)	CALL output
												   >	285:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -352
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	286:     ST  1,-352(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -353
												   >	* TOFF dec: -354
												   >	* Param end outnl
												   >	287:    LDA  1,-352(1)	Ghost frame becomes new active frame 
												   >	288:    LDA  3,1(7)	Return address in ac 
												   >	289:    JMP  7,-256(7)	CALL outnl
												   >	290:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -352
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	291:    LDC  2,0(6)	Set return value to 0 
												   >	292:     LD  3,-1(1)	Load return address 
												   >	293:     LD  1,0(1)	Adjust fp 
												   >	294:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,294(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	295:    LDA  1,0(0)	set first frame at end of globals 
												   >	296:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	297:    LDA  3,1(7)	Return address in ac 
												   >	298:    JMP  7,-260(7)	Jump to main 
												   >	299:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pi.mem pi.mem.f21 differ: byte 58, line 2
pi (MEM DIFF)
WARNING(4): The variable 'k' seems not to be used.							WARNING(4): The variable 'k' seems not to be used.
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 2]
.   .   Child: 0  Var: N of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: N of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: LEN of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: LEN of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Sibling: 2  Var: i of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Sibling: 2  Var: i of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Sibling: 3  Var: j of type int [mem: Local loc: -5 size: 1] [line: 4]				.   .   Sibling: 3  Var: j of type int [mem: Local loc: -5 size: 1] [line: 4]
.   .   Sibling: 4  Var: k of type int [mem: Local loc: -6 size: 1] [line: 4]				.   .   Sibling: 4  Var: k of type int [mem: Local loc: -6 size: 1] [line: 4]
.   .   Sibling: 5  Var: q of type int [mem: Local loc: -7 size: 1] [line: 4]				.   .   Sibling: 5  Var: q of type int [mem: Local loc: -7 size: 1] [line: 4]
.   .   Sibling: 6  Var: x of type int [mem: Local loc: -8 size: 1] [line: 4]				.   .   Sibling: 6  Var: x of type int [mem: Local loc: -8 size: 1] [line: 4]
.   .   Sibling: 7  Var: nines of type int [mem: Local loc: -9 size: 1] [line: 4]			.   .   Sibling: 7  Var: nines of type int [mem: Local loc: -9 size: 1] [line: 4]
.   .   Sibling: 8  Var: predigit of type int [mem: Local loc: -10 size: 1] [line: 4]			.   .   Sibling: 8  Var: predigit of type int [mem: Local loc: -10 size: 1] [line: 4]
.   .   Sibling: 9  Var: a of array of type int [mem: Local loc: -12 size: 341] [line: 5]		.   .   Sibling: 9  Var: a of array of type int [mem: Local loc: -12 size: 341] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: N of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Id: N of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Const 100 of type int [line: 7]							.   .   .   Child: 1  Const 100 of type int [line: 7]
.   .   Sibling: 1  Assign: = of type int [line: 8]						   |	.   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   Child: 0  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   Child: 1  Op: / of type int [line: 8]							.   .   .   Child: 1  Op: / of type int [line: 8]
.   .   .   .   Child: 0  Op: * of type int [line: 8]							.   .   .   .   Child: 0  Op: * of type int [line: 8]
.   .   .   .   .   Child: 0  Id: N of type int [mem: Local loc: -2 size: 1] [line: 8]			.   .   .   .   .   Child: 0  Id: N of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   .   .   .   Child: 1  Const 10 of type int [line: 8]						.   .   .   .   .   Child: 1  Const 10 of type int [line: 8]
.   .   .   .   Child: 1  Const 3 of type int [line: 8]							.   .   .   .   Child: 1  Const 3 of type int [line: 8]
.   .   Sibling: 2  Assign: = of type int [line: 10]						   |	.   .   Sibling: 2  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 10]				.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 10]
.   .   .   Child: 1  Const 0 of type int [line: 10]							.   .   .   Child: 1  Const 0 of type int [line: 10]
.   .   Sibling: 3  While [line: 11]									.   .   Sibling: 3  While [line: 11]
.   .   .   Child: 0  Op: < of type bool [line: 11]							.   .   .   Child: 0  Op: < of type bool [line: 11]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 11]
.   .   .   .   Child: 1  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 11]			.   .   .   .   Child: 1  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 11]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 11]
.   .   .   .   Child: 1  Assign: = of type int [line: 12]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 12]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 341] [li	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 341] [li
.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line: 12]		.   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line: 12]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 12]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 12]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 13]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 13]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 13]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 13]
.   .   Sibling: 4  Assign: = of type int [line: 16]						   |	.   .   Sibling: 4  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size: 1] [line: 16]			.   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size: 1] [line: 16]
.   .   .   Child: 1  Const 0 of type int [line: 16]							.   .   .   Child: 1  Const 0 of type int [line: 16]
.   .   Sibling: 5  Assign: = of type int [line: 16]						   |	.   .   Sibling: 5  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size: 1] [line: 16]			.   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size: 1] [line: 16]
.   .   .   Child: 1  Const 0 of type int [line: 16]							.   .   .   Child: 1  Const 0 of type int [line: 16]
.   .   Sibling: 6  Assign: = of type int [line: 17]						   |	.   .   Sibling: 6  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 17]				.   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 17]
.   .   .   Child: 1  Const 0 of type int [line: 17]							.   .   .   Child: 1  Const 0 of type int [line: 17]
.   .   Sibling: 7  While [line: 18]									.   .   Sibling: 7  While [line: 18]
.   .   .   Child: 0  Op: < of type bool [line: 18]							.   .   .   Child: 0  Op: < of type bool [line: 18]
.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 18]
.   .   .   .   Child: 1  Id: N of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   Child: 1  Id: N of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 18]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 18]
.   .   .   .   Child: 1  Assign: = of type int [line: 19]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 19]
.   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 19]			.   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 19]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 19]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 19]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 20]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 20]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 20]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 20]
.   .   .   .   .   Child: 1  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 20]		.   .   .   .   .   Child: 1  Id: LEN of type int [mem: Local loc: -3 size: 1] [line: 20]
.   .   .   .   Sibling: 2  While [line: 21]								.   .   .   .   Sibling: 2  While [line: 21]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 21]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 21]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 21]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 21]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 22]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 22]
.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 22]		.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 22]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 22]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 22]
.   .   .   .   .   .   .   .   .   Child: 0  Const 10 of type int [line: 22]				.   .   .   .   .   .   .   .   .   Child: 0  Const 10 of type int [line: 22]
.   .   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 22]				.   .   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 22]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -1	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -1
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 22]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 22]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 22]					.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 22]
.   .   .   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [li
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 23]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 23]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 	.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 
.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]					.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   .   .   .   .   Child: 1  Op: % of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Op: % of type int [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]					.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]
.   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 23]				.   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 23]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 24]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 24]
.   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 24]		.   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 24]
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 24]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 24]
.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -8 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 24]					.   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 24]
.   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 24]				.   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 24]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 24]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 24]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 24]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 24]
.   .   .   .   .   .   Sibling: 3  Assign: -= of type int [line: 25]					.   .   .   .   .   .   Sibling: 3  Assign: -= of type int [line: 25]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 25]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 25]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 25]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 25]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 28]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 28]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 28]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 341] [li	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Local loc: -12 size: 341] [li
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 28]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 28]
.   .   .   .   .   Child: 1  Op: % of type int [line: 28]						.   .   .   .   .   Child: 1  Op: % of type int [line: 28]
.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]		.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]
.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 28]					.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 28]
.   .   .   .   Sibling: 4  Assign: = of type int [line: 28]					   |	.   .   .   .   Sibling: 4  Assign: := of type int [line: 28]
.   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]			.   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]
.   .   .   .   .   Child: 1  Op: / of type int [line: 28]						.   .   .   .   .   Child: 1  Op: / of type int [line: 28]
.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]		.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 28]
.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 28]					.   .   .   .   .   .   Child: 1  Const 10 of type int [line: 28]
.   .   .   .   Sibling: 5  If [line: 30]								.   .   .   .   Sibling: 5  If [line: 30]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 30]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 30]
.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 30]		.   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 30]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 30]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 30]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 30]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 30]
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 31]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 31]
.   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size: 1] [line: 
.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -352] [line: 33]				.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -352] [line: 33]
.   .   .   .   .   .   Child: 1  If [line: 34]								.   .   .   .   .   .   Child: 1  If [line: 34]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 34]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 34]
.   .   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: q of type int [mem: Local loc: -7 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 34]				.   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 34]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 34]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 34]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 35]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 35]				.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]
.   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 35]				.   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 35]
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 36]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 36]
.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size	.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 36]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 36]
.   .   .   .   .   .   .   .   Sibling: 3  While [line: 37]						.   .   .   .   .   .   .   .   Sibling: 3  While [line: 37]
.   .   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 37]				.   .   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 37]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 37]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 37]
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 37]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 37]
.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 38]			.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 38]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 0 of type int [line: 38]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 0 of type int [line: 38]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 38]			.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 38]
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: -- of type int [line: 39]			.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: -- of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 
.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -352] [line: 42]			.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -352] [line: 42]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 43]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 43]
.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size	.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size
.   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 43]				.   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 43]
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 44]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 44]
.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size	.   .   .   .   .   .   .   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size
.   .   .   .   .   .   .   .   .   Child: 1  Id: q of type int [mem: Local loc: -7 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: q of type int [mem: Local loc: -7 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 3  While [line: 45]						.   .   .   .   .   .   .   .   Sibling: 3  While [line: 45]
.   .   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 45]				.   .   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 45]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 45]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 45]
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 45]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -352] [line: 45]
.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 46]			.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 46]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 46]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 46]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 46]			.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 46]
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: -- of type int [line: 47]			.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: -- of type int [line: 47]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: nines of type int [mem: Local loc: -9 
.   .   .   .   Sibling: 6  Assign: ++ of type int [line: 51]						.   .   .   .   Sibling: 6  Assign: ++ of type int [line: 51]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 51]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -5 size: 1] [line: 51]
.   .   Sibling: 8  Call: output of type void [line: 53]						.   .   Sibling: 8  Call: output of type void [line: 53]
.   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size: 1] [line: 53]			.   .   .   Child: 0  Id: predigit of type int [mem: Local loc: -10 size: 1] [line: 53]
.   .   Sibling: 9  Call: outnl of type void [line: 54]							.   .   Sibling: 9  Call: outnl of type void [line: 54]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
pi.out ztmp23114.txt differ: byte 52, line 2
pi (Output DIFF)
WARNING(4): The variable 'k' seems not to be used.							WARNING(4): The variable 'k' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/pi.tm
Number of errors: 0										   |	0
------------------------------------								   |	3
Loading file: pi.tm										   |	1
												   >	4
												   >	1
												   >	5
												   >	9
												   >	2
												   >	6
												   >	5
												   >	3
												   >	5
												   >	8
												   >	9
												   >	7
												   >	9
												   >	3
												   >	2
												   >	3
												   >	8
												   >	4
												   >	6
												   >	2
												   >	6
												   >	4
												   >	3
												   >	3
												   >	8
												   >	3
												   >	2
												   >	7
												   >	9
												   >	5
												   >	0
												   >	2
												   >	8
												   >	8
												   >	4
												   >	1
												   >	9
												   >	7
												   >	1
												   >	6
												   >	9
												   >	3
												   >	9
												   >	9
												   >	3
												   >	7
												   >	5
												   >	1
												   >	0
												   >	5
												   >	8
												   >	2
												   >	0
												   >	9
												   >	7
												   >	4
												   >	9
												   >	4
												   >	4
												   >	5
												   >	9
												   >	2
												   >	3
												   >	0
												   >	7
												   >	8
												   >	1
												   >	6
												   >	4
												   >	0
												   >	6
												   >	2
												   >	8
												   >	6
												   >	2
												   >	0
												   >	8
												   >	9
												   >	9
												   >	8
												   >	6
												   >	2
												   >	8
												   >	0
												   >	3
												   >	4
												   >	8
												   >	2
												   >	5
												   >	3
												   >	4
												   >	2
												   >	1
												   >	1
												   >	7
												   >	0
												   >	6
												   >	7
Bye.													Bye.
====================================
FILE: poker.c-
-rw-------. 1 corg7983 domain_users  2980 Nov 17 15:35 poker.c-
-rw-------. 1 corg7983 domain_users  2980 Nov 17 15:35 poker.c-.f21
-rw-------. 1 corg7983 domain_users  2980 Nov 17 15:35 poker.c-.f22
-rw-------. 1 corg7983 domain_users   162 Nov 17 15:35 poker.expected
-rw-------. 1 corg7983 domain_users    19 Nov 17 15:35 poker.in
-rw-------. 1 corg7983 domain_users 37866 Nov 22 12:27 poker.mem
-rw-------. 1 corg7983 domain_users  5556 Nov 17 15:35 poker.mem.diffs
-rw-------. 1 corg7983 domain_users 38714 Nov 17 15:35 poker.mem.f21
-rw-------. 1 corg7983 domain_users   107 Nov 22 12:27 poker.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 poker.tm
-rw-------. 1 corg7983 domain_users  1363 Nov 17 15:35 poker.tm.diffs
-rw-------. 1 corg7983 domain_users 55587 Nov 17 15:35 poker.tm.f21
TM CODE COMPARISON
poker (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  poker.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION suit
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	 40:     LD  3,-2(1)	Load variable c
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:     LD  3,0(0)	Load variable numSuits
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    MOD  3,4,3	Op % 
												   >	 45:    LDA  2,0(3)	Copy result to return register 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 49:    LDC  2,0(6)	Set return value to 0 
												   >	 50:     LD  3,-1(1)	Load return address 
												   >	 51:     LD  1,0(1)	Adjust fp 
												   >	 52:    JMP  7,0(3)	Return 
												   >	* END FUNCTION suit
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION pips
												   >	* TOFF set: -3
												   >	 53:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	 54:     LD  3,-2(1)	Load variable c
												   >	 55:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 56:     LD  3,0(0)	Load variable numSuits
												   >	* TOFF inc: -3
												   >	 57:     LD  4,-3(1)	Pop left into ac1 
												   >	 58:    DIV  3,4,3	Op / 
												   >	 59:    LDA  2,0(3)	Copy result to return register 
												   >	 60:     LD  3,-1(1)	Load return address 
												   >	 61:     LD  1,0(1)	Adjust fp 
												   >	 62:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 63:    LDC  2,0(6)	Set return value to 0 
												   >	 64:     LD  3,-1(1)	Load return address 
												   >	 65:     LD  1,0(1)	Adjust fp 
												   >	 66:    JMP  7,0(3)	Return 
												   >	* END FUNCTION pips
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION p
												   >	* TOFF set: -4
												   >	 67:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	* CALL pips
												   >	 68:     ST  1,-4(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 69:     LD  3,-2(1)	Load variable a
												   >	 70:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end pips
												   >	 71:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 72:    LDA  3,1(7)	Return address in ac 
												   >	 73:    JMP  7,-21(7)	CALL pips
												   >	 74:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -4
												   >	 75:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	* CALL pips
												   >	 76:     ST  1,-5(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 77:     LD  3,-3(1)	Load variable b
												   >	 78:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end pips
												   >	 79:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 80:    LDA  3,1(7)	Return address in ac 
												   >	 81:    JMP  7,-29(7)	CALL pips
												   >	 82:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -5
												   >	* TOFF inc: -4
												   >	 83:     LD  4,-4(1)	Pop left into ac1 
												   >	 84:    TEQ  3,4,3	Op = 
												   >	 85:    LDA  2,0(3)	Copy result to return register 
												   >	 86:     LD  3,-1(1)	Load return address 
												   >	 87:     LD  1,0(1)	Adjust fp 
												   >	 88:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 89:    LDC  2,0(6)	Set return value to 0 
												   >	 90:     LD  3,-1(1)	Load return address 
												   >	 91:     LD  1,0(1)	Adjust fp 
												   >	 92:    JMP  7,0(3)	Return 
												   >	* END FUNCTION p
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION ppp
												   >	* TOFF set: -5
												   >	 93:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* RETURN
												   >	* CALL p
												   >	 94:     ST  1,-5(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 95:     LD  3,-2(1)	Load variable a
												   >	 96:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	 97:     LD  3,-3(1)	Load variable b
												   >	 98:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end p
												   >	 99:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-35(7)	CALL p
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -5
												   >	103:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	* CALL p
												   >	104:     ST  1,-6(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	105:     LD  3,-3(1)	Load variable b
												   >	106:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	107:     LD  3,-4(1)	Load variable c
												   >	108:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end p
												   >	109:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-45(7)	CALL p
												   >	112:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -6
												   >	* TOFF inc: -5
												   >	113:     LD  4,-5(1)	Pop left into ac1 
												   >	114:    AND  3,4,3	Op AND 
												   >	115:    LDA  2,0(3)	Copy result to return register 
												   >	116:     LD  3,-1(1)	Load return address 
												   >	117:     LD  1,0(1)	Adjust fp 
												   >	118:    JMP  7,0(3)	Return 
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	119:    LDC  2,0(6)	Set return value to 0 
												   >	120:     LD  3,-1(1)	Load return address 
												   >	121:     LD  1,0(1)	Adjust fp 
												   >	122:    JMP  7,0(3)	Return 
												   >	* END FUNCTION ppp
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION pppp
												   >	* TOFF set: -6
												   >	123:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* RETURN
												   >	* CALL p
												   >	124:     ST  1,-6(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	125:     LD  3,-2(1)	Load variable a
												   >	126:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	127:     LD  3,-3(1)	Load variable b
												   >	128:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end p
												   >	129:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	130:    LDA  3,1(7)	Return address in ac 
												   >	131:    JMP  7,-65(7)	CALL p
												   >	132:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -6
												   >	133:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL p
												   >	134:     ST  1,-7(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	135:     LD  3,-3(1)	Load variable b
												   >	136:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	137:     LD  3,-4(1)	Load variable c
												   >	138:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end p
												   >	139:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	140:    LDA  3,1(7)	Return address in ac 
												   >	141:    JMP  7,-75(7)	CALL p
												   >	142:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	143:     LD  4,-6(1)	Pop left into ac1 
												   >	144:    AND  3,4,3	Op AND 
												   >	145:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL p
												   >	146:     ST  1,-7(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	147:     LD  3,-4(1)	Load variable c
												   >	148:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	149:     LD  3,-5(1)	Load variable d
												   >	150:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end p
												   >	151:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	152:    LDA  3,1(7)	Return address in ac 
												   >	153:    JMP  7,-87(7)	CALL p
												   >	154:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	155:     LD  4,-6(1)	Pop left into ac1 
												   >	156:    AND  3,4,3	Op AND 
												   >	157:    LDA  2,0(3)	Copy result to return register 
												   >	158:     LD  3,-1(1)	Load return address 
												   >	159:     LD  1,0(1)	Adjust fp 
												   >	160:    JMP  7,0(3)	Return 
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	161:    LDC  2,0(6)	Set return value to 0 
												   >	162:     LD  3,-1(1)	Load return address 
												   >	163:     LD  1,0(1)	Adjust fp 
												   >	164:    JMP  7,0(3)	Return 
												   >	* END FUNCTION pppp
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION handtype
												   >	* TOFF set: -7
												   >	165:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL suit
												   >	166:     ST  1,-8(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	167:     LD  3,-2(1)	Load variable a
												   >	168:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end suit
												   >	169:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	170:    LDA  3,1(7)	Return address in ac 
												   >	171:    JMP  7,-133(7)	CALL suit
												   >	172:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -8
												   >	173:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL suit
												   >	174:     ST  1,-9(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	175:     LD  3,-3(1)	Load variable b
												   >	176:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end suit
												   >	177:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	178:    LDA  3,1(7)	Return address in ac 
												   >	179:    JMP  7,-141(7)	CALL suit
												   >	180:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	181:     LD  4,-8(1)	Pop left into ac1 
												   >	182:    TEQ  3,4,3	Op = 
												   >	183:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL suit
												   >	184:     ST  1,-9(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	185:     LD  3,-2(1)	Load variable a
												   >	186:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end suit
												   >	187:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-151(7)	CALL suit
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -9
												   >	191:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL suit
												   >	192:     ST  1,-10(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	193:     LD  3,-4(1)	Load variable c
												   >	194:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end suit
												   >	195:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	196:    LDA  3,1(7)	Return address in ac 
												   >	197:    JMP  7,-159(7)	CALL suit
												   >	198:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	199:     LD  4,-9(1)	Pop left into ac1 
												   >	200:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	201:     LD  4,-8(1)	Pop left into ac1 
												   >	202:    AND  3,4,3	Op AND 
												   >	203:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL suit
												   >	204:     ST  1,-9(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	205:     LD  3,-2(1)	Load variable a
												   >	206:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end suit
												   >	207:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	208:    LDA  3,1(7)	Return address in ac 
												   >	209:    JMP  7,-171(7)	CALL suit
												   >	210:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -9
												   >	211:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL suit
												   >	212:     ST  1,-10(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	213:     LD  3,-5(1)	Load variable d
												   >	214:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end suit
												   >	215:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	216:    LDA  3,1(7)	Return address in ac 
												   >	217:    JMP  7,-179(7)	CALL suit
												   >	218:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	219:     LD  4,-9(1)	Pop left into ac1 
												   >	220:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	221:     LD  4,-8(1)	Pop left into ac1 
												   >	222:    AND  3,4,3	Op AND 
												   >	223:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL suit
												   >	224:     ST  1,-9(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	225:     LD  3,-2(1)	Load variable a
												   >	226:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end suit
												   >	227:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	228:    LDA  3,1(7)	Return address in ac 
												   >	229:    JMP  7,-191(7)	CALL suit
												   >	230:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -9
												   >	231:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL suit
												   >	232:     ST  1,-10(1)	Store fp in ghost frame for suit
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	233:     LD  3,-6(1)	Load variable e
												   >	234:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end suit
												   >	235:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	236:    LDA  3,1(7)	Return address in ac 
												   >	237:    JMP  7,-199(7)	CALL suit
												   >	238:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end suit
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	239:     LD  4,-9(1)	Pop left into ac1 
												   >	240:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	241:     LD  4,-8(1)	Pop left into ac1 
												   >	242:    AND  3,4,3	Op AND 
												   >	243:     ST  3,-7(1)	Store variable isflush
												   >	* IF
												   >	244:     LD  3,-7(1)	Load variable isflush
												   >	245:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	246:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	247:     LD  3,-2(1)	Load variable a
												   >	248:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	249:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	250:    LDA  3,1(7)	Return address in ac 
												   >	251:    JMP  7,-199(7)	CALL pips
												   >	252:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	253:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	254:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	255:     LD  4,-9(1)	Pop left into ac1 
												   >	256:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	257:     LD  4,-8(1)	Pop left into ac1 
												   >	258:    AND  3,4,3	Op AND 
												   >	259:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	260:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	261:     LD  3,-3(1)	Load variable b
												   >	262:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	263:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	264:    LDA  3,1(7)	Return address in ac 
												   >	265:    JMP  7,-213(7)	CALL pips
												   >	266:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	267:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	268:     LD  3,-1(0)	Load variable numPips
												   >	269:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	270:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	271:     LD  4,-10(1)	Pop left into ac1 
												   >	272:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	273:     LD  4,-9(1)	Pop left into ac1 
												   >	274:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	275:     LD  4,-8(1)	Pop left into ac1 
												   >	276:    AND  3,4,3	Op AND 
												   >	277:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	278:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	279:     LD  3,-6(1)	Load variable e
												   >	280:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	281:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	282:    LDA  3,1(7)	Return address in ac 
												   >	283:    JMP  7,-231(7)	CALL pips
												   >	284:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	285:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	286:     LD  3,-1(0)	Load variable numPips
												   >	287:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	288:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	289:     LD  4,-10(1)	Pop left into ac1 
												   >	290:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	291:     LD  4,-9(1)	Pop left into ac1 
												   >	292:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	293:     LD  4,-8(1)	Pop left into ac1 
												   >	294:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* RETURN
												   >	296:    LDC  3,0(6)	Load integer constant 
												   >	297:    LDA  2,0(3)	Copy result to return register 
												   >	298:     LD  3,-1(1)	Load return address 
												   >	299:     LD  1,0(1)	Adjust fp 
												   >	300:    JMP  7,0(3)	Return 
												   >	295:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	302:     LD  3,-7(1)	Load variable isflush
												   >	303:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	304:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	305:     LD  3,-2(1)	Load variable a
												   >	306:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	307:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	308:    LDA  3,1(7)	Return address in ac 
												   >	309:    JMP  7,-257(7)	CALL pips
												   >	310:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	311:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	312:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	313:     LD  3,-6(1)	Load variable e
												   >	314:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	315:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	316:    LDA  3,1(7)	Return address in ac 
												   >	317:    JMP  7,-265(7)	CALL pips
												   >	318:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	319:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	320:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	321:     LD  4,-10(1)	Pop left into ac1 
												   >	322:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	323:     LD  4,-9(1)	Pop left into ac1 
												   >	324:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	325:     LD  4,-8(1)	Pop left into ac1 
												   >	326:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* RETURN
												   >	328:    LDC  3,1(6)	Load integer constant 
												   >	329:    LDA  2,0(3)	Copy result to return register 
												   >	330:     LD  3,-1(1)	Load return address 
												   >	331:     LD  1,0(1)	Adjust fp 
												   >	332:    JMP  7,0(3)	Return 
												   >	327:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL pppp
												   >	334:     ST  1,-8(1)	Store fp in ghost frame for pppp
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	335:     LD  3,-2(1)	Load variable a
												   >	336:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	337:     LD  3,-3(1)	Load variable b
												   >	338:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	339:     LD  3,-4(1)	Load variable c
												   >	340:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 4
												   >	341:     LD  3,-5(1)	Load variable d
												   >	342:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end pppp
												   >	343:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	344:    LDA  3,1(7)	Return address in ac 
												   >	345:    JMP  7,-223(7)	CALL pppp
												   >	346:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pppp
												   >	* TOFF set: -8
												   >	347:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pppp
												   >	348:     ST  1,-9(1)	Store fp in ghost frame for pppp
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	349:     LD  3,-3(1)	Load variable b
												   >	350:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	351:     LD  3,-4(1)	Load variable c
												   >	352:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 3
												   >	353:     LD  3,-5(1)	Load variable d
												   >	354:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param 4
												   >	355:     LD  3,-6(1)	Load variable e
												   >	356:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end pppp
												   >	357:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	358:    LDA  3,1(7)	Return address in ac 
												   >	359:    JMP  7,-237(7)	CALL pppp
												   >	360:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pppp
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	361:     LD  4,-8(1)	Pop left into ac1 
												   >	362:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	364:    LDC  3,2(6)	Load integer constant 
												   >	365:    LDA  2,0(3)	Copy result to return register 
												   >	366:     LD  3,-1(1)	Load return address 
												   >	367:     LD  1,0(1)	Adjust fp 
												   >	368:    JMP  7,0(3)	Return 
												   >	363:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL ppp
												   >	370:     ST  1,-8(1)	Store fp in ghost frame for ppp
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	371:     LD  3,-2(1)	Load variable a
												   >	372:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	373:     LD  3,-3(1)	Load variable b
												   >	374:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	375:     LD  3,-4(1)	Load variable c
												   >	376:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end ppp
												   >	377:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	378:    LDA  3,1(7)	Return address in ac 
												   >	379:    JMP  7,-287(7)	CALL ppp
												   >	380:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ppp
												   >	* TOFF set: -8
												   >	381:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	382:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	383:     LD  3,-5(1)	Load variable d
												   >	384:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	385:     LD  3,-6(1)	Load variable e
												   >	386:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	387:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	388:    LDA  3,1(7)	Return address in ac 
												   >	389:    JMP  7,-323(7)	CALL p
												   >	390:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	391:     LD  4,-8(1)	Pop left into ac1 
												   >	392:    AND  3,4,3	Op AND 
												   >	393:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	394:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	395:     LD  3,-2(1)	Load variable a
												   >	396:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	397:     LD  3,-3(1)	Load variable b
												   >	398:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	399:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	400:    LDA  3,1(7)	Return address in ac 
												   >	401:    JMP  7,-335(7)	CALL p
												   >	402:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	403:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL ppp
												   >	404:     ST  1,-10(1)	Store fp in ghost frame for ppp
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	405:     LD  3,-4(1)	Load variable c
												   >	406:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 2
												   >	407:     LD  3,-5(1)	Load variable d
												   >	408:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param 3
												   >	409:     LD  3,-6(1)	Load variable e
												   >	410:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end ppp
												   >	411:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	412:    LDA  3,1(7)	Return address in ac 
												   >	413:    JMP  7,-321(7)	CALL ppp
												   >	414:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ppp
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	415:     LD  4,-9(1)	Pop left into ac1 
												   >	416:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	417:     LD  4,-8(1)	Pop left into ac1 
												   >	418:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	420:    LDC  3,3(6)	Load integer constant 
												   >	421:    LDA  2,0(3)	Copy result to return register 
												   >	422:     LD  3,-1(1)	Load return address 
												   >	423:     LD  1,0(1)	Adjust fp 
												   >	424:    JMP  7,0(3)	Return 
												   >	419:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	426:     LD  3,-7(1)	Load variable isflush
												   >	* THEN
												   >	* RETURN
												   >	428:    LDC  3,4(6)	Load integer constant 
												   >	429:    LDA  2,0(3)	Copy result to return register 
												   >	430:     LD  3,-1(1)	Load return address 
												   >	431:     LD  1,0(1)	Adjust fp 
												   >	432:    JMP  7,0(3)	Return 
												   >	427:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL pips
												   >	434:     ST  1,-8(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	435:     LD  3,-2(1)	Load variable a
												   >	436:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end pips
												   >	437:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	438:    LDA  3,1(7)	Return address in ac 
												   >	439:    JMP  7,-387(7)	CALL pips
												   >	440:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -8
												   >	441:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	442:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	443:     LD  3,-3(1)	Load variable b
												   >	444:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	445:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	446:    LDA  3,1(7)	Return address in ac 
												   >	447:    JMP  7,-395(7)	CALL pips
												   >	448:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	449:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	450:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	451:     LD  4,-9(1)	Pop left into ac1 
												   >	452:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -8
												   >	453:     LD  4,-8(1)	Pop left into ac1 
												   >	454:    TEQ  3,4,3	Op = 
												   >	455:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	456:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	457:     LD  3,-3(1)	Load variable b
												   >	458:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	459:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	460:    LDA  3,1(7)	Return address in ac 
												   >	461:    JMP  7,-409(7)	CALL pips
												   >	462:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	463:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	464:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	465:     LD  3,-4(1)	Load variable c
												   >	466:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	467:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	468:    LDA  3,1(7)	Return address in ac 
												   >	469:    JMP  7,-417(7)	CALL pips
												   >	470:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	471:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	472:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	473:     LD  4,-10(1)	Pop left into ac1 
												   >	474:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	475:     LD  4,-9(1)	Pop left into ac1 
												   >	476:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	477:     LD  4,-8(1)	Pop left into ac1 
												   >	478:    AND  3,4,3	Op AND 
												   >	479:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	480:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	481:     LD  3,-4(1)	Load variable c
												   >	482:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	483:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	484:    LDA  3,1(7)	Return address in ac 
												   >	485:    JMP  7,-433(7)	CALL pips
												   >	486:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	487:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	488:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	489:     LD  3,-5(1)	Load variable d
												   >	490:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	491:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	492:    LDA  3,1(7)	Return address in ac 
												   >	493:    JMP  7,-441(7)	CALL pips
												   >	494:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	495:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	496:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	497:     LD  4,-10(1)	Pop left into ac1 
												   >	498:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	499:     LD  4,-9(1)	Pop left into ac1 
												   >	500:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	501:     LD  4,-8(1)	Pop left into ac1 
												   >	502:    AND  3,4,3	Op AND 
												   >	503:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	504:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	505:     LD  3,-5(1)	Load variable d
												   >	506:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	507:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	508:    LDA  3,1(7)	Return address in ac 
												   >	509:    JMP  7,-457(7)	CALL pips
												   >	510:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	511:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	512:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	513:     LD  3,-6(1)	Load variable e
												   >	514:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	515:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	516:    LDA  3,1(7)	Return address in ac 
												   >	517:    JMP  7,-465(7)	CALL pips
												   >	518:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	519:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	520:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	521:     LD  4,-10(1)	Pop left into ac1 
												   >	522:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -9
												   >	523:     LD  4,-9(1)	Pop left into ac1 
												   >	524:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -8
												   >	525:     LD  4,-8(1)	Pop left into ac1 
												   >	526:    AND  3,4,3	Op AND 
												   >	527:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL pips
												   >	528:     ST  1,-9(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	529:     LD  3,-2(1)	Load variable a
												   >	530:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end pips
												   >	531:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	532:    LDA  3,1(7)	Return address in ac 
												   >	533:    JMP  7,-481(7)	CALL pips
												   >	534:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -9
												   >	535:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	536:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	537:     LD  4,-9(1)	Pop left into ac1 
												   >	538:    TEQ  3,4,3	Op = 
												   >	539:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	540:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	541:     LD  3,-3(1)	Load variable b
												   >	542:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	543:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	544:    LDA  3,1(7)	Return address in ac 
												   >	545:    JMP  7,-493(7)	CALL pips
												   >	546:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	547:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	548:     LD  3,-1(0)	Load variable numPips
												   >	549:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	550:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	551:     LD  4,-11(1)	Pop left into ac1 
												   >	552:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -10
												   >	553:     LD  4,-10(1)	Pop left into ac1 
												   >	554:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -9
												   >	555:     LD  4,-9(1)	Pop left into ac1 
												   >	556:    AND  3,4,3	Op AND 
												   >	557:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	558:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	559:     LD  3,-4(1)	Load variable c
												   >	560:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	561:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	562:    LDA  3,1(7)	Return address in ac 
												   >	563:    JMP  7,-511(7)	CALL pips
												   >	564:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	565:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	566:     LD  3,-1(0)	Load variable numPips
												   >	567:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	568:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	569:     LD  4,-11(1)	Pop left into ac1 
												   >	570:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -10
												   >	571:     LD  4,-10(1)	Pop left into ac1 
												   >	572:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -9
												   >	573:     LD  4,-9(1)	Pop left into ac1 
												   >	574:    AND  3,4,3	Op AND 
												   >	575:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	576:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	577:     LD  3,-5(1)	Load variable d
												   >	578:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	579:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	580:    LDA  3,1(7)	Return address in ac 
												   >	581:    JMP  7,-529(7)	CALL pips
												   >	582:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	583:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	584:     LD  3,-1(0)	Load variable numPips
												   >	585:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	586:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	587:     LD  4,-11(1)	Pop left into ac1 
												   >	588:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -10
												   >	589:     LD  4,-10(1)	Pop left into ac1 
												   >	590:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -9
												   >	591:     LD  4,-9(1)	Pop left into ac1 
												   >	592:    AND  3,4,3	Op AND 
												   >	593:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL pips
												   >	594:     ST  1,-10(1)	Store fp in ghost frame for pips
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	595:     LD  3,-6(1)	Load variable e
												   >	596:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end pips
												   >	597:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	598:    LDA  3,1(7)	Return address in ac 
												   >	599:    JMP  7,-547(7)	CALL pips
												   >	600:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pips
												   >	* TOFF set: -10
												   >	601:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	602:     LD  3,-1(0)	Load variable numPips
												   >	603:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	604:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	605:     LD  4,-11(1)	Pop left into ac1 
												   >	606:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -10
												   >	607:     LD  4,-10(1)	Pop left into ac1 
												   >	608:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -9
												   >	609:     LD  4,-9(1)	Pop left into ac1 
												   >	610:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	611:     LD  4,-8(1)	Pop left into ac1 
												   >	612:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	614:    LDC  3,5(6)	Load integer constant 
												   >	615:    LDA  2,0(3)	Copy result to return register 
												   >	616:     LD  3,-1(1)	Load return address 
												   >	617:     LD  1,0(1)	Adjust fp 
												   >	618:    JMP  7,0(3)	Return 
												   >	613:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL ppp
												   >	620:     ST  1,-8(1)	Store fp in ghost frame for ppp
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	621:     LD  3,-2(1)	Load variable a
												   >	622:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	623:     LD  3,-3(1)	Load variable b
												   >	624:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	625:     LD  3,-4(1)	Load variable c
												   >	626:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end ppp
												   >	627:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	628:    LDA  3,1(7)	Return address in ac 
												   >	629:    JMP  7,-537(7)	CALL ppp
												   >	630:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ppp
												   >	* TOFF set: -8
												   >	631:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL ppp
												   >	632:     ST  1,-9(1)	Store fp in ghost frame for ppp
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	633:     LD  3,-3(1)	Load variable b
												   >	634:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	635:     LD  3,-4(1)	Load variable c
												   >	636:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 3
												   >	637:     LD  3,-5(1)	Load variable d
												   >	638:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end ppp
												   >	639:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	640:    LDA  3,1(7)	Return address in ac 
												   >	641:    JMP  7,-549(7)	CALL ppp
												   >	642:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ppp
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	643:     LD  4,-8(1)	Pop left into ac1 
												   >	644:     OR  3,4,3	Op OR 
												   >	645:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL ppp
												   >	646:     ST  1,-9(1)	Store fp in ghost frame for ppp
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	647:     LD  3,-4(1)	Load variable c
												   >	648:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	649:     LD  3,-5(1)	Load variable d
												   >	650:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 3
												   >	651:     LD  3,-6(1)	Load variable e
												   >	652:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end ppp
												   >	653:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	654:    LDA  3,1(7)	Return address in ac 
												   >	655:    JMP  7,-563(7)	CALL ppp
												   >	656:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ppp
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	657:     LD  4,-8(1)	Pop left into ac1 
												   >	658:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	660:    LDC  3,6(6)	Load integer constant 
												   >	661:    LDA  2,0(3)	Copy result to return register 
												   >	662:     LD  3,-1(1)	Load return address 
												   >	663:     LD  1,0(1)	Adjust fp 
												   >	664:    JMP  7,0(3)	Return 
												   >	659:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL p
												   >	666:     ST  1,-8(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	667:     LD  3,-2(1)	Load variable a
												   >	668:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	669:     LD  3,-3(1)	Load variable b
												   >	670:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end p
												   >	671:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	672:    LDA  3,1(7)	Return address in ac 
												   >	673:    JMP  7,-607(7)	CALL p
												   >	674:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -8
												   >	675:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	676:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	677:     LD  3,-4(1)	Load variable c
												   >	678:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	679:     LD  3,-5(1)	Load variable d
												   >	680:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	681:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	682:    LDA  3,1(7)	Return address in ac 
												   >	683:    JMP  7,-617(7)	CALL p
												   >	684:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	685:     LD  4,-8(1)	Pop left into ac1 
												   >	686:    AND  3,4,3	Op AND 
												   >	687:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	688:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	689:     LD  3,-2(1)	Load variable a
												   >	690:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	691:     LD  3,-3(1)	Load variable b
												   >	692:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	693:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	694:    LDA  3,1(7)	Return address in ac 
												   >	695:    JMP  7,-629(7)	CALL p
												   >	696:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	697:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL p
												   >	698:     ST  1,-10(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	699:     LD  3,-5(1)	Load variable d
												   >	700:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 2
												   >	701:     LD  3,-6(1)	Load variable e
												   >	702:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end p
												   >	703:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	704:    LDA  3,1(7)	Return address in ac 
												   >	705:    JMP  7,-639(7)	CALL p
												   >	706:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	707:     LD  4,-9(1)	Pop left into ac1 
												   >	708:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	709:     LD  4,-8(1)	Pop left into ac1 
												   >	710:     OR  3,4,3	Op OR 
												   >	711:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	712:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	713:     LD  3,-3(1)	Load variable b
												   >	714:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	715:     LD  3,-4(1)	Load variable c
												   >	716:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	717:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	718:    LDA  3,1(7)	Return address in ac 
												   >	719:    JMP  7,-653(7)	CALL p
												   >	720:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	721:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	* CALL p
												   >	722:     ST  1,-10(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	723:     LD  3,-5(1)	Load variable d
												   >	724:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 2
												   >	725:     LD  3,-6(1)	Load variable e
												   >	726:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end p
												   >	727:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	728:    LDA  3,1(7)	Return address in ac 
												   >	729:    JMP  7,-663(7)	CALL p
												   >	730:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -10
												   >	* TOFF inc: -9
												   >	731:     LD  4,-9(1)	Pop left into ac1 
												   >	732:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -8
												   >	733:     LD  4,-8(1)	Pop left into ac1 
												   >	734:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	736:    LDC  3,7(6)	Load integer constant 
												   >	737:    LDA  2,0(3)	Copy result to return register 
												   >	738:     LD  3,-1(1)	Load return address 
												   >	739:     LD  1,0(1)	Adjust fp 
												   >	740:    JMP  7,0(3)	Return 
												   >	735:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	* CALL p
												   >	742:     ST  1,-8(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	743:     LD  3,-2(1)	Load variable a
												   >	744:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	745:     LD  3,-3(1)	Load variable b
												   >	746:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end p
												   >	747:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	748:    LDA  3,1(7)	Return address in ac 
												   >	749:    JMP  7,-683(7)	CALL p
												   >	750:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -8
												   >	751:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	752:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	753:     LD  3,-3(1)	Load variable b
												   >	754:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	755:     LD  3,-4(1)	Load variable c
												   >	756:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	757:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	758:    LDA  3,1(7)	Return address in ac 
												   >	759:    JMP  7,-693(7)	CALL p
												   >	760:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	761:     LD  4,-8(1)	Pop left into ac1 
												   >	762:     OR  3,4,3	Op OR 
												   >	763:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	764:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	765:     LD  3,-4(1)	Load variable c
												   >	766:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	767:     LD  3,-5(1)	Load variable d
												   >	768:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	769:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	770:    LDA  3,1(7)	Return address in ac 
												   >	771:    JMP  7,-705(7)	CALL p
												   >	772:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	773:     LD  4,-8(1)	Pop left into ac1 
												   >	774:     OR  3,4,3	Op OR 
												   >	775:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	* CALL p
												   >	776:     ST  1,-9(1)	Store fp in ghost frame for p
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	777:     LD  3,-5(1)	Load variable d
												   >	778:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	779:     LD  3,-6(1)	Load variable e
												   >	780:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end p
												   >	781:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	782:    LDA  3,1(7)	Return address in ac 
												   >	783:    JMP  7,-717(7)	CALL p
												   >	784:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end p
												   >	* TOFF set: -9
												   >	* TOFF inc: -8
												   >	785:     LD  4,-8(1)	Pop left into ac1 
												   >	786:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* RETURN
												   >	788:    LDC  3,8(6)	Load integer constant 
												   >	789:    LDA  2,0(3)	Copy result to return register 
												   >	790:     LD  3,-1(1)	Load return address 
												   >	791:     LD  1,0(1)	Adjust fp 
												   >	792:    JMP  7,0(3)	Return 
												   >	787:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	794:    LDC  3,9(6)	Load integer constant 
												   >	795:    LDA  2,0(3)	Copy result to return register 
												   >	796:     LD  3,-1(1)	Load return address 
												   >	797:     LD  1,0(1)	Adjust fp 
												   >	798:    JMP  7,0(3)	Return 
												   >	793:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	741:    JMP  7,57(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	665:    JMP  7,133(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	619:    JMP  7,179(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	433:    JMP  7,365(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	425:    JMP  7,373(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	369:    JMP  7,429(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	333:    JMP  7,465(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	301:    JMP  7,497(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -7
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	799:    LDC  2,0(6)	Set return value to 0 
												   >	800:     LD  3,-1(1)	Load return address 
												   >	801:     LD  1,0(1)	Adjust fp 
												   >	802:    JMP  7,0(3)	Return 
												   >	* END FUNCTION handtype
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	803:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	804:    LDC  3,10(6)	load size of array hands
												   >	805:     ST  3,-2(1)	save size of array hands
												   >	* Compound Body
												   >	* EXPRESSION
												   >	806:    LDC  3,0(6)	Load integer constant 
												   >	807:     ST  3,-20(1)	Store variable i
												   >	* WHILE
												   >	808:     LD  3,-20(1)	Load variable i
												   >	809:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	810:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	811:     LD  4,-21(1)	Pop left into ac1 
												   >	812:    TLT  3,4,3	Op < 
												   >	813:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	815:     LD  3,-20(1)	Load variable i
												   >	816:     ST  3,-21(1)	Push index 
												   >	* TOFF dec: -22
												   >	817:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	818:     LD  4,-21(1)	Pop index 
												   >	819:    LDA  5,-3(1)	Load address of base of array hands
												   >	820:    SUB  5,5,4	Compute offset of value 
												   >	821:     ST  3,0(5)	Store variable hands
												   >	* EXPRESSION
												   >	822:     LD  3,-20(1)	Load variable i
												   >	823:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	824:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	825:     LD  4,-21(1)	Pop left into ac1 
												   >	826:    ADD  3,4,3	Op + 
												   >	827:     ST  3,-20(1)	Store variable i
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	828:    JMP  7,-21(7)	go to beginning of loop 
												   >	814:    JMP  7,14(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	829:    LDC  3,4(6)	Load integer constant 
												   >	830:     ST  3,0(0)	Store variable numSuits
												   >	* EXPRESSION
												   >	831:    LDC  3,6(6)	Load integer constant 
												   >	832:     ST  3,-1(0)	Store variable numPips
												   >	* EXPRESSION
												   >	833:     LD  3,-1(0)	Load variable numPips
												   >	834:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	835:     LD  3,0(0)	Load variable numSuits
												   >	* TOFF inc: -21
												   >	836:     LD  4,-21(1)	Pop left into ac1 
												   >	837:    MUL  3,4,3	Op * 
												   >	838:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	839:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	840:     LD  4,-21(1)	Pop left into ac1 
												   >	841:    SUB  3,4,3	Op - 
												   >	842:     ST  3,-2(0)	Store variable numCards
												   >	* EXPRESSION
												   >	843:    LDC  3,0(6)	Load integer constant 
												   >	844:     ST  3,-19(1)	Store variable possible
												   >	* EXPRESSION
												   >	845:    LDC  3,0(6)	Load integer constant 
												   >	846:     ST  3,-13(1)	Store variable a
												   >	* WHILE
												   >	847:     LD  3,-13(1)	Load variable a
												   >	848:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	849:     LD  3,-2(0)	Load variable numCards
												   >	* TOFF inc: -21
												   >	850:     LD  4,-21(1)	Pop left into ac1 
												   >	851:    TLE  3,4,3	Op <= 
												   >	852:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	854:     ST  1,-21(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param 1
												   >	855:     LD  3,-13(1)	Load variable a
												   >	856:     ST  3,-23(1)	Push parameter 
												   >	* TOFF dec: -24
												   >	* Param end output
												   >	857:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	858:    LDA  3,1(7)	Return address in ac 
												   >	859:    JMP  7,-854(7)	CALL output
												   >	860:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -21
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	861:     ST  1,-21(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param end outnl
												   >	862:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	863:    LDA  3,1(7)	Return address in ac 
												   >	864:    JMP  7,-831(7)	CALL outnl
												   >	865:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -21
												   >	* EXPRESSION
												   >	866:     LD  3,-13(1)	Load variable a
												   >	867:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	868:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	869:     LD  4,-21(1)	Pop left into ac1 
												   >	870:    ADD  3,4,3	Op + 
												   >	871:     ST  3,-14(1)	Store variable b
												   >	* WHILE
												   >	872:     LD  3,-14(1)	Load variable b
												   >	873:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	874:     LD  3,-2(0)	Load variable numCards
												   >	* TOFF inc: -21
												   >	875:     LD  4,-21(1)	Pop left into ac1 
												   >	876:    TLE  3,4,3	Op <= 
												   >	877:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	879:     LD  3,-14(1)	Load variable b
												   >	880:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	881:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	882:     LD  4,-21(1)	Pop left into ac1 
												   >	883:    ADD  3,4,3	Op + 
												   >	884:     ST  3,-15(1)	Store variable c
												   >	* WHILE
												   >	885:     LD  3,-15(1)	Load variable c
												   >	886:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	887:     LD  3,-2(0)	Load variable numCards
												   >	* TOFF inc: -21
												   >	888:     LD  4,-21(1)	Pop left into ac1 
												   >	889:    TLE  3,4,3	Op <= 
												   >	890:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	892:     LD  3,-15(1)	Load variable c
												   >	893:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	894:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	895:     LD  4,-21(1)	Pop left into ac1 
												   >	896:    ADD  3,4,3	Op + 
												   >	897:     ST  3,-16(1)	Store variable d
												   >	* WHILE
												   >	898:     LD  3,-16(1)	Load variable d
												   >	899:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	900:     LD  3,-2(0)	Load variable numCards
												   >	* TOFF inc: -21
												   >	901:     LD  4,-21(1)	Pop left into ac1 
												   >	902:    TLE  3,4,3	Op <= 
												   >	903:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	905:     LD  3,-16(1)	Load variable d
												   >	906:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	907:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	908:     LD  4,-21(1)	Pop left into ac1 
												   >	909:    ADD  3,4,3	Op + 
												   >	910:     ST  3,-17(1)	Store variable e
												   >	* WHILE
												   >	911:     LD  3,-17(1)	Load variable e
												   >	912:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	913:     LD  3,-2(0)	Load variable numCards
												   >	* TOFF inc: -21
												   >	914:     LD  4,-21(1)	Pop left into ac1 
												   >	915:    TLE  3,4,3	Op <= 
												   >	916:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	918:     LD  3,-19(1)	Load variable possible
												   >	919:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	920:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	921:     LD  4,-21(1)	Pop left into ac1 
												   >	922:    ADD  3,4,3	Op + 
												   >	923:     ST  3,-19(1)	Store variable possible
												   >	* EXPRESSION
												   >	* CALL handtype
												   >	924:     ST  1,-21(1)	Store fp in ghost frame for handtype
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param 1
												   >	925:     LD  3,-13(1)	Load variable a
												   >	926:     ST  3,-23(1)	Push parameter 
												   >	* TOFF dec: -24
												   >	* Param 2
												   >	927:     LD  3,-14(1)	Load variable b
												   >	928:     ST  3,-24(1)	Push parameter 
												   >	* TOFF dec: -25
												   >	* Param 3
												   >	929:     LD  3,-15(1)	Load variable c
												   >	930:     ST  3,-25(1)	Push parameter 
												   >	* TOFF dec: -26
												   >	* Param 4
												   >	931:     LD  3,-16(1)	Load variable d
												   >	932:     ST  3,-26(1)	Push parameter 
												   >	* TOFF dec: -27
												   >	* Param 5
												   >	933:     LD  3,-17(1)	Load variable e
												   >	934:     ST  3,-27(1)	Push parameter 
												   >	* TOFF dec: -28
												   >	* Param end handtype
												   >	935:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	936:    LDA  3,1(7)	Return address in ac 
												   >	937:    JMP  7,-773(7)	CALL handtype
												   >	938:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end handtype
												   >	* TOFF set: -21
												   >	939:     ST  3,-18(1)	Store variable h
												   >	* EXPRESSION
												   >	940:     LD  3,-18(1)	Load variable h
												   >	941:     ST  3,-21(1)	Push index 
												   >	* TOFF dec: -22
												   >	942:    LDA  3,-3(1)	Load address of base of array hands
												   >	943:     ST  3,-22(1)	Push left side 
												   >	* TOFF dec: -23
												   >	944:     LD  3,-18(1)	Load variable h
												   >	* TOFF inc: -22
												   >	945:     LD  4,-22(1)	Pop left into ac1 
												   >	946:    SUB  3,4,3	compute location from index 
												   >	947:     LD  3,0(3)	Load array element 
												   >	948:     ST  3,-22(1)	Push left side 
												   >	* TOFF dec: -23
												   >	949:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -22
												   >	950:     LD  4,-22(1)	Pop left into ac1 
												   >	951:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -21
												   >	952:     LD  4,-21(1)	Pop index 
												   >	953:    LDA  5,-3(1)	Load address of base of array hands
												   >	954:    SUB  5,5,4	Compute offset of value 
												   >	955:     ST  3,0(5)	Store variable hands
												   >	* EXPRESSION
												   >	956:     LD  3,-17(1)	load lhs variable e
												   >	957:    LDA  3,1(3)	increment value of e
												   >	958:     ST  3,-17(1)	Store variable e
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	959:    JMP  7,-49(7)	go to beginning of loop 
												   >	917:    JMP  7,42(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	960:     LD  3,-16(1)	load lhs variable d
												   >	961:    LDA  3,1(3)	increment value of d
												   >	962:     ST  3,-16(1)	Store variable d
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	963:    JMP  7,-66(7)	go to beginning of loop 
												   >	904:    JMP  7,59(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	964:     LD  3,-15(1)	load lhs variable c
												   >	965:    LDA  3,1(3)	increment value of c
												   >	966:     ST  3,-15(1)	Store variable c
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	967:    JMP  7,-83(7)	go to beginning of loop 
												   >	891:    JMP  7,76(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	968:     LD  3,-14(1)	load lhs variable b
												   >	969:    LDA  3,1(3)	increment value of b
												   >	970:     ST  3,-14(1)	Store variable b
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	971:    JMP  7,-100(7)	go to beginning of loop 
												   >	878:    JMP  7,93(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	972:     LD  3,-13(1)	load lhs variable a
												   >	973:    LDA  3,1(3)	increment value of a
												   >	974:     ST  3,-13(1)	Store variable a
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	975:    JMP  7,-129(7)	go to beginning of loop 
												   >	853:    JMP  7,122(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	976:    LDC  3,0(6)	Load integer constant 
												   >	977:     ST  3,-18(1)	Store variable h
												   >	* WHILE
												   >	978:     LD  3,-18(1)	Load variable h
												   >	979:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	980:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	981:     LD  4,-21(1)	Pop left into ac1 
												   >	982:    TLT  3,4,3	Op < 
												   >	983:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -21
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	985:     ST  1,-21(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param 1
												   >	986:     LD  3,-18(1)	Load variable h
												   >	987:     ST  3,-23(1)	Push parameter 
												   >	* TOFF dec: -24
												   >	* Param end output
												   >	988:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	989:    LDA  3,1(7)	Return address in ac 
												   >	990:    JMP  7,-985(7)	CALL output
												   >	991:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -21
												   >	* EXPRESSION
												   >	* CALL output
												   >	992:     ST  1,-21(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param 1
												   >	993:    LDA  3,-3(1)	Load address of base of array hands
												   >	994:     ST  3,-23(1)	Push left side 
												   >	* TOFF dec: -24
												   >	995:     LD  3,-18(1)	Load variable h
												   >	* TOFF inc: -23
												   >	996:     LD  4,-23(1)	Pop left into ac1 
												   >	997:    SUB  3,4,3	compute location from index 
												   >	998:     LD  3,0(3)	Load array element 
												   >	999:     ST  3,-23(1)	Push parameter 
												   >	* TOFF dec: -24
												   >	* Param end output
												   >	1000:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	1001:    LDA  3,1(7)	Return address in ac 
												   >	1002:    JMP  7,-997(7)	CALL output
												   >	1003:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -21
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	1004:     ST  1,-21(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -22
												   >	* TOFF dec: -23
												   >	* Param end outnl
												   >	1005:    LDA  1,-21(1)	Ghost frame becomes new active frame 
												   >	1006:    LDA  3,1(7)	Return address in ac 
												   >	1007:    JMP  7,-974(7)	CALL outnl
												   >	1008:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -21
												   >	* EXPRESSION
												   >	1009:     LD  3,-18(1)	Load variable h
												   >	1010:     ST  3,-21(1)	Push left side 
												   >	* TOFF dec: -22
												   >	1011:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -21
												   >	1012:     LD  4,-21(1)	Pop left into ac1 
												   >	1013:    ADD  3,4,3	Op + 
												   >	1014:     ST  3,-18(1)	Store variable h
												   >	* TOFF set: -21
												   >	* END COMPOUND
												   >	1015:    JMP  7,-38(7)	go to beginning of loop 
												   >	984:    JMP  7,31(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	1016:    LDC  3,0(6)	Load integer constant 
												   >	1017:    LDA  2,0(3)	Copy result to return register 
												   >	1018:     LD  3,-1(1)	Load return address 
												   >	1019:     LD  1,0(1)	Adjust fp 
												   >	1020:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	1021:    LDC  2,0(6)	Set return value to 0 
												   >	1022:     LD  3,-1(1)	Load return address 
												   >	1023:     LD  1,0(1)	Adjust fp 
												   >	1024:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,1024(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	1025:    LDA  1,-3(0)	set first frame at end of globals 
												   >	1026:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	1027:    LDA  3,1(7)	Return address in ac 
												   >	1028:    JMP  7,-226(7)	Jump to main 
												   >	1029:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
poker.mem poker.mem.f21 differ: byte 1, line 1
poker (MEM DIFF)
Var: numSuits of type int [mem: Global loc: 0 size: 1] [line: 4]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: numPips of type int [mem: Global loc: -1 size: 1] [line: 4]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: numCards of type int [mem: Global loc: -2 size: 1] [line: 4]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Func: suit returns type int [mem: Global loc: 0 size: -3] [line: 6]			   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: numSuits of type int [mem: Global loc: 0 size: 1] [line: 4]
												   >	Sibling: 8  Var: numPips of type int [mem: Global loc: -1 size: 1] [line: 4]
												   >	Sibling: 9  Var: numCards of type int [mem: Global loc: -2 size: 1] [line: 4]
												   >	Sibling: 10  Func: suit returns type int [mem: Global loc: 0 size: -3] [line: 6]
.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 6]				.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 6]
.   .   Child: 1  Return [line: 6]									.   .   Child: 1  Return [line: 6]
.   .   .   Child: 0  Op: % of type int [line: 6]							.   .   .   Child: 0  Op: % of type int [line: 6]
.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 6]		.   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 6]
Sibling: 4  Func: pips returns type int [mem: Global loc: 0 size: -3] [line: 7]			   |	Sibling: 11  Func: pips returns type int [mem: Global loc: 0 size: -3] [line: 7]
.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 7]				.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]
.   .   Child: 1  Return [line: 7]									.   .   Child: 1  Return [line: 7]
.   .   .   Child: 0  Op: / of type int [line: 7]							.   .   .   Child: 0  Op: / of type int [line: 7]
.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 7]		.   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 7]
Sibling: 5  Func: p returns type bool [mem: Global loc: 0 size: -4] [line: 9]			   |	Sibling: 12  Func: p returns type bool [mem: Global loc: 0 size: -4] [line: 9]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 9]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 9]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 9]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 9]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 9]
.   .   Child: 1  Return [line: 9]									.   .   Child: 1  Return [line: 9]
.   .   .   Child: 0  Op: == of type bool [line: 9]						   |	.   .   .   Child: 0  Op: = of type bool [line: 9]
.   .   .   .   Child: 0  Call: pips of type int [line: 9]						.   .   .   .   Child: 0  Call: pips of type int [line: 9]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 9]		.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Call: pips of type int [line: 9]						.   .   .   .   Child: 1  Call: pips of type int [line: 9]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 9]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 9]
Sibling: 6  Func: ppp returns type bool [mem: Global loc: 0 size: -5] [line: 10]		   |	Sibling: 13  Func: ppp returns type bool [mem: Global loc: 0 size: -5] [line: 10]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 10]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 10]				.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 10]
.   .   Child: 1  Return [line: 10]									.   .   Child: 1  Return [line: 10]
.   .   .   Child: 0  Op: and of type bool [line: 10]							.   .   .   Child: 0  Op: and of type bool [line: 10]
.   .   .   .   Child: 0  Call: p of type bool [line: 10]						.   .   .   .   Child: 0  Call: p of type bool [line: 10]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 10]		.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]		.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   .   .   .   Child: 1  Call: p of type bool [line: 10]						.   .   .   .   Child: 1  Call: p of type bool [line: 10]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 10]		.   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 10]
Sibling: 7  Func: pppp returns type bool [mem: Global loc: 0 size: -6] [line: 11]		   |	Sibling: 14  Func: pppp returns type bool [mem: Global loc: 0 size: -6] [line: 11]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 11]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 11]				.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 11]
.   Sibling: 3  Parm: d of type int [mem: Parameter loc: -5 size: 1] [line: 11]				.   Sibling: 3  Parm: d of type int [mem: Parameter loc: -5 size: 1] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 11]
.   .   Child: 1  Return [line: 11]									.   .   Child: 1  Return [line: 11]
.   .   .   Child: 0  Op: and of type bool [line: 11]							.   .   .   Child: 0  Op: and of type bool [line: 11]
.   .   .   .   Child: 0  Op: and of type bool [line: 11]						.   .   .   .   Child: 0  Op: and of type bool [line: 11]
.   .   .   .   .   Child: 0  Call: p of type bool [line: 11]						.   .   .   .   .   Child: 0  Call: p of type bool [line: 11]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]
.   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 11	.   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 11
.   .   .   .   .   Child: 1  Call: p of type bool [line: 11]						.   .   .   .   .   Child: 1  Call: p of type bool [line: 11]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 11	.   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 11
.   .   .   .   Child: 1  Call: p of type bool [line: 11]						.   .   .   .   Child: 1  Call: p of type bool [line: 11]
.   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 11]		.   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1] [line: 11]
.   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -5 size: 1] [line: 11]		.   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -5 size: 1] [line: 11]
Sibling: 8  Func: handtype returns type int [mem: Global loc: 0 size: -7] [line: 13]		   |	Sibling: 15  Func: handtype returns type int [mem: Global loc: 0 size: -7] [line: 13]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]
.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 13]				.   Sibling: 2  Parm: c of type int [mem: Parameter loc: -4 size: 1] [line: 13]
.   Sibling: 3  Parm: d of type int [mem: Parameter loc: -5 size: 1] [line: 13]				.   Sibling: 3  Parm: d of type int [mem: Parameter loc: -5 size: 1] [line: 13]
.   Sibling: 4  Parm: e of type int [mem: Parameter loc: -6 size: 1] [line: 13]				.   Sibling: 4  Parm: e of type int [mem: Parameter loc: -6 size: 1] [line: 13]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 14]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 14]
.   .   Child: 0  Var: isflush of type bool [mem: Local loc: -7 size: 1] [line: 15]			.   .   Child: 0  Var: isflush of type bool [mem: Local loc: -7 size: 1] [line: 15]
.   .   Child: 1  Assign: = of type bool [line: 17]						   |	.   .   Child: 1  Assign: := of type bool [line: 17]
.   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 17]			.   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 17]
.   .   .   Child: 1  Op: and of type bool [line: 19]							.   .   .   Child: 1  Op: and of type bool [line: 19]
.   .   .   .   Child: 0  Op: and of type bool [line: 18]						.   .   .   .   Child: 0  Op: and of type bool [line: 18]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 17]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 17]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 17]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 17]
.   .   .   .   .   .   .   Child: 0  Call: suit of type int [line: 17]					.   .   .   .   .   .   .   Child: 0  Call: suit of type int [line: 17]
.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Call: suit of type int [line: 17]					.   .   .   .   .   .   .   Child: 1  Call: suit of type int [line: 17]
.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [li
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 18]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 18]
.   .   .   .   .   .   .   Child: 0  Call: suit of type int [line: 18]					.   .   .   .   .   .   .   Child: 0  Call: suit of type int [line: 18]
.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Call: suit of type int [line: 18]					.   .   .   .   .   .   .   Child: 1  Call: suit of type int [line: 18]
.   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1] [li
.   .   .   .   .   Child: 1  Op: == of type bool [line: 19]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 19]
.   .   .   .   .   .   Child: 0  Call: suit of type int [line: 19]					.   .   .   .   .   .   Child: 0  Call: suit of type int [line: 19]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Call: suit of type int [line: 19]					.   .   .   .   .   .   Child: 1  Call: suit of type int [line: 19]
.   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc: -5 size: 1] [line: 
.   .   .   .   Child: 1  Op: == of type bool [line: 20]					   |	.   .   .   .   Child: 1  Op: = of type bool [line: 20]
.   .   .   .   .   Child: 0  Call: suit of type int [line: 20]						.   .   .   .   .   Child: 0  Call: suit of type int [line: 20]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 20]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 20]
.   .   .   .   .   Child: 1  Call: suit of type int [line: 20]						.   .   .   .   .   Child: 1  Call: suit of type int [line: 20]
.   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [line: 20]		.   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [line: 20]
.   .   Sibling: 1  If [line: 23]									.   .   Sibling: 1  If [line: 23]
.   .   .   Child: 0  Op: and of type bool [line: 23]							.   .   .   Child: 0  Op: and of type bool [line: 23]
.   .   .   .   Child: 0  Op: and of type bool [line: 23]						.   .   .   .   Child: 0  Op: and of type bool [line: 23]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 23]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 2	.   .   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 2
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 23]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 23]
.   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 23]					.   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 23]
.   .   .   .   .   Child: 1  Op: == of type bool [line: 23]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Call: pips of type int [line: 23]					.   .   .   .   .   .   Child: 0  Call: pips of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]						.   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [lin	.   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [lin
.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 23]
.   .   .   .   Child: 1  Op: == of type bool [line: 23]					   |	.   .   .   .   Child: 1  Op: = of type bool [line: 23]
.   .   .   .   .   Child: 0  Call: pips of type int [line: 23]						.   .   .   .   .   Child: 0  Call: pips of type int [line: 23]
.   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [line: 23]		.   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [line: 23]
.   .   .   .   .   Child: 1  Op: - of type int [line: 23]						.   .   .   .   .   Child: 1  Op: - of type int [line: 23]
.   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 2	.   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 2
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   Child: 1  Return [line: 24]									.   .   .   Child: 1  Return [line: 24]
.   .   .   .   Child: 0  Const 0 of type int [line: 24]						.   .   .   .   Child: 0  Const 0 of type int [line: 24]
.   .   .   Child: 2  If [line: 27]									.   .   .   Child: 2  If [line: 27]
.   .   .   .   Child: 0  Op: and of type bool [line: 27]						.   .   .   .   Child: 0  Op: and of type bool [line: 27]
.   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 27]		.   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [line: 27]
.   .   .   .   .   Child: 1  Op: == of type bool [line: 27]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 27]
.   .   .   .   .   .   Child: 0  Call: pips of type int [line: 27]					.   .   .   .   .   .   Child: 0  Call: pips of type int [line: 27]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Op: - of type int [line: 27]						.   .   .   .   .   .   Child: 1  Op: - of type int [line: 27]
.   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 27]					.   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 27]
.   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc: -6 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 27]					.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 27]
.   .   .   .   Child: 1  Return [line: 28]								.   .   .   .   Child: 1  Return [line: 28]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 28]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 28]
.   .   .   .   Child: 2  If [line: 31]									.   .   .   .   Child: 2  If [line: 31]
.   .   .   .   .   Child: 0  Op: or of type bool [line: 31]						.   .   .   .   .   Child: 0  Op: or of type bool [line: 31]
.   .   .   .   .   .   Child: 0  Call: pppp of type bool [line: 31]					.   .   .   .   .   .   Child: 0  Call: pppp of type bool [line: 31]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line	.   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line
.   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter loc: -4 size: 1] [line	.   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter loc: -4 size: 1] [line
.   .   .   .   .   .   .   Sibling: 3  Id: d of type int [mem: Parameter loc: -5 size: 1] [line	.   .   .   .   .   .   .   Sibling: 3  Id: d of type int [mem: Parameter loc: -5 size: 1] [line
.   .   .   .   .   .   Child: 1  Call: pppp of type bool [line: 31]					.   .   .   .   .   .   Child: 1  Call: pppp of type bool [line: 31]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line	.   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter loc: -4 size: 1] [line
.   .   .   .   .   .   .   Sibling: 2  Id: d of type int [mem: Parameter loc: -5 size: 1] [line	.   .   .   .   .   .   .   Sibling: 2  Id: d of type int [mem: Parameter loc: -5 size: 1] [line
.   .   .   .   .   .   .   Sibling: 3  Id: e of type int [mem: Parameter loc: -6 size: 1] [line	.   .   .   .   .   .   .   Sibling: 3  Id: e of type int [mem: Parameter loc: -6 size: 1] [line
.   .   .   .   .   Child: 1  Return [line: 32]								.   .   .   .   .   Child: 1  Return [line: 32]
.   .   .   .   .   .   Child: 0  Const 2 of type int [line: 32]					.   .   .   .   .   .   Child: 0  Const 2 of type int [line: 32]
.   .   .   .   .   Child: 2  If [line: 35]								.   .   .   .   .   Child: 2  If [line: 35]
.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 35]					.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 35]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]
.   .   .   .   .   .   .   .   Child: 0  Call: ppp of type bool [line: 35]				.   .   .   .   .   .   .   .   Child: 0  Call: ppp of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 
.   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter loc: -4 size: 	.   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter loc: -4 size: 
.   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 35]				.   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc: -5 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc: -5 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Parameter loc: -6 size: 	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Parameter loc: -6 size: 
.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 35]					.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 35]
.   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 35]				.   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 
.   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 35]				.   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -5 size: 	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -5 size: 
.   .   .   .   .   .   .   .   .   Sibling: 2  Id: e of type int [mem: Parameter loc: -6 size: 	.   .   .   .   .   .   .   .   .   Sibling: 2  Id: e of type int [mem: Parameter loc: -6 size: 
.   .   .   .   .   .   Child: 1  Return [line: 36]							.   .   .   .   .   .   Child: 1  Return [line: 36]
.   .   .   .   .   .   .   Child: 0  Const 3 of type int [line: 36]					.   .   .   .   .   .   .   Child: 0  Const 3 of type int [line: 36]
.   .   .   .   .   .   Child: 2  If [line: 39]								.   .   .   .   .   .   Child: 2  If [line: 39]
.   .   .   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [lin	.   .   .   .   .   .   .   Child: 0  Id: isflush of type bool [mem: Local loc: -7 size: 1] [lin
.   .   .   .   .   .   .   Child: 1  Return [line: 40]							.   .   .   .   .   .   .   Child: 1  Return [line: 40]
.   .   .   .   .   .   .   .   Child: 0  Const 4 of type int [line: 40]				.   .   .   .   .   .   .   .   Child: 0  Const 4 of type int [line: 40]
.   .   .   .   .   .   .   Child: 2  If [line: 43]							.   .   .   .   .   .   .   Child: 2  If [line: 43]
.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 43]				.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 43]
.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]				.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 43]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 43]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 43]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 43]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 43]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 44]				.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 44]	   |	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 44]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 44]	   |	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [m	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [m
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 44]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 44]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 44]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Glob	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Glob
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 44]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 44]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: pips of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 44]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global l	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global l
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 44]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 44]
.   .   .   .   .   .   .   .   Child: 1  Return [line: 46]						.   .   .   .   .   .   .   .   Child: 1  Return [line: 46]
.   .   .   .   .   .   .   .   .   Child: 0  Const 5 of type int [line: 46]				.   .   .   .   .   .   .   .   .   Child: 0  Const 5 of type int [line: 46]
.   .   .   .   .   .   .   .   Child: 2  If [line: 49]							.   .   .   .   .   .   .   .   Child: 2  If [line: 49]
.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 49]				.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 49]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 49]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 49]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: ppp of type bool [line: 49]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: ppp of type bool [line: 49]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter lo	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter lo
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter lo	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Parameter lo
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 49]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 49]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter lo	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Parameter lo
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: d of type int [mem: Parameter lo	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: d of type int [mem: Parameter lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 49]			.   .   .   .   .   .   .   .   .   .   Child: 1  Call: ppp of type bool [line: 49]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -4 
.   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -	.   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Parameter loc: -
.   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: e of type int [mem: Parameter loc: -	.   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: e of type int [mem: Parameter loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 50]						.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 50]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 6 of type int [line: 50]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 6 of type int [line: 50]
.   .   .   .   .   .   .   .   .   Child: 2  If [line: 53]						.   .   .   .   .   .   .   .   .   Child: 2  If [line: 53]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 53]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 53]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Para	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Para
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Para	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Para
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Para	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Para
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Para	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Para
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 53]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Paramete	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: Paramete
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 53]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Paramete	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Paramete
.   .   .   .   .   .   .   .   .   .   Child: 1  Return [line: 54]					.   .   .   .   .   .   .   .   .   .   Child: 1  Return [line: 54]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 7 of type int [line: 54]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 7 of type int [line: 54]
.   .   .   .   .   .   .   .   .   .   Child: 2  If [line: 57]						.   .   .   .   .   .   .   .   .   .   Child: 2  If [line: 57]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 57]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 57	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: p of type bool [line: 57
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Pa
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: c of type int [mem: 
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parame
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Para	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: d of type int [mem: Para
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: p of type bool [line: 57]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Paramete	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: e of type int [mem: Paramete
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Return [line: 58]					.   .   .   .   .   .   .   .   .   .   .   Child: 1  Return [line: 58]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 8 of type int [line: 58]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 8 of type int [line: 58]
.   .   .   .   .   .   .   .   .   .   .   Child: 2  Return [line: 60]					.   .   .   .   .   .   .   .   .   .   .   Child: 2  Return [line: 60]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 60]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 9 of type int [line: 60]
Sibling: 9  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 63]		   |	Sibling: 16  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 63]
.   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 64]						.   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 64]
.   .   Child: 0  Var: hands of array of type int [mem: Local loc: -3 size: 11] [line: 65]		.   .   Child: 0  Var: hands of array of type int [mem: Local loc: -3 size: 11] [line: 65]
.   .   Sibling: 1  Var: a of type int [mem: Local loc: -13 size: 1] [line: 66]				.   .   Sibling: 1  Var: a of type int [mem: Local loc: -13 size: 1] [line: 66]
.   .   Sibling: 2  Var: b of type int [mem: Local loc: -14 size: 1] [line: 66]				.   .   Sibling: 2  Var: b of type int [mem: Local loc: -14 size: 1] [line: 66]
.   .   Sibling: 3  Var: c of type int [mem: Local loc: -15 size: 1] [line: 66]				.   .   Sibling: 3  Var: c of type int [mem: Local loc: -15 size: 1] [line: 66]
.   .   Sibling: 4  Var: d of type int [mem: Local loc: -16 size: 1] [line: 66]				.   .   Sibling: 4  Var: d of type int [mem: Local loc: -16 size: 1] [line: 66]
.   .   Sibling: 5  Var: e of type int [mem: Local loc: -17 size: 1] [line: 66]				.   .   Sibling: 5  Var: e of type int [mem: Local loc: -17 size: 1] [line: 66]
.   .   Sibling: 6  Var: h of type int [mem: Local loc: -18 size: 1] [line: 66]				.   .   Sibling: 6  Var: h of type int [mem: Local loc: -18 size: 1] [line: 66]
.   .   Sibling: 7  Var: possible of type int [mem: Local loc: -19 size: 1] [line: 66]			.   .   Sibling: 7  Var: possible of type int [mem: Local loc: -19 size: 1] [line: 66]
.   .   Sibling: 8  Var: i of type int [mem: Local loc: -20 size: 1] [line: 66]				.   .   Sibling: 8  Var: i of type int [mem: Local loc: -20 size: 1] [line: 66]
.   .   Child: 1  Assign: = of type int [line: 68]						   |	.   .   Child: 1  Assign: := of type int [line: 68]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 68]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 68]
.   .   .   Child: 1  Const 0 of type int [line: 68]							.   .   .   Child: 1  Const 0 of type int [line: 68]
.   .   Sibling: 1  While [line: 69]									.   .   Sibling: 1  While [line: 69]
.   .   .   Child: 0  Op: < of type bool [line: 69]							.   .   .   Child: 0  Op: < of type bool [line: 69]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 69]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 69]
.   .   .   .   Child: 1  Const 10 of type int [line: 69]						.   .   .   .   Child: 1  Const 10 of type int [line: 69]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 69]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 69]
.   .   .   .   Child: 1  Assign: = of type int [line: 70]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 70]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 70]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 70]
.   .   .   .   .   .   Child: 0  Id: hands of array of type int [mem: Local loc: -3 size: 11] [	.   .   .   .   .   .   Child: 0  Id: hands of array of type int [mem: Local loc: -3 size: 11] [
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -20 size: 1] [line: 70]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -20 size: 1] [line: 70]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 70]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 70]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 71]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 71]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 71]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 71]
.   .   .   .   .   Child: 1  Op: + of type int [line: 71]						.   .   .   .   .   Child: 1  Op: + of type int [line: 71]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 71]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -20 size: 1] [line: 71]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 71]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 71]
.   .   Sibling: 2  Assign: = of type int [line: 74]						   |	.   .   Sibling: 2  Assign: := of type int [line: 74]
.   .   .   Child: 0  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 74]			.   .   .   Child: 0  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 74]
.   .   .   Child: 1  Const 4 of type int [line: 74]							.   .   .   Child: 1  Const 4 of type int [line: 74]
.   .   Sibling: 3  Assign: = of type int [line: 75]						   |	.   .   Sibling: 3  Assign: := of type int [line: 75]
.   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 75]			.   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 75]
.   .   .   Child: 1  Const 6 of type int [line: 75]							.   .   .   Child: 1  Const 6 of type int [line: 75]
.   .   Sibling: 4  Assign: = of type int [line: 76]						   |	.   .   Sibling: 4  Assign: := of type int [line: 76]
.   .   .   Child: 0  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 76]			.   .   .   Child: 0  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 76]
.   .   .   Child: 1  Op: - of type int [line: 76]							.   .   .   Child: 1  Op: - of type int [line: 76]
.   .   .   .   Child: 0  Op: * of type int [line: 76]							.   .   .   .   Child: 0  Op: * of type int [line: 76]
.   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 76]		.   .   .   .   .   Child: 0  Id: numPips of type int [mem: Global loc: -1 size: 1] [line: 76]
.   .   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 76]		.   .   .   .   .   Child: 1  Id: numSuits of type int [mem: Global loc: 0 size: 1] [line: 76]
.   .   .   .   Child: 1  Const 1 of type int [line: 76]						.   .   .   .   Child: 1  Const 1 of type int [line: 76]
.   .   Sibling: 5  Assign: = of type int [line: 78]						   |	.   .   Sibling: 5  Assign: := of type int [line: 78]
.   .   .   Child: 0  Id: possible of type int [mem: Local loc: -19 size: 1] [line: 78]			.   .   .   Child: 0  Id: possible of type int [mem: Local loc: -19 size: 1] [line: 78]
.   .   .   Child: 1  Const 0 of type int [line: 78]							.   .   .   Child: 1  Const 0 of type int [line: 78]
.   .   Sibling: 6  Assign: = of type int [line: 79]						   |	.   .   Sibling: 6  Assign: := of type int [line: 79]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 79]			.   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 79]
.   .   .   Child: 1  Const 0 of type int [line: 79]							.   .   .   Child: 1  Const 0 of type int [line: 79]
.   .   Sibling: 7  While [line: 80]									.   .   Sibling: 7  While [line: 80]
.   .   .   Child: 0  Op: <= of type bool [line: 80]							.   .   .   Child: 0  Op: <= of type bool [line: 80]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 80]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 80]
.   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 80]		.   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 80]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 80]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 80]
.   .   .   .   Child: 1  Call: output of type void [line: 81]						.   .   .   .   Child: 1  Call: output of type void [line: 81]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 81]		.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 81]
.   .   .   .   Sibling: 1  Call: outnl of type void [line: 81]						.   .   .   .   Sibling: 1  Call: outnl of type void [line: 81]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 82]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 82]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 82]		.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 82]
.   .   .   .   .   Child: 1  Op: + of type int [line: 82]						.   .   .   .   .   Child: 1  Op: + of type int [line: 82]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 82]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 82]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 82]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 82]
.   .   .   .   Sibling: 3  While [line: 83]								.   .   .   .   Sibling: 3  While [line: 83]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 83]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 83]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 83]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 83]
.   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 	.   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1] [line: 
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 83]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 83]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 84]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 84]
.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [line: 84]	.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [line: 84]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 84]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 84]
.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 84]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 84]
.   .   .   .   .   .   Sibling: 1  While [line: 85]							.   .   .   .   .   .   Sibling: 1  While [line: 85]
.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 85]					.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 85]
.   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [line:	.   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [line:
.   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1]	.   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 size: 1]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 85]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 85]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 86]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 86]
.   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 86]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 86]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 86]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 86]
.   .   .   .   .   .   .   .   Sibling: 1  While [line: 87]						.   .   .   .   .   .   .   .   Sibling: 1  While [line: 87]
.   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 87]				.   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 87]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 size: 1	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 size: 1
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 87]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 87]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 88]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 88]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc: -17 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc: -17 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 88]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 88]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 88]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 88]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  While [line: 89]					.   .   .   .   .   .   .   .   .   .   Sibling: 1  While [line: 89]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 89]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc: -17	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc: -17
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: numCards of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [lin	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [lin
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 90]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: possible of type int [mem: Loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: possible of type int [mem: Loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 90]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: possible of type int [mem:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: possible of type int [mem:
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 90]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 91]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 91]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: handtype of type int [line: 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: handtype of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: c of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 3  Id: d of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 3  Id: d of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 4  Id: e of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 4  Id: e of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 92]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 92]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 92]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 92]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: hands of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: hands of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: h of type int [mem: Local 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: h of type int [mem: Local 
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 92]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 92]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 92]		.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 92]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: hands of array of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: hands of array of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: h of type int [mem: Lo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: h of type int [mem: Lo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 92]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 92]
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 93]		.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 93]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: e of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 95]			.   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 95]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -16 siz
.   .   .   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 97]				.   .   .   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 97]
.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -15 size: 1] [l
.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 99]					.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 99]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 99]	.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -14 size: 1] [line: 99]
.   .   .   .   Sibling: 4  Assign: ++ of type int [line: 101]						.   .   .   .   Sibling: 4  Assign: ++ of type int [line: 101]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 101]		.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -13 size: 1] [line: 101]
.   .   Sibling: 8  Assign: = of type int [line: 103]						   |	.   .   Sibling: 8  Assign: := of type int [line: 103]
.   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 103]			.   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 103]
.   .   .   Child: 1  Const 0 of type int [line: 103]							.   .   .   Child: 1  Const 0 of type int [line: 103]
.   .   Sibling: 9  While [line: 104]									.   .   Sibling: 9  While [line: 104]
.   .   .   Child: 0  Op: < of type bool [line: 104]							.   .   .   Child: 0  Op: < of type bool [line: 104]
.   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 104]			.   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 104]
.   .   .   .   Child: 1  Const 10 of type int [line: 104]						.   .   .   .   Child: 1  Const 10 of type int [line: 104]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 104]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -21] [line: 104]
.   .   .   .   Child: 1  Call: output of type void [line: 106]						.   .   .   .   Child: 1  Call: output of type void [line: 106]
.   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 106]		.   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 106]
.   .   .   .   Sibling: 1  Call: output of type void [line: 107]					.   .   .   .   Sibling: 1  Call: output of type void [line: 107]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 107]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 107]
.   .   .   .   .   .   Child: 0  Id: hands of array of type int [mem: Local loc: -3 size: 11] [	.   .   .   .   .   .   Child: 0  Id: hands of array of type int [mem: Local loc: -3 size: 11] [
.   .   .   .   .   .   Child: 1  Id: h of type int [mem: Local loc: -18 size: 1] [line: 107]		.   .   .   .   .   .   Child: 1  Id: h of type int [mem: Local loc: -18 size: 1] [line: 107]
.   .   .   .   Sibling: 2  Call: outnl of type void [line: 108]					.   .   .   .   Sibling: 2  Call: outnl of type void [line: 108]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 109]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 109]
.   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 109]		.   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 109]
.   .   .   .   .   Child: 1  Op: + of type int [line: 109]						.   .   .   .   .   Child: 1  Op: + of type int [line: 109]
.   .   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 109]		.   .   .   .   .   .   Child: 0  Id: h of type int [mem: Local loc: -18 size: 1] [line: 109]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 109]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 109]
.   .   Sibling: 10  Return [line: 112]									.   .   Sibling: 10  Return [line: 112]
.   .   .   Child: 0  Const 0 of type int [line: 112]							.   .   .   Child: 0  Const 0 of type int [line: 112]
Offset for end of global space: -3									Offset for end of global space: -3
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
poker.out ztmp23114.txt differ: byte 1, line 1
poker (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/poker.tm
Number of errors: 0										   |	0
------------------------------------								   |	1
Loading file: poker.tm										   |	2
												   >	3
												   >	4
												   >	5
												   >	6
												   >	7
												   >	8
												   >	9
												   >	10
												   >	11
												   >	12
												   >	13
												   >	14
												   >	15
												   >	16
												   >	17
												   >	18
												   >	19
												   >	20
												   >	21
												   >	22
												   >	23
												   >	0 4
												   >	1 8
												   >	2 120
												   >	3 720
												   >	4 12
												   >	5 3060
												   >	6 3840
												   >	7 8640
												   >	8 23040
												   >	9 3060
Bye.													Bye.
====================================
FILE: polynum.c-
-rw-------. 1 corg7983 domain_users   793 Nov 17 15:35 polynum.c-
-rw-------. 1 corg7983 domain_users   808 Nov 17 15:35 polynum.c-.f21
-rw-------. 1 corg7983 domain_users   793 Nov 17 15:35 polynum.c-.f22
-rw-------. 1 corg7983 domain_users    41 Nov 17 15:35 polynum.expected
-rw-------. 1 corg7983 domain_users 10212 Nov 22 12:27 polynum.mem
-rw-------. 1 corg7983 domain_users  2443 Nov 17 15:35 polynum.mem.diffs
-rw-------. 1 corg7983 domain_users 11068 Nov 17 15:35 polynum.mem.f21
-rw-------. 1 corg7983 domain_users   109 Nov 22 12:27 polynum.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 polynum.tm
-rw-------. 1 corg7983 domain_users   212 Nov 17 15:35 polynum.tm.diffs
-rw-------. 1 corg7983 domain_users 11469 Nov 17 15:35 polynum.tm.f21
TM CODE COMPARISON
polynum (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  polynum.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -11
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	* EXPRESSION
												   >	 42:    LDC  3,1(6)	Load integer constant 
												   >	 43:     ST  3,-8(1)	Store variable min
												   >	* WHILE
												   >	 44:     LD  3,-2(1)	Load variable i
												   >	 45:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 46:    LDC  3,2000(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	 47:     LD  4,-11(1)	Pop left into ac1 
												   >	 48:    TLT  3,4,3	Op < 
												   >	 49:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -11
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 51:    LDC  3,2(6)	Load integer constant 
												   >	 52:     ST  3,-3(1)	Store variable m
												   >	* EXPRESSION
												   >	 53:     LD  3,-3(1)	Load variable m
												   >	 54:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 55:     LD  3,-3(1)	Load variable m
												   >	 56:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	 57:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	 58:     LD  4,-12(1)	Pop left into ac1 
												   >	 59:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	 60:     LD  4,-11(1)	Pop left into ac1 
												   >	 61:    MUL  3,4,3	Op * 
												   >	 62:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 63:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	 64:     LD  4,-11(1)	Pop left into ac1 
												   >	 65:    DIV  3,4,3	Op / 
												   >	 66:     ST  3,-6(1)	Store variable tm
												   >	* EXPRESSION
												   >	 67:     LD  3,-2(1)	Load variable i
												   >	 68:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 69:     LD  3,-3(1)	Load variable m
												   >	 70:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	 71:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	 72:     LD  4,-12(1)	Pop left into ac1 
												   >	 73:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	 74:     LD  4,-11(1)	Pop left into ac1 
												   >	 75:    SUB  3,4,3	Op - 
												   >	 76:     ST  3,-5(1)	Store variable x
												   >	* EXPRESSION
												   >	 77:     LD  3,-5(1)	Load variable x
												   >	 78:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 79:     LD  3,-6(1)	Load variable tm
												   >	* TOFF inc: -11
												   >	 80:     LD  4,-11(1)	Pop left into ac1 
												   >	 81:    DIV  3,4,3	Op / 
												   >	 82:     ST  3,-4(1)	Store variable t
												   >	* EXPRESSION
												   >	 83:    LDC  3,0(6)	Load integer constant 
												   >	 84:     ST  3,-7(1)	Store variable num
												   >	* WHILE
												   >	 85:     LD  3,-4(1)	Load variable t
												   >	 86:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 87:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	 88:     LD  4,-11(1)	Pop left into ac1 
												   >	 89:    TGT  3,4,3	Op > 
												   >	 90:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -11
												   >	* Compound Body
												   >	* IF
												   >	 92:     LD  3,-4(1)	Load variable t
												   >	 93:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 94:     LD  3,-6(1)	Load variable tm
												   >	* TOFF inc: -11
												   >	 95:     LD  4,-11(1)	Pop left into ac1 
												   >	 96:    MUL  3,4,3	Op * 
												   >	 97:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	 98:     LD  3,-5(1)	Load variable x
												   >	* TOFF inc: -11
												   >	 99:     LD  4,-11(1)	Pop left into ac1 
												   >	100:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	102:     LD  3,-7(1)	Load variable num
												   >	103:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	104:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	105:     LD  4,-11(1)	Pop left into ac1 
												   >	106:    ADD  3,4,3	Op + 
												   >	107:     ST  3,-7(1)	Store variable num
												   >	101:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	108:     LD  3,-3(1)	Load variable m
												   >	109:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	110:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	111:     LD  4,-11(1)	Pop left into ac1 
												   >	112:    ADD  3,4,3	Op + 
												   >	113:     ST  3,-3(1)	Store variable m
												   >	* EXPRESSION
												   >	114:     LD  3,-3(1)	Load variable m
												   >	115:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	116:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	117:     LD  4,-11(1)	Pop left into ac1 
												   >	118:    ADD  3,4,3	Op + 
												   >	119:     ST  3,-9(1)	Store variable a
												   >	* EXPRESSION
												   >	120:     LD  3,-3(1)	Load variable m
												   >	121:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	122:     LD  3,-3(1)	Load variable m
												   >	123:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	124:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	125:     LD  4,-12(1)	Pop left into ac1 
												   >	126:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	127:     LD  4,-11(1)	Pop left into ac1 
												   >	128:    MUL  3,4,3	Op * 
												   >	129:     ST  3,-10(1)	Store variable b
												   >	* EXPRESSION
												   >	130:     LD  3,-3(1)	Load variable m
												   >	131:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	132:     LD  3,-3(1)	Load variable m
												   >	133:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	134:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	135:     LD  4,-12(1)	Pop left into ac1 
												   >	136:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	137:     LD  4,-11(1)	Pop left into ac1 
												   >	138:    MUL  3,4,3	Op * 
												   >	139:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	140:    LDC  3,1(6)	Load integer constant 
												   >	141:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	142:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	143:     LD  4,-12(1)	Pop left into ac1 
												   >	144:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	145:     LD  4,-11(1)	Pop left into ac1 
												   >	146:    DIV  3,4,3	Op / 
												   >	147:     ST  3,-6(1)	Store variable tm
												   >	* EXPRESSION
												   >	148:     LD  3,-2(1)	Load variable i
												   >	149:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	150:     LD  3,-3(1)	Load variable m
												   >	151:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	152:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	153:     LD  4,-12(1)	Pop left into ac1 
												   >	154:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -11
												   >	155:     LD  4,-11(1)	Pop left into ac1 
												   >	156:    SUB  3,4,3	Op - 
												   >	157:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	158:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	159:     LD  4,-11(1)	Pop left into ac1 
												   >	160:    ADD  3,4,3	Op + 
												   >	161:     ST  3,-5(1)	Store variable x
												   >	* EXPRESSION
												   >	162:     LD  3,-5(1)	Load variable x
												   >	163:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	164:     LD  3,-6(1)	Load variable tm
												   >	* TOFF inc: -11
												   >	165:     LD  4,-11(1)	Pop left into ac1 
												   >	166:    DIV  3,4,3	Op / 
												   >	167:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	168:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	169:     LD  4,-11(1)	Pop left into ac1 
												   >	170:    MUL  3,4,3	Op * 
												   >	171:     ST  3,-4(1)	Store variable t
												   >	* TOFF set: -11
												   >	* END COMPOUND
												   >	172:    JMP  7,-88(7)	go to beginning of loop 
												   >	 91:    JMP  7,81(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	173:     LD  3,-7(1)	Load variable num
												   >	174:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	175:     LD  3,-8(1)	Load variable min
												   >	* TOFF inc: -11
												   >	176:     LD  4,-11(1)	Pop left into ac1 
												   >	177:    TGE  3,4,3	Op >= 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -11
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	179:     ST  1,-11(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	180:     LD  3,-7(1)	Load variable num
												   >	181:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end output
												   >	182:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	183:    LDA  3,1(7)	Return address in ac 
												   >	184:    JMP  7,-179(7)	CALL output
												   >	185:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -11
												   >	* EXPRESSION
												   >	* CALL output
												   >	186:     ST  1,-11(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	187:     LD  3,-2(1)	Load variable i
												   >	188:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end output
												   >	189:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	190:    LDA  3,1(7)	Return address in ac 
												   >	191:    JMP  7,-186(7)	CALL output
												   >	192:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -11
												   >	* EXPRESSION
												   >	* CALL output
												   >	193:     ST  1,-11(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -12
												   >	* TOFF dec: -13
												   >	* Param 1
												   >	194:    LDC  3,11111111(6)	Load integer constant 
												   >	195:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end output
												   >	196:    LDA  1,-11(1)	Ghost frame becomes new active frame 
												   >	197:    LDA  3,1(7)	Return address in ac 
												   >	198:    JMP  7,-193(7)	CALL output
												   >	199:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -11
												   >	* EXPRESSION
												   >	200:     LD  3,-7(1)	Load variable num
												   >	201:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	202:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	203:     LD  4,-11(1)	Pop left into ac1 
												   >	204:    ADD  3,4,3	Op + 
												   >	205:     ST  3,-8(1)	Store variable min
												   >	* TOFF set: -11
												   >	* END COMPOUND
												   >	178:    JZR  3,27(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	206:     LD  3,-2(1)	Load variable i
												   >	207:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	208:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	209:     LD  4,-11(1)	Pop left into ac1 
												   >	210:    ADD  3,4,3	Op + 
												   >	211:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -11
												   >	* END COMPOUND
												   >	212:    JMP  7,-169(7)	go to beginning of loop 
												   >	 50:    JMP  7,162(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	213:    LDC  3,0(6)	Load integer constant 
												   >	214:    LDA  2,0(3)	Copy result to return register 
												   >	215:     LD  3,-1(1)	Load return address 
												   >	216:     LD  1,0(1)	Adjust fp 
												   >	217:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	218:    LDC  2,0(6)	Set return value to 0 
												   >	219:     LD  3,-1(1)	Load return address 
												   >	220:     LD  1,0(1)	Adjust fp 
												   >	221:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,221(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	222:    LDA  1,0(0)	set first frame at end of globals 
												   >	223:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	224:    LDA  3,1(7)	Return address in ac 
												   >	225:    JMP  7,-187(7)	Jump to main 
												   >	226:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
polynum.mem polynum.mem.f21 differ: byte 7, line 1
polynum (MEM DIFF)
Func: main returns type int [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 2]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: m of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Sibling: 1  Var: m of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Sibling: 2  Var: t of type int [mem: Local loc: -4 size: 1] [line: 5]				.   .   Sibling: 2  Var: t of type int [mem: Local loc: -4 size: 1] [line: 5]
.   .   Sibling: 3  Var: x of type int [mem: Local loc: -5 size: 1] [line: 6]				.   .   Sibling: 3  Var: x of type int [mem: Local loc: -5 size: 1] [line: 6]
.   .   Sibling: 4  Var: tm of type int [mem: Local loc: -6 size: 1] [line: 7]				.   .   Sibling: 4  Var: tm of type int [mem: Local loc: -6 size: 1] [line: 7]
.   .   Sibling: 5  Var: num of type int [mem: Local loc: -7 size: 1] [line: 8]				.   .   Sibling: 5  Var: num of type int [mem: Local loc: -7 size: 1] [line: 8]
.   .   Sibling: 6  Var: min of type int [mem: Local loc: -8 size: 1] [line: 9]				.   .   Sibling: 6  Var: min of type int [mem: Local loc: -8 size: 1] [line: 9]
.   .   Sibling: 7  Var: a of type int [mem: Local loc: -9 size: 1] [line: 10]				.   .   Sibling: 7  Var: a of type int [mem: Local loc: -9 size: 1] [line: 10]
.   .   Sibling: 8  Var: b of type int [mem: Local loc: -10 size: 1] [line: 11]				.   .   Sibling: 8  Var: b of type int [mem: Local loc: -10 size: 1] [line: 11]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Const 1 of type int [line: 13]							.   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   Sibling: 1  Assign: = of type int [line: 14]						   |	.   .   Sibling: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: min of type int [mem: Local loc: -8 size: 1] [line: 14]			.   .   .   Child: 0  Id: min of type int [mem: Local loc: -8 size: 1] [line: 14]
.   .   .   Child: 1  Const 1 of type int [line: 14]							.   .   .   Child: 1  Const 1 of type int [line: 14]
.   .   Sibling: 2  While [line: 15]									.   .   Sibling: 2  While [line: 15]
.   .   .   Child: 0  Op: < of type bool [line: 15]							.   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 2000 of type int [line: 15]						.   .   .   .   Child: 1  Const 2000 of type int [line: 15]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 15]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 15]
.   .   .   .   Child: 1  Assign: = of type int [line: 16]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 16]			.   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 16]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 16]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 16]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 17]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 17]
.   .   .   .   .   Child: 0  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 17]		.   .   .   .   .   Child: 0  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 17]
.   .   .   .   .   Child: 1  Op: / of type int [line: 17]						.   .   .   .   .   Child: 1  Op: / of type int [line: 17]
.   .   .   .   .   .   Child: 0  Op: * of type int [line: 17]						.   .   .   .   .   .   Child: 0  Op: * of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 17]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 17]
.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 17]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 17]
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 17]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 17]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 18]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 18]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 18]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 18]
.   .   .   .   .   Child: 1  Op: - of type int [line: 18]						.   .   .   .   .   Child: 1  Op: - of type int [line: 18]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 18]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   .   .   .   Child: 1  Op: + of type int [line: 18]						.   .   .   .   .   .   Child: 1  Op: + of type int [line: 18]
.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 18]		.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 18]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 18]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 19]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 19]
.   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 19]			.   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 19]
.   .   .   .   .   Child: 1  Op: / of type int [line: 19]						.   .   .   .   .   Child: 1  Op: / of type int [line: 19]
.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 19]		.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 19]
.   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 19]		.   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 19]
.   .   .   .   Sibling: 4  Assign: = of type int [line: 20]					   |	.   .   .   .   Sibling: 4  Assign: := of type int [line: 20]
.   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 20]		.   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 20]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 20]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 20]
.   .   .   .   Sibling: 5  While [line: 21]								.   .   .   .   Sibling: 5  While [line: 21]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 21]
.   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 21]		.   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 21]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 21]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 21]
.   .   .   .   .   .   Child: 1  If [line: 22]								.   .   .   .   .   .   Child: 1  If [line: 22]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 22]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 22]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 22]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 22]
.   .   .   .   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [l
.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -5 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 22]				   |	.   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 22]
.   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line	.   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line
.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]					.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [	.   .   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 23]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 23]		.   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 24]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 24]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -9 size: 1] [line: 24]		.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -9 size: 1] [line: 24]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 24]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 24]
.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 24]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 24]
.   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 25]				   |	.   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 25]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -10 size: 1] [line: 25]	.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -10 size: 1] [line: 25]
.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 25]					.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 25]
.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 25]					.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 25]
.   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 25]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 25]
.   .   .   .   .   .   Sibling: 4  Assign: = of type int [line: 26]				   |	.   .   .   .   .   .   Sibling: 4  Assign: := of type int [line: 26]
.   .   .   .   .   .   .   Child: 0  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 26]	.   .   .   .   .   .   .   Child: 0  Id: tm of type int [mem: Local loc: -6 size: 1] [line: 26]
.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 26]					.   .   .   .   .   .   .   Child: 1  Op: / of type int [line: 26]
.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 26]					.   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 26]
.   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 26]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 26]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 26]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 26]
.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 26]					.   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 26]
.   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 26]				.   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 26]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 26]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 26]
.   .   .   .   .   .   Sibling: 5  Assign: = of type int [line: 27]				   |	.   .   .   .   .   .   Sibling: 5  Assign: := of type int [line: 27]
.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 27]		.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [line: 27]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 27]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 27]
.   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 27]					.   .   .   .   .   .   .   .   Child: 0  Op: - of type int [line: 27]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 27]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 27]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: m of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 27]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 27]
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 27]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 27]
.   .   .   .   .   .   Sibling: 6  Assign: = of type int [line: 28]				   |	.   .   .   .   .   .   Sibling: 6  Assign: := of type int [line: 28]
.   .   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 28]		.   .   .   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -4 size: 1] [line: 28]
.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 28]					.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 28]
.   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 28]					.   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 28]
.   .   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -5 size: 1] [li
.   .   .   .   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 1  Id: tm of type int [mem: Local loc: -6 size: 1] [l
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 28]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 28]
.   .   .   .   Sibling: 6  If [line: 30]								.   .   .   .   Sibling: 6  If [line: 30]
.   .   .   .   .   Child: 0  Op: >= of type bool [line: 30]						.   .   .   .   .   Child: 0  Op: >= of type bool [line: 30]
.   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 30]		.   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 30]
.   .   .   .   .   .   Child: 1  Id: min of type int [mem: Local loc: -8 size: 1] [line: 30]		.   .   .   .   .   .   Child: 1  Id: min of type int [mem: Local loc: -8 size: 1] [line: 30]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 30]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -11] [line: 30]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 31]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 31]
.   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 31	.   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line: 31
.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 32]				.   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 32]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 32]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 32]
.   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 33]				.   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 33]
.   .   .   .   .   .   .   Child: 0  Const 11111111 of type int [line: 33]				.   .   .   .   .   .   .   Child: 0  Const 11111111 of type int [line: 33]
.   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 34]				   |	.   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 34]
.   .   .   .   .   .   .   Child: 0  Id: min of type int [mem: Local loc: -8 size: 1] [line: 34	.   .   .   .   .   .   .   Child: 0  Id: min of type int [mem: Local loc: -8 size: 1] [line: 34
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 34]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 34]
.   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line	.   .   .   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -7 size: 1] [line
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 34]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 34]
.   .   .   .   Sibling: 7  Assign: = of type int [line: 36]					   |	.   .   .   .   Sibling: 7  Assign: := of type int [line: 36]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]
.   .   .   .   .   Child: 1  Op: + of type int [line: 36]						.   .   .   .   .   Child: 1  Op: + of type int [line: 36]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]
.   .   Sibling: 3  Return [line: 38]									.   .   Sibling: 3  Return [line: 38]
.   .   .   Child: 0  Const 0 of type int [line: 38]							.   .   .   Child: 0  Const 0 of type int [line: 38]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
polynum.out ztmp23114.txt differ: byte 1, line 1
polynum (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/polynum.tm
Number of errors: 0										   <
------------------------------------								   <
Loading file: polynum.tm									   <
Bye.													Bye.
====================================
FILE: proc.c-
-rw-------. 1 corg7983 domain_users   749 Nov 17 15:35 proc.c-
-rw-------. 1 corg7983 domain_users   750 Nov 17 15:35 proc.c-.f21
-rw-------. 1 corg7983 domain_users   749 Nov 17 15:35 proc.c-.f22
-rw-------. 1 corg7983 domain_users   166 Nov 17 15:35 proc.expected
-rw-------. 1 corg7983 domain_users  7705 Nov 22 12:27 proc.mem
-rw-------. 1 corg7983 domain_users   361 Nov 17 15:35 proc.mem.diffs
-rw-------. 1 corg7983 domain_users  8549 Nov 17 15:35 proc.mem.f21
-rw-------. 1 corg7983 domain_users   208 Nov 22 12:27 proc.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 proc.tm
-rw-------. 1 corg7983 domain_users   212 Nov 17 15:35 proc.tm.diffs
-rw-------. 1 corg7983 domain_users 18335 Nov 17 15:35 proc.tm.f21
TM CODE COMPARISON
proc (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  proc.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION square
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	 40:     LD  3,-2(1)	Load variable x
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    MUL  3,4,3	Op * 
												   >	 45:    LDA  2,0(3)	Copy result to return register 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 49:    LDC  2,0(6)	Set return value to 0 
												   >	 50:     LD  3,-1(1)	Load return address 
												   >	 51:     LD  1,0(1)	Adjust fp 
												   >	 52:    JMP  7,0(3)	Return 
												   >	* END FUNCTION square
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION max
												   >	* TOFF set: -4
												   >	 53:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 54:     LD  3,-2(1)	Load variable x
												   >	 55:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 56:     LD  3,-3(1)	Load variable y
												   >	* TOFF inc: -4
												   >	 57:     LD  4,-4(1)	Pop left into ac1 
												   >	 58:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* RETURN
												   >	 60:     LD  3,-2(1)	Load variable x
												   >	 61:    LDA  2,0(3)	Copy result to return register 
												   >	 62:     LD  3,-1(1)	Load return address 
												   >	 63:     LD  1,0(1)	Adjust fp 
												   >	 64:    JMP  7,0(3)	Return 
												   >	 59:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	 66:     LD  3,-3(1)	Load variable y
												   >	 67:    LDA  2,0(3)	Copy result to return register 
												   >	 68:     LD  3,-1(1)	Load return address 
												   >	 69:     LD  1,0(1)	Adjust fp 
												   >	 70:    JMP  7,0(3)	Return 
												   >	 65:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 71:    LDC  2,0(6)	Set return value to 0 
												   >	 72:     LD  3,-1(1)	Load return address 
												   >	 73:     LD  1,0(1)	Adjust fp 
												   >	 74:    JMP  7,0(3)	Return 
												   >	* END FUNCTION max
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION toInt
												   >	* TOFF set: -3
												   >	 75:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	 76:     LD  3,-2(1)	Load variable b
												   >	* THEN
												   >	* RETURN
												   >	 78:    LDC  3,1(6)	Load integer constant 
												   >	 79:    LDA  2,0(3)	Copy result to return register 
												   >	 80:     LD  3,-1(1)	Load return address 
												   >	 81:     LD  1,0(1)	Adjust fp 
												   >	 82:    JMP  7,0(3)	Return 
												   >	 77:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	 84:    LDC  3,0(6)	Load integer constant 
												   >	 85:    LDA  2,0(3)	Copy result to return register 
												   >	 86:     LD  3,-1(1)	Load return address 
												   >	 87:     LD  1,0(1)	Adjust fp 
												   >	 88:    JMP  7,0(3)	Return 
												   >	 83:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 89:    LDC  2,0(6)	Set return value to 0 
												   >	 90:     LD  3,-1(1)	Load return address 
												   >	 91:     LD  1,0(1)	Adjust fp 
												   >	 92:    JMP  7,0(3)	Return 
												   >	* END FUNCTION toInt
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION toBool
												   >	* TOFF set: -3
												   >	 93:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	 94:     LD  3,-2(1)	Load variable x
												   >	 95:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 96:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 97:     LD  4,-3(1)	Pop left into ac1 
												   >	 98:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	100:    LDC  3,0(6)	Load Boolean constant 
												   >	101:    LDA  2,0(3)	Copy result to return register 
												   >	102:     LD  3,-1(1)	Load return address 
												   >	103:     LD  1,0(1)	Adjust fp 
												   >	104:    JMP  7,0(3)	Return 
												   >	 99:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	106:    LDC  3,1(6)	Load Boolean constant 
												   >	107:    LDA  2,0(3)	Copy result to return register 
												   >	108:     LD  3,-1(1)	Load return address 
												   >	109:     LD  1,0(1)	Adjust fp 
												   >	110:    JMP  7,0(3)	Return 
												   >	105:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	111:    LDC  2,0(6)	Set return value to 0 
												   >	112:     LD  3,-1(1)	Load return address 
												   >	113:     LD  1,0(1)	Adjust fp 
												   >	114:    JMP  7,0(3)	Return 
												   >	* END FUNCTION toBool
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	115:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	116:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	* CALL square
												   >	117:     ST  1,-8(1)	Store fp in ghost frame for square
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	118:    LDC  3,31(6)	Load integer constant 
												   >	119:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end square
												   >	120:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	121:    LDA  3,1(7)	Return address in ac 
												   >	122:    JMP  7,-84(7)	CALL square
												   >	123:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end square
												   >	* TOFF set: -8
												   >	124:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	125:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-122(7)	CALL output
												   >	128:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	129:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	130:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-99(7)	CALL outnl
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	134:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	* CALL max
												   >	135:     ST  1,-8(1)	Store fp in ghost frame for max
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	136:    LDC  3,131(6)	Load integer constant 
												   >	137:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	138:    LDC  3,42(6)	Load integer constant 
												   >	139:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end max
												   >	140:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	141:    LDA  3,1(7)	Return address in ac 
												   >	142:    JMP  7,-90(7)	CALL max
												   >	143:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end max
												   >	* TOFF set: -8
												   >	144:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	145:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	146:    LDA  3,1(7)	Return address in ac 
												   >	147:    JMP  7,-142(7)	CALL output
												   >	148:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	149:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	150:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-119(7)	CALL outnl
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL toBool
												   >	154:     ST  1,-6(1)	Store fp in ghost frame for toBool
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	155:    LDC  3,42(6)	Load integer constant 
												   >	156:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end toBool
												   >	157:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	158:    LDA  3,1(7)	Return address in ac 
												   >	159:    JMP  7,-67(7)	CALL toBool
												   >	160:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end toBool
												   >	* TOFF set: -6
												   >	161:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	* CALL toInt
												   >	162:     ST  1,-6(1)	Store fp in ghost frame for toInt
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	163:    LDC  3,1(6)	Load Boolean constant 
												   >	164:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end toInt
												   >	165:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	166:    LDA  3,1(7)	Return address in ac 
												   >	167:    JMP  7,-93(7)	CALL toInt
												   >	168:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end toInt
												   >	* TOFF set: -6
												   >	169:     ST  3,-4(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	170:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	171:     LD  3,-4(1)	Load variable x
												   >	172:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	173:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-170(7)	CALL output
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	177:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	178:     LD  3,-2(1)	Load variable a
												   >	179:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	180:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	181:    LDA  3,1(7)	Return address in ac 
												   >	182:    JMP  7,-166(7)	CALL outputb
												   >	183:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* IF
												   >	184:    LDC  3,666(6)	Load integer constant 
												   >	185:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	186:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	187:     LD  4,-6(1)	Pop left into ac1 
												   >	188:    ADD  3,4,3	Op + 
												   >	189:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	190:    LDC  3,13(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	191:     LD  4,-6(1)	Pop left into ac1 
												   >	192:    TGT  3,4,3	Op > 
												   >	193:    LDC  4,1(6)	Load 1 
												   >	194:    XOR  3,3,4	Op XOR to get logical not 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	196:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	197:    LDC  3,0(6)	Load integer constant 
												   >	198:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	199:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-196(7)	CALL output
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	195:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL output
												   >	204:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	205:    LDC  3,666(6)	Load integer constant 
												   >	206:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	207:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	208:    LDA  3,1(7)	Return address in ac 
												   >	209:    JMP  7,-204(7)	CALL output
												   >	210:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	203:    JMP  7,7(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	211:    LDC  3,666(6)	Load integer constant 
												   >	212:    NEG  3,3,3	Op unary - 
												   >	213:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	214:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	215:     LD  4,-6(1)	Pop left into ac1 
												   >	216:    ADD  3,4,3	Op + 
												   >	217:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	218:    LDC  3,13(6)	Load integer constant 
												   >	219:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -6
												   >	220:     LD  4,-6(1)	Pop left into ac1 
												   >	221:    TGT  3,4,3	Op > 
												   >	222:    LDC  4,1(6)	Load 1 
												   >	223:    XOR  3,3,4	Op XOR to get logical not 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	225:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	226:    LDC  3,0(6)	Load integer constant 
												   >	227:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	228:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	229:    LDA  3,1(7)	Return address in ac 
												   >	230:    JMP  7,-225(7)	CALL output
												   >	231:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	224:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL output
												   >	233:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	234:    LDC  3,666(6)	Load integer constant 
												   >	235:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	236:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	237:    LDA  3,1(7)	Return address in ac 
												   >	238:    JMP  7,-233(7)	CALL output
												   >	239:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	232:    JMP  7,7(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	240:    LDC  3,666(6)	Load integer constant 
												   >	241:    NEG  3,3,3	Op unary - 
												   >	242:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	243:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	244:     LD  4,-6(1)	Pop left into ac1 
												   >	245:    ADD  3,4,3	Op + 
												   >	246:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	247:    LDC  3,13(6)	Load integer constant 
												   >	248:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -6
												   >	249:     LD  4,-6(1)	Pop left into ac1 
												   >	250:    TGT  3,4,3	Op > 
												   >	251:    LDC  4,1(6)	Load 1 
												   >	252:    XOR  3,3,4	Op XOR to get logical not 
												   >	253:    LDC  4,1(6)	Load 1 
												   >	254:    XOR  3,3,4	Op XOR to get logical not 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	256:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	257:    LDC  3,0(6)	Load integer constant 
												   >	258:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	259:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	260:    LDA  3,1(7)	Return address in ac 
												   >	261:    JMP  7,-256(7)	CALL output
												   >	262:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	255:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL output
												   >	264:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	265:    LDC  3,666(6)	Load integer constant 
												   >	266:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	267:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	268:    LDA  3,1(7)	Return address in ac 
												   >	269:    JMP  7,-264(7)	CALL output
												   >	270:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	263:    JMP  7,7(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	271:    LDC  3,0(6)	Load Boolean constant 
												   >	272:    LDC  4,1(6)	Load 1 
												   >	273:    XOR  3,3,4	Op XOR to get logical not 
												   >	274:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	275:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -6
												   >	276:     LD  4,-6(1)	Pop left into ac1 
												   >	277:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	279:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	280:    LDC  3,7(6)	Load integer constant 
												   >	281:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	282:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	283:    LDA  3,1(7)	Return address in ac 
												   >	284:    JMP  7,-279(7)	CALL output
												   >	285:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	278:    JZR  3,7(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	286:    LDC  3,4(6)	Load integer constant 
												   >	287:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	288:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	289:     LD  4,-6(1)	Pop left into ac1 
												   >	290:    TGT  3,4,3	Op > 
												   >	291:    LDC  4,1(6)	Load 1 
												   >	292:    XOR  3,3,4	Op XOR to get logical not 
												   >	293:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	294:    LDC  3,6(6)	Load integer constant 
												   >	295:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	296:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	297:     LD  4,-7(1)	Pop left into ac1 
												   >	298:    TGT  3,4,3	Op > 
												   >	* TOFF inc: -6
												   >	299:     LD  4,-6(1)	Pop left into ac1 
												   >	300:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL output
												   >	302:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	303:    LDC  3,7(6)	Load integer constant 
												   >	304:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	305:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	306:    LDA  3,1(7)	Return address in ac 
												   >	307:    JMP  7,-302(7)	CALL output
												   >	308:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	301:    JZR  3,7(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	309:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	310:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	311:    LDA  3,1(7)	Return address in ac 
												   >	312:    JMP  7,-279(7)	CALL outnl
												   >	313:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	314:    LDC  2,0(6)	Set return value to 0 
												   >	315:     LD  3,-1(1)	Load return address 
												   >	316:     LD  1,0(1)	Adjust fp 
												   >	317:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,317(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	318:    LDA  1,0(0)	set first frame at end of globals 
												   >	319:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	320:    LDA  3,1(7)	Return address in ac 
												   >	321:    JMP  7,-207(7)	Jump to main 
												   >	322:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
proc.mem proc.mem.f21 differ: byte 109, line 3
proc (MEM DIFF)
WARNING(8): The variable 'b' seems not to be used.							WARNING(8): The variable 'b' seems not to be used.
WARNING(9): The variable 'y' seems not to be used.							WARNING(9): The variable 'y' seems not to be used.
Func: square returns type int [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: square returns type int [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 1]
.   .   Child: 1  Return [line: 1]									.   .   Child: 1  Return [line: 1]
.   .   .   Child: 0  Op: * of type int [line: 1]							.   .   .   Child: 0  Op: * of type int [line: 1]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
Sibling: 1  Func: max returns type int [mem: Global loc: 0 size: -4] [line: 2]			   |	Sibling: 8  Func: max returns type int [mem: Global loc: 0 size: -4] [line: 2]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]				.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 2]
.   .   Child: 1  If [line: 2]										.   .   Child: 1  If [line: 2]
.   .   .   Child: 0  Op: > of type bool [line: 2]							.   .   .   Child: 0  Op: > of type bool [line: 2]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]			.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   .   .   Child: 1  Return [line: 2]									.   .   .   Child: 1  Return [line: 2]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   .   .   Child: 2  Return [line: 2]									.   .   .   Child: 2  Return [line: 2]
.   .   .   .   Child: 0  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]			.   .   .   .   Child: 0  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 2]
Sibling: 2  Func: toInt returns type int [mem: Global loc: 0 size: -3] [line: 3]		   |	Sibling: 9  Func: toInt returns type int [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: b of type bool [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: b of type bool [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]
.   .   Child: 1  If [line: 3]										.   .   Child: 1  If [line: 3]
.   .   .   Child: 0  Id: b of type bool [mem: Parameter loc: -2 size: 1] [line: 3]			.   .   .   Child: 0  Id: b of type bool [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   .   Child: 1  Return [line: 3]									.   .   .   Child: 1  Return [line: 3]
.   .   .   .   Child: 0  Const 1 of type int [line: 3]							.   .   .   .   Child: 0  Const 1 of type int [line: 3]
.   .   .   Child: 2  Return [line: 3]									.   .   .   Child: 2  Return [line: 3]
.   .   .   .   Child: 0  Const 0 of type int [line: 3]							.   .   .   .   Child: 0  Const 0 of type int [line: 3]
Sibling: 3  Func: toBool returns type bool [mem: Global loc: 0 size: -3] [line: 4]		   |	Sibling: 10  Func: toBool returns type bool [mem: Global loc: 0 size: -3] [line: 4]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]
.   .   Child: 1  If [line: 4]										.   .   Child: 1  If [line: 4]
.   .   .   Child: 0  Op: == of type bool [line: 4]						   |	.   .   .   Child: 0  Op: = of type bool [line: 4]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   .   .   Child: 1  Const 0 of type int [line: 4]							.   .   .   .   Child: 1  Const 0 of type int [line: 4]
.   .   .   Child: 1  Return [line: 4]									.   .   .   Child: 1  Return [line: 4]
.   .   .   .   Child: 0  Const false of type bool [line: 4]						.   .   .   .   Child: 0  Const false of type bool [line: 4]
.   .   .   Child: 2  Return [line: 4]									.   .   .   Child: 2  Return [line: 4]
.   .   .   .   Child: 0  Const true of type bool [line: 4]						.   .   .   .   Child: 0  Const true of type bool [line: 4]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]		   |	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 7]
.   .   Child: 0  Var: a of type bool [mem: Local loc: -2 size: 1] [line: 8]				.   .   Child: 0  Var: a of type bool [mem: Local loc: -2 size: 1] [line: 8]
.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 8]				.   .   Sibling: 1  Var: b of type bool [mem: Local loc: -3 size: 1] [line: 8]
.   .   Sibling: 2  Var: x of type int [mem: Local loc: -4 size: 1] [line: 9]				.   .   Sibling: 2  Var: x of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Sibling: 3  Var: y of type int [mem: Local loc: -5 size: 1] [line: 9]				.   .   Sibling: 3  Var: y of type int [mem: Local loc: -5 size: 1] [line: 9]
.   .   Child: 1  Call: output of type void [line: 11]							.   .   Child: 1  Call: output of type void [line: 11]
.   .   .   Child: 0  Call: square of type int [line: 11]						.   .   .   Child: 0  Call: square of type int [line: 11]
.   .   .   .   Child: 0  Const 31 of type int [line: 11]						.   .   .   .   Child: 0  Const 31 of type int [line: 11]
.   .   Sibling: 1  Call: outnl of type void [line: 12]							.   .   Sibling: 1  Call: outnl of type void [line: 12]
.   .   Sibling: 2  Call: output of type void [line: 13]						.   .   Sibling: 2  Call: output of type void [line: 13]
.   .   .   Child: 0  Call: max of type int [line: 13]							.   .   .   Child: 0  Call: max of type int [line: 13]
.   .   .   .   Child: 0  Const 131 of type int [line: 13]						.   .   .   .   Child: 0  Const 131 of type int [line: 13]
.   .   .   .   Sibling: 1  Const 42 of type int [line: 13]						.   .   .   .   Sibling: 1  Const 42 of type int [line: 13]
.   .   Sibling: 3  Call: outnl of type void [line: 14]							.   .   Sibling: 3  Call: outnl of type void [line: 14]
.   .   Sibling: 4  Assign: = of type bool [line: 16]						   |	.   .   Sibling: 4  Assign: := of type bool [line: 16]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 16]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 16]
.   .   .   Child: 1  Call: toBool of type bool [line: 16]						.   .   .   Child: 1  Call: toBool of type bool [line: 16]
.   .   .   .   Child: 0  Const 42 of type int [line: 16]						.   .   .   .   Child: 0  Const 42 of type int [line: 16]
.   .   Sibling: 5  Assign: = of type int [line: 17]						   |	.   .   Sibling: 5  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 17]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 17]
.   .   .   Child: 1  Call: toInt of type int [line: 17]						.   .   .   Child: 1  Call: toInt of type int [line: 17]
.   .   .   .   Child: 0  Const true of type bool [line: 17]						.   .   .   .   Child: 0  Const true of type bool [line: 17]
.   .   Sibling: 6  Call: output of type void [line: 18]						.   .   Sibling: 6  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 18]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   Sibling: 7  Call: outputb of type void [line: 19]						.   .   Sibling: 7  Call: outputb of type void [line: 19]
.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 19]			.   .   .   Child: 0  Id: a of type bool [mem: Local loc: -2 size: 1] [line: 19]
.   .   Sibling: 8  If [line: 21]									.   .   Sibling: 8  If [line: 21]
.   .   .   Child: 0  Op: not of type bool [line: 21]							.   .   .   Child: 0  Op: not of type bool [line: 21]
.   .   .   .   Child: 0  Op: > of type bool [line: 21]							.   .   .   .   Child: 0  Op: > of type bool [line: 21]
.   .   .   .   .   Child: 0  Op: + of type int [line: 21]						.   .   .   .   .   Child: 0  Op: + of type int [line: 21]
.   .   .   .   .   .   Child: 0  Const 666 of type int [line: 21]					.   .   .   .   .   .   Child: 0  Const 666 of type int [line: 21]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 21]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 21]
.   .   .   .   .   Child: 1  Const 13 of type int [line: 21]						.   .   .   .   .   Child: 1  Const 13 of type int [line: 21]
.   .   .   Child: 1  Call: output of type void [line: 21]						.   .   .   Child: 1  Call: output of type void [line: 21]
.   .   .   .   Child: 0  Const 0 of type int [line: 21]						.   .   .   .   Child: 0  Const 0 of type int [line: 21]
.   .   .   Child: 2  Call: output of type void [line: 21]						.   .   .   Child: 2  Call: output of type void [line: 21]
.   .   .   .   Child: 0  Const 666 of type int [line: 21]						.   .   .   .   Child: 0  Const 666 of type int [line: 21]
.   .   Sibling: 9  If [line: 22]									.   .   Sibling: 9  If [line: 22]
.   .   .   Child: 0  Op: not of type bool [line: 22]							.   .   .   Child: 0  Op: not of type bool [line: 22]
.   .   .   .   Child: 0  Op: > of type bool [line: 22]							.   .   .   .   Child: 0  Op: > of type bool [line: 22]
.   .   .   .   .   Child: 0  Op: + of type int [line: 22]						.   .   .   .   .   Child: 0  Op: + of type int [line: 22]
.   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 22]					.   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 22]
.   .   .   .   .   .   .   Child: 0  Const 666 of type int [line: 22]					.   .   .   .   .   .   .   Child: 0  Const 666 of type int [line: 22]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 22]						.   .   .   .   .   Child: 1  Op: chsign of type int [line: 22]
.   .   .   .   .   .   Child: 0  Const 13 of type int [line: 22]					.   .   .   .   .   .   Child: 0  Const 13 of type int [line: 22]
.   .   .   Child: 1  Call: output of type void [line: 22]						.   .   .   Child: 1  Call: output of type void [line: 22]
.   .   .   .   Child: 0  Const 0 of type int [line: 22]						.   .   .   .   Child: 0  Const 0 of type int [line: 22]
.   .   .   Child: 2  Call: output of type void [line: 22]						.   .   .   Child: 2  Call: output of type void [line: 22]
.   .   .   .   Child: 0  Const 666 of type int [line: 22]						.   .   .   .   Child: 0  Const 666 of type int [line: 22]
.   .   Sibling: 10  If [line: 23]									.   .   Sibling: 10  If [line: 23]
.   .   .   Child: 0  Op: not of type bool [line: 23]							.   .   .   Child: 0  Op: not of type bool [line: 23]
.   .   .   .   Child: 0  Op: not of type bool [line: 23]						.   .   .   .   Child: 0  Op: not of type bool [line: 23]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 23]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Op: + of type int [line: 23]						.   .   .   .   .   .   Child: 0  Op: + of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 23]					.   .   .   .   .   .   .   Child: 0  Op: chsign of type int [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Const 666 of type int [line: 23]				.   .   .   .   .   .   .   .   Child: 0  Const 666 of type int [line: 23]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 23]					.   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Const 13 of type int [line: 23]					.   .   .   .   .   .   .   Child: 0  Const 13 of type int [line: 23]
.   .   .   Child: 1  Call: output of type void [line: 23]						.   .   .   Child: 1  Call: output of type void [line: 23]
.   .   .   .   Child: 0  Const 0 of type int [line: 23]						.   .   .   .   Child: 0  Const 0 of type int [line: 23]
.   .   .   Child: 2  Call: output of type void [line: 23]						.   .   .   Child: 2  Call: output of type void [line: 23]
.   .   .   .   Child: 0  Const 666 of type int [line: 23]						.   .   .   .   Child: 0  Const 666 of type int [line: 23]
.   .   Sibling: 11  If [line: 24]									.   .   Sibling: 11  If [line: 24]
.   .   .   Child: 0  Op: and of type bool [line: 24]							.   .   .   Child: 0  Op: and of type bool [line: 24]
.   .   .   .   Child: 0  Op: not of type bool [line: 24]						.   .   .   .   Child: 0  Op: not of type bool [line: 24]
.   .   .   .   .   Child: 0  Const false of type bool [line: 24]					.   .   .   .   .   Child: 0  Const false of type bool [line: 24]
.   .   .   .   Child: 1  Const true of type bool [line: 24]						.   .   .   .   Child: 1  Const true of type bool [line: 24]
.   .   .   Child: 1  Call: output of type void [line: 24]						.   .   .   Child: 1  Call: output of type void [line: 24]
.   .   .   .   Child: 0  Const 7 of type int [line: 24]						.   .   .   .   Child: 0  Const 7 of type int [line: 24]
.   .   Sibling: 12  If [line: 25]									.   .   Sibling: 12  If [line: 25]
.   .   .   Child: 0  Op: and of type bool [line: 25]							.   .   .   Child: 0  Op: and of type bool [line: 25]
.   .   .   .   Child: 0  Op: not of type bool [line: 25]						.   .   .   .   Child: 0  Op: not of type bool [line: 25]
.   .   .   .   .   Child: 0  Op: > of type bool [line: 25]						.   .   .   .   .   Child: 0  Op: > of type bool [line: 25]
.   .   .   .   .   .   Child: 0  Const 4 of type int [line: 25]					.   .   .   .   .   .   Child: 0  Const 4 of type int [line: 25]
.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 25]					.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 25]
.   .   .   .   Child: 1  Op: > of type bool [line: 25]							.   .   .   .   Child: 1  Op: > of type bool [line: 25]
.   .   .   .   .   Child: 0  Const 6 of type int [line: 25]						.   .   .   .   .   Child: 0  Const 6 of type int [line: 25]
.   .   .   .   .   Child: 1  Const 4 of type int [line: 25]						.   .   .   .   .   Child: 1  Const 4 of type int [line: 25]
.   .   .   Child: 1  Call: output of type void [line: 25]						.   .   .   Child: 1  Call: output of type void [line: 25]
.   .   .   .   Child: 0  Const 7 of type int [line: 25]						.   .   .   .   Child: 0  Const 7 of type int [line: 25]
.   .   Sibling: 13  Call: outnl of type void [line: 26]						.   .   Sibling: 13  Call: outnl of type void [line: 26]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
proc.out ztmp23114.txt differ: byte 103, line 3
proc (Output DIFF)
WARNING(8): The variable 'b' seems not to be used.							WARNING(8): The variable 'b' seems not to be used.
WARNING(9): The variable 'y' seems not to be used.							WARNING(9): The variable 'y' seems not to be used.
Number of warnings: 2										   |	Loading file: BroadTests/proc.tm
Number of errors: 0										   |	961
------------------------------------								   |	131
Loading file: proc.tm										   |	1 T 666 0 666 7 7
Bye.													Bye.
====================================
FILE: ptriangle.c-
-rw-------. 1 corg7983 domain_users   590 Nov 17 15:35 ptriangle.c-
-rw-------. 1 corg7983 domain_users   589 Nov 17 15:35 ptriangle.c-.f21
-rw-------. 1 corg7983 domain_users   590 Nov 17 15:35 ptriangle.c-.f22
-rw-------. 1 corg7983 domain_users   201 Nov 17 15:35 ptriangle.expected
-rw-------. 1 corg7983 domain_users    22 Nov 17 15:35 ptriangle.in
-rw-------. 1 corg7983 domain_users  5366 Nov 22 12:27 ptriangle.mem
-rw-------. 1 corg7983 domain_users   919 Nov 17 15:35 ptriangle.mem.diffs
-rw-------. 1 corg7983 domain_users  6206 Nov 17 15:35 ptriangle.mem.f21
-rw-------. 1 corg7983 domain_users   198 Nov 22 12:27 ptriangle.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 ptriangle.tm
-rw-------. 1 corg7983 domain_users   411 Nov 17 15:35 ptriangle.tm.diffs
-rw-------. 1 corg7983 domain_users 10099 Nov 17 15:35 ptriangle.tm.f21
TM CODE COMPARISON
ptriangle (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  ptriangle.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION comb
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-2(1)	Load variable a
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 46:    LDC  3,1(6)	Load integer constant 
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 51:     LD  3,-3(1)	Load variable b
												   >	 52:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 53:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 54:     LD  4,-4(1)	Pop left into ac1 
												   >	 55:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 57:    LDC  3,1(6)	Load integer constant 
												   >	 58:    LDA  2,0(3)	Copy result to return register 
												   >	 59:     LD  3,-1(1)	Load return address 
												   >	 60:     LD  1,0(1)	Adjust fp 
												   >	 61:    JMP  7,0(3)	Return 
												   >	 56:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	 62:     LD  3,-3(1)	Load variable b
												   >	 63:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 64:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 65:     LD  4,-4(1)	Pop left into ac1 
												   >	 66:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 68:     LD  3,-2(1)	Load variable a
												   >	 69:    LDA  2,0(3)	Copy result to return register 
												   >	 70:     LD  3,-1(1)	Load return address 
												   >	 71:     LD  1,0(1)	Adjust fp 
												   >	 72:    JMP  7,0(3)	Return 
												   >	 67:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	* CALL comb
												   >	 73:     ST  1,-4(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 74:     LD  3,-2(1)	Load variable a
												   >	 75:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 76:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 77:     LD  4,-6(1)	Pop left into ac1 
												   >	 78:    SUB  3,4,3	Op - 
												   >	 79:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 80:     LD  3,-3(1)	Load variable b
												   >	 81:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 82:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 83:     LD  4,-7(1)	Pop left into ac1 
												   >	 84:    SUB  3,4,3	Op - 
												   >	 85:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end comb
												   >	 86:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-50(7)	CALL comb
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -4
												   >	 90:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	* CALL comb
												   >	 91:     ST  1,-5(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 92:     LD  3,-2(1)	Load variable a
												   >	 93:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 94:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	 95:     LD  4,-7(1)	Pop left into ac1 
												   >	 96:    SUB  3,4,3	Op - 
												   >	 97:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	 98:     LD  3,-3(1)	Load variable b
												   >	 99:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end comb
												   >	100:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	101:    LDA  3,1(7)	Return address in ac 
												   >	102:    JMP  7,-64(7)	CALL comb
												   >	103:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -5
												   >	* TOFF inc: -4
												   >	104:     LD  4,-4(1)	Pop left into ac1 
												   >	105:    ADD  3,4,3	Op + 
												   >	106:    LDA  2,0(3)	Copy result to return register 
												   >	107:     LD  3,-1(1)	Load return address 
												   >	108:     LD  1,0(1)	Adjust fp 
												   >	109:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	110:    LDC  2,0(6)	Set return value to 0 
												   >	111:     LD  3,-1(1)	Load return address 
												   >	112:     LD  1,0(1)	Adjust fp 
												   >	113:    JMP  7,0(3)	Return 
												   >	* END FUNCTION comb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	114:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* WHILE
												   >	115:    LDC  3,1(6)	Load Boolean constant 
												   >	116:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* IF
												   >	* CALL input
												   >	118:     ST  1,-5(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end input
												   >	119:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-121(7)	CALL input
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -5
												   >	123:     ST  3,-4(1)	Store variable n
												   >	124:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	125:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	126:     LD  4,-5(1)	Pop left into ac1 
												   >	127:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* BREAK
												   >	129:    JMP  7,-13(7)	break 
												   >	128:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	130:    LDC  3,0(6)	Load integer constant 
												   >	131:     ST  3,-2(1)	Store variable a
												   >	* WHILE
												   >	132:     LD  3,-2(1)	Load variable a
												   >	133:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	134:     LD  3,-4(1)	Load variable n
												   >	* TOFF inc: -5
												   >	135:     LD  4,-5(1)	Pop left into ac1 
												   >	136:    TLE  3,4,3	Op <= 
												   >	137:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	139:    LDC  3,0(6)	Load integer constant 
												   >	140:     ST  3,-3(1)	Store variable b
												   >	* WHILE
												   >	141:     LD  3,-3(1)	Load variable b
												   >	142:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	143:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -5
												   >	144:     LD  4,-5(1)	Pop left into ac1 
												   >	145:    TLE  3,4,3	Op <= 
												   >	146:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	148:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	* CALL comb
												   >	149:     ST  1,-7(1)	Store fp in ghost frame for comb
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	150:     LD  3,-2(1)	Load variable a
												   >	151:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	152:     LD  3,-3(1)	Load variable b
												   >	153:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end comb
												   >	154:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-118(7)	CALL comb
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end comb
												   >	* TOFF set: -7
												   >	158:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	159:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-156(7)	CALL output
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	163:     LD  3,-3(1)	load lhs variable b
												   >	164:    LDA  3,1(3)	increment value of b
												   >	165:     ST  3,-3(1)	Store variable b
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	166:    JMP  7,-26(7)	go to beginning of loop 
												   >	147:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	167:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	168:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-137(7)	CALL outnl
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	172:     LD  3,-2(1)	load lhs variable a
												   >	173:    LDA  3,1(3)	increment value of a
												   >	174:     ST  3,-2(1)	Store variable a
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	175:    JMP  7,-44(7)	go to beginning of loop 
												   >	138:    JMP  7,37(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	176:    JMP  7,-62(7)	go to beginning of loop 
												   >	117:    JMP  7,59(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	177:    LDC  2,0(6)	Set return value to 0 
												   >	178:     LD  3,-1(1)	Load return address 
												   >	179:     LD  1,0(1)	Adjust fp 
												   >	180:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,180(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	181:    LDA  1,0(0)	set first frame at end of globals 
												   >	182:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	183:    LDA  3,1(7)	Return address in ac 
												   >	184:    JMP  7,-71(7)	Jump to main 
												   >	185:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
ptriangle.mem ptriangle.mem.f21 differ: byte 7, line 1
ptriangle (MEM DIFF)
Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 4]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: comb returns type int [mem: Global loc: 0 size: -4] [line: 4]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 4]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 4]				.   Sibling: 1  Parm: b of type int [mem: Parameter loc: -3 size: 1] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]
.   .   Child: 1  If [line: 6]										.   .   Child: 1  If [line: 6]
.   .   .   Child: 0  Op: == of type bool [line: 6]						   |	.   .   .   Child: 0  Op: = of type bool [line: 6]
.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   Child: 1  Return [line: 7]									.   .   .   Child: 1  Return [line: 7]
.   .   .   .   Child: 0  Const 1 of type int [line: 7]							.   .   .   .   Child: 0  Const 1 of type int [line: 7]
.   .   Sibling: 1  If [line: 8]									.   .   Sibling: 1  If [line: 8]
.   .   .   Child: 0  Op: == of type bool [line: 8]						   |	.   .   .   Child: 0  Op: = of type bool [line: 8]
.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 0 of type int [line: 8]							.   .   .   .   Child: 1  Const 0 of type int [line: 8]
.   .   .   Child: 1  Return [line: 9]									.   .   .   Child: 1  Return [line: 9]
.   .   .   .   Child: 0  Const 1 of type int [line: 9]							.   .   .   .   Child: 0  Const 1 of type int [line: 9]
.   .   Sibling: 2  If [line: 10]									.   .   Sibling: 2  If [line: 10]
.   .   .   Child: 0  Op: == of type bool [line: 10]						   |	.   .   .   Child: 0  Op: = of type bool [line: 10]
.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   .   .   .   Child: 1  Const 1 of type int [line: 10]						.   .   .   .   Child: 1  Const 1 of type int [line: 10]
.   .   .   Child: 1  Return [line: 11]									.   .   .   Child: 1  Return [line: 11]
.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 11]
.   .   Sibling: 3  Return [line: 13]									.   .   Sibling: 3  Return [line: 13]
.   .   .   Child: 0  Op: + of type int [line: 13]							.   .   .   Child: 0  Op: + of type int [line: 13]
.   .   .   .   Child: 0  Call: comb of type int [line: 13]						.   .   .   .   Child: 0  Call: comb of type int [line: 13]
.   .   .   .   .   Child: 0  Op: - of type int [line: 13]						.   .   .   .   .   Child: 0  Op: - of type int [line: 13]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   .   .   .   Sibling: 1  Op: - of type int [line: 13]						.   .   .   .   .   Sibling: 1  Op: - of type int [line: 13]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   .   .   Child: 1  Call: comb of type int [line: 13]						.   .   .   .   Child: 1  Call: comb of type int [line: 13]
.   .   .   .   .   Child: 0  Op: - of type int [line: 13]						.   .   .   .   .   Child: 0  Op: - of type int [line: 13]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]		.   .   .   .   .   Sibling: 1  Id: b of type int [mem: Parameter loc: -3 size: 1] [line: 13]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 16]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 16]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 17]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 17]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 18]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 18]				.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   Child: 1  While [line: 20]									.   .   Child: 1  While [line: 20]
.   .   .   Child: 0  Const true of type bool [line: 20]						.   .   .   Child: 0  Const true of type bool [line: 20]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 20]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 20]
.   .   .   .   Child: 1  If [line: 21]									.   .   .   .   Child: 1  If [line: 21]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 21]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 21]
.   .   .   .   .   .   Child: 0  Assign: = of type int [line: 21]				   |	.   .   .   .   .   .   Child: 0  Assign: := of type int [line: 21]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 21]		.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 21]
.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 21]				.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 21]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 21]
.   .   .   .   .   Child: 1  Break [line: 21]								.   .   .   .   .   Child: 1  Break [line: 21]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 22]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 22]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 22]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 22]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 22]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 22]
.   .   .   .   Sibling: 2  While [line: 23]								.   .   .   .   Sibling: 2  While [line: 23]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 23]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 23]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 23]
.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -4 size: 1] [line: 23]		.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Local loc: -4 size: 1] [line: 23]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 23]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 23]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 24]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 24]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 24]		.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 24]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 24]
.   .   .   .   .   .   Sibling: 1  While [line: 25]							.   .   .   .   .   .   Sibling: 1  While [line: 25]
.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 25]					.   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 25]
.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 25]
.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 26]				.   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 26]
.   .   .   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 26]				.   .   .   .   .   .   .   .   .   Child: 0  Call: comb of type int [line: 26]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Local loc: -3 size: 	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: b of type int [mem: Local loc: -3 size: 
.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 27]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 27]
.   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 29]					.   .   .   .   .   .   Sibling: 2  Call: outnl of type void [line: 29]
.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 30]					.   .   .   .   .   .   Sibling: 3  Assign: ++ of type int [line: 30]
.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 30]		.   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 30]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
ptriangle.out ztmp23114.txt differ: byte 1, line 1
ptriangle (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/ptriangle.tm
Number of errors: 0										   |	entered: 5
------------------------------------								   |	1
Loading file: ptriangle.tm									   |	1 1
ERROR: TM Command 5 unknown.									   |	1 2 1
ERROR: TM Command 7 unknown.									   |	1 3 3 1
ERROR: TM Command 0 unknown.									   |	1 4 6 4 1
												   >	1 5 10 10 5 1
												   >	entered: 7
												   >	1
												   >	1 1
												   >	1 2 1
												   >	1 3 3 1
												   >	1 4 6 4 1
												   >	1 5 10 10 5 1
												   >	1 6 15 20 15 6 1
												   >	1 7 21 35 35 21 7 1
												   >	entered: 0
Bye.													Bye.
====================================
FILE: pushpoparray.c-
-rw-------. 1 corg7983 domain_users   605 Nov 17 15:35 pushpoparray.c-
-rw-------. 1 corg7983 domain_users   616 Nov 17 15:35 pushpoparray.c-.f21
-rw-------. 1 corg7983 domain_users   605 Nov 17 15:35 pushpoparray.c-.f22
-rw-------. 1 corg7983 domain_users   147 Nov 17 15:35 pushpoparray.expected
-rw-------. 1 corg7983 domain_users  8997 Nov 22 12:27 pushpoparray.mem
-rw-------. 1 corg7983 domain_users  1331 Nov 17 15:35 pushpoparray.mem.diffs
-rw-------. 1 corg7983 domain_users  9850 Nov 17 15:35 pushpoparray.mem.f21
-rw-------. 1 corg7983 domain_users   166 Nov 22 12:27 pushpoparray.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 pushpoparray.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 pushpoparray.tm.diffs
-rw-------. 1 corg7983 domain_users 19634 Nov 17 15:35 pushpoparray.tm.f21
TM CODE COMPARISON
pushpoparray (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpoparray.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-2(1)	Load address of base of array pa
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:    LDC  3,66(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    SUB  3,4,3	compute location from index 
												   >	 45:     LD  3,0(3)	Load array element 
												   >	* EXPRESSION
												   >	 46:     LD  3,-2(1)	Load address of base of array pa
												   >	 47:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 48:    LDC  3,22(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 49:     LD  4,-3(1)	Pop left into ac1 
												   >	 50:    SUB  3,4,3	compute location from index 
												   >	 51:     LD  3,0(3)	Load array element 
												   >	 52:     ST  3,0(0)	Store variable a
												   >	* EXPRESSION
												   >	 53:    LDC  3,88(6)	Load integer constant 
												   >	 54:     LD  5,-2(1)	Load address of base of array pa
												   >	 55:    SUB  5,5,3	Compute offset of value 
												   >	 56:     LD  3,0(5)	load lhs variable pa
												   >	 57:    LDA  3,1(3)	increment value of pa
												   >	 58:     ST  3,0(5)	Store variable pa
												   >	* EXPRESSION
												   >	* CALL output
												   >	 59:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 60:     LD  3,0(0)	Load variable a
												   >	 61:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 62:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 63:    LDA  3,1(7)	Return address in ac 
												   >	 64:    JMP  7,-59(7)	CALL output
												   >	 65:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	 66:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 67:     LD  3,-2(1)	Load address of base of array pa
												   >	 68:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 69:    LDC  3,88(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 70:     LD  4,-5(1)	Pop left into ac1 
												   >	 71:    SUB  3,4,3	compute location from index 
												   >	 72:     LD  3,0(3)	Load array element 
												   >	 73:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 74:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-71(7)	CALL output
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* RETURN
												   >	 78:     LD  3,-2(1)	Load address of base of array pa
												   >	 79:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 80:    LDC  3,22(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 81:     LD  4,-3(1)	Pop left into ac1 
												   >	 82:    SUB  3,4,3	compute location from index 
												   >	 83:     LD  3,0(3)	Load array element 
												   >	 84:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 85:     LD  3,-2(1)	Load address of base of array pa
												   >	 86:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 87:    LDC  3,44(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 88:     LD  4,-4(1)	Pop left into ac1 
												   >	 89:    SUB  3,4,3	compute location from index 
												   >	 90:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -3
												   >	 91:     LD  4,-3(1)	Pop left into ac1 
												   >	 92:    ADD  3,4,3	Op + 
												   >	 93:    LDA  2,0(3)	Copy result to return register 
												   >	 94:     LD  3,-1(1)	Load return address 
												   >	 95:     LD  1,0(1)	Adjust fp 
												   >	 96:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 97:    LDC  2,0(6)	Set return value to 0 
												   >	 98:     LD  3,-1(1)	Load return address 
												   >	 99:     LD  1,0(1)	Adjust fp 
												   >	100:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	101:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -104
												   >	102:    LDC  3,100(6)	load size of array bb
												   >	103:     ST  3,-3(1)	save size of array bb
												   >	* Compound Body
												   >	* EXPRESSION
												   >	104:    LDC  3,11(6)	Load integer constant 
												   >	105:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	106:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	107:     LD  4,-104(1)	Pop index 
												   >	108:    LDA  5,-2(0)	Load address of base of array aa
												   >	109:    SUB  5,5,4	Compute offset of value 
												   >	110:     ST  3,0(5)	Store variable aa
												   >	* EXPRESSION
												   >	111:    LDC  3,22(6)	Load integer constant 
												   >	112:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	113:    LDC  3,22(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	114:     LD  4,-104(1)	Pop index 
												   >	115:    LDA  5,-4(1)	Load address of base of array bb
												   >	116:    SUB  5,5,4	Compute offset of value 
												   >	117:     ST  3,0(5)	Store variable bb
												   >	* EXPRESSION
												   >	118:    LDC  3,33(6)	Load integer constant 
												   >	119:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	120:    LDC  3,33(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	121:     LD  4,-104(1)	Pop index 
												   >	122:    LDA  5,-2(0)	Load address of base of array aa
												   >	123:    SUB  5,5,4	Compute offset of value 
												   >	124:     ST  3,0(5)	Store variable aa
												   >	* EXPRESSION
												   >	125:    LDC  3,44(6)	Load integer constant 
												   >	126:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	127:    LDC  3,44(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	128:     LD  4,-104(1)	Pop index 
												   >	129:    LDA  5,-4(1)	Load address of base of array bb
												   >	130:    SUB  5,5,4	Compute offset of value 
												   >	131:     ST  3,0(5)	Store variable bb
												   >	* EXPRESSION
												   >	132:    LDC  3,55(6)	Load integer constant 
												   >	133:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	134:    LDC  3,55(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	135:     LD  4,-104(1)	Pop index 
												   >	136:    LDA  5,-2(0)	Load address of base of array aa
												   >	137:    SUB  5,5,4	Compute offset of value 
												   >	138:     ST  3,0(5)	Store variable aa
												   >	* EXPRESSION
												   >	139:    LDC  3,66(6)	Load integer constant 
												   >	140:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	141:    LDC  3,66(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	142:     LD  4,-104(1)	Pop index 
												   >	143:    LDA  5,-4(1)	Load address of base of array bb
												   >	144:    SUB  5,5,4	Compute offset of value 
												   >	145:     ST  3,0(5)	Store variable bb
												   >	* EXPRESSION
												   >	146:    LDC  3,77(6)	Load integer constant 
												   >	147:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	148:    LDC  3,77(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	149:     LD  4,-104(1)	Pop index 
												   >	150:    LDA  5,-2(0)	Load address of base of array aa
												   >	151:    SUB  5,5,4	Compute offset of value 
												   >	152:     ST  3,0(5)	Store variable aa
												   >	* EXPRESSION
												   >	153:    LDC  3,88(6)	Load integer constant 
												   >	154:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	155:    LDC  3,88(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	156:     LD  4,-104(1)	Pop index 
												   >	157:    LDA  5,-4(1)	Load address of base of array bb
												   >	158:    SUB  5,5,4	Compute offset of value 
												   >	159:     ST  3,0(5)	Store variable bb
												   >	* EXPRESSION
												   >	160:    LDC  3,99(6)	Load integer constant 
												   >	161:     ST  3,-104(1)	Push index 
												   >	* TOFF dec: -105
												   >	162:    LDC  3,99(6)	Load integer constant 
												   >	* TOFF inc: -104
												   >	163:     LD  4,-104(1)	Pop index 
												   >	164:    LDA  5,-2(0)	Load address of base of array aa
												   >	165:    SUB  5,5,4	Compute offset of value 
												   >	166:     ST  3,0(5)	Store variable aa
												   >	* EXPRESSION
												   >	* CALL output
												   >	167:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	168:    LDA  3,-2(0)	Load address of base of array aa
												   >	169:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	170:    LDC  3,11(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	171:     LD  4,-106(1)	Pop left into ac1 
												   >	172:    SUB  3,4,3	compute location from index 
												   >	173:     LD  3,0(3)	Load array element 
												   >	174:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	175:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	176:    LDA  3,1(7)	Return address in ac 
												   >	177:    JMP  7,-172(7)	CALL output
												   >	178:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	179:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	180:    LDA  3,-4(1)	Load address of base of array bb
												   >	181:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	182:    LDC  3,22(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	183:     LD  4,-106(1)	Pop left into ac1 
												   >	184:    SUB  3,4,3	compute location from index 
												   >	185:     LD  3,0(3)	Load array element 
												   >	186:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	187:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-184(7)	CALL output
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	191:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	192:    LDC  3,99(6)	Load integer constant 
												   >	193:    LDA  5,-2(0)	Load address of base of array aa
												   >	194:    SUB  5,5,3	Compute offset of value 
												   >	195:     LD  3,0(5)	load lhs variable aa
												   >	196:    LDA  3,1(3)	increment value of aa
												   >	197:     ST  3,0(5)	Store variable aa
												   >	198:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	199:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-196(7)	CALL output
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	203:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	204:    LDA  3,-2(0)	Load address of base of array aa
												   >	205:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	206:    LDC  3,99(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	207:     LD  4,-106(1)	Pop left into ac1 
												   >	208:    SUB  3,4,3	compute location from index 
												   >	209:     LD  3,0(3)	Load array element 
												   >	210:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	211:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	212:    LDA  3,1(7)	Return address in ac 
												   >	213:    JMP  7,-208(7)	CALL output
												   >	214:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	215:     ST  1,-104(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param end outnl
												   >	216:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	217:    LDA  3,1(7)	Return address in ac 
												   >	218:    JMP  7,-185(7)	CALL outnl
												   >	219:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	220:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	221:    LDA  3,-2(0)	Load address of base of array aa
												   >	222:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	223:    LDC  3,33(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	224:     LD  4,-106(1)	Pop left into ac1 
												   >	225:    SUB  3,4,3	compute location from index 
												   >	226:     LD  3,0(3)	Load array element 
												   >	227:     ST  3,0(0)	Store variable a
												   >	228:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	229:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	230:    LDA  3,1(7)	Return address in ac 
												   >	231:    JMP  7,-226(7)	CALL output
												   >	232:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	233:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	234:     LD  3,0(0)	Load variable a
												   >	235:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	236:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	237:    LDA  3,1(7)	Return address in ac 
												   >	238:    JMP  7,-233(7)	CALL output
												   >	239:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	240:     ST  1,-104(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param end outnl
												   >	241:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	242:    LDA  3,1(7)	Return address in ac 
												   >	243:    JMP  7,-210(7)	CALL outnl
												   >	244:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	245:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	246:    LDA  3,-4(1)	Load address of base of array bb
												   >	247:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	248:    LDC  3,66(6)	Load integer constant 
												   >	249:     ST  3,-107(1)	Push left side 
												   >	* TOFF dec: -108
												   >	250:    LDC  3,44(6)	Load integer constant 
												   >	* TOFF inc: -107
												   >	251:     LD  4,-107(1)	Pop left into ac1 
												   >	252:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -106
												   >	253:     LD  4,-106(1)	Pop left into ac1 
												   >	254:    SUB  3,4,3	compute location from index 
												   >	255:     LD  3,0(3)	Load array element 
												   >	256:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	257:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	258:    LDA  3,1(7)	Return address in ac 
												   >	259:    JMP  7,-254(7)	CALL output
												   >	260:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	261:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	262:    LDA  3,-2(0)	Load address of base of array aa
												   >	263:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	264:    LDC  3,77(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	265:     LD  4,-106(1)	Pop left into ac1 
												   >	266:    SUB  3,4,3	compute location from index 
												   >	267:     LD  3,0(3)	Load array element 
												   >	268:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	269:    LDA  3,-4(1)	Load address of base of array bb
												   >	270:     ST  3,-107(1)	Push left side 
												   >	* TOFF dec: -108
												   >	271:    LDC  3,88(6)	Load integer constant 
												   >	* TOFF inc: -107
												   >	272:     LD  4,-107(1)	Pop left into ac1 
												   >	273:    SUB  3,4,3	compute location from index 
												   >	274:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -106
												   >	275:     LD  4,-106(1)	Pop left into ac1 
												   >	276:    MUL  3,4,3	Op * 
												   >	277:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	278:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	279:    LDA  3,1(7)	Return address in ac 
												   >	280:    JMP  7,-275(7)	CALL output
												   >	281:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	282:     ST  1,-104(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param end outnl
												   >	283:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	284:    LDA  3,1(7)	Return address in ac 
												   >	285:    JMP  7,-252(7)	CALL outnl
												   >	286:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	287:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	* CALL dog
												   >	288:     ST  1,-106(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -107
												   >	* TOFF dec: -108
												   >	* Param 1
												   >	289:    LDA  3,-4(1)	Load address of base of array bb
												   >	290:     ST  3,-108(1)	Push parameter 
												   >	* TOFF dec: -109
												   >	* Param end dog
												   >	291:    LDA  1,-106(1)	Ghost frame becomes new active frame 
												   >	292:    LDA  3,1(7)	Return address in ac 
												   >	293:    JMP  7,-255(7)	CALL dog
												   >	294:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -106
												   >	295:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	296:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	297:    LDA  3,1(7)	Return address in ac 
												   >	298:    JMP  7,-293(7)	CALL output
												   >	299:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	300:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	301:    LDA  3,-4(1)	Load address of base of array bb
												   >	302:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	303:    LDC  3,88(6)	Load integer constant 
												   >	* TOFF inc: -106
												   >	304:     LD  4,-106(1)	Pop left into ac1 
												   >	305:    SUB  3,4,3	compute location from index 
												   >	306:     LD  3,0(3)	Load array element 
												   >	307:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	308:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	309:    LDA  3,1(7)	Return address in ac 
												   >	310:    JMP  7,-305(7)	CALL output
												   >	311:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL output
												   >	312:     ST  1,-104(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param 1
												   >	313:    LDA  3,-4(1)	Load address of base of array bb
												   >	314:     ST  3,-106(1)	Push left side 
												   >	* TOFF dec: -107
												   >	* CALL dog
												   >	315:     ST  1,-107(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -108
												   >	* TOFF dec: -109
												   >	* Param 1
												   >	316:    LDA  3,-4(1)	Load address of base of array bb
												   >	317:     ST  3,-109(1)	Push parameter 
												   >	* TOFF dec: -110
												   >	* Param end dog
												   >	318:    LDA  1,-107(1)	Ghost frame becomes new active frame 
												   >	319:    LDA  3,1(7)	Return address in ac 
												   >	320:    JMP  7,-282(7)	CALL dog
												   >	321:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -107
												   >	* TOFF inc: -106
												   >	322:     LD  4,-106(1)	Pop left into ac1 
												   >	323:    SUB  3,4,3	compute location from index 
												   >	324:     LD  3,0(3)	Load array element 
												   >	325:     ST  3,-106(1)	Push parameter 
												   >	* TOFF dec: -107
												   >	* Param end output
												   >	326:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	327:    LDA  3,1(7)	Return address in ac 
												   >	328:    JMP  7,-323(7)	CALL output
												   >	329:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -104
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	330:     ST  1,-104(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -105
												   >	* TOFF dec: -106
												   >	* Param end outnl
												   >	331:    LDA  1,-104(1)	Ghost frame becomes new active frame 
												   >	332:    LDA  3,1(7)	Return address in ac 
												   >	333:    JMP  7,-300(7)	CALL outnl
												   >	334:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -104
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	335:    LDC  2,0(6)	Set return value to 0 
												   >	336:     LD  3,-1(1)	Load return address 
												   >	337:     LD  1,0(1)	Adjust fp 
												   >	338:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,338(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	339:    LDA  1,-102(0)	set first frame at end of globals 
												   >	340:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	341:    LDC  3,100(6)	load size of array aa
												   >	342:     ST  3,-1(0)	save size of array aa
												   >	* END INIT GLOBALS AND STATICS
												   >	343:    LDA  3,1(7)	Return address in ac 
												   >	344:    JMP  7,-244(7)	Jump to main 
												   >	345:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpoparray.mem pushpoparray.mem.f21 differ: byte 53, line 2
pushpoparray (MEM DIFF)
WARNING(16): The variable 'b' seems not to be used.							WARNING(16): The variable 'b' seems not to be used.
Var: a of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: aa of array of type int [mem: Global loc: -2 size: 101] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: a of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: aa of array of type int [mem: Global loc: -2 size: 101] [line: 1]
												   >	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   Child: 0  Parm: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 4]
.   .   Child: 1  Op: [ of type int [line: 5]								.   .   Child: 1  Op: [ of type int [line: 5]
.   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Const 66 of type int [line: 5]							.   .   .   Child: 1  Const 66 of type int [line: 5]
.   .   Sibling: 1  Assign: = of type int [line: 6]						   |	.   .   Sibling: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 6]				.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 6]
.   .   .   Child: 1  Op: [ of type int [line: 6]							.   .   .   Child: 1  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]	.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 22 of type int [line: 6]						.   .   .   .   Child: 1  Const 22 of type int [line: 6]
.   .   Sibling: 2  Assign: ++ of type int [line: 7]							.   .   Sibling: 2  Assign: ++ of type int [line: 7]
.   .   .   Child: 0  Op: [ of type int [line: 7]							.   .   .   Child: 0  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]	.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Const 88 of type int [line: 7]						.   .   .   .   Child: 1  Const 88 of type int [line: 7]
.   .   Sibling: 3  Call: output of type void [line: 8]							.   .   Sibling: 3  Call: output of type void [line: 8]
.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 8]				.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 8]
.   .   Sibling: 4  Call: output of type void [line: 9]							.   .   Sibling: 4  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: [ of type int [line: 9]							.   .   .   Child: 0  Op: [ of type int [line: 9]
.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 9]	.   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Const 88 of type int [line: 9]						.   .   .   .   Child: 1  Const 88 of type int [line: 9]
.   .   Sibling: 5  Return [line: 10]									.   .   Sibling: 5  Return [line: 10]
.   .   .   Child: 0  Op: + of type int [line: 10]							.   .   .   Child: 0  Op: + of type int [line: 10]
.   .   .   .   Child: 0  Op: [ of type int [line: 10]							.   .   .   .   Child: 0  Op: [ of type int [line: 10]
.   .   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line	.   .   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line
.   .   .   .   .   Child: 1  Const 22 of type int [line: 10]						.   .   .   .   .   Child: 1  Const 22 of type int [line: 10]
.   .   .   .   Child: 1  Op: [ of type int [line: 10]							.   .   .   .   Child: 1  Op: [ of type int [line: 10]
.   .   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line	.   .   .   .   .   Child: 0  Id: pa of array of type int [mem: Parameter loc: -2 size: 1] [line
.   .   .   .   .   Child: 1  Const 44 of type int [line: 10]						.   .   .   .   .   Child: 1  Const 44 of type int [line: 10]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]
.   Child: 1  Compound [mem: None loc: 0 size: -104] [line: 15]						.   Child: 1  Compound [mem: None loc: 0 size: -104] [line: 15]
.   .   Child: 0  Var: b of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   Child: 0  Var: b of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   Sibling: 1  Var: bb of array of type int [mem: Local loc: -4 size: 101] [line: 16]		.   .   Sibling: 1  Var: bb of array of type int [mem: Local loc: -4 size: 101] [line: 16]
.   .   Child: 1  Assign: = of type int [line: 18]						   |	.   .   Child: 1  Assign: := of type int [line: 18]
.   .   .   Child: 0  Op: [ of type int [line: 18]							.   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 18]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 18]
.   .   .   .   Child: 1  Const 11 of type int [line: 18]						.   .   .   .   Child: 1  Const 11 of type int [line: 18]
.   .   .   Child: 1  Const 11 of type int [line: 18]							.   .   .   Child: 1  Const 11 of type int [line: 18]
.   .   Sibling: 1  Assign: = of type int [line: 19]						   |	.   .   Sibling: 1  Assign: := of type int [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 19]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 19]
.   .   .   .   Child: 1  Const 22 of type int [line: 19]						.   .   .   .   Child: 1  Const 22 of type int [line: 19]
.   .   .   Child: 1  Const 22 of type int [line: 19]							.   .   .   Child: 1  Const 22 of type int [line: 19]
.   .   Sibling: 2  Assign: = of type int [line: 20]						   |	.   .   Sibling: 2  Assign: := of type int [line: 20]
.   .   .   Child: 0  Op: [ of type int [line: 20]							.   .   .   Child: 0  Op: [ of type int [line: 20]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 20]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 20]
.   .   .   .   Child: 1  Const 33 of type int [line: 20]						.   .   .   .   Child: 1  Const 33 of type int [line: 20]
.   .   .   Child: 1  Const 33 of type int [line: 20]							.   .   .   Child: 1  Const 33 of type int [line: 20]
.   .   Sibling: 3  Assign: = of type int [line: 21]						   |	.   .   Sibling: 3  Assign: := of type int [line: 21]
.   .   .   Child: 0  Op: [ of type int [line: 21]							.   .   .   Child: 0  Op: [ of type int [line: 21]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 21]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 21]
.   .   .   .   Child: 1  Const 44 of type int [line: 21]						.   .   .   .   Child: 1  Const 44 of type int [line: 21]
.   .   .   Child: 1  Const 44 of type int [line: 21]							.   .   .   Child: 1  Const 44 of type int [line: 21]
.   .   Sibling: 4  Assign: = of type int [line: 22]						   |	.   .   Sibling: 4  Assign: := of type int [line: 22]
.   .   .   Child: 0  Op: [ of type int [line: 22]							.   .   .   Child: 0  Op: [ of type int [line: 22]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 22]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 22]
.   .   .   .   Child: 1  Const 55 of type int [line: 22]						.   .   .   .   Child: 1  Const 55 of type int [line: 22]
.   .   .   Child: 1  Const 55 of type int [line: 22]							.   .   .   Child: 1  Const 55 of type int [line: 22]
.   .   Sibling: 5  Assign: = of type int [line: 23]						   |	.   .   Sibling: 5  Assign: := of type int [line: 23]
.   .   .   Child: 0  Op: [ of type int [line: 23]							.   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 23]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 23]
.   .   .   .   Child: 1  Const 66 of type int [line: 23]						.   .   .   .   Child: 1  Const 66 of type int [line: 23]
.   .   .   Child: 1  Const 66 of type int [line: 23]							.   .   .   Child: 1  Const 66 of type int [line: 23]
.   .   Sibling: 6  Assign: = of type int [line: 24]						   |	.   .   Sibling: 6  Assign: := of type int [line: 24]
.   .   .   Child: 0  Op: [ of type int [line: 24]							.   .   .   Child: 0  Op: [ of type int [line: 24]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 24]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 24]
.   .   .   .   Child: 1  Const 77 of type int [line: 24]						.   .   .   .   Child: 1  Const 77 of type int [line: 24]
.   .   .   Child: 1  Const 77 of type int [line: 24]							.   .   .   Child: 1  Const 77 of type int [line: 24]
.   .   Sibling: 7  Assign: = of type int [line: 25]						   |	.   .   Sibling: 7  Assign: := of type int [line: 25]
.   .   .   Child: 0  Op: [ of type int [line: 25]							.   .   .   Child: 0  Op: [ of type int [line: 25]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 25]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 25]
.   .   .   .   Child: 1  Const 88 of type int [line: 25]						.   .   .   .   Child: 1  Const 88 of type int [line: 25]
.   .   .   Child: 1  Const 88 of type int [line: 25]							.   .   .   Child: 1  Const 88 of type int [line: 25]
.   .   Sibling: 8  Assign: = of type int [line: 26]						   |	.   .   Sibling: 8  Assign: := of type int [line: 26]
.   .   .   Child: 0  Op: [ of type int [line: 26]							.   .   .   Child: 0  Op: [ of type int [line: 26]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 26]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 26]
.   .   .   .   Child: 1  Const 99 of type int [line: 26]						.   .   .   .   Child: 1  Const 99 of type int [line: 26]
.   .   .   Child: 1  Const 99 of type int [line: 26]							.   .   .   Child: 1  Const 99 of type int [line: 26]
.   .   Sibling: 9  Call: output of type void [line: 28]						.   .   Sibling: 9  Call: output of type void [line: 28]
.   .   .   Child: 0  Op: [ of type int [line: 28]							.   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 28]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 28]
.   .   .   .   Child: 1  Const 11 of type int [line: 28]						.   .   .   .   Child: 1  Const 11 of type int [line: 28]
.   .   Sibling: 10  Call: output of type void [line: 29]						.   .   Sibling: 10  Call: output of type void [line: 29]
.   .   .   Child: 0  Op: [ of type int [line: 29]							.   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 29]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 29]
.   .   .   .   Child: 1  Const 22 of type int [line: 29]						.   .   .   .   Child: 1  Const 22 of type int [line: 29]
.   .   Sibling: 11  Call: output of type void [line: 30]						.   .   Sibling: 11  Call: output of type void [line: 30]
.   .   .   Child: 0  Assign: ++ of type int [line: 30]							.   .   .   Child: 0  Assign: ++ of type int [line: 30]
.   .   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:	.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:
.   .   .   .   .   Child: 1  Const 99 of type int [line: 30]						.   .   .   .   .   Child: 1  Const 99 of type int [line: 30]
.   .   Sibling: 12  Call: output of type void [line: 31]						.   .   Sibling: 12  Call: output of type void [line: 31]
.   .   .   Child: 0  Op: [ of type int [line: 31]							.   .   .   Child: 0  Op: [ of type int [line: 31]
.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 31]	.   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line: 31]
.   .   .   .   Child: 1  Const 99 of type int [line: 31]						.   .   .   .   Child: 1  Const 99 of type int [line: 31]
.   .   Sibling: 13  Call: outnl of type void [line: 32]						.   .   Sibling: 13  Call: outnl of type void [line: 32]
.   .   Sibling: 14  Call: output of type void [line: 34]						.   .   Sibling: 14  Call: output of type void [line: 34]
.   .   .   Child: 0  Assign: = of type int [line: 34]						   |	.   .   .   Child: 0  Assign: := of type int [line: 34]
.   .   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 34]			.   .   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 34]
.   .   .   .   Child: 1  Op: [ of type int [line: 34]							.   .   .   .   Child: 1  Op: [ of type int [line: 34]
.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:	.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:
.   .   .   .   .   Child: 1  Const 33 of type int [line: 34]						.   .   .   .   .   Child: 1  Const 33 of type int [line: 34]
.   .   Sibling: 15  Call: output of type void [line: 35]						.   .   Sibling: 15  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 35]				.   .   .   Child: 0  Id: a of type int [mem: Global loc: 0 size: 1] [line: 35]
.   .   Sibling: 16  Call: outnl of type void [line: 36]						.   .   Sibling: 16  Call: outnl of type void [line: 36]
.   .   Sibling: 17  Call: output of type void [line: 38]						.   .   Sibling: 17  Call: output of type void [line: 38]
.   .   .   Child: 0  Op: [ of type int [line: 38]							.   .   .   Child: 0  Op: [ of type int [line: 38]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 38]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 38]
.   .   .   .   Child: 1  Op: - of type int [line: 38]							.   .   .   .   Child: 1  Op: - of type int [line: 38]
.   .   .   .   .   Child: 0  Const 66 of type int [line: 38]						.   .   .   .   .   Child: 0  Const 66 of type int [line: 38]
.   .   .   .   .   Child: 1  Const 44 of type int [line: 38]						.   .   .   .   .   Child: 1  Const 44 of type int [line: 38]
.   .   Sibling: 18  Call: output of type void [line: 39]						.   .   Sibling: 18  Call: output of type void [line: 39]
.   .   .   Child: 0  Op: * of type int [line: 39]							.   .   .   Child: 0  Op: * of type int [line: 39]
.   .   .   .   Child: 0  Op: [ of type int [line: 39]							.   .   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:	.   .   .   .   .   Child: 0  Id: aa of array of type int [mem: Global loc: -2 size: 101] [line:
.   .   .   .   .   Child: 1  Const 77 of type int [line: 39]						.   .   .   .   .   Child: 1  Const 77 of type int [line: 39]
.   .   .   .   Child: 1  Op: [ of type int [line: 39]							.   .   .   .   Child: 1  Op: [ of type int [line: 39]
.   .   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 	.   .   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 
.   .   .   .   .   Child: 1  Const 88 of type int [line: 39]						.   .   .   .   .   Child: 1  Const 88 of type int [line: 39]
.   .   Sibling: 19  Call: outnl of type void [line: 40]						.   .   Sibling: 19  Call: outnl of type void [line: 40]
.   .   Sibling: 20  Call: output of type void [line: 42]						.   .   Sibling: 20  Call: output of type void [line: 42]
.   .   .   Child: 0  Call: dog of type int [line: 42]							.   .   .   Child: 0  Call: dog of type int [line: 42]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 42]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 42]
.   .   Sibling: 21  Call: output of type void [line: 43]						.   .   Sibling: 21  Call: output of type void [line: 43]
.   .   .   Child: 0  Op: [ of type int [line: 43]							.   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 43]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 43]
.   .   .   .   Child: 1  Const 88 of type int [line: 43]						.   .   .   .   Child: 1  Const 88 of type int [line: 43]
.   .   Sibling: 22  Call: output of type void [line: 44]						.   .   Sibling: 22  Call: output of type void [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 44]		.   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 44]
.   .   .   .   Child: 1  Call: dog of type int [line: 44]						.   .   .   .   Child: 1  Call: dog of type int [line: 44]
.   .   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 	.   .   .   .   .   Child: 0  Id: bb of array of type int [mem: Local loc: -4 size: 101] [line: 
.   .   Sibling: 23  Call: outnl of type void [line: 45]						.   .   Sibling: 23  Call: outnl of type void [line: 45]
Offset for end of global space: -102									Offset for end of global space: -102
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
pushpoparray.out ztmp23114.txt differ: byte 53, line 2
pushpoparray (Output DIFF)
WARNING(16): The variable 'b' seems not to be used.							WARNING(16): The variable 'b' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/pushpoparray.tm
Number of errors: 0										   |	11 22 100 100
------------------------------------								   |	33 33
Loading file: pushpoparray.tm									   |	22 6776
												   >	22 89 66 89 22 90 66
Bye.													Bye.
====================================
FILE: pushpopcall2.c-
-rw-------. 1 corg7983 domain_users  204 Nov 17 15:35 pushpopcall2.c-
-rw-------. 1 corg7983 domain_users  207 Nov 17 15:35 pushpopcall2.c-.f21
-rw-------. 1 corg7983 domain_users  204 Nov 17 15:35 pushpopcall2.c-.f22
-rw-------. 1 corg7983 domain_users  118 Nov 17 15:35 pushpopcall2.expected
-rw-------. 1 corg7983 domain_users 2777 Nov 22 12:27 pushpopcall2.mem
-rw-------. 1 corg7983 domain_users  377 Nov 17 15:35 pushpopcall2.mem.diffs
-rw-------. 1 corg7983 domain_users 3621 Nov 17 15:35 pushpopcall2.mem.f21
-rw-------. 1 corg7983 domain_users  165 Nov 22 12:27 pushpopcall2.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 pushpopcall2.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 pushpopcall2.tm.diffs
-rw-------. 1 corg7983 domain_users 7088 Nov 17 15:35 pushpopcall2.tm.f21
TM CODE COMPARISON
pushpopcall2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpopcall2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	 40:     LD  3,-2(1)	Load variable x
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:     LD  3,-3(1)	Load variable y
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    MUL  3,4,3	Op * 
												   >	 45:    LDA  2,0(3)	Copy result to return register 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 49:    LDC  2,0(6)	Set return value to 0 
												   >	 50:     LD  3,-1(1)	Load return address 
												   >	 51:     LD  1,0(1)	Adjust fp 
												   >	 52:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 53:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 54:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL dog
												   >	 55:     ST  1,-4(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 56:    LDC  3,111(6)	Load integer constant 
												   >	 57:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 58:    LDC  3,222(6)	Load integer constant 
												   >	 59:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	 60:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-24(7)	CALL dog
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -4
												   >	 64:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	 65:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 66:    LDA  3,1(7)	Return address in ac 
												   >	 67:    JMP  7,-62(7)	CALL output
												   >	 68:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 69:    LDC  3,333(6)	Load integer constant 
												   >	 70:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 71:    LDC  3,444(6)	Load integer constant 
												   >	 72:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	 73:    LDC  3,555(6)	Load integer constant 
												   >	 74:     ST  3,-4(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	 75:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	* CALL dog
												   >	 76:     ST  1,-7(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 77:     LD  3,-2(1)	Load variable x
												   >	 78:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	 79:     LD  3,-3(1)	Load variable y
												   >	 80:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end dog
												   >	 81:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 82:    LDA  3,1(7)	Return address in ac 
												   >	 83:    JMP  7,-45(7)	CALL dog
												   >	 84:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -7
												   >	 85:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 86:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 87:    LDA  3,1(7)	Return address in ac 
												   >	 88:    JMP  7,-83(7)	CALL output
												   >	 89:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	 90:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL dog
												   >	 91:     ST  1,-4(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 92:    LDC  3,333(6)	Load integer constant 
												   >	 93:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 94:    LDC  3,33(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 95:     LD  4,-6(1)	Pop left into ac1 
												   >	 96:    ADD  3,4,3	Op + 
												   >	 97:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	 98:    LDC  3,444(6)	Load integer constant 
												   >	 99:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	100:    LDC  3,44(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	101:     LD  4,-7(1)	Pop left into ac1 
												   >	102:    MUL  3,4,3	Op * 
												   >	103:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	104:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	105:    LDA  3,1(7)	Return address in ac 
												   >	106:    JMP  7,-68(7)	CALL dog
												   >	107:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -4
												   >	108:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	109:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-106(7)	CALL output
												   >	112:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	113:    LDC  2,0(6)	Set return value to 0 
												   >	114:     LD  3,-1(1)	Load return address 
												   >	115:     LD  1,0(1)	Adjust fp 
												   >	116:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,116(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	117:    LDA  1,-1(0)	set first frame at end of globals 
												   >	118:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	119:    LDA  3,1(7)	Return address in ac 
												   >	120:    JMP  7,-68(7)	Jump to main 
												   >	121:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpopcall2.mem pushpopcall2.mem.f21 differ: byte 58, line 2
pushpopcall2 (MEM DIFF)
WARNING(3): The variable 'g' seems not to be used.							WARNING(3): The variable 'g' seems not to be used.
Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 1]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]				.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 1]
.   .   Child: 1  Return [line: 1]									.   .   Child: 1  Return [line: 1]
.   .   .   Child: 0  Op: * of type int [line: 1]							.   .   .   Child: 0  Op: * of type int [line: 1]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]			.   .   .   .   Child: 1  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]
Sibling: 1  Var: g of type int [mem: Global loc: 0 size: 1] [line: 3]				   |	Sibling: 8  Var: g of type int [mem: Global loc: 0 size: 1] [line: 3]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 4]
.   .   Child: 1  Call: output of type void [line: 5]							.   .   Child: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Call: dog of type int [line: 5]							.   .   .   Child: 0  Call: dog of type int [line: 5]
.   .   .   .   Child: 0  Const 111 of type int [line: 5]						.   .   .   .   Child: 0  Const 111 of type int [line: 5]
.   .   .   .   Sibling: 1  Const 222 of type int [line: 5]						.   .   .   .   Sibling: 1  Const 222 of type int [line: 5]
.   .   Sibling: 1  Compound [mem: None loc: 0 size: -5] [line: 6]					.   .   Sibling: 1  Compound [mem: None loc: 0 size: -5] [line: 6]
.   .   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 7]			.   .   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 7]			.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 333 of type int [line: 8]						.   .   .   .   Child: 1  Const 333 of type int [line: 8]
.   .   .   Sibling: 1  Assign: = of type int [line: 8]						   |	.   .   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 444 of type int [line: 8]						.   .   .   .   Child: 1  Const 444 of type int [line: 8]
.   .   .   Sibling: 2  Assign: = of type int [line: 8]						   |	.   .   .   Sibling: 2  Assign: := of type int [line: 8]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   .   Child: 1  Const 555 of type int [line: 8]						.   .   .   .   Child: 1  Const 555 of type int [line: 8]
.   .   .   Sibling: 3  Call: output of type void [line: 9]						.   .   .   Sibling: 3  Call: output of type void [line: 9]
.   .   .   .   Child: 0  Call: dog of type int [line: 9]						.   .   .   .   Child: 0  Call: dog of type int [line: 9]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]		.   .   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 2  Call: output of type void [line: 11]						.   .   Sibling: 2  Call: output of type void [line: 11]
.   .   .   Child: 0  Call: dog of type int [line: 11]							.   .   .   Child: 0  Call: dog of type int [line: 11]
.   .   .   .   Child: 0  Op: + of type int [line: 11]							.   .   .   .   Child: 0  Op: + of type int [line: 11]
.   .   .   .   .   Child: 0  Const 333 of type int [line: 11]						.   .   .   .   .   Child: 0  Const 333 of type int [line: 11]
.   .   .   .   .   Child: 1  Const 33 of type int [line: 11]						.   .   .   .   .   Child: 1  Const 33 of type int [line: 11]
.   .   .   .   Sibling: 1  Op: * of type int [line: 11]						.   .   .   .   Sibling: 1  Op: * of type int [line: 11]
.   .   .   .   .   Child: 0  Const 444 of type int [line: 11]						.   .   .   .   .   Child: 0  Const 444 of type int [line: 11]
.   .   .   .   .   Child: 1  Const 44 of type int [line: 11]						.   .   .   .   .   Child: 1  Const 44 of type int [line: 11]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
pushpopcall2.out ztmp23114.txt differ: byte 52, line 2
pushpopcall2 (Output DIFF)
WARNING(3): The variable 'g' seems not to be used.							WARNING(3): The variable 'g' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/pushpopcall2.tm
Number of errors: 0										   |	24642 147852 7150176
------------------------------------								   <
Loading file: pushpopcall2.tm									   <
Bye.													Bye.
====================================
FILE: pushpopcall3.c-
-rw-------. 1 corg7983 domain_users  298 Nov 17 15:35 pushpopcall3.c-
-rw-------. 1 corg7983 domain_users  299 Nov 17 15:35 pushpopcall3.c-.f21
-rw-------. 1 corg7983 domain_users  298 Nov 17 15:35 pushpopcall3.c-.f22
-rw-------. 1 corg7983 domain_users  164 Nov 17 15:35 pushpopcall3.expected
-rw-------. 1 corg7983 domain_users 4289 Nov 22 12:27 pushpopcall3.mem
-rw-------. 1 corg7983 domain_users  125 Nov 17 15:35 pushpopcall3.mem.diffs
-rw-------. 1 corg7983 domain_users 5131 Nov 17 15:35 pushpopcall3.mem.f21
-rw-------. 1 corg7983 domain_users  218 Nov 22 12:27 pushpopcall3.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 pushpopcall3.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 pushpopcall3.tm.diffs
-rw-------. 1 corg7983 domain_users 8958 Nov 17 15:35 pushpopcall3.tm.f21
TM CODE COMPARISON
pushpopcall3 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpopcall3.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	 40:    LDC  3,7(6)	Load integer constant 
												   >	 41:     ST  3,-4(1)	Store variable p
												   >	* Compound Body
												   >	* RETURN
												   >	 42:     LD  3,-2(1)	Load variable x
												   >	 43:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 44:     LD  3,-4(1)	Load variable p
												   >	* TOFF inc: -5
												   >	 45:     LD  4,-5(1)	Pop left into ac1 
												   >	 46:    MOD  3,4,3	Op % 
												   >	 47:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 48:     LD  3,-3(1)	Load variable y
												   >	 49:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 50:     LD  3,-4(1)	Load variable p
												   >	* TOFF inc: -6
												   >	 51:     LD  4,-6(1)	Pop left into ac1 
												   >	 52:    MOD  3,4,3	Op % 
												   >	* TOFF inc: -5
												   >	 53:     LD  4,-5(1)	Pop left into ac1 
												   >	 54:    ADD  3,4,3	Op + 
												   >	 55:    LDA  2,0(3)	Copy result to return register 
												   >	 56:     LD  3,-1(1)	Load return address 
												   >	 57:     LD  1,0(1)	Adjust fp 
												   >	 58:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 59:    LDC  2,0(6)	Set return value to 0 
												   >	 60:     LD  3,-1(1)	Load return address 
												   >	 61:     LD  1,0(1)	Adjust fp 
												   >	 62:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 63:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	 64:    LDC  3,1000(6)	Load integer constant 
												   >	 65:     ST  3,-2(1)	Store variable a
												   >	 66:    LDC  3,2000(6)	Load integer constant 
												   >	 67:     ST  3,-3(1)	Store variable b
												   >	 68:    LDC  3,3000(6)	Load integer constant 
												   >	 69:     ST  3,-4(1)	Store variable c
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 70:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	* CALL dog
												   >	 71:     ST  1,-7(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 72:     LD  3,-2(1)	Load variable a
												   >	 73:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 2
												   >	 74:    LDC  3,2(6)	Load integer constant 
												   >	 75:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 76:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -10
												   >	 77:     LD  4,-10(1)	Pop left into ac1 
												   >	 78:    MUL  3,4,3	Op * 
												   >	 79:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end dog
												   >	 80:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-44(7)	CALL dog
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -7
												   >	 84:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 85:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-82(7)	CALL output
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 89:     LD  3,-2(1)	Load variable a
												   >	 90:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 91:     LD  3,0(0)	Load variable g
												   >	* TOFF inc: -8
												   >	 92:     LD  4,-8(1)	Pop left into ac1 
												   >	 93:    ADD  3,4,3	Op + 
												   >	 94:     ST  3,-6(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 95:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	* CALL dog
												   >	 96:     ST  1,-10(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	 97:     LD  3,0(0)	Load variable g
												   >	 98:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 2
												   >	 99:     LD  3,-6(1)	Load variable y
												   >	100:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param end dog
												   >	101:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	102:    LDA  3,1(7)	Return address in ac 
												   >	103:    JMP  7,-65(7)	CALL dog
												   >	104:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -10
												   >	105:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	106:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-103(7)	CALL output
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	110:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	111:     LD  3,0(0)	Load variable g
												   >	112:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	113:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-110(7)	CALL output
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	117:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	118:    LDC  3,999(6)	Load integer constant 
												   >	119:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	* CALL dog
												   >	120:     ST  1,-8(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	121:    LDC  3,333(6)	Load integer constant 
												   >	122:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	123:    LDC  3,33(6)	Load integer constant 
												   >	124:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	125:     LD  3,0(0)	Load variable g
												   >	* TOFF inc: -11
												   >	126:     LD  4,-11(1)	Pop left into ac1 
												   >	127:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -10
												   >	128:     LD  4,-10(1)	Pop left into ac1 
												   >	129:    ADD  3,4,3	Op + 
												   >	130:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	131:     LD  3,-3(1)	Load variable b
												   >	132:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	133:    LDC  3,17(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	134:     LD  4,-11(1)	Pop left into ac1 
												   >	135:    MOD  3,4,3	Op % 
												   >	136:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	137:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -11
												   >	138:     LD  4,-11(1)	Pop left into ac1 
												   >	139:    ADD  3,4,3	Op + 
												   >	140:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end dog
												   >	141:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	142:    LDA  3,1(7)	Return address in ac 
												   >	143:    JMP  7,-105(7)	CALL dog
												   >	144:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -8
												   >	* TOFF inc: -7
												   >	145:     LD  4,-7(1)	Pop left into ac1 
												   >	146:    ADD  3,4,3	Op + 
												   >	147:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	148:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-145(7)	CALL output
												   >	151:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	152:    LDC  2,0(6)	Set return value to 0 
												   >	153:     LD  3,-1(1)	Load return address 
												   >	154:     LD  1,0(1)	Adjust fp 
												   >	155:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,155(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	156:    LDA  1,-1(0)	set first frame at end of globals 
												   >	157:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	158:    LDC  3,4000(6)	Load integer constant 
												   >	159:     ST  3,0(0)	Store variable g
												   >	* END INIT GLOBALS AND STATICS
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-99(7)	Jump to main 
												   >	162:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpopcall3.mem pushpopcall3.mem.f21 differ: byte 111, line 3
pushpopcall3 (MEM DIFF)
WARNING(12): The variable 'x' seems not to be used.							WARNING(12): The variable 'x' seems not to be used.
WARNING(12): The variable 'z' seems not to be used.							WARNING(12): The variable 'z' seems not to be used.
Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 1]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]				.   Sibling: 1  Parm: y of type int [mem: Parameter loc: -3 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 1]
.   .   Child: 0  Var: p of type int [mem: Local loc: -4 size: 1] [line: 2]				.   .   Child: 0  Var: p of type int [mem: Local loc: -4 size: 1] [line: 2]
.   .   .   Child: 0  Const 7 of type int [line: 2]							.   .   .   Child: 0  Const 7 of type int [line: 2]
.   .   Child: 1  Return [line: 3]									.   .   Child: 1  Return [line: 3]
.   .   .   Child: 0  Op: + of type int [line: 3]							.   .   .   Child: 0  Op: + of type int [line: 3]
.   .   .   .   Child: 0  Op: % of type int [line: 3]							.   .   .   .   Child: 0  Op: % of type int [line: 3]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]		.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -4 size: 1] [line: 3]			.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -4 size: 1] [line: 3]
.   .   .   .   Child: 1  Op: % of type int [line: 3]							.   .   .   .   Child: 1  Op: % of type int [line: 3]
.   .   .   .   .   Child: 0  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 3]		.   .   .   .   .   Child: 0  Id: y of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -4 size: 1] [line: 3]			.   .   .   .   .   Child: 1  Id: p of type int [mem: Local loc: -4 size: 1] [line: 3]
Sibling: 1  Var: g of type int [mem: Global loc: 0 size: 1] [line: 6]				   |	Sibling: 8  Var: g of type int [mem: Global loc: 0 size: 1] [line: 6]
.   Child: 0  Const 4000 of type int [line: 6]								.   Child: 0  Const 4000 of type int [line: 6]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 7]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 7]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 7]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   .   Child: 0  Const 1000 of type int [line: 8]							.   .   .   Child: 0  Const 1000 of type int [line: 8]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 8]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 8]
.   .   .   Child: 0  Const 2000 of type int [line: 8]							.   .   .   Child: 0  Const 2000 of type int [line: 8]
.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 8]				.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 0  Const 3000 of type int [line: 8]							.   .   .   Child: 0  Const 3000 of type int [line: 8]
.   .   Child: 1  Call: output of type void [line: 10]							.   .   Child: 1  Call: output of type void [line: 10]
.   .   .   Child: 0  Call: dog of type int [line: 10]							.   .   .   Child: 0  Call: dog of type int [line: 10]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   .   Sibling: 1  Op: * of type int [line: 10]						.   .   .   .   Sibling: 1  Op: * of type int [line: 10]
.   .   .   .   .   Child: 0  Const 2 of type int [line: 10]						.   .   .   .   .   Child: 0  Const 2 of type int [line: 10]
.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   Sibling: 1  Compound [mem: None loc: 0 size: -8] [line: 11]					.   .   Sibling: 1  Compound [mem: None loc: 0 size: -8] [line: 11]
.   .   .   Child: 0  Var: x of type int [mem: Local loc: -5 size: 1] [line: 12]			.   .   .   Child: 0  Var: x of type int [mem: Local loc: -5 size: 1] [line: 12]
.   .   .   Sibling: 1  Var: y of type int [mem: Local loc: -6 size: 1] [line: 12]			.   .   .   Sibling: 1  Var: y of type int [mem: Local loc: -6 size: 1] [line: 12]
.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -7 size: 1] [line: 12]			.   .   .   Sibling: 2  Var: z of type int [mem: Local loc: -7 size: 1] [line: 12]
.   .   .   Child: 1  Assign: = of type int [line: 14]						   |	.   .   .   Child: 1  Assign: := of type int [line: 14]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -6 size: 1] [line: 14]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -6 size: 1] [line: 14]
.   .   .   .   Child: 1  Op: + of type int [line: 14]							.   .   .   .   Child: 1  Op: + of type int [line: 14]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 14]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 14]			.   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 14]
.   .   .   Sibling: 1  Call: output of type void [line: 15]						.   .   .   Sibling: 1  Call: output of type void [line: 15]
.   .   .   .   Child: 0  Call: dog of type int [line: 15]						.   .   .   .   Child: 0  Call: dog of type int [line: 15]
.   .   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]			.   .   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]
.   .   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -6 size: 1] [line: 15]		.   .   .   .   .   Sibling: 1  Id: y of type int [mem: Local loc: -6 size: 1] [line: 15]
.   .   .   Sibling: 2  Call: output of type void [line: 16]						.   .   .   Sibling: 2  Call: output of type void [line: 16]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 16]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 16]
.   .   Sibling: 2  Call: output of type void [line: 19]						.   .   Sibling: 2  Call: output of type void [line: 19]
.   .   .   Child: 0  Op: + of type int [line: 19]							.   .   .   Child: 0  Op: + of type int [line: 19]
.   .   .   .   Child: 0  Const 999 of type int [line: 19]						.   .   .   .   Child: 0  Const 999 of type int [line: 19]
.   .   .   .   Child: 1  Call: dog of type int [line: 19]						.   .   .   .   Child: 1  Call: dog of type int [line: 19]
.   .   .   .   .   Child: 0  Op: + of type int [line: 19]						.   .   .   .   .   Child: 0  Op: + of type int [line: 19]
.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 19]					.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 19]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 19]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 19]
.   .   .   .   .   .   .   Child: 0  Const 33 of type int [line: 19]					.   .   .   .   .   .   .   Child: 0  Const 33 of type int [line: 19]
.   .   .   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]		.   .   .   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 19]
.   .   .   .   .   Sibling: 1  Op: + of type int [line: 19]						.   .   .   .   .   Sibling: 1  Op: + of type int [line: 19]
.   .   .   .   .   .   Child: 0  Op: % of type int [line: 19]						.   .   .   .   .   .   Child: 0  Op: % of type int [line: 19]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]		.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   .   .   .   .   .   Child: 1  Const 17 of type int [line: 19]					.   .   .   .   .   .   .   Child: 1  Const 17 of type int [line: 19]
.   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 19]		.   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 19]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
pushpopcall3.out ztmp23114.txt differ: byte 105, line 3
pushpopcall3 (Output DIFF)
WARNING(12): The variable 'x' seems not to be used.							WARNING(12): The variable 'x' seems not to be used.
WARNING(12): The variable 'z' seems not to be used.							WARNING(12): The variable 'z' seems not to be used.
Number of warnings: 2										   |	Loading file: BroadTests/pushpopcall3.tm
Number of errors: 0										   |	9 5 4000 1005
------------------------------------								   <
Loading file: pushpopcall3.tm									   <
Bye.													Bye.
====================================
FILE: pushpopcall.c-
-rw-------. 1 corg7983 domain_users   260 Nov 17 15:35 pushpopcall.c-
-rw-------. 1 corg7983 domain_users   260 Nov 17 15:35 pushpopcall.c-.f21
-rw-------. 1 corg7983 domain_users   260 Nov 17 15:35 pushpopcall.c-.f22
-rw-------. 1 corg7983 domain_users   183 Nov 17 15:35 pushpopcall.expected
-rw-------. 1 corg7983 domain_users  3450 Nov 22 12:27 pushpopcall.mem
-rw-------. 1 corg7983 domain_users     0 Nov 17 15:35 pushpopcall.mem.diffs
-rw-------. 1 corg7983 domain_users  4292 Nov 17 15:35 pushpopcall.mem.f21
-rw-------. 1 corg7983 domain_users   215 Nov 22 12:27 pushpopcall.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 pushpopcall.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 pushpopcall.tm.diffs
-rw-------. 1 corg7983 domain_users 11866 Nov 17 15:35 pushpopcall.tm.f21
TM CODE COMPARISON
pushpopcall (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpopcall.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	 40:     LD  3,-2(1)	Load variable x
												   >	 41:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 42:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 43:     LD  4,-3(1)	Pop left into ac1 
												   >	 44:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* RETURN
												   >	 46:    LDC  3,1000(6)	Load integer constant 
												   >	 47:    LDA  2,0(3)	Copy result to return register 
												   >	 48:     LD  3,-1(1)	Load return address 
												   >	 49:     LD  1,0(1)	Adjust fp 
												   >	 50:    JMP  7,0(3)	Return 
												   >	 45:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL output
												   >	 51:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL dog
												   >	 52:     ST  1,-5(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 53:    LDC  3,666(6)	Load integer constant 
												   >	 54:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	 55:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-19(7)	CALL dog
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -5
												   >	 59:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 60:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-57(7)	CALL output
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	 64:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 65:    LDC  3,777(6)	Load integer constant 
												   >	 66:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	* CALL dog
												   >	 67:     ST  1,-6(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 68:    LDC  3,888(6)	Load integer constant 
												   >	 69:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end dog
												   >	 70:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 71:    LDA  3,1(7)	Return address in ac 
												   >	 72:    JMP  7,-34(7)	CALL dog
												   >	 73:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -6
												   >	* TOFF inc: -5
												   >	 74:     LD  4,-5(1)	Pop left into ac1 
												   >	 75:    ADD  3,4,3	Op + 
												   >	 76:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 77:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-74(7)	CALL output
												   >	 80:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	 81:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 82:    LDC  3,111(6)	Load integer constant 
												   >	 83:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 84:    LDC  3,222(6)	Load integer constant 
												   >	 85:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	* CALL dog
												   >	 86:     ST  1,-7(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 87:    LDC  3,333(6)	Load integer constant 
												   >	 88:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end dog
												   >	 89:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-53(7)	CALL dog
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	 93:     LD  4,-6(1)	Pop left into ac1 
												   >	 94:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -5
												   >	 95:     LD  4,-5(1)	Pop left into ac1 
												   >	 96:    ADD  3,4,3	Op + 
												   >	 97:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 98:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-95(7)	CALL output
												   >	101:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	102:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL dog
												   >	103:     ST  1,-5(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	* CALL dog
												   >	104:     ST  1,-7(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	105:    LDC  3,444(6)	Load integer constant 
												   >	106:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end dog
												   >	107:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	108:    LDA  3,1(7)	Return address in ac 
												   >	109:    JMP  7,-71(7)	CALL dog
												   >	110:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -7
												   >	111:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	112:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	113:    LDA  3,1(7)	Return address in ac 
												   >	114:    JMP  7,-76(7)	CALL dog
												   >	115:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -5
												   >	116:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	117:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	118:    LDA  3,1(7)	Return address in ac 
												   >	119:    JMP  7,-114(7)	CALL output
												   >	120:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	121:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL dog
												   >	122:     ST  1,-5(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	123:     LD  3,-2(1)	Load variable x
												   >	124:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	125:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	126:     LD  4,-7(1)	Pop left into ac1 
												   >	127:    ADD  3,4,3	Op + 
												   >	128:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	129:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	130:    LDA  3,1(7)	Return address in ac 
												   >	131:    JMP  7,-93(7)	CALL dog
												   >	132:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -5
												   >	133:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	* CALL dog
												   >	134:     ST  1,-6(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	135:    LDC  3,1(6)	Load integer constant 
												   >	136:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	137:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -8
												   >	138:     LD  4,-8(1)	Pop left into ac1 
												   >	139:    ADD  3,4,3	Op + 
												   >	140:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end dog
												   >	141:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	142:    LDA  3,1(7)	Return address in ac 
												   >	143:    JMP  7,-105(7)	CALL dog
												   >	144:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -6
												   >	* TOFF inc: -5
												   >	145:     LD  4,-5(1)	Pop left into ac1 
												   >	146:    ADD  3,4,3	Op + 
												   >	147:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	148:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-145(7)	CALL output
												   >	151:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	152:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL dog
												   >	153:     ST  1,-5(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	154:    LDC  3,555(6)	Load integer constant 
												   >	155:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	156:    LDC  3,666(6)	Load integer constant 
												   >	157:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	158:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -8
												   >	159:     LD  4,-8(1)	Pop left into ac1 
												   >	160:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -7
												   >	161:     LD  4,-7(1)	Pop left into ac1 
												   >	162:    ADD  3,4,3	Op + 
												   >	163:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end dog
												   >	164:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	165:    LDA  3,1(7)	Return address in ac 
												   >	166:    JMP  7,-128(7)	CALL dog
												   >	167:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -5
												   >	168:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	169:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	170:    LDA  3,1(7)	Return address in ac 
												   >	171:    JMP  7,-166(7)	CALL output
												   >	172:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* RETURN
												   >	173:    LDC  3,555(6)	Load integer constant 
												   >	174:    LDA  2,0(3)	Copy result to return register 
												   >	175:     LD  3,-1(1)	Load return address 
												   >	176:     LD  1,0(1)	Adjust fp 
												   >	177:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	178:    LDC  2,0(6)	Set return value to 0 
												   >	179:     LD  3,-1(1)	Load return address 
												   >	180:     LD  1,0(1)	Adjust fp 
												   >	181:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	182:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	183:     ST  1,-2(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	* CALL dog
												   >	184:     ST  1,-4(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	185:    LDC  3,0(6)	Load integer constant 
												   >	186:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end dog
												   >	187:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-151(7)	CALL dog
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -4
												   >	191:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end output
												   >	192:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	193:    LDA  3,1(7)	Return address in ac 
												   >	194:    JMP  7,-189(7)	CALL output
												   >	195:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	196:    LDC  2,0(6)	Set return value to 0 
												   >	197:     LD  3,-1(1)	Load return address 
												   >	198:     LD  1,0(1)	Adjust fp 
												   >	199:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,199(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	200:    LDA  1,-2(0)	set first frame at end of globals 
												   >	201:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	202:    LDA  3,1(7)	Return address in ac 
												   >	203:    JMP  7,-22(7)	Jump to main 
												   >	204:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpopcall.mem pushpopcall.mem.f21 differ: byte 103, line 3
pushpopcall (MEM DIFF)
WARNING(1): The variable 'g' seems not to be used.							WARNING(1): The variable 'g' seems not to be used.
WARNING(1): The variable 'h' seems not to be used.							WARNING(1): The variable 'h' seems not to be used.
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: h of type int [mem: Global loc: -1 size: 1] [line: 1]				   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: h of type int [mem: Global loc: -1 size: 1] [line: 1]
												   >	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]
.   .   Child: 1  If [line: 4]										.   .   Child: 1  If [line: 4]
.   .   .   Child: 0  Op: > of type bool [line: 4]							.   .   .   Child: 0  Op: > of type bool [line: 4]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   .   .   Child: 1  Const 0 of type int [line: 4]							.   .   .   .   Child: 1  Const 0 of type int [line: 4]
.   .   .   Child: 1  Return [line: 4]									.   .   .   Child: 1  Return [line: 4]
.   .   .   .   Child: 0  Const 1000 of type int [line: 4]						.   .   .   .   Child: 0  Const 1000 of type int [line: 4]
.   .   Sibling: 1  Call: output of type void [line: 5]							.   .   Sibling: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Call: dog of type int [line: 5]							.   .   .   Child: 0  Call: dog of type int [line: 5]
.   .   .   .   Child: 0  Const 666 of type int [line: 5]						.   .   .   .   Child: 0  Const 666 of type int [line: 5]
.   .   Sibling: 2  Call: output of type void [line: 6]							.   .   Sibling: 2  Call: output of type void [line: 6]
.   .   .   Child: 0  Op: + of type int [line: 6]							.   .   .   Child: 0  Op: + of type int [line: 6]
.   .   .   .   Child: 0  Const 777 of type int [line: 6]						.   .   .   .   Child: 0  Const 777 of type int [line: 6]
.   .   .   .   Child: 1  Call: dog of type int [line: 6]						.   .   .   .   Child: 1  Call: dog of type int [line: 6]
.   .   .   .   .   Child: 0  Const 888 of type int [line: 6]						.   .   .   .   .   Child: 0  Const 888 of type int [line: 6]
.   .   Sibling: 3  Call: output of type void [line: 7]							.   .   Sibling: 3  Call: output of type void [line: 7]
.   .   .   Child: 0  Op: + of type int [line: 7]							.   .   .   Child: 0  Op: + of type int [line: 7]
.   .   .   .   Child: 0  Const 111 of type int [line: 7]						.   .   .   .   Child: 0  Const 111 of type int [line: 7]
.   .   .   .   Child: 1  Op: * of type int [line: 7]							.   .   .   .   Child: 1  Op: * of type int [line: 7]
.   .   .   .   .   Child: 0  Const 222 of type int [line: 7]						.   .   .   .   .   Child: 0  Const 222 of type int [line: 7]
.   .   .   .   .   Child: 1  Call: dog of type int [line: 7]						.   .   .   .   .   Child: 1  Call: dog of type int [line: 7]
.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 7]					.   .   .   .   .   .   Child: 0  Const 333 of type int [line: 7]
.   .   Sibling: 4  Call: output of type void [line: 8]							.   .   Sibling: 4  Call: output of type void [line: 8]
.   .   .   Child: 0  Call: dog of type int [line: 8]							.   .   .   Child: 0  Call: dog of type int [line: 8]
.   .   .   .   Child: 0  Call: dog of type int [line: 8]						.   .   .   .   Child: 0  Call: dog of type int [line: 8]
.   .   .   .   .   Child: 0  Const 444 of type int [line: 8]						.   .   .   .   .   Child: 0  Const 444 of type int [line: 8]
.   .   Sibling: 5  Call: output of type void [line: 9]							.   .   Sibling: 5  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: + of type int [line: 9]							.   .   .   Child: 0  Op: + of type int [line: 9]
.   .   .   .   Child: 0  Call: dog of type int [line: 9]						.   .   .   .   Child: 0  Call: dog of type int [line: 9]
.   .   .   .   .   Child: 0  Op: + of type int [line: 9]						.   .   .   .   .   Child: 0  Op: + of type int [line: 9]
.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]		.   .   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 9]						.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 9]
.   .   .   .   Child: 1  Call: dog of type int [line: 9]						.   .   .   .   Child: 1  Call: dog of type int [line: 9]
.   .   .   .   .   Child: 0  Op: + of type int [line: 9]						.   .   .   .   .   Child: 0  Op: + of type int [line: 9]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 9]						.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 9]
.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]		.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   Sibling: 6  Call: output of type void [line: 10]						.   .   Sibling: 6  Call: output of type void [line: 10]
.   .   .   Child: 0  Call: dog of type int [line: 10]							.   .   .   Child: 0  Call: dog of type int [line: 10]
.   .   .   .   Child: 0  Op: + of type int [line: 10]							.   .   .   .   Child: 0  Op: + of type int [line: 10]
.   .   .   .   .   Child: 0  Const 555 of type int [line: 10]						.   .   .   .   .   Child: 0  Const 555 of type int [line: 10]
.   .   .   .   .   Child: 1  Op: * of type int [line: 10]						.   .   .   .   .   Child: 1  Op: * of type int [line: 10]
.   .   .   .   .   .   Child: 0  Const 666 of type int [line: 10]					.   .   .   .   .   .   Child: 0  Const 666 of type int [line: 10]
.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]		.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   .   Sibling: 7  Return [line: 12]									.   .   Sibling: 7  Return [line: 12]
.   .   .   Child: 0  Const 555 of type int [line: 12]							.   .   .   Child: 0  Const 555 of type int [line: 12]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 15]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 15]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 15]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 15]
.   .   Child: 1  Call: output of type void [line: 15]							.   .   Child: 1  Call: output of type void [line: 15]
.   .   .   Child: 0  Call: dog of type int [line: 15]							.   .   .   Child: 0  Call: dog of type int [line: 15]
.   .   .   .   Child: 0  Const 0 of type int [line: 15]						.   .   .   .   Child: 0  Const 0 of type int [line: 15]
Offset for end of global space: -2									Offset for end of global space: -2
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
pushpopcall.out ztmp23114.txt differ: byte 103, line 3
pushpopcall (Output DIFF)
WARNING(1): The variable 'g' seems not to be used.							WARNING(1): The variable 'g' seems not to be used.
WARNING(1): The variable 'h' seems not to be used.							WARNING(1): The variable 'h' seems not to be used.
Number of warnings: 2										   |	Loading file: BroadTests/pushpopcall.tm
Number of errors: 0										   |	1000 1777 222111 1000 2000 1000 555
------------------------------------								   <
Loading file: pushpopcall.tm									   <
Bye.													Bye.
====================================
FILE: pushpopexp.c-
-rw-------. 1 corg7983 domain_users   439 Nov 17 15:35 pushpopexp.c-
-rw-------. 1 corg7983 domain_users   451 Nov 17 15:35 pushpopexp.c-.f21
-rw-------. 1 corg7983 domain_users   439 Nov 17 15:35 pushpopexp.c-.f22
-rw-------. 1 corg7983 domain_users   120 Nov 17 15:35 pushpopexp.expected
-rw-------. 1 corg7983 domain_users  7988 Nov 22 12:27 pushpopexp.mem
-rw-------. 1 corg7983 domain_users  1488 Nov 17 15:35 pushpopexp.mem.diffs
-rw-------. 1 corg7983 domain_users  8841 Nov 17 15:35 pushpopexp.mem.f21
-rw-------. 1 corg7983 domain_users   164 Nov 22 12:27 pushpopexp.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 pushpopexp.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 pushpopexp.tm.diffs
-rw-------. 1 corg7983 domain_users 12112 Nov 17 15:35 pushpopexp.tm.f21
TM CODE COMPARISON
pushpopexp (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpopexp.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,331(6)	Load integer constant 
												   >	 41:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	 42:    LDC  3,2(6)	Load integer constant 
												   >	 43:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 44:    LDC  3,3(6)	Load integer constant 
												   >	 45:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 46:    LDC  3,5(6)	Load integer constant 
												   >	 47:     ST  3,-4(1)	Store variable c
												   >	* EXPRESSION
												   >	 48:    LDC  3,7(6)	Load integer constant 
												   >	 49:     ST  3,-5(1)	Store variable d
												   >	* EXPRESSION
												   >	* CALL output
												   >	 50:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 51:     LD  3,-5(1)	Load variable d
												   >	 52:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 53:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 54:    LDA  3,1(7)	Return address in ac 
												   >	 55:    JMP  7,-50(7)	CALL output
												   >	 56:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	 57:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 58:     LD  3,-2(1)	Load variable a
												   >	 59:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 60:     LD  3,-3(1)	Load variable b
												   >	 61:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 62:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -9
												   >	 63:     LD  4,-9(1)	Pop left into ac1 
												   >	 64:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	 65:     LD  4,-8(1)	Pop left into ac1 
												   >	 66:    ADD  3,4,3	Op + 
												   >	 67:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	 68:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 69:    LDA  3,1(7)	Return address in ac 
												   >	 70:    JMP  7,-65(7)	CALL output
												   >	 71:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 72:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 73:     LD  3,-5(1)	Load variable d
												   >	 74:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 75:     LD  3,-2(1)	Load variable a
												   >	 76:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 77:     LD  3,-3(1)	Load variable b
												   >	 78:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 79:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -10
												   >	 80:     LD  4,-10(1)	Pop left into ac1 
												   >	 81:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -9
												   >	 82:     LD  4,-9(1)	Pop left into ac1 
												   >	 83:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -8
												   >	 84:     LD  4,-8(1)	Pop left into ac1 
												   >	 85:    TGT  3,4,3	Op > 
												   >	 86:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	 87:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-73(7)	CALL outputb
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	 91:     ST  1,-6(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	 92:     LD  3,-5(1)	Load variable d
												   >	 93:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 94:     LD  3,-2(1)	Load variable a
												   >	 95:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 96:     LD  3,-3(1)	Load variable b
												   >	 97:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 98:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -10
												   >	 99:     LD  4,-10(1)	Pop left into ac1 
												   >	100:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -9
												   >	101:     LD  4,-9(1)	Pop left into ac1 
												   >	102:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -8
												   >	103:     LD  4,-8(1)	Pop left into ac1 
												   >	104:    TGT  3,4,3	Op > 
												   >	105:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	106:     LD  3,-3(1)	Load variable b
												   >	107:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	108:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -9
												   >	109:     LD  4,-9(1)	Pop left into ac1 
												   >	110:    TLT  3,4,3	Op < 
												   >	* TOFF inc: -8
												   >	111:     LD  4,-8(1)	Pop left into ac1 
												   >	112:     OR  3,4,3	Op OR 
												   >	113:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end outputb
												   >	114:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-100(7)	CALL outputb
												   >	117:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	118:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	119:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	120:    LDA  3,1(7)	Return address in ac 
												   >	121:    JMP  7,-88(7)	CALL outnl
												   >	122:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	123:    LDC  3,101(6)	Load integer constant 
												   >	124:     ST  3,-6(1)	Store variable a
												   >	* EXPRESSION
												   >	125:    LDC  3,103(6)	Load integer constant 
												   >	126:     ST  3,-7(1)	Store variable b
												   >	* EXPRESSION
												   >	127:    LDC  3,107(6)	Load integer constant 
												   >	128:     ST  3,-8(1)	Store variable c
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	129:     ST  1,-9(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	130:     LD  3,-5(1)	Load variable d
												   >	131:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	132:    LDC  3,20(6)	Load integer constant 
												   >	* TOFF inc: -11
												   >	133:     LD  4,-11(1)	Pop left into ac1 
												   >	134:    MUL  3,4,3	Op * 
												   >	135:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	136:     LD  3,-6(1)	Load variable a
												   >	137:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	138:     LD  3,-8(1)	Load variable c
												   >	139:     ST  3,-13(1)	Push left side 
												   >	* TOFF dec: -14
												   >	140:     LD  3,-7(1)	Load variable b
												   >	* TOFF inc: -13
												   >	141:     LD  4,-13(1)	Pop left into ac1 
												   >	142:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -12
												   >	143:     LD  4,-12(1)	Pop left into ac1 
												   >	144:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -11
												   >	145:     LD  4,-11(1)	Pop left into ac1 
												   >	146:    TLT  3,4,3	Op < 
												   >	147:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end outputb
												   >	148:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	149:    LDA  3,1(7)	Return address in ac 
												   >	150:    JMP  7,-134(7)	CALL outputb
												   >	151:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -9
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	* COMPOUND
												   >	* TOFF set: -10
												   >	* Compound Body
												   >	* EXPRESSION
												   >	152:    LDC  3,101(6)	Load integer constant 
												   >	153:     ST  3,-6(1)	Store variable w
												   >	* EXPRESSION
												   >	154:    LDC  3,103(6)	Load integer constant 
												   >	155:     ST  3,-7(1)	Store variable x
												   >	* EXPRESSION
												   >	156:    LDC  3,107(6)	Load integer constant 
												   >	157:     ST  3,-8(1)	Store variable y
												   >	* EXPRESSION
												   >	158:    LDC  3,109(6)	Load integer constant 
												   >	159:     ST  3,-9(1)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	160:     ST  1,-10(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	161:     LD  3,-6(1)	Load variable w
												   >	162:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	163:     LD  3,-7(1)	Load variable x
												   >	* TOFF inc: -12
												   >	164:     LD  4,-12(1)	Pop left into ac1 
												   >	165:    MUL  3,4,3	Op * 
												   >	166:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	167:     LD  3,-8(1)	Load variable y
												   >	168:     ST  3,-13(1)	Push left side 
												   >	* TOFF dec: -14
												   >	169:     LD  3,-9(1)	Load variable z
												   >	* TOFF inc: -13
												   >	170:     LD  4,-13(1)	Pop left into ac1 
												   >	171:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -12
												   >	172:     LD  4,-12(1)	Pop left into ac1 
												   >	173:    ADD  3,4,3	Op + 
												   >	174:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end output
												   >	175:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	176:    LDA  3,1(7)	Return address in ac 
												   >	177:    JMP  7,-172(7)	CALL output
												   >	178:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -10
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	179:     ST  1,-10(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param end outnl
												   >	180:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	181:    LDA  3,1(7)	Return address in ac 
												   >	182:    JMP  7,-149(7)	CALL outnl
												   >	183:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -10
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	184:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	185:     LD  3,-2(1)	Load variable a
												   >	186:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	187:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -8
												   >	188:     LD  4,-8(1)	Pop left into ac1 
												   >	189:    MUL  3,4,3	Op * 
												   >	190:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	191:     LD  3,-4(1)	Load variable c
												   >	192:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	193:     LD  3,-5(1)	Load variable d
												   >	* TOFF inc: -9
												   >	194:     LD  4,-9(1)	Pop left into ac1 
												   >	195:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	196:     LD  4,-8(1)	Pop left into ac1 
												   >	197:    ADD  3,4,3	Op + 
												   >	198:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	199:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-196(7)	CALL output
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL output
												   >	203:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	204:     LD  3,0(0)	Load variable g
												   >	205:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	206:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	207:    LDA  3,1(7)	Return address in ac 
												   >	208:    JMP  7,-203(7)	CALL output
												   >	209:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	210:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	211:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	212:    LDA  3,1(7)	Return address in ac 
												   >	213:    JMP  7,-180(7)	CALL outnl
												   >	214:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	215:    LDC  2,0(6)	Set return value to 0 
												   >	216:     LD  3,-1(1)	Load return address 
												   >	217:     LD  1,0(1)	Adjust fp 
												   >	218:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,218(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	219:    LDA  1,-2(0)	set first frame at end of globals 
												   >	220:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	221:    LDA  3,1(7)	Return address in ac 
												   >	222:    JMP  7,-184(7)	Jump to main 
												   >	223:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpopexp.mem pushpopexp.mem.f21 differ: byte 53, line 2
pushpopexp (MEM DIFF)
WARNING(30): The variable 'h' seems not to be used.							WARNING(30): The variable 'h' seems not to be used.
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 2]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 4]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 4]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Sibling: 3  Var: d of type int [mem: Local loc: -5 size: 1] [line: 4]				.   .   Sibling: 3  Var: d of type int [mem: Local loc: -5 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 6]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 6]
.   .   .   Child: 1  Const 331 of type int [line: 6]							.   .   .   Child: 1  Const 331 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type int [line: 7]						   |	.   .   Sibling: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 7]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Const 2 of type int [line: 7]							.   .   .   Child: 1  Const 2 of type int [line: 7]
.   .   Sibling: 2  Assign: = of type int [line: 7]						   |	.   .   Sibling: 2  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 7]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   .   Child: 1  Const 3 of type int [line: 7]							.   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   Sibling: 3  Assign: = of type int [line: 7]						   |	.   .   Sibling: 3  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   Child: 1  Const 5 of type int [line: 7]							.   .   .   Child: 1  Const 5 of type int [line: 7]
.   .   Sibling: 4  Assign: = of type int [line: 7]						   |	.   .   Sibling: 4  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 7]				.   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 7]
.   .   .   Child: 1  Const 7 of type int [line: 7]							.   .   .   Child: 1  Const 7 of type int [line: 7]
.   .   Sibling: 5  Call: output of type void [line: 8]							.   .   Sibling: 5  Call: output of type void [line: 8]
.   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 8]				.   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 8]
.   .   Sibling: 6  Call: output of type void [line: 9]							.   .   Sibling: 6  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: + of type int [line: 9]							.   .   .   Child: 0  Op: + of type int [line: 9]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Op: * of type int [line: 9]							.   .   .   .   Child: 1  Op: * of type int [line: 9]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 9]			.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 9]
.   .   Sibling: 7  Call: outputb of type void [line: 10]						.   .   Sibling: 7  Call: outputb of type void [line: 10]
.   .   .   Child: 0  Op: > of type bool [line: 10]							.   .   .   Child: 0  Op: > of type bool [line: 10]
.   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 10]
.   .   .   .   Child: 1  Op: + of type int [line: 10]							.   .   .   .   Child: 1  Op: + of type int [line: 10]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Op: * of type int [line: 10]						.   .   .   .   .   Child: 1  Op: * of type int [line: 10]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 10]		.   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   Sibling: 8  Call: outputb of type void [line: 11]						.   .   Sibling: 8  Call: outputb of type void [line: 11]
.   .   .   Child: 0  Op: or of type bool [line: 11]							.   .   .   Child: 0  Op: or of type bool [line: 11]
.   .   .   .   Child: 0  Op: > of type bool [line: 11]							.   .   .   .   Child: 0  Op: > of type bool [line: 11]
.   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 11]			.   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Op: + of type int [line: 11]						.   .   .   .   .   Child: 1  Op: + of type int [line: 11]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 11]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 11]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]		.   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   .   .   Child: 1  Op: < of type bool [line: 11]							.   .   .   .   Child: 1  Op: < of type bool [line: 11]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]			.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]
.   .   Sibling: 9  Call: outnl of type void [line: 12]							.   .   Sibling: 9  Call: outnl of type void [line: 12]
.   .   Sibling: 10  Compound [mem: None loc: 0 size: -9] [line: 13]					.   .   Sibling: 10  Compound [mem: None loc: 0 size: -9] [line: 13]
.   .   .   Child: 0  Var: a of type int [mem: Local loc: -6 size: 1] [line: 14]			.   .   .   Child: 0  Var: a of type int [mem: Local loc: -6 size: 1] [line: 14]
.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -7 size: 1] [line: 14]			.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -7 size: 1] [line: 14]
.   .   .   Sibling: 2  Var: c of type int [mem: Local loc: -8 size: 1] [line: 14]			.   .   .   Sibling: 2  Var: c of type int [mem: Local loc: -8 size: 1] [line: 14]
.   .   .   Child: 1  Assign: = of type int [line: 15]						   |	.   .   .   Child: 1  Assign: := of type int [line: 15]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -6 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -6 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 101 of type int [line: 15]						.   .   .   .   Child: 1  Const 101 of type int [line: 15]
.   .   .   Sibling: 1  Assign: = of type int [line: 15]					   |	.   .   .   Sibling: 1  Assign: := of type int [line: 15]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -7 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -7 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 103 of type int [line: 15]						.   .   .   .   Child: 1  Const 103 of type int [line: 15]
.   .   .   Sibling: 2  Assign: = of type int [line: 15]					   |	.   .   .   Sibling: 2  Assign: := of type int [line: 15]
.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -8 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -8 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 107 of type int [line: 15]						.   .   .   .   Child: 1  Const 107 of type int [line: 15]
.   .   .   Sibling: 3  Call: outputb of type void [line: 17]						.   .   .   Sibling: 3  Call: outputb of type void [line: 17]
.   .   .   .   Child: 0  Op: < of type bool [line: 17]							.   .   .   .   Child: 0  Op: < of type bool [line: 17]
.   .   .   .   .   Child: 0  Op: * of type int [line: 17]						.   .   .   .   .   Child: 0  Op: * of type int [line: 17]
.   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 17]		.   .   .   .   .   .   Child: 0  Id: d of type int [mem: Local loc: -5 size: 1] [line: 17]
.   .   .   .   .   .   Child: 1  Const 20 of type int [line: 17]					.   .   .   .   .   .   Child: 1  Const 20 of type int [line: 17]
.   .   .   .   .   Child: 1  Op: - of type int [line: 17]						.   .   .   .   .   Child: 1  Op: - of type int [line: 17]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -6 size: 1] [line: 17]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -6 size: 1] [line: 17]
.   .   .   .   .   .   Child: 1  Op: / of type int [line: 17]						.   .   .   .   .   .   Child: 1  Op: / of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -8 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -8 size: 1] [line: 17]
.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -7 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -7 size: 1] [line: 17]
.   .   Sibling: 11  Compound [mem: None loc: 0 size: -10] [line: 19]					.   .   Sibling: 11  Compound [mem: None loc: 0 size: -10] [line: 19]
.   .   .   Child: 0  Var: w of type int [mem: Local loc: -6 size: 1] [line: 20]			.   .   .   Child: 0  Var: w of type int [mem: Local loc: -6 size: 1] [line: 20]
.   .   .   Sibling: 1  Var: x of type int [mem: Local loc: -7 size: 1] [line: 20]			.   .   .   Sibling: 1  Var: x of type int [mem: Local loc: -7 size: 1] [line: 20]
.   .   .   Sibling: 2  Var: y of type int [mem: Local loc: -8 size: 1] [line: 20]			.   .   .   Sibling: 2  Var: y of type int [mem: Local loc: -8 size: 1] [line: 20]
.   .   .   Sibling: 3  Var: z of type int [mem: Local loc: -9 size: 1] [line: 20]			.   .   .   Sibling: 3  Var: z of type int [mem: Local loc: -9 size: 1] [line: 20]
.   .   .   Child: 1  Assign: = of type int [line: 22]						   |	.   .   .   Child: 1  Assign: := of type int [line: 22]
.   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -6 size: 1] [line: 22]			.   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -6 size: 1] [line: 22]
.   .   .   .   Child: 1  Const 101 of type int [line: 22]						.   .   .   .   Child: 1  Const 101 of type int [line: 22]
.   .   .   Sibling: 1  Assign: = of type int [line: 22]					   |	.   .   .   Sibling: 1  Assign: := of type int [line: 22]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -7 size: 1] [line: 22]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -7 size: 1] [line: 22]
.   .   .   .   Child: 1  Const 103 of type int [line: 22]						.   .   .   .   Child: 1  Const 103 of type int [line: 22]
.   .   .   Sibling: 2  Assign: = of type int [line: 22]					   |	.   .   .   Sibling: 2  Assign: := of type int [line: 22]
.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -8 size: 1] [line: 22]			.   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -8 size: 1] [line: 22]
.   .   .   .   Child: 1  Const 107 of type int [line: 22]						.   .   .   .   Child: 1  Const 107 of type int [line: 22]
.   .   .   Sibling: 3  Assign: = of type int [line: 22]					   |	.   .   .   Sibling: 3  Assign: := of type int [line: 22]
.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -9 size: 1] [line: 22]			.   .   .   .   Child: 0  Id: z of type int [mem: Local loc: -9 size: 1] [line: 22]
.   .   .   .   Child: 1  Const 109 of type int [line: 22]						.   .   .   .   Child: 1  Const 109 of type int [line: 22]
.   .   .   Sibling: 4  Call: output of type void [line: 23]						.   .   .   Sibling: 4  Call: output of type void [line: 23]
.   .   .   .   Child: 0  Op: + of type int [line: 23]							.   .   .   .   Child: 0  Op: + of type int [line: 23]
.   .   .   .   .   Child: 0  Op: * of type int [line: 23]						.   .   .   .   .   Child: 0  Op: * of type int [line: 23]
.   .   .   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -6 size: 1] [line: 23]		.   .   .   .   .   .   Child: 0  Id: w of type int [mem: Local loc: -6 size: 1] [line: 23]
.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -7 size: 1] [line: 23]		.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -7 size: 1] [line: 23]
.   .   .   .   .   Child: 1  Op: * of type int [line: 23]						.   .   .   .   .   Child: 1  Op: * of type int [line: 23]
.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -8 size: 1] [line: 23]		.   .   .   .   .   .   Child: 0  Id: y of type int [mem: Local loc: -8 size: 1] [line: 23]
.   .   .   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -9 size: 1] [line: 23]		.   .   .   .   .   .   Child: 1  Id: z of type int [mem: Local loc: -9 size: 1] [line: 23]
.   .   .   Sibling: 5  Call: outnl of type void [line: 24]						.   .   .   Sibling: 5  Call: outnl of type void [line: 24]
.   .   Sibling: 12  Call: output of type void [line: 26]						.   .   Sibling: 12  Call: output of type void [line: 26]
.   .   .   Child: 0  Op: + of type int [line: 26]							.   .   .   Child: 0  Op: + of type int [line: 26]
.   .   .   .   Child: 0  Op: * of type int [line: 26]							.   .   .   .   Child: 0  Op: * of type int [line: 26]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 26]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 26]			.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   .   Child: 1  Op: * of type int [line: 26]							.   .   .   .   Child: 1  Op: * of type int [line: 26]
.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 26]			.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 26]
.   .   .   .   .   Child: 1  Id: d of type int [mem: Local loc: -5 size: 1] [line: 26]			.   .   .   .   .   Child: 1  Id: d of type int [mem: Local loc: -5 size: 1] [line: 26]
.   .   Sibling: 13  Call: output of type void [line: 27]						.   .   Sibling: 13  Call: output of type void [line: 27]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 27]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 27]
.   .   Sibling: 14  Call: outnl of type void [line: 28]						.   .   Sibling: 14  Call: outnl of type void [line: 28]
Sibling: 2  Var: h of type int [mem: Global loc: -1 size: 1] [line: 30]				   |	Sibling: 9  Var: h of type int [mem: Global loc: -1 size: 1] [line: 30]
Offset for end of global space: -2									Offset for end of global space: -2
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
pushpopexp.out ztmp23114.txt differ: byte 53, line 2
pushpopexp (Output DIFF)
WARNING(30): The variable 'h' seems not to be used.							WARNING(30): The variable 'h' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/pushpopexp.tm
Number of errors: 0										   |	7 17 F T
------------------------------------								   |	F 22066
Loading file: pushpopexp.tm									   |	41 331
Bye.													Bye.
====================================
FILE: pushpopparm.c-
-rw-------. 1 corg7983 domain_users  292 Nov 17 15:35 pushpopparm.c-
-rw-------. 1 corg7983 domain_users  297 Nov 17 15:35 pushpopparm.c-.f21
-rw-------. 1 corg7983 domain_users  292 Nov 17 15:35 pushpopparm.c-.f22
-rw-------. 1 corg7983 domain_users   73 Nov 17 15:35 pushpopparm.expected
-rw-------. 1 corg7983 domain_users 3953 Nov 22 12:27 pushpopparm.mem
-rw-------. 1 corg7983 domain_users  601 Nov 17 15:35 pushpopparm.mem.diffs
-rw-------. 1 corg7983 domain_users 4800 Nov 17 15:35 pushpopparm.mem.f21
-rw-------. 1 corg7983 domain_users  113 Nov 22 12:27 pushpopparm.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 pushpopparm.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 pushpopparm.tm.diffs
-rw-------. 1 corg7983 domain_users 9690 Nov 17 15:35 pushpopparm.tm.f21
TM CODE COMPARISON
pushpopparm (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpopparm.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load variable a
												   >	 42:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 43:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 47:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 48:     LD  3,-3(1)	Load address of base of array b
												   >	 49:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 50:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 51:     LD  4,-6(1)	Pop left into ac1 
												   >	 52:    SUB  3,4,3	compute location from index 
												   >	 53:     LD  3,0(3)	Load array element 
												   >	 54:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 55:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-52(7)	CALL output
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 59:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 60:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-29(7)	CALL outnl
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* RETURN
												   >	 64:     LD  3,-2(1)	Load variable a
												   >	 65:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 66:     LD  3,-3(1)	Load address of base of array b
												   >	 67:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 68:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 69:     LD  4,-5(1)	Pop left into ac1 
												   >	 70:    SUB  3,4,3	compute location from index 
												   >	 71:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	 72:     LD  4,-4(1)	Pop left into ac1 
												   >	 73:    ADD  3,4,3	Op + 
												   >	 74:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 75:    LDA  3,-2(0)	Load address of base of array h
												   >	 76:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 77:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 78:     LD  4,-5(1)	Pop left into ac1 
												   >	 79:    SUB  3,4,3	compute location from index 
												   >	 80:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	 81:     LD  4,-4(1)	Pop left into ac1 
												   >	 82:    ADD  3,4,3	Op + 
												   >	 83:    LDA  2,0(3)	Copy result to return register 
												   >	 84:     LD  3,-1(1)	Load return address 
												   >	 85:     LD  1,0(1)	Adjust fp 
												   >	 86:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 87:    LDC  2,0(6)	Set return value to 0 
												   >	 88:     LD  3,-1(1)	Load return address 
												   >	 89:     LD  1,0(1)	Adjust fp 
												   >	 90:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 91:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -12
												   >	 92:    LDC  3,8(6)	load size of array q
												   >	 93:     ST  3,-3(1)	save size of array q
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 94:    LDC  3,100(6)	Load integer constant 
												   >	 95:     ST  3,-2(1)	Store variable p
												   >	* EXPRESSION
												   >	 96:    LDC  3,3(6)	Load integer constant 
												   >	 97:     ST  3,-12(1)	Push index 
												   >	* TOFF dec: -13
												   >	 98:    LDC  3,1000(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	 99:     LD  4,-12(1)	Pop index 
												   >	100:    LDA  5,-4(1)	Load address of base of array q
												   >	101:    SUB  5,5,4	Compute offset of value 
												   >	102:     ST  3,0(5)	Store variable q
												   >	* EXPRESSION
												   >	103:    LDC  3,200(6)	Load integer constant 
												   >	104:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	105:    LDC  3,3(6)	Load integer constant 
												   >	106:     ST  3,-12(1)	Push index 
												   >	* TOFF dec: -13
												   >	107:    LDC  3,2000(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	108:     LD  4,-12(1)	Pop index 
												   >	109:    LDA  5,-2(0)	Load address of base of array h
												   >	110:    SUB  5,5,4	Compute offset of value 
												   >	111:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	112:    LDC  3,0(6)	Load integer constant 
												   >	113:     ST  3,-12(1)	Push index 
												   >	* TOFF dec: -13
												   >	114:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -12
												   >	115:     LD  4,-12(1)	Pop index 
												   >	116:    LDA  5,-2(0)	Load address of base of array h
												   >	117:    SUB  5,5,4	Compute offset of value 
												   >	118:     ST  3,0(5)	Store variable h
												   >	* EXPRESSION
												   >	* CALL output
												   >	119:     ST  1,-12(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -13
												   >	* TOFF dec: -14
												   >	* Param 1
												   >	* CALL dog
												   >	120:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	121:     LD  3,-2(1)	Load variable p
												   >	122:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param 2
												   >	123:    LDA  3,-4(1)	Load address of base of array q
												   >	124:     ST  3,-17(1)	Push parameter 
												   >	* TOFF dec: -18
												   >	* Param end dog
												   >	125:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-89(7)	CALL dog
												   >	128:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	129:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end output
												   >	130:    LDA  1,-12(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-127(7)	CALL output
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -12
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	134:     ST  1,-12(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -13
												   >	* TOFF dec: -14
												   >	* Param end outnl
												   >	135:    LDA  1,-12(1)	Ghost frame becomes new active frame 
												   >	136:    LDA  3,1(7)	Return address in ac 
												   >	137:    JMP  7,-104(7)	CALL outnl
												   >	138:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -12
												   >	* EXPRESSION
												   >	* CALL output
												   >	139:     ST  1,-12(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -13
												   >	* TOFF dec: -14
												   >	* Param 1
												   >	* CALL dog
												   >	140:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	141:     LD  3,0(0)	Load variable g
												   >	142:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param 2
												   >	143:    LDA  3,-2(0)	Load address of base of array h
												   >	144:     ST  3,-17(1)	Push parameter 
												   >	* TOFF dec: -18
												   >	* Param end dog
												   >	145:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	146:    LDA  3,1(7)	Return address in ac 
												   >	147:    JMP  7,-109(7)	CALL dog
												   >	148:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	149:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end output
												   >	150:    LDA  1,-12(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-147(7)	CALL output
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -12
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	154:     ST  1,-12(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -13
												   >	* TOFF dec: -14
												   >	* Param end outnl
												   >	155:    LDA  1,-12(1)	Ghost frame becomes new active frame 
												   >	156:    LDA  3,1(7)	Return address in ac 
												   >	157:    JMP  7,-124(7)	CALL outnl
												   >	158:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -12
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	159:    LDC  2,0(6)	Set return value to 0 
												   >	160:     LD  3,-1(1)	Load return address 
												   >	161:     LD  1,0(1)	Adjust fp 
												   >	162:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,162(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	163:    LDA  1,-12(0)	set first frame at end of globals 
												   >	164:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	165:    LDC  3,10(6)	load size of array h
												   >	166:     ST  3,-1(0)	save size of array h
												   >	* END INIT GLOBALS AND STATICS
												   >	167:    LDA  3,1(7)	Return address in ac 
												   >	168:    JMP  7,-78(7)	Jump to main 
												   >	169:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpopparm.mem pushpopparm.mem.f21 differ: byte 1, line 1
pushpopparm (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: h of array of type int [mem: Global loc: -2 size: 11] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: h of array of type int [mem: Global loc: -2 size: 11] [line: 1]
												   >	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: a of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]			.   Sibling: 1  Parm: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]
.   .   Child: 1  Call: output of type void [line: 4]							.   .   Child: 1  Call: output of type void [line: 4]
.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 4]			.   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 4]
.   .   Sibling: 1  Call: output of type void [line: 5]							.   .   Sibling: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Op: [ of type int [line: 5]							.   .   .   Child: 0  Op: [ of type int [line: 5]
.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 5]		.   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [line: 5]
.   .   .   .   Child: 1  Const 3 of type int [line: 5]							.   .   .   .   Child: 1  Const 3 of type int [line: 5]
.   .   Sibling: 2  Call: outnl of type void [line: 6]							.   .   Sibling: 2  Call: outnl of type void [line: 6]
.   .   Sibling: 3  Return [line: 7]									.   .   Sibling: 3  Return [line: 7]
.   .   .   Child: 0  Op: + of type int [line: 7]							.   .   .   Child: 0  Op: + of type int [line: 7]
.   .   .   .   Child: 0  Op: + of type int [line: 7]							.   .   .   .   Child: 0  Op: + of type int [line: 7]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   .   Child: 0  Id: a of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 7]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 7]
.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: b of array of type int [mem: Parameter loc: -3 size: 1] [l
.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 7]						.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 7]
.   .   .   .   Child: 1  Op: [ of type int [line: 7]							.   .   .   .   Child: 1  Op: [ of type int [line: 7]
.   .   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 7	.   .   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 7
.   .   .   .   .   Child: 1  Const 0 of type int [line: 7]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 7]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 10]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -12] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -12] [line: 11]
.   .   Child: 0  Var: p of type int [mem: Local loc: -2 size: 1] [line: 12]				.   .   Child: 0  Var: p of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   Sibling: 1  Var: q of array of type int [mem: Local loc: -4 size: 9] [line: 12]			.   .   Sibling: 1  Var: q of array of type int [mem: Local loc: -4 size: 9] [line: 12]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   .   Child: 1  Const 100 of type int [line: 13]							.   .   .   Child: 1  Const 100 of type int [line: 13]
.   .   Sibling: 1  Assign: = of type int [line: 14]						   |	.   .   Sibling: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Local loc: -4 size: 9] [line: 14]		.   .   .   .   Child: 0  Id: q of array of type int [mem: Local loc: -4 size: 9] [line: 14]
.   .   .   .   Child: 1  Const 3 of type int [line: 14]						.   .   .   .   Child: 1  Const 3 of type int [line: 14]
.   .   .   Child: 1  Const 1000 of type int [line: 14]							.   .   .   Child: 1  Const 1000 of type int [line: 14]
.   .   Sibling: 2  Assign: = of type int [line: 15]						   |	.   .   Sibling: 2  Assign: := of type int [line: 15]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]
.   .   .   Child: 1  Const 200 of type int [line: 15]							.   .   .   Child: 1  Const 200 of type int [line: 15]
.   .   Sibling: 3  Assign: = of type int [line: 16]						   |	.   .   Sibling: 3  Assign: := of type int [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 16]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 16]
.   .   .   .   Child: 1  Const 3 of type int [line: 16]						.   .   .   .   Child: 1  Const 3 of type int [line: 16]
.   .   .   Child: 1  Const 2000 of type int [line: 16]							.   .   .   Child: 1  Const 2000 of type int [line: 16]
.   .   Sibling: 4  Assign: = of type int [line: 17]						   |	.   .   Sibling: 4  Assign: := of type int [line: 17]
.   .   .   Child: 0  Op: [ of type int [line: 17]							.   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 17]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 17]
.   .   .   .   Child: 1  Const 0 of type int [line: 17]						.   .   .   .   Child: 1  Const 0 of type int [line: 17]
.   .   .   Child: 1  Const 8 of type int [line: 17]							.   .   .   Child: 1  Const 8 of type int [line: 17]
.   .   Sibling: 5  Call: output of type void [line: 18]						.   .   Sibling: 5  Call: output of type void [line: 18]
.   .   .   Child: 0  Call: dog of type int [line: 18]							.   .   .   Child: 0  Call: dog of type int [line: 18]
.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: p of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   .   Sibling: 1  Id: q of array of type int [mem: Local loc: -4 size: 9] [line: 18]		.   .   .   .   Sibling: 1  Id: q of array of type int [mem: Local loc: -4 size: 9] [line: 18]
.   .   Sibling: 6  Call: outnl of type void [line: 19]							.   .   Sibling: 6  Call: outnl of type void [line: 19]
.   .   Sibling: 7  Call: output of type void [line: 20]						.   .   Sibling: 7  Call: output of type void [line: 20]
.   .   .   Child: 0  Call: dog of type int [line: 20]							.   .   .   Child: 0  Call: dog of type int [line: 20]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]
.   .   .   .   Sibling: 1  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 20]	.   .   .   .   Sibling: 1  Id: h of array of type int [mem: Global loc: -2 size: 11] [line: 20]
.   .   Sibling: 8  Call: outnl of type void [line: 21]							.   .   Sibling: 8  Call: outnl of type void [line: 21]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
pushpopparm.out ztmp23114.txt differ: byte 1, line 1
pushpopparm (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/pushpopparm.tm
Number of errors: 0										   |	100 1000
------------------------------------								   |	1108
Loading file: pushpopparm.tm									   |	200 2000
												   >	2208
Bye.													Bye.
====================================
FILE: pushpoptiny.c-
-rw-------. 1 corg7983 domain_users  159 Nov 17 15:35 pushpoptiny.c-
-rw-------. 1 corg7983 domain_users  162 Nov 17 15:35 pushpoptiny.c-.f21
-rw-------. 1 corg7983 domain_users  159 Nov 17 15:35 pushpoptiny.c-.f22
-rw-------. 1 corg7983 domain_users   58 Nov 17 15:35 pushpoptiny.expected
-rw-------. 1 corg7983 domain_users 2241 Nov 22 12:27 pushpoptiny.mem
-rw-------. 1 corg7983 domain_users  353 Nov 17 15:35 pushpoptiny.mem.diffs
-rw-------. 1 corg7983 domain_users 3085 Nov 17 15:35 pushpoptiny.mem.f21
-rw-------. 1 corg7983 domain_users  113 Nov 22 12:27 pushpoptiny.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 pushpoptiny.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 pushpoptiny.tm.diffs
-rw-------. 1 corg7983 domain_users 5704 Nov 17 15:35 pushpoptiny.tm.f21
TM CODE COMPARISON
pushpoptiny (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  pushpoptiny.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,11(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 42:    LDC  3,22(6)	Load integer constant 
												   >	 43:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 44:    LDC  3,13(6)	Load integer constant 
												   >	 45:     ST  3,-4(1)	Store variable c
												   >	* EXPRESSION
												   >	* CALL output
												   >	 46:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 47:     LD  3,-2(1)	Load variable a
												   >	 48:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 49:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 50:    LDA  3,1(7)	Return address in ac 
												   >	 51:    JMP  7,-46(7)	CALL output
												   >	 52:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 53:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 54:     LD  3,-2(1)	Load variable a
												   >	 55:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 56:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -7
												   >	 57:     LD  4,-7(1)	Pop left into ac1 
												   >	 58:    MUL  3,4,3	Op * 
												   >	 59:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 60:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-57(7)	CALL output
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 64:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 65:     LD  3,-2(1)	Load variable a
												   >	 66:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 67:     LD  3,-3(1)	Load variable b
												   >	 68:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 69:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -8
												   >	 70:     LD  4,-8(1)	Pop left into ac1 
												   >	 71:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -7
												   >	 72:     LD  4,-7(1)	Pop left into ac1 
												   >	 73:    SUB  3,4,3	Op - 
												   >	 74:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 75:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 76:    LDA  3,1(7)	Return address in ac 
												   >	 77:    JMP  7,-72(7)	CALL output
												   >	 78:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	 79:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 80:     LD  3,-2(1)	Load variable a
												   >	 81:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 82:     LD  3,-3(1)	Load variable b
												   >	 83:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 84:     LD  3,-4(1)	Load variable c
												   >	* TOFF inc: -8
												   >	 85:     LD  4,-8(1)	Pop left into ac1 
												   >	 86:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -7
												   >	 87:     LD  4,-7(1)	Pop left into ac1 
												   >	 88:    SUB  3,4,3	Op - 
												   >	 89:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 90:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-87(7)	CALL output
												   >	 93:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 94:    LDC  2,0(6)	Set return value to 0 
												   >	 95:     LD  3,-1(1)	Load return address 
												   >	 96:     LD  1,0(1)	Adjust fp 
												   >	 97:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,97(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 98:    LDA  1,0(0)	set first frame at end of globals 
												   >	 99:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-63(7)	Jump to main 
												   >	102:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
pushpoptiny.mem pushpoptiny.mem.f21 differ: byte 7, line 1
pushpoptiny (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 2]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 3]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 3]
.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 3]				.   .   Sibling: 2  Var: c of type int [mem: Local loc: -4 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Const 11 of type int [line: 5]							.   .   .   Child: 1  Const 11 of type int [line: 5]
.   .   Sibling: 1  Assign: = of type int [line: 6]						   |	.   .   Sibling: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 6]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   Child: 1  Const 22 of type int [line: 6]							.   .   .   Child: 1  Const 22 of type int [line: 6]
.   .   Sibling: 2  Assign: = of type int [line: 7]						   |	.   .   Sibling: 2  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   .   Child: 1  Const 13 of type int [line: 7]							.   .   .   Child: 1  Const 13 of type int [line: 7]
.   .   Sibling: 3  Call: output of type void [line: 8]							.   .   Sibling: 3  Call: output of type void [line: 8]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   Sibling: 4  Call: output of type void [line: 9]							.   .   Sibling: 4  Call: output of type void [line: 9]
.   .   .   Child: 0  Op: * of type int [line: 9]							.   .   .   Child: 0  Op: * of type int [line: 9]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 9]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 9]			.   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 9]
.   .   Sibling: 5  Call: output of type void [line: 10]						.   .   Sibling: 5  Call: output of type void [line: 10]
.   .   .   Child: 0  Op: - of type int [line: 10]							.   .   .   Child: 0  Op: - of type int [line: 10]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   .   Child: 1  Op: / of type int [line: 10]							.   .   .   .   Child: 1  Op: / of type int [line: 10]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 10]			.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 10]
.   .   Sibling: 6  Call: output of type void [line: 11]						.   .   Sibling: 6  Call: output of type void [line: 11]
.   .   .   Child: 0  Op: - of type int [line: 11]							.   .   .   Child: 0  Op: - of type int [line: 11]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   .   Child: 1  Op: / of type int [line: 11]							.   .   .   .   Child: 1  Op: / of type int [line: 11]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]			.   .   .   .   .   Child: 1  Id: c of type int [mem: Local loc: -4 size: 1] [line: 11]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
pushpoptiny.out ztmp23114.txt differ: byte 1, line 1
pushpoptiny (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/pushpoptiny.tm
Number of errors: 0										   |	11 242 10 10
------------------------------------								   <
Loading file: pushpoptiny.tm									   <
Bye.													Bye.
====================================
FILE: queens.c-
-rw-------. 1 corg7983 domain_users  1100 Nov 17 15:35 queens.c-
-rw-------. 1 corg7983 domain_users  1108 Nov 17 15:35 queens.c-.f21
-rw-------. 1 corg7983 domain_users  1100 Nov 17 15:35 queens.c-.f22
-rw-------. 1 corg7983 domain_users   654 Nov 17 15:35 queens.expected
-rw-------. 1 corg7983 domain_users    22 Nov 17 15:35 queens.in
-rw-------. 1 corg7983 domain_users 13050 Nov 22 12:27 queens.mem
-rw-------. 1 corg7983 domain_users  2426 Nov 17 15:35 queens.mem.diffs
-rw-------. 1 corg7983 domain_users 13906 Nov 17 15:35 queens.mem.f21
-rw-------. 1 corg7983 domain_users   195 Nov 22 12:27 queens.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 queens.tm
-rw-------. 1 corg7983 domain_users   413 Nov 17 15:35 queens.tm.diffs
-rw-------. 1 corg7983 domain_users 17398 Nov 17 15:35 queens.tm.f21
TM CODE COMPARISON
queens (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  queens.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION printboard
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-3(1)	Load variable i
												   >	 43:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 44:     LD  3,-78(0)	Load variable n
												   >	* TOFF inc: -4
												   >	 45:     LD  4,-4(1)	Pop left into ac1 
												   >	 46:    TLT  3,4,3	Op < 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 49:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 50:     LD  3,-2(1)	Load address of base of array col
												   >	 51:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 52:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -6
												   >	 53:     LD  4,-6(1)	Pop left into ac1 
												   >	 54:    SUB  3,4,3	compute location from index 
												   >	 55:     LD  3,0(3)	Load array element 
												   >	 56:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 57:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 58:    LDA  3,1(7)	Return address in ac 
												   >	 59:    JMP  7,-54(7)	CALL output
												   >	 60:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 61:     LD  3,-3(1)	load lhs variable i
												   >	 62:    LDA  3,1(3)	increment value of i
												   >	 63:     ST  3,-3(1)	Store variable i
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	 64:    JMP  7,-23(7)	go to beginning of loop 
												   >	 48:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 65:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 66:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-35(7)	CALL outnl
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 70:     LD  3,-79(0)	load lhs variable count
												   >	 71:    LDA  3,1(3)	increment value of count
												   >	 72:     ST  3,-79(0)	Store variable count
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 73:    LDC  2,0(6)	Set return value to 0 
												   >	 74:     LD  3,-1(1)	Load return address 
												   >	 75:     LD  1,0(1)	Adjust fp 
												   >	 76:    JMP  7,0(3)	Return 
												   >	* END FUNCTION printboard
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION try
												   >	* TOFF set: -3
												   >	 77:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	 78:     LD  3,-2(1)	Load variable c
												   >	 79:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 80:     LD  3,-78(0)	Load variable n
												   >	* TOFF inc: -4
												   >	 81:     LD  4,-4(1)	Pop left into ac1 
												   >	 82:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL printboard
												   >	 84:     ST  1,-4(1)	Store fp in ghost frame for printboard
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 85:    LDA  3,-14(0)	Load address of base of array col
												   >	 86:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end printboard
												   >	 87:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-51(7)	CALL printboard
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printboard
												   >	* TOFF set: -4
												   >	 83:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 92:    LDC  3,0(6)	Load integer constant 
												   >	 93:     ST  3,-3(1)	Store variable r
												   >	* WHILE
												   >	 94:     LD  3,-3(1)	Load variable r
												   >	 95:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 96:     LD  3,-78(0)	Load variable n
												   >	* TOFF inc: -4
												   >	 97:     LD  4,-4(1)	Pop left into ac1 
												   >	 98:    TLT  3,4,3	Op < 
												   >	 99:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	101:    LDA  3,-1(0)	Load address of base of array row
												   >	102:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	103:     LD  3,-3(1)	Load variable r
												   >	* TOFF inc: -4
												   >	104:     LD  4,-4(1)	Pop left into ac1 
												   >	105:    SUB  3,4,3	compute location from index 
												   >	106:     LD  3,0(3)	Load array element 
												   >	107:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	108:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	109:     LD  4,-4(1)	Pop left into ac1 
												   >	110:    TEQ  3,4,3	Op = 
												   >	111:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	112:    LDA  3,-27(0)	Load address of base of array diagone
												   >	113:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	114:     LD  3,-3(1)	Load variable r
												   >	115:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	116:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -6
												   >	117:     LD  4,-6(1)	Pop left into ac1 
												   >	118:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -5
												   >	119:     LD  4,-5(1)	Pop left into ac1 
												   >	120:    SUB  3,4,3	compute location from index 
												   >	121:     LD  3,0(3)	Load array element 
												   >	122:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	123:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	124:     LD  4,-5(1)	Pop left into ac1 
												   >	125:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	126:     LD  4,-4(1)	Pop left into ac1 
												   >	127:    AND  3,4,3	Op AND 
												   >	128:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	129:    LDA  3,-53(0)	Load address of base of array diagtwo
												   >	130:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	131:     LD  3,-3(1)	Load variable r
												   >	132:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	133:     LD  3,-78(0)	Load variable n
												   >	134:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	135:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	136:     LD  4,-7(1)	Pop left into ac1 
												   >	137:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -6
												   >	138:     LD  4,-6(1)	Pop left into ac1 
												   >	139:    ADD  3,4,3	Op + 
												   >	140:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	141:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -6
												   >	142:     LD  4,-6(1)	Pop left into ac1 
												   >	143:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -5
												   >	144:     LD  4,-5(1)	Pop left into ac1 
												   >	145:    SUB  3,4,3	compute location from index 
												   >	146:     LD  3,0(3)	Load array element 
												   >	147:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	148:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	149:     LD  4,-5(1)	Pop left into ac1 
												   >	150:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	151:     LD  4,-4(1)	Pop left into ac1 
												   >	152:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	154:     LD  3,-3(1)	Load variable r
												   >	155:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	156:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	157:     LD  4,-4(1)	Pop index 
												   >	158:    LDA  5,-1(0)	Load address of base of array row
												   >	159:    SUB  5,5,4	Compute offset of value 
												   >	160:     ST  3,0(5)	Store variable row
												   >	* EXPRESSION
												   >	161:     LD  3,-2(1)	Load variable c
												   >	162:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	163:     LD  3,-3(1)	Load variable r
												   >	* TOFF inc: -4
												   >	164:     LD  4,-4(1)	Pop index 
												   >	165:    LDA  5,-14(0)	Load address of base of array col
												   >	166:    SUB  5,5,4	Compute offset of value 
												   >	167:     ST  3,0(5)	Store variable col
												   >	* EXPRESSION
												   >	168:     LD  3,-3(1)	Load variable r
												   >	169:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	170:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -4
												   >	171:     LD  4,-4(1)	Pop left into ac1 
												   >	172:    ADD  3,4,3	Op + 
												   >	173:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	174:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	175:     LD  4,-4(1)	Pop index 
												   >	176:    LDA  5,-27(0)	Load address of base of array diagone
												   >	177:    SUB  5,5,4	Compute offset of value 
												   >	178:     ST  3,0(5)	Store variable diagone
												   >	* EXPRESSION
												   >	179:     LD  3,-3(1)	Load variable r
												   >	180:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	181:     LD  3,-78(0)	Load variable n
												   >	182:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	183:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	184:     LD  4,-5(1)	Pop left into ac1 
												   >	185:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -4
												   >	186:     LD  4,-4(1)	Pop left into ac1 
												   >	187:    ADD  3,4,3	Op + 
												   >	188:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	189:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -4
												   >	190:     LD  4,-4(1)	Pop left into ac1 
												   >	191:    SUB  3,4,3	Op - 
												   >	192:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	193:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	194:     LD  4,-4(1)	Pop index 
												   >	195:    LDA  5,-53(0)	Load address of base of array diagtwo
												   >	196:    SUB  5,5,4	Compute offset of value 
												   >	197:     ST  3,0(5)	Store variable diagtwo
												   >	* EXPRESSION
												   >	* CALL try
												   >	198:     ST  1,-4(1)	Store fp in ghost frame for try
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	199:     LD  3,-2(1)	Load variable c
												   >	200:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	201:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	202:     LD  4,-6(1)	Pop left into ac1 
												   >	203:    ADD  3,4,3	Op + 
												   >	204:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end try
												   >	205:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	206:    LDA  3,1(7)	Return address in ac 
												   >	207:    JMP  7,-131(7)	CALL try
												   >	208:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end try
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	209:     LD  3,-3(1)	Load variable r
												   >	210:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	211:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	212:     LD  4,-4(1)	Pop index 
												   >	213:    LDA  5,-1(0)	Load address of base of array row
												   >	214:    SUB  5,5,4	Compute offset of value 
												   >	215:     ST  3,0(5)	Store variable row
												   >	* EXPRESSION
												   >	216:     LD  3,-3(1)	Load variable r
												   >	217:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	218:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -4
												   >	219:     LD  4,-4(1)	Pop left into ac1 
												   >	220:    ADD  3,4,3	Op + 
												   >	221:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	222:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	223:     LD  4,-4(1)	Pop index 
												   >	224:    LDA  5,-27(0)	Load address of base of array diagone
												   >	225:    SUB  5,5,4	Compute offset of value 
												   >	226:     ST  3,0(5)	Store variable diagone
												   >	* EXPRESSION
												   >	227:     LD  3,-3(1)	Load variable r
												   >	228:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	229:     LD  3,-78(0)	Load variable n
												   >	230:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	231:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	232:     LD  4,-5(1)	Pop left into ac1 
												   >	233:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -4
												   >	234:     LD  4,-4(1)	Pop left into ac1 
												   >	235:    ADD  3,4,3	Op + 
												   >	236:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	237:     LD  3,-2(1)	Load variable c
												   >	* TOFF inc: -4
												   >	238:     LD  4,-4(1)	Pop left into ac1 
												   >	239:    SUB  3,4,3	Op - 
												   >	240:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	241:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	242:     LD  4,-4(1)	Pop index 
												   >	243:    LDA  5,-53(0)	Load address of base of array diagtwo
												   >	244:    SUB  5,5,4	Compute offset of value 
												   >	245:     ST  3,0(5)	Store variable diagtwo
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	153:    JZR  3,92(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	246:     LD  3,-3(1)	load lhs variable r
												   >	247:    LDA  3,1(3)	increment value of r
												   >	248:     ST  3,-3(1)	Store variable r
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	249:    JMP  7,-156(7)	go to beginning of loop 
												   >	100:    JMP  7,149(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	 91:    JMP  7,158(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	250:    LDC  2,0(6)	Set return value to 0 
												   >	251:     LD  3,-1(1)	Load return address 
												   >	252:     LD  1,0(1)	Adjust fp 
												   >	253:    JMP  7,0(3)	Return 
												   >	* END FUNCTION try
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION solve
												   >	* TOFF set: -3
												   >	254:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	255:     LD  3,-2(1)	Load variable num
												   >	256:     ST  3,-78(0)	Store variable n
												   >	* EXPRESSION
												   >	257:    LDC  3,0(6)	Load integer constant 
												   >	258:     ST  3,-79(0)	Store variable count
												   >	* EXPRESSION
												   >	* CALL try
												   >	259:     ST  1,-3(1)	Store fp in ghost frame for try
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	260:    LDC  3,0(6)	Load integer constant 
												   >	261:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end try
												   >	262:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	263:    LDA  3,1(7)	Return address in ac 
												   >	264:    JMP  7,-188(7)	CALL try
												   >	265:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end try
												   >	* TOFF set: -3
												   >	* RETURN
												   >	266:     LD  3,-79(0)	Load variable count
												   >	267:    LDA  2,0(3)	Copy result to return register 
												   >	268:     LD  3,-1(1)	Load return address 
												   >	269:     LD  1,0(1)	Adjust fp 
												   >	270:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	271:    LDC  2,0(6)	Set return value to 0 
												   >	272:     LD  3,-1(1)	Load return address 
												   >	273:     LD  1,0(1)	Adjust fp 
												   >	274:    JMP  7,0(3)	Return 
												   >	* END FUNCTION solve
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	275:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* WHILE
												   >	* CALL input
												   >	276:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	277:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	278:    LDA  3,1(7)	Return address in ac 
												   >	279:    JMP  7,-279(7)	CALL input
												   >	280:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	281:     ST  3,-2(1)	Store variable num
												   >	282:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	283:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	284:     LD  4,-3(1)	Pop left into ac1 
												   >	285:    TGT  3,4,3	Op > 
												   >	286:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	288:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL solve
												   >	289:     ST  1,-5(1)	Store fp in ghost frame for solve
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	290:     LD  3,-2(1)	Load variable num
												   >	291:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end solve
												   >	292:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	293:    LDA  3,1(7)	Return address in ac 
												   >	294:    JMP  7,-41(7)	CALL solve
												   >	295:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end solve
												   >	* TOFF set: -5
												   >	296:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	297:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	298:    LDA  3,1(7)	Return address in ac 
												   >	299:    JMP  7,-294(7)	CALL output
												   >	300:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	301:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	302:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	303:    LDA  3,1(7)	Return address in ac 
												   >	304:    JMP  7,-271(7)	CALL outnl
												   >	305:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	306:    JMP  7,-31(7)	go to beginning of loop 
												   >	287:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	307:    LDC  2,0(6)	Set return value to 0 
												   >	308:     LD  3,-1(1)	Load return address 
												   >	309:     LD  1,0(1)	Adjust fp 
												   >	310:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,310(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	311:    LDA  1,-80(0)	set first frame at end of globals 
												   >	312:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	313:    LDC  3,12(6)	load size of array col
												   >	314:     ST  3,-13(0)	save size of array col
												   >	315:    LDC  3,25(6)	load size of array diagone
												   >	316:     ST  3,-26(0)	save size of array diagone
												   >	317:    LDC  3,25(6)	load size of array diagtwo
												   >	318:     ST  3,-52(0)	save size of array diagtwo
												   >	319:    LDC  3,12(6)	load size of array row
												   >	320:     ST  3,0(0)	save size of array row
												   >	* END INIT GLOBALS AND STATICS
												   >	321:    LDA  3,1(7)	Return address in ac 
												   >	322:    JMP  7,-48(7)	Jump to main 
												   >	323:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
queens.mem queens.mem.f21 differ: byte 1, line 1
queens (MEM DIFF)
Var: row of array of type int [mem: Global loc: -1 size: 13] [line: 6]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: col of array of type int [mem: Global loc: -14 size: 13] [line: 7]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Var: diagone of array of type int [mem: Global loc: -27 size: 26] [line: 8]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 3  Var: diagtwo of array of type int [mem: Global loc: -53 size: 26] [line: 9]		   |	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 4  Var: n of type int [mem: Global loc: -78 size: 1] [line: 10]			   |	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 5  Var: count of type int [mem: Global loc: -79 size: 1] [line: 11]			   |	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
Sibling: 6  Func: printboard returns type void [mem: Global loc: 0 size: -3] [line: 13]		   |	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: row of array of type int [mem: Global loc: -1 size: 13] [line: 6]
												   >	Sibling: 8  Var: col of array of type int [mem: Global loc: -14 size: 13] [line: 7]
												   >	Sibling: 9  Var: diagone of array of type int [mem: Global loc: -27 size: 26] [line: 8]
												   >	Sibling: 10  Var: diagtwo of array of type int [mem: Global loc: -53 size: 26] [line: 9]
												   >	Sibling: 11  Var: n of type int [mem: Global loc: -78 size: 1] [line: 10]
												   >	Sibling: 12  Var: count of type int [mem: Global loc: -79 size: 1] [line: 11]
												   >	Sibling: 13  Func: printboard returns type void [mem: Global loc: 0 size: -3] [line: 13]
.   Child: 0  Parm: col of array of type int [mem: Parameter loc: -2 size: 1] [line: 13]		.   Child: 0  Parm: col of array of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 14]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 14]
.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 15]				.   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 15]
.   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 17]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   Child: 1  Const 0 of type int [line: 17]							.   .   .   Child: 1  Const 0 of type int [line: 17]
.   .   Sibling: 1  While [line: 18]									.   .   Sibling: 1  While [line: 18]
.   .   .   Child: 0  Op: < of type bool [line: 18]							.   .   .   Child: 0  Op: < of type bool [line: 18]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 18]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 18]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 18]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 18]
.   .   .   .   Child: 1  Call: output of type void [line: 19]						.   .   .   .   Child: 1  Call: output of type void [line: 19]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 19]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   .   .   Child: 0  Id: col of array of type int [mem: Parameter loc: -2 size: 1] 	.   .   .   .   .   .   Child: 0  Id: col of array of type int [mem: Parameter loc: -2 size: 1] 
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 19]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 20]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 20]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 20]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 20]
.   .   Sibling: 2  Call: outnl of type void [line: 22]							.   .   Sibling: 2  Call: outnl of type void [line: 22]
.   .   Sibling: 3  Assign: ++ of type int [line: 23]							.   .   Sibling: 3  Assign: ++ of type int [line: 23]
.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 23]			.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 23]
Sibling: 7  Func: try returns type void [mem: Global loc: 0 size: -3] [line: 26]		   |	Sibling: 14  Func: try returns type void [mem: Global loc: 0 size: -3] [line: 26]
.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 26]				.   Child: 0  Parm: c of type int [mem: Parameter loc: -2 size: 1] [line: 26]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 27]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 27]
.   .   Child: 0  Var: r of type int [mem: Local loc: -3 size: 1] [line: 28]				.   .   Child: 0  Var: r of type int [mem: Local loc: -3 size: 1] [line: 28]
.   .   Child: 1  If [line: 30]										.   .   Child: 1  If [line: 30]
.   .   .   Child: 0  Op: == of type bool [line: 30]						   |	.   .   .   Child: 0  Op: = of type bool [line: 30]
.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 30]			.   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size: 1] [line: 30]
.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 30]			.   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 30]
.   .   .   Child: 1  Call: printboard of type void [line: 31]						.   .   .   Child: 1  Call: printboard of type void [line: 31]
.   .   .   .   Child: 0  Id: col of array of type int [mem: Global loc: -14 size: 13] [line: 31	.   .   .   .   Child: 0  Id: col of array of type int [mem: Global loc: -14 size: 13] [line: 31
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -4] [line: 32]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -4] [line: 32]
.   .   .   .   Child: 1  Assign: = of type int [line: 33]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 33]
.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 33]			.   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 33]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 33]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 33]
.   .   .   .   Sibling: 1  While [line: 34]								.   .   .   .   Sibling: 1  While [line: 34]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 34]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 34]
.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 34]		.   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 34]
.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 34]		.   .   .   .   .   .   Child: 1  Id: n of type int [mem: Global loc: -78 size: 1] [line: 34]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 34]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 34]
.   .   .   .   .   .   Child: 1  If [line: 35]								.   .   .   .   .   .   Child: 1  If [line: 35]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]
.   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]				.   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 35]			   |	.   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 35]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]
.   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 35]			   |	.   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 35]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Glo	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Glo
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 35]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 35]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 35]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 35]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 35]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 35]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 35]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 36]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 36]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 36]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global loc:	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global loc:
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 37]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 37]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 37]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 37]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: col of array of type int [mem: Global loc:	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: col of array of type int [mem: Global loc:
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 size	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 size
.   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 38]			   |	.   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 38]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 38]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 38]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 38]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 38]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 38]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 38]
.   .   .   .   .   .   .   .   Sibling: 3  Assign: = of type int [line: 39]			   |	.   .   .   .   .   .   .   .   Sibling: 3  Assign: := of type int [line: 39]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 39]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 39]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 39]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 39]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 39]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 39]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 39]
.   .   .   .   .   .   .   .   Sibling: 4  Call: try of type void [line: 40]				.   .   .   .   .   .   .   .   Sibling: 4  Call: try of type void [line: 40]
.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 40]				.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 40]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Parameter loc: -2 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 40]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 40]
.   .   .   .   .   .   .   .   Sibling: 5  Assign: = of type int [line: 41]			   |	.   .   .   .   .   .   .   .   Sibling: 5  Assign: := of type int [line: 41]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 41]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 41]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global loc:	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: row of array of type int [mem: Global loc:
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: r of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 41]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 41]
.   .   .   .   .   .   .   .   Sibling: 6  Assign: = of type int [line: 42]			   |	.   .   .   .   .   .   .   .   Sibling: 6  Assign: := of type int [line: 42]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 42]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 42]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagone of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 42]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 42]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 42]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 42]
.   .   .   .   .   .   .   .   Sibling: 7  Assign: = of type int [line: 43]			   |	.   .   .   .   .   .   .   .   Sibling: 7  Assign: := of type int [line: 43]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 43]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: diagtwo of array of type int [mem: Global 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Global loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 43]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 43]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 43]
.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 45]					.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 45]
.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 45]		.   .   .   .   .   .   .   Child: 0  Id: r of type int [mem: Local loc: -3 size: 1] [line: 45]
Sibling: 8  Func: solve returns type int [mem: Global loc: 0 size: -3] [line: 50]		   |	Sibling: 15  Func: solve returns type int [mem: Global loc: 0 size: -3] [line: 50]
.   Child: 0  Parm: num of type int [mem: Parameter loc: -2 size: 1] [line: 50]				.   Child: 0  Parm: num of type int [mem: Parameter loc: -2 size: 1] [line: 50]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 51]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 51]
.   .   Child: 1  Assign: = of type int [line: 52]						   |	.   .   Child: 1  Assign: := of type int [line: 52]
.   .   .   Child: 0  Id: n of type int [mem: Global loc: -78 size: 1] [line: 52]			.   .   .   Child: 0  Id: n of type int [mem: Global loc: -78 size: 1] [line: 52]
.   .   .   Child: 1  Id: num of type int [mem: Parameter loc: -2 size: 1] [line: 52]			.   .   .   Child: 1  Id: num of type int [mem: Parameter loc: -2 size: 1] [line: 52]
.   .   Sibling: 1  Assign: = of type int [line: 53]						   |	.   .   Sibling: 1  Assign: := of type int [line: 53]
.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 53]			.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 53]
.   .   .   Child: 1  Const 0 of type int [line: 53]							.   .   .   Child: 1  Const 0 of type int [line: 53]
.   .   Sibling: 2  Call: try of type void [line: 54]							.   .   Sibling: 2  Call: try of type void [line: 54]
.   .   .   Child: 0  Const 0 of type int [line: 54]							.   .   .   Child: 0  Const 0 of type int [line: 54]
.   .   Sibling: 3  Return [line: 56]									.   .   Sibling: 3  Return [line: 56]
.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 56]			.   .   .   Child: 0  Id: count of type int [mem: Global loc: -79 size: 1] [line: 56]
Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 59]		   |	Sibling: 16  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 59]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 60]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 60]
.   .   Child: 0  Var: num of type int [mem: Local loc: -2 size: 1] [line: 61]				.   .   Child: 0  Var: num of type int [mem: Local loc: -2 size: 1] [line: 61]
.   .   Child: 1  While [line: 63]									.   .   Child: 1  While [line: 63]
.   .   .   Child: 0  Op: > of type bool [line: 63]							.   .   .   Child: 0  Op: > of type bool [line: 63]
.   .   .   .   Child: 0  Assign: = of type int [line: 63]					   |	.   .   .   .   Child: 0  Assign: := of type int [line: 63]
.   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -2 size: 1] [line: 63]		.   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -2 size: 1] [line: 63]
.   .   .   .   .   Child: 1  Call: input of type int [line: 63]					.   .   .   .   .   Child: 1  Call: input of type int [line: 63]
.   .   .   .   Child: 1  Const 0 of type int [line: 63]						.   .   .   .   Child: 1  Const 0 of type int [line: 63]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 63]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 63]
.   .   .   .   Child: 1  Call: output of type void [line: 64]						.   .   .   .   Child: 1  Call: output of type void [line: 64]
.   .   .   .   .   Child: 0  Call: solve of type int [line: 64]					.   .   .   .   .   Child: 0  Call: solve of type int [line: 64]
.   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -2 size: 1] [line: 64]		.   .   .   .   .   .   Child: 0  Id: num of type int [mem: Local loc: -2 size: 1] [line: 64]
.   .   .   .   Sibling: 1  Call: outnl of type void [line: 65]						.   .   .   .   Sibling: 1  Call: outnl of type void [line: 65]
Offset for end of global space: -80									Offset for end of global space: -80
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
queens.out ztmp23114.txt differ: byte 1, line 1
queens (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/queens.tm
Number of errors: 0										   |	entered: 4
------------------------------------								   |	1 3 0 2
Loading file: queens.tm										   |	2 0 3 1
ERROR: TM Command 4 unknown.									   |	2
ERROR: TM Command 7 unknown.									   |	entered: 7
ERROR: TM Command 0 unknown.									   |	0 2 4 6 1 3 5
												   >	0 3 6 2 5 1 4
												   >	0 4 1 5 2 6 3
												   >	0 5 3 1 6 4 2
												   >	1 3 0 6 4 2 5
												   >	1 3 5 0 2 4 6
												   >	1 4 0 3 6 2 5
												   >	1 4 2 0 6 3 5
												   >	1 4 6 3 0 2 5
												   >	1 5 2 6 3 0 4
												   >	1 6 4 2 0 5 3
												   >	2 0 5 1 4 6 3
												   >	2 0 5 3 1 6 4
												   >	2 4 6 1 3 5 0
												   >	2 5 1 4 0 3 6
												   >	2 6 1 3 5 0 4
												   >	2 6 3 0 4 1 5
												   >	3 0 2 5 1 6 4
												   >	3 0 4 1 5 2 6
												   >	3 1 6 4 2 0 5
												   >	3 5 0 2 4 6 1
												   >	3 6 2 5 1 4 0
												   >	3 6 4 1 5 0 2
												   >	4 0 3 6 2 5 1
												   >	4 0 5 3 1 6 2
												   >	4 1 5 2 6 3 0
												   >	4 2 0 5 3 1 6
												   >	4 6 1 3 5 0 2
												   >	4 6 1 5 2 0 3
												   >	5 0 2 4 6 1 3
												   >	5 1 4 0 3 6 2
												   >	5 2 0 3 6 4 1
												   >	5 2 4 6 0 3 1
												   >	5 2 6 3 0 4 1
												   >	5 3 1 6 4 2 0
												   >	5 3 6 0 2 4 1
												   >	6 1 3 5 0 2 4
												   >	6 2 5 1 4 0 3
												   >	6 3 0 4 1 5 2
												   >	6 4 2 0 5 3 1
												   >	40
												   >	entered: 0
Bye.													Bye.
====================================
FILE: return.c-
-rw-------. 1 corg7983 domain_users  128 Nov 17 15:35 return.c-
-rw-------. 1 corg7983 domain_users  129 Nov 17 15:35 return.c-.f21
-rw-------. 1 corg7983 domain_users  128 Nov 17 15:35 return.c-.f22
-rw-------. 1 corg7983 domain_users   44 Nov 17 15:35 return.expected
-rw-------. 1 corg7983 domain_users 1121 Nov 22 12:27 return.mem
-rw-------. 1 corg7983 domain_users  121 Nov 17 15:35 return.mem.diffs
-rw-------. 1 corg7983 domain_users 1963 Nov 17 15:35 return.mem.f21
-rw-------. 1 corg7983 domain_users  108 Nov 22 12:27 return.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 return.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 return.tm.diffs
-rw-------. 1 corg7983 domain_users 5176 Nov 17 15:35 return.tm.f21
TM CODE COMPARISON
return (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  return.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION null
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* RETURN
												   >	 40:    LDC  3,107(6)	Load integer constant 
												   >	 41:    LDA  2,0(3)	Copy result to return register 
												   >	 42:     LD  3,-1(1)	Load return address 
												   >	 43:     LD  1,0(1)	Adjust fp 
												   >	 44:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 45:    LDC  2,0(6)	Set return value to 0 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* END FUNCTION null
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -2
												   >	 49:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* RETURN
												   >	* CALL null
												   >	 50:     ST  1,-2(1)	Store fp in ghost frame for null
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end null
												   >	 51:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	 52:    LDA  3,1(7)	Return address in ac 
												   >	 53:    JMP  7,-15(7)	CALL null
												   >	 54:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end null
												   >	* TOFF set: -2
												   >	 55:    LDA  2,0(3)	Copy result to return register 
												   >	 56:     LD  3,-1(1)	Load return address 
												   >	 57:     LD  1,0(1)	Adjust fp 
												   >	 58:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 59:    LDC  2,0(6)	Set return value to 0 
												   >	 60:     LD  3,-1(1)	Load return address 
												   >	 61:     LD  1,0(1)	Adjust fp 
												   >	 62:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 63:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 64:    LDC  3,899(6)	Load integer constant 
												   >	* EXPRESSION
												   >	* CALL cat
												   >	 65:     ST  1,-3(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end cat
												   >	 66:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-20(7)	CALL cat
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -3
												   >	 70:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 71:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 72:     LD  3,-2(1)	Load variable x
												   >	 73:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 74:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 75:    LDA  3,1(7)	Return address in ac 
												   >	 76:    JMP  7,-71(7)	CALL output
												   >	 77:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 78:    LDC  2,0(6)	Set return value to 0 
												   >	 79:     LD  3,-1(1)	Load return address 
												   >	 80:     LD  1,0(1)	Adjust fp 
												   >	 81:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,81(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 82:    LDA  1,0(0)	set first frame at end of globals 
												   >	 83:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 84:    LDA  3,1(7)	Return address in ac 
												   >	 85:    JMP  7,-23(7)	Jump to main 
												   >	 86:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
return.mem return.mem.f21 differ: byte 7, line 1
return (MEM DIFF)
Func: null returns type int [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: null returns type int [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 2]
.   .   Child: 1  Return [line: 3]									.   .   Child: 1  Return [line: 3]
.   .   .   Child: 0  Const 107 of type int [line: 3]							.   .   .   Child: 0  Const 107 of type int [line: 3]
Sibling: 1  Func: cat returns type int [mem: Global loc: 0 size: -2] [line: 6]			   |	Sibling: 8  Func: cat returns type int [mem: Global loc: 0 size: -2] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 7]
.   .   Child: 1  Return [line: 8]									.   .   Child: 1  Return [line: 8]
.   .   .   Child: 0  Call: null of type int [line: 8]							.   .   .   Child: 0  Call: null of type int [line: 8]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   Child: 1  Const 899 of type int [line: 14]							.   .   Child: 1  Const 899 of type int [line: 14]
.   .   Sibling: 1  Assign: = of type int [line: 15]						   |	.   .   Sibling: 1  Assign: := of type int [line: 15]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 15]
.   .   .   Child: 1  Call: cat of type int [line: 15]							.   .   .   Child: 1  Call: cat of type int [line: 15]
.   .   Sibling: 2  Call: output of type void [line: 16]						.   .   Sibling: 2  Call: output of type void [line: 16]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 16]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
return.out ztmp23114.txt differ: byte 1, line 1
return (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/return.tm
Number of errors: 0										   |	107
------------------------------------								   <
Loading file: return.tm										   <
Bye.													Bye.
====================================
FILE: righttri.c-
-rw-------. 1 corg7983 domain_users   757 Nov 17 15:35 righttri.c-
-rw-------. 1 corg7983 domain_users   768 Nov 17 15:35 righttri.c-.f21
-rw-------. 1 corg7983 domain_users   757 Nov 17 15:35 righttri.c-.f22
-rw-------. 1 corg7983 domain_users   186 Nov 17 15:35 righttri.expected
-rw-------. 1 corg7983 domain_users    16 Nov 17 15:35 righttri.in
-rw-------. 1 corg7983 domain_users  9114 Nov 22 12:27 righttri.mem
-rw-------. 1 corg7983 domain_users  2177 Nov 17 15:35 righttri.mem.diffs
-rw-------. 1 corg7983 domain_users  9966 Nov 17 15:35 righttri.mem.f21
-rw-------. 1 corg7983 domain_users   110 Nov 22 12:27 righttri.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 righttri.tm
-rw-------. 1 corg7983 domain_users   279 Nov 17 15:35 righttri.tm.diffs
-rw-------. 1 corg7983 domain_users 10634 Nov 17 15:35 righttri.tm.f21
TM CODE COMPARISON
righttri (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  righttri.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	 42:    LDC  3,1(6)	Load integer constant 
												   >	 43:     ST  3,-4(1)	Store variable aa
												   >	* EXPRESSION
												   >	 44:    LDC  3,0(6)	Load integer constant 
												   >	 45:     ST  3,-6(1)	Store variable c
												   >	* WHILE
												   >	 46:     LD  3,-6(1)	Load variable c
												   >	 47:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 48:    LDC  3,50(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 49:     LD  4,-8(1)	Pop left into ac1 
												   >	 50:    TLT  3,4,3	Op < 
												   >	 51:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 53:    LDC  3,1(6)	Load integer constant 
												   >	 54:     ST  3,-7(1)	Store variable cc
												   >	 55:     ST  3,-6(1)	Store variable c
												   >	* EXPRESSION
												   >	 56:    LDC  3,1(6)	Load integer constant 
												   >	 57:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 58:    LDC  3,1(6)	Load integer constant 
												   >	 59:     ST  3,-5(1)	Store variable bb
												   >	* WHILE
												   >	 60:     LD  3,-3(1)	Load variable b
												   >	 61:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 62:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -8
												   >	 63:     LD  4,-8(1)	Pop left into ac1 
												   >	 64:    TLE  3,4,3	Op <= 
												   >	 65:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* IF
												   >	 67:     LD  3,-4(1)	Load variable aa
												   >	 68:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 69:     LD  3,-5(1)	Load variable bb
												   >	* TOFF inc: -8
												   >	 70:     LD  4,-8(1)	Pop left into ac1 
												   >	 71:    ADD  3,4,3	Op + 
												   >	 72:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 73:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 74:     LD  4,-8(1)	Pop left into ac1 
												   >	 75:    DIV  3,4,3	Op / 
												   >	 76:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 77:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 78:     LD  4,-8(1)	Pop left into ac1 
												   >	 79:    MOD  3,4,3	Op % 
												   >	 80:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 81:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 82:     LD  4,-8(1)	Pop left into ac1 
												   >	 83:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* WHILE
												   >	 85:     LD  3,-7(1)	Load variable cc
												   >	 86:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 87:     LD  3,-4(1)	Load variable aa
												   >	 88:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	 89:     LD  3,-5(1)	Load variable bb
												   >	* TOFF inc: -9
												   >	 90:     LD  4,-9(1)	Pop left into ac1 
												   >	 91:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -8
												   >	 92:     LD  4,-8(1)	Pop left into ac1 
												   >	 93:    TLT  3,4,3	Op < 
												   >	 94:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 96:     LD  3,-6(1)	Load variable c
												   >	 97:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 98:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 99:     LD  4,-8(1)	Pop left into ac1 
												   >	100:    ADD  3,4,3	Op + 
												   >	101:     ST  3,-6(1)	Store variable c
												   >	* EXPRESSION
												   >	102:     LD  3,-7(1)	Load variable cc
												   >	103:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	104:    LDC  3,2(6)	Load integer constant 
												   >	105:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	106:     LD  3,-6(1)	Load variable c
												   >	* TOFF inc: -9
												   >	107:     LD  4,-9(1)	Pop left into ac1 
												   >	108:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	109:     LD  4,-8(1)	Pop left into ac1 
												   >	110:    ADD  3,4,3	Op + 
												   >	111:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	112:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	113:     LD  4,-8(1)	Pop left into ac1 
												   >	114:    SUB  3,4,3	Op - 
												   >	115:     ST  3,-7(1)	Store variable cc
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	116:    JMP  7,-32(7)	go to beginning of loop 
												   >	 95:    JMP  7,21(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	117:     LD  3,-4(1)	Load variable aa
												   >	118:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	119:     LD  3,-5(1)	Load variable bb
												   >	* TOFF inc: -8
												   >	120:     LD  4,-8(1)	Pop left into ac1 
												   >	121:    ADD  3,4,3	Op + 
												   >	122:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	123:     LD  3,-7(1)	Load variable cc
												   >	* TOFF inc: -8
												   >	124:     LD  4,-8(1)	Pop left into ac1 
												   >	125:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	127:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	128:     LD  3,-2(1)	Load variable a
												   >	129:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	130:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-127(7)	CALL output
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	134:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	135:     LD  3,-3(1)	Load variable b
												   >	136:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	137:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	138:    LDA  3,1(7)	Return address in ac 
												   >	139:    JMP  7,-134(7)	CALL output
												   >	140:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL output
												   >	141:     ST  1,-8(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	142:     LD  3,-6(1)	Load variable c
												   >	143:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end output
												   >	144:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	145:    LDA  3,1(7)	Return address in ac 
												   >	146:    JMP  7,-141(7)	CALL output
												   >	147:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	148:     ST  1,-8(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param end outnl
												   >	149:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	150:    LDA  3,1(7)	Return address in ac 
												   >	151:    JMP  7,-118(7)	CALL outnl
												   >	152:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -8
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	126:    JZR  3,26(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	 84:    JZR  3,68(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	153:     LD  3,-3(1)	Load variable b
												   >	154:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	155:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	156:     LD  4,-8(1)	Pop left into ac1 
												   >	157:    ADD  3,4,3	Op + 
												   >	158:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	159:     LD  3,-5(1)	Load variable bb
												   >	160:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	161:    LDC  3,2(6)	Load integer constant 
												   >	162:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	163:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -9
												   >	164:     LD  4,-9(1)	Pop left into ac1 
												   >	165:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	166:     LD  4,-8(1)	Pop left into ac1 
												   >	167:    ADD  3,4,3	Op + 
												   >	168:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	169:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	170:     LD  4,-8(1)	Pop left into ac1 
												   >	171:    SUB  3,4,3	Op - 
												   >	172:     ST  3,-5(1)	Store variable bb
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	173:    JMP  7,-114(7)	go to beginning of loop 
												   >	 66:    JMP  7,107(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	174:     LD  3,-2(1)	Load variable a
												   >	175:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	176:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	177:     LD  4,-8(1)	Pop left into ac1 
												   >	178:    ADD  3,4,3	Op + 
												   >	179:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	180:     LD  3,-4(1)	Load variable aa
												   >	181:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	182:    LDC  3,2(6)	Load integer constant 
												   >	183:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	184:     LD  3,-2(1)	Load variable a
												   >	* TOFF inc: -9
												   >	185:     LD  4,-9(1)	Pop left into ac1 
												   >	186:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -8
												   >	187:     LD  4,-8(1)	Pop left into ac1 
												   >	188:    ADD  3,4,3	Op + 
												   >	189:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	190:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	191:     LD  4,-8(1)	Pop left into ac1 
												   >	192:    SUB  3,4,3	Op - 
												   >	193:     ST  3,-4(1)	Store variable aa
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	194:    JMP  7,-149(7)	go to beginning of loop 
												   >	 52:    JMP  7,142(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	195:    LDC  2,0(6)	Set return value to 0 
												   >	196:     LD  3,-1(1)	Load return address 
												   >	197:     LD  1,0(1)	Adjust fp 
												   >	198:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,198(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	199:    LDA  1,0(0)	set first frame at end of globals 
												   >	200:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	201:    LDA  3,1(7)	Return address in ac 
												   >	202:    JMP  7,-164(7)	Jump to main 
												   >	203:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
righttri.mem righttri.mem.f21 differ: byte 7, line 1
righttri (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 4]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 6]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   Sibling: 2  Var: aa of type int [mem: Local loc: -4 size: 1] [line: 7]				.   .   Sibling: 2  Var: aa of type int [mem: Local loc: -4 size: 1] [line: 7]
.   .   Sibling: 3  Var: bb of type int [mem: Local loc: -5 size: 1] [line: 8]				.   .   Sibling: 3  Var: bb of type int [mem: Local loc: -5 size: 1] [line: 8]
.   .   Sibling: 4  Var: c of type int [mem: Local loc: -6 size: 1] [line: 9]				.   .   Sibling: 4  Var: c of type int [mem: Local loc: -6 size: 1] [line: 9]
.   .   Sibling: 5  Var: cc of type int [mem: Local loc: -7 size: 1] [line: 10]				.   .   Sibling: 5  Var: cc of type int [mem: Local loc: -7 size: 1] [line: 10]
.   .   Child: 1  Assign: = of type int [line: 12]						   |	.   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 12]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   Child: 1  Const 1 of type int [line: 12]							.   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   Sibling: 1  Assign: = of type int [line: 13]						   |	.   .   Sibling: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 13]			.   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   Child: 1  Const 1 of type int [line: 13]							.   .   .   Child: 1  Const 1 of type int [line: 13]
.   .   Sibling: 2  Assign: = of type int [line: 14]						   |	.   .   Sibling: 2  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 14]				.   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 14]
.   .   .   Child: 1  Const 0 of type int [line: 14]							.   .   .   Child: 1  Const 0 of type int [line: 14]
.   .   Sibling: 3  While [line: 15]									.   .   Sibling: 3  While [line: 15]
.   .   .   Child: 0  Op: < of type bool [line: 15]							.   .   .   Child: 0  Op: < of type bool [line: 15]
.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 50 of type int [line: 15]						.   .   .   .   Child: 1  Const 50 of type int [line: 15]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 15]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 15]
.   .   .   .   Child: 1  Assign: = of type int [line: 16]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 16]			.   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size: 1] [line: 16]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 16]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 size: 1] [line: 16]		.   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 size: 1] [line: 16]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 16]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 16]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 17]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 17]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 17]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 17]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 18]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 18]
.   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [line: 18]		.   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [line: 18]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 18]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 18]
.   .   .   .   Sibling: 3  While [line: 19]								.   .   .   .   Sibling: 3  While [line: 19]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 19]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 19]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 19]		.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 19]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 19]
.   .   .   .   .   .   Child: 1  If [line: 20]								.   .   .   .   .   .   Child: 1  If [line: 20]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 20]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 20]
.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 20]					.   .   .   .   .   .   .   .   Child: 0  Op: % of type int [line: 20]
.   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 20]				.   .   .   .   .   .   .   .   .   Child: 0  Op: / of type int [line: 20]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 20]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 20]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 20]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 20]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 20]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 20]
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 20]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 20]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 20]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 20]
.   .   .   .   .   .   .   .   Child: 1  While [line: 21]						.   .   .   .   .   .   .   .   Child: 1  While [line: 21]
.   .   .   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 21]				.   .   .   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 21]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 size: 1	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 size: 1
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 21]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 21]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 21]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 21]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 22]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 22]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 23]		   |	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc: -7 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 23]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: cc of type int [mem: Local loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 23]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 23]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 23]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: c of type int [mem: Local 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   .   .   .   .   .   Sibling: 1  If [line: 25]						.   .   .   .   .   .   .   .   Sibling: 1  If [line: 25]
.   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 25]			   |	.   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 25]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 25]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 25]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: bb of type int [mem: Local loc: -5 siz
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: cc of type int [mem: Local loc: -7 size: 1	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: cc of type int [mem: Local loc: -7 size: 1
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 25]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 25]
.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 26]			.   .   .   .   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 26]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 27]		.   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: output of type void [line: 27]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 28]		.   .   .   .   .   .   .   .   .   .   Sibling: 2  Call: output of type void [line: 28]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -6 size
.   .   .   .   .   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 29]			.   .   .   .   .   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 29]
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 32]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 32]
.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 32]		.   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 32]
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 32]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 32]
.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 32]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 32]
.   .   .   .   .   .   Sibling: 2  Assign: = of type int [line: 33]				   |	.   .   .   .   .   .   Sibling: 2  Assign: := of type int [line: 33]
.   .   .   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [line: 33]	.   .   .   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [line: 33]
.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 33]					.   .   .   .   .   .   .   Child: 1  Op: - of type int [line: 33]
.   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 33]					.   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 33]
.   .   .   .   .   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [l	.   .   .   .   .   .   .   .   .   Child: 0  Id: bb of type int [mem: Local loc: -5 size: 1] [l
.   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 33]				.   .   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 33]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 33]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 33]
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1]
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 33]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 33]
.   .   .   .   Sibling: 4  Assign: = of type int [line: 35]					   |	.   .   .   .   Sibling: 4  Assign: := of type int [line: 35]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 35]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 35]
.   .   .   .   .   Child: 1  Op: + of type int [line: 35]						.   .   .   .   .   Child: 1  Op: + of type int [line: 35]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 35]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 35]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 35]
.   .   .   .   Sibling: 5  Assign: = of type int [line: 36]					   |	.   .   .   .   Sibling: 5  Assign: := of type int [line: 36]
.   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 36]		.   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 36]
.   .   .   .   .   Child: 1  Op: - of type int [line: 36]						.   .   .   .   .   Child: 1  Op: - of type int [line: 36]
.   .   .   .   .   .   Child: 0  Op: + of type int [line: 36]						.   .   .   .   .   .   Child: 0  Op: + of type int [line: 36]
.   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 36]	.   .   .   .   .   .   .   Child: 0  Id: aa of type int [mem: Local loc: -4 size: 1] [line: 36]
.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 36]					.   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 36]
.   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 36]				.   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 36]
.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 36]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
righttri.out ztmp23114.txt differ: byte 1, line 1
righttri (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/righttri.tm
Number of errors: 0										   |	4 3 5
------------------------------------								   |	8 6 10
Loading file: righttri.tm									   |	12 5 13
												   >	12 9 15
												   >	15 8 17
												   >	16 12 20
												   >	20 15 25
												   >	21 20 29
												   >	24 7 25
												   >	24 10 26
												   >	24 18 30
												   >	28 21 35
												   >	30 16 34
												   >	32 24 40
												   >	35 12 37
												   >	36 15 39
												   >	36 27 45
Bye.													Bye.
====================================
FILE: scope2.c-
-rw-------. 1 corg7983 domain_users   638 Nov 17 15:35 scope2.c-
-rw-------. 1 corg7983 domain_users   652 Nov 17 15:35 scope2.c-.f21
-rw-------. 1 corg7983 domain_users   638 Nov 17 15:35 scope2.c-.f22
-rw-------. 1 corg7983 domain_users   100 Nov 17 15:35 scope2.expected
-rw-------. 1 corg7983 domain_users  6799 Nov 22 12:27 scope2.mem
-rw-------. 1 corg7983 domain_users  1726 Nov 17 15:35 scope2.mem.diffs
-rw-------. 1 corg7983 domain_users  7654 Nov 17 15:35 scope2.mem.f21
-rw-------. 1 corg7983 domain_users   108 Nov 22 12:27 scope2.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 scope2.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 scope2.tm.diffs
-rw-------. 1 corg7983 domain_users 14216 Nov 17 15:35 scope2.tm.f21
TM CODE COMPARISON
scope2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  scope2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION ant
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,111(6)	Load integer constant 
												   >	 41:     ST  3,-4(1)	Store variable b
												   >	* EXPRESSION
												   >	 42:    LDC  3,222(6)	Load integer constant 
												   >	 43:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 44:    LDC  3,333(6)	Load integer constant 
												   >	 45:     ST  3,0(0)	Store variable g
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 46:    LDC  3,444(6)	Load integer constant 
												   >	 47:     ST  3,-3(1)	Store variable a
												   >	* EXPRESSION
												   >	 48:    LDC  3,555(6)	Load integer constant 
												   >	 49:     ST  3,-6(1)	Store variable b
												   >	* EXPRESSION
												   >	 50:    LDC  3,666(6)	Load integer constant 
												   >	 51:     ST  3,-5(1)	Store variable c
												   >	* EXPRESSION
												   >	 52:    LDC  3,777(6)	Load integer constant 
												   >	 53:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	 54:    LDC  3,888(6)	Load integer constant 
												   >	 55:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 56:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 57:     LD  3,-3(1)	Load variable a
												   >	 58:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 59:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 60:    LDA  3,1(7)	Return address in ac 
												   >	 61:    JMP  7,-56(7)	CALL output
												   >	 62:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	 63:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 64:     LD  3,-6(1)	Load variable b
												   >	 65:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 66:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-63(7)	CALL output
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	 70:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 71:     LD  3,-5(1)	Load variable c
												   >	 72:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 73:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 74:    LDA  3,1(7)	Return address in ac 
												   >	 75:    JMP  7,-70(7)	CALL output
												   >	 76:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	 77:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 78:     LD  3,0(0)	Load variable g
												   >	 79:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 80:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-77(7)	CALL output
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL output
												   >	 84:     ST  1,-7(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param 1
												   >	 85:     LD  3,-2(1)	Load variable x
												   >	 86:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end output
												   >	 87:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-84(7)	CALL output
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -7
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 91:     ST  1,-7(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end outnl
												   >	 92:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	 93:    LDA  3,1(7)	Return address in ac 
												   >	 94:    JMP  7,-61(7)	CALL outnl
												   >	 95:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -7
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	 96:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 97:     LD  3,-3(1)	Load variable a
												   >	 98:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	 99:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-96(7)	CALL output
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	103:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	104:     LD  3,-4(1)	Load variable b
												   >	105:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	106:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	107:    LDA  3,1(7)	Return address in ac 
												   >	108:    JMP  7,-103(7)	CALL output
												   >	109:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	110:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	111:     LD  3,0(0)	Load variable g
												   >	112:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	113:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-110(7)	CALL output
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	117:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	118:     LD  3,-2(1)	Load variable x
												   >	119:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	120:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	121:    LDA  3,1(7)	Return address in ac 
												   >	122:    JMP  7,-117(7)	CALL output
												   >	123:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	124:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	125:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	126:    LDA  3,1(7)	Return address in ac 
												   >	127:    JMP  7,-94(7)	CALL outnl
												   >	128:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	129:    LDC  3,11(6)	Load integer constant 
												   >	130:     ST  3,-3(1)	Store variable a
												   >	* EXPRESSION
												   >	131:    LDC  3,12(6)	Load integer constant 
												   >	132:     ST  3,-4(1)	Store variable b
												   >	* EXPRESSION
												   >	133:    LDC  3,14(6)	Load integer constant 
												   >	134:     ST  3,-2(1)	Store variable x
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	135:    LDC  3,15(6)	Load integer constant 
												   >	136:     ST  3,-2(1)	Store variable x
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	137:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	138:     LD  3,-3(1)	Load variable a
												   >	139:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	140:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	141:    LDA  3,1(7)	Return address in ac 
												   >	142:    JMP  7,-137(7)	CALL output
												   >	143:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	144:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	145:     LD  3,-4(1)	Load variable b
												   >	146:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	147:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	148:    LDA  3,1(7)	Return address in ac 
												   >	149:    JMP  7,-144(7)	CALL output
												   >	150:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	151:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	152:     LD  3,0(0)	Load variable g
												   >	153:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	154:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	155:    LDA  3,1(7)	Return address in ac 
												   >	156:    JMP  7,-151(7)	CALL output
												   >	157:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL output
												   >	158:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	159:     LD  3,-2(1)	Load variable x
												   >	160:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	161:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	162:    LDA  3,1(7)	Return address in ac 
												   >	163:    JMP  7,-158(7)	CALL output
												   >	164:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	165:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	166:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	167:    LDA  3,1(7)	Return address in ac 
												   >	168:    JMP  7,-135(7)	CALL outnl
												   >	169:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* RETURN
												   >	170:     LD  3,-3(1)	Load variable a
												   >	171:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	172:     LD  3,-4(1)	Load variable b
												   >	* TOFF inc: -5
												   >	173:     LD  4,-5(1)	Pop left into ac1 
												   >	174:    ADD  3,4,3	Op + 
												   >	175:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	176:     LD  3,0(0)	Load variable g
												   >	* TOFF inc: -5
												   >	177:     LD  4,-5(1)	Pop left into ac1 
												   >	178:    ADD  3,4,3	Op + 
												   >	179:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	180:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -5
												   >	181:     LD  4,-5(1)	Pop left into ac1 
												   >	182:    ADD  3,4,3	Op + 
												   >	183:    LDA  2,0(3)	Copy result to return register 
												   >	184:     LD  3,-1(1)	Load return address 
												   >	185:     LD  1,0(1)	Adjust fp 
												   >	186:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	187:    LDC  2,0(6)	Set return value to 0 
												   >	188:     LD  3,-1(1)	Load return address 
												   >	189:     LD  1,0(1)	Adjust fp 
												   >	190:    JMP  7,0(3)	Return 
												   >	* END FUNCTION ant
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	191:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	192:    LDC  3,16(6)	Load integer constant 
												   >	193:     ST  3,-2(1)	Store variable a
												   >	* EXPRESSION
												   >	194:    LDC  3,1(6)	Load integer constant 
												   >	195:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	* CALL output
												   >	196:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL ant
												   >	197:     ST  1,-5(1)	Store fp in ghost frame for ant
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	198:    LDC  3,2(6)	Load integer constant 
												   >	199:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end ant
												   >	200:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	201:    LDA  3,1(7)	Return address in ac 
												   >	202:    JMP  7,-164(7)	CALL ant
												   >	203:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end ant
												   >	* TOFF set: -5
												   >	204:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	205:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	206:    LDA  3,1(7)	Return address in ac 
												   >	207:    JMP  7,-202(7)	CALL output
												   >	208:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	209:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	210:     LD  3,0(0)	Load variable g
												   >	211:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	212:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	213:    LDA  3,1(7)	Return address in ac 
												   >	214:    JMP  7,-209(7)	CALL output
												   >	215:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	216:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	217:     LD  3,-2(1)	Load variable a
												   >	218:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	219:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	220:    LDA  3,1(7)	Return address in ac 
												   >	221:    JMP  7,-216(7)	CALL output
												   >	222:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	223:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	224:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	225:    LDA  3,1(7)	Return address in ac 
												   >	226:    JMP  7,-193(7)	CALL outnl
												   >	227:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	228:    LDC  2,0(6)	Set return value to 0 
												   >	229:     LD  3,-1(1)	Load return address 
												   >	230:     LD  1,0(1)	Adjust fp 
												   >	231:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,231(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	232:    LDA  1,-1(0)	set first frame at end of globals 
												   >	233:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	234:    LDA  3,1(7)	Return address in ac 
												   >	235:    JMP  7,-45(7)	Jump to main 
												   >	236:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
scope2.mem scope2.mem.f21 differ: byte 1, line 1
scope2 (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: ant returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: ant returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 3]
.   .   Child: 0  Var: a of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Child: 0  Var: a of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -4 size: 1] [line: 5]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -4 size: 1] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 6]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 6]
.   .   .   Child: 1  Const 111 of type int [line: 6]							.   .   .   Child: 1  Const 111 of type int [line: 6]
.   .   Sibling: 1  Assign: = of type int [line: 7]						   |	.   .   Sibling: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   Child: 1  Const 222 of type int [line: 7]							.   .   .   Child: 1  Const 222 of type int [line: 7]
.   .   Sibling: 2  Assign: = of type int [line: 8]						   |	.   .   Sibling: 2  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 8]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 8]
.   .   .   Child: 1  Const 333 of type int [line: 8]							.   .   .   Child: 1  Const 333 of type int [line: 8]
.   .   Sibling: 3  Compound [mem: None loc: 0 size: -7] [line: 9]					.   .   Sibling: 3  Compound [mem: None loc: 0 size: -7] [line: 9]
.   .   .   Child: 0  Var: c of type int [mem: Local loc: -5 size: 1] [line: 10]			.   .   .   Child: 0  Var: c of type int [mem: Local loc: -5 size: 1] [line: 10]
.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 11]			.   .   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 11]
.   .   .   Child: 1  Assign: = of type int [line: 12]						   |	.   .   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   .   Child: 1  Const 444 of type int [line: 12]						.   .   .   .   Child: 1  Const 444 of type int [line: 12]
.   .   .   Sibling: 1  Assign: = of type int [line: 13]					   |	.   .   .   Sibling: 1  Assign: := of type int [line: 13]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 13]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 13]
.   .   .   .   Child: 1  Const 555 of type int [line: 13]						.   .   .   .   Child: 1  Const 555 of type int [line: 13]
.   .   .   Sibling: 2  Assign: = of type int [line: 14]					   |	.   .   .   Sibling: 2  Assign: := of type int [line: 14]
.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -5 size: 1] [line: 14]			.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -5 size: 1] [line: 14]
.   .   .   .   Child: 1  Const 666 of type int [line: 14]						.   .   .   .   Child: 1  Const 666 of type int [line: 14]
.   .   .   Sibling: 3  Assign: = of type int [line: 15]					   |	.   .   .   Sibling: 3  Assign: := of type int [line: 15]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 777 of type int [line: 15]						.   .   .   .   Child: 1  Const 777 of type int [line: 15]
.   .   .   Sibling: 4  Assign: = of type int [line: 16]					   |	.   .   .   Sibling: 4  Assign: := of type int [line: 16]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]
.   .   .   .   Child: 1  Const 888 of type int [line: 16]						.   .   .   .   Child: 1  Const 888 of type int [line: 16]
.   .   .   Sibling: 5  Call: output of type void [line: 17]						.   .   .   Sibling: 5  Call: output of type void [line: 17]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 17]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   Sibling: 6  Call: output of type void [line: 18]						.   .   .   Sibling: 6  Call: output of type void [line: 18]
.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 18]			.   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 18]
.   .   .   Sibling: 7  Call: output of type void [line: 19]						.   .   .   Sibling: 7  Call: output of type void [line: 19]
.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -5 size: 1] [line: 19]			.   .   .   .   Child: 0  Id: c of type int [mem: Local loc: -5 size: 1] [line: 19]
.   .   .   Sibling: 8  Call: output of type void [line: 20]						.   .   .   Sibling: 8  Call: output of type void [line: 20]
.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]			.   .   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 20]
.   .   .   Sibling: 9  Call: output of type void [line: 21]						.   .   .   Sibling: 9  Call: output of type void [line: 21]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 21]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 21]
.   .   .   Sibling: 10  Call: outnl of type void [line: 22]						.   .   .   Sibling: 10  Call: outnl of type void [line: 22]
.   .   Sibling: 4  Call: output of type void [line: 24]						.   .   Sibling: 4  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 24]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   Sibling: 5  Call: output of type void [line: 25]						.   .   Sibling: 5  Call: output of type void [line: 25]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 25]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 25]
.   .   Sibling: 6  Call: output of type void [line: 26]						.   .   Sibling: 6  Call: output of type void [line: 26]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 26]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 26]
.   .   Sibling: 7  Call: output of type void [line: 27]						.   .   Sibling: 7  Call: output of type void [line: 27]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 27]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 27]
.   .   Sibling: 8  Call: outnl of type void [line: 28]							.   .   Sibling: 8  Call: outnl of type void [line: 28]
.   .   Sibling: 9  Assign: = of type int [line: 29]						   |	.   .   Sibling: 9  Assign: := of type int [line: 29]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 29]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 29]
.   .   .   Child: 1  Const 11 of type int [line: 29]							.   .   .   Child: 1  Const 11 of type int [line: 29]
.   .   Sibling: 10  Assign: = of type int [line: 30]						   |	.   .   Sibling: 10  Assign: := of type int [line: 30]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 30]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 30]
.   .   .   Child: 1  Const 12 of type int [line: 30]							.   .   .   Child: 1  Const 12 of type int [line: 30]
.   .   Sibling: 11  Assign: = of type int [line: 31]						   |	.   .   Sibling: 11  Assign: := of type int [line: 31]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 31]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 31]
.   .   .   Child: 1  Const 14 of type int [line: 31]							.   .   .   Child: 1  Const 14 of type int [line: 31]
.   .   Sibling: 12  Compound [mem: None loc: 0 size: -5] [line: 32]					.   .   Sibling: 12  Compound [mem: None loc: 0 size: -5] [line: 32]
.   .   .   Child: 1  Assign: = of type int [line: 33]						   |	.   .   .   Child: 1  Assign: := of type int [line: 33]
.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 33]			.   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 33]
.   .   .   .   Child: 1  Const 15 of type int [line: 33]						.   .   .   .   Child: 1  Const 15 of type int [line: 33]
.   .   Sibling: 13  Call: output of type void [line: 35]						.   .   Sibling: 13  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 35]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 35]
.   .   Sibling: 14  Call: output of type void [line: 36]						.   .   Sibling: 14  Call: output of type void [line: 36]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 36]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -4 size: 1] [line: 36]
.   .   Sibling: 15  Call: output of type void [line: 37]						.   .   Sibling: 15  Call: output of type void [line: 37]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 37]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 37]
.   .   Sibling: 16  Call: output of type void [line: 38]						.   .   Sibling: 16  Call: output of type void [line: 38]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 38]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 38]
.   .   Sibling: 17  Call: outnl of type void [line: 39]						.   .   Sibling: 17  Call: outnl of type void [line: 39]
.   .   Sibling: 18  Return [line: 41]									.   .   Sibling: 18  Return [line: 41]
.   .   .   Child: 0  Op: + of type int [line: 41]							.   .   .   Child: 0  Op: + of type int [line: 41]
.   .   .   .   Child: 0  Op: + of type int [line: 41]							.   .   .   .   Child: 0  Op: + of type int [line: 41]
.   .   .   .   .   Child: 0  Op: + of type int [line: 41]						.   .   .   .   .   Child: 0  Op: + of type int [line: 41]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 41]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -3 size: 1] [line: 41]
.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -4 size: 1] [line: 41]		.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -4 size: 1] [line: 41]
.   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 41]			.   .   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 41]
.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 41]			.   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 41]
Sibling: 2  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 44]		   |	Sibling: 9  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 44]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 45]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 45]
.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 46]				.   .   Child: 0  Var: a of type int [mem: Local loc: -2 size: 1] [line: 46]
.   .   Child: 1  Assign: = of type int [line: 47]						   |	.   .   Child: 1  Assign: := of type int [line: 47]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 47]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 47]
.   .   .   Child: 1  Const 16 of type int [line: 47]							.   .   .   Child: 1  Const 16 of type int [line: 47]
.   .   Sibling: 1  Assign: = of type int [line: 48]						   |	.   .   Sibling: 1  Assign: := of type int [line: 48]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 48]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 48]
.   .   .   Child: 1  Const 1 of type int [line: 48]							.   .   .   Child: 1  Const 1 of type int [line: 48]
.   .   Sibling: 2  Call: output of type void [line: 49]						.   .   Sibling: 2  Call: output of type void [line: 49]
.   .   .   Child: 0  Call: ant of type int [line: 49]							.   .   .   Child: 0  Call: ant of type int [line: 49]
.   .   .   .   Child: 0  Const 2 of type int [line: 49]						.   .   .   .   Child: 0  Const 2 of type int [line: 49]
.   .   Sibling: 3  Call: output of type void [line: 50]						.   .   Sibling: 3  Call: output of type void [line: 50]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 50]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 50]
.   .   Sibling: 4  Call: output of type void [line: 51]						.   .   Sibling: 4  Call: output of type void [line: 51]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 51]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -2 size: 1] [line: 51]
.   .   Sibling: 5  Call: outnl of type void [line: 52]							.   .   Sibling: 5  Call: outnl of type void [line: 52]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
scope2.out ztmp23114.txt differ: byte 1, line 1
scope2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/scope2.tm
Number of errors: 0										   |	444 555 666 777 888
------------------------------------								   |	444 111 777 888
Loading file: scope2.tm										   |	11 12 777 15
												   >	815 777 16
Bye.													Bye.
====================================
FILE: sieve.c-
-rw-------. 1 corg7983 domain_users  418 Nov 17 15:35 sieve.c-
-rw-------. 1 corg7983 domain_users  430 Nov 17 15:35 sieve.c-.f21
-rw-------. 1 corg7983 domain_users  418 Nov 17 15:35 sieve.c-.f22
-rw-------. 1 corg7983 domain_users  194 Nov 17 15:35 sieve.expected
-rw-------. 1 corg7983 domain_users   17 Nov 17 15:35 sieve.in
-rw-------. 1 corg7983 domain_users 7329 Nov 22 12:27 sieve.mem
-rw-------. 1 corg7983 domain_users 1604 Nov 17 15:35 sieve.mem.diffs
-rw-------. 1 corg7983 domain_users 8182 Nov 17 15:35 sieve.mem.f21
-rw-------. 1 corg7983 domain_users  107 Nov 22 12:27 sieve.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 sieve.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 sieve.tm.diffs
-rw-------. 1 corg7983 domain_users 9897 Nov 17 15:35 sieve.tm.f21
TM CODE COMPARISON
sieve (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  sieve.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -206
												   >	 40:    LDC  3,201(6)	load size of array n
												   >	 41:     ST  3,-4(1)	save size of array n
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 42:    LDC  3,200(6)	Load integer constant 
												   >	 43:     ST  3,-2(1)	Store variable max
												   >	* EXPRESSION
												   >	 44:    LDC  3,2(6)	Load integer constant 
												   >	 45:     ST  3,-3(1)	Store variable k
												   >	* WHILE
												   >	 46:     LD  3,-3(1)	Load variable k
												   >	 47:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	 48:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -206
												   >	 49:     LD  4,-206(1)	Pop left into ac1 
												   >	 50:    TLE  3,4,3	Op <= 
												   >	 51:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -206
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 53:     LD  3,-3(1)	Load variable k
												   >	 54:     ST  3,-206(1)	Push index 
												   >	* TOFF dec: -207
												   >	 55:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -206
												   >	 56:     LD  4,-206(1)	Pop index 
												   >	 57:    LDA  5,-5(1)	Load address of base of array n
												   >	 58:    SUB  5,5,4	Compute offset of value 
												   >	 59:     ST  3,0(5)	Store variable n
												   >	* EXPRESSION
												   >	 60:     LD  3,-3(1)	Load variable k
												   >	 61:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	 62:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -206
												   >	 63:     LD  4,-206(1)	Pop left into ac1 
												   >	 64:    ADD  3,4,3	Op + 
												   >	 65:     ST  3,-3(1)	Store variable k
												   >	* TOFF set: -206
												   >	* END COMPOUND
												   >	 66:    JMP  7,-21(7)	go to beginning of loop 
												   >	 52:    JMP  7,14(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	 67:    LDC  3,2(6)	Load integer constant 
												   >	 68:     ST  3,-3(1)	Store variable k
												   >	* WHILE
												   >	 69:     LD  3,-3(1)	Load variable k
												   >	 70:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	 71:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -206
												   >	 72:     LD  4,-206(1)	Pop left into ac1 
												   >	 73:    MUL  3,4,3	Op * 
												   >	 74:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	 75:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -206
												   >	 76:     LD  4,-206(1)	Pop left into ac1 
												   >	 77:    TLE  3,4,3	Op <= 
												   >	 78:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -207
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 80:     LD  3,-3(1)	Load variable k
												   >	 81:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	 82:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -207
												   >	 83:     LD  4,-207(1)	Pop left into ac1 
												   >	 84:    MUL  3,4,3	Op * 
												   >	 85:     ST  3,-206(1)	Store variable j
												   >	* WHILE
												   >	 86:     LD  3,-206(1)	Load variable j
												   >	 87:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	 88:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -207
												   >	 89:     LD  4,-207(1)	Pop left into ac1 
												   >	 90:    TLE  3,4,3	Op <= 
												   >	 91:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -207
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 93:     LD  3,-206(1)	Load variable j
												   >	 94:     ST  3,-207(1)	Push index 
												   >	* TOFF dec: -208
												   >	 95:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -207
												   >	 96:     LD  4,-207(1)	Pop index 
												   >	 97:    LDA  5,-5(1)	Load address of base of array n
												   >	 98:    SUB  5,5,4	Compute offset of value 
												   >	 99:     ST  3,0(5)	Store variable n
												   >	* EXPRESSION
												   >	100:     LD  3,-206(1)	Load variable j
												   >	101:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	102:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -207
												   >	103:     LD  4,-207(1)	Pop left into ac1 
												   >	104:    ADD  3,4,3	Op + 
												   >	105:     ST  3,-206(1)	Store variable j
												   >	* TOFF set: -207
												   >	* END COMPOUND
												   >	106:    JMP  7,-21(7)	go to beginning of loop 
												   >	 92:    JMP  7,14(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	107:     LD  3,-3(1)	Load variable k
												   >	108:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	109:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -207
												   >	110:     LD  4,-207(1)	Pop left into ac1 
												   >	111:    ADD  3,4,3	Op + 
												   >	112:     ST  3,-3(1)	Store variable k
												   >	* WHILE
												   >	113:     LD  3,-3(1)	Load variable k
												   >	114:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	115:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -207
												   >	116:     LD  4,-207(1)	Pop left into ac1 
												   >	117:    TLE  3,4,3	Op <= 
												   >	118:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	119:    LDA  3,-5(1)	Load address of base of array n
												   >	120:     ST  3,-208(1)	Push left side 
												   >	* TOFF dec: -209
												   >	121:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -208
												   >	122:     LD  4,-208(1)	Pop left into ac1 
												   >	123:    SUB  3,4,3	compute location from index 
												   >	124:     LD  3,0(3)	Load array element 
												   >	125:    LDC  4,1(6)	Load 1 
												   >	126:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -207
												   >	127:     LD  4,-207(1)	Pop left into ac1 
												   >	128:    AND  3,4,3	Op AND 
												   >	129:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* EXPRESSION
												   >	131:     LD  3,-3(1)	Load variable k
												   >	132:     ST  3,-207(1)	Push left side 
												   >	* TOFF dec: -208
												   >	133:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -207
												   >	134:     LD  4,-207(1)	Pop left into ac1 
												   >	135:    ADD  3,4,3	Op + 
												   >	136:     ST  3,-3(1)	Store variable k
												   >	137:    JMP  7,-25(7)	go to beginning of loop 
												   >	130:    JMP  7,7(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -206
												   >	* END COMPOUND
												   >	138:    JMP  7,-70(7)	go to beginning of loop 
												   >	 79:    JMP  7,59(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	139:    LDC  3,2(6)	Load integer constant 
												   >	140:     ST  3,-3(1)	Store variable k
												   >	* WHILE
												   >	141:     LD  3,-3(1)	Load variable k
												   >	142:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	143:     LD  3,-2(1)	Load variable max
												   >	* TOFF inc: -206
												   >	144:     LD  4,-206(1)	Pop left into ac1 
												   >	145:    TLE  3,4,3	Op <= 
												   >	146:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -206
												   >	* Compound Body
												   >	* IF
												   >	148:    LDA  3,-5(1)	Load address of base of array n
												   >	149:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	150:     LD  3,-3(1)	Load variable k
												   >	* TOFF inc: -206
												   >	151:     LD  4,-206(1)	Pop left into ac1 
												   >	152:    SUB  3,4,3	compute location from index 
												   >	153:     LD  3,0(3)	Load array element 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -206
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	155:     ST  1,-206(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -207
												   >	* TOFF dec: -208
												   >	* Param 1
												   >	156:     LD  3,-3(1)	Load variable k
												   >	157:     ST  3,-208(1)	Push parameter 
												   >	* TOFF dec: -209
												   >	* Param end output
												   >	158:    LDA  1,-206(1)	Ghost frame becomes new active frame 
												   >	159:    LDA  3,1(7)	Return address in ac 
												   >	160:    JMP  7,-155(7)	CALL output
												   >	161:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -206
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	162:     ST  1,-206(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -207
												   >	* TOFF dec: -208
												   >	* Param end outnl
												   >	163:    LDA  1,-206(1)	Ghost frame becomes new active frame 
												   >	164:    LDA  3,1(7)	Return address in ac 
												   >	165:    JMP  7,-132(7)	CALL outnl
												   >	166:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -206
												   >	* TOFF set: -206
												   >	* END COMPOUND
												   >	154:    JZR  3,12(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	167:     LD  3,-3(1)	Load variable k
												   >	168:     ST  3,-206(1)	Push left side 
												   >	* TOFF dec: -207
												   >	169:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -206
												   >	170:     LD  4,-206(1)	Pop left into ac1 
												   >	171:    ADD  3,4,3	Op + 
												   >	172:     ST  3,-3(1)	Store variable k
												   >	* TOFF set: -206
												   >	* END COMPOUND
												   >	173:    JMP  7,-33(7)	go to beginning of loop 
												   >	147:    JMP  7,26(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	174:    LDC  3,0(6)	Load integer constant 
												   >	175:    LDA  2,0(3)	Copy result to return register 
												   >	176:     LD  3,-1(1)	Load return address 
												   >	177:     LD  1,0(1)	Adjust fp 
												   >	178:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	179:    LDC  2,0(6)	Set return value to 0 
												   >	180:     LD  3,-1(1)	Load return address 
												   >	181:     LD  1,0(1)	Adjust fp 
												   >	182:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,182(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	183:    LDA  1,0(0)	set first frame at end of globals 
												   >	184:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	185:    LDA  3,1(7)	Return address in ac 
												   >	186:    JMP  7,-148(7)	Jump to main 
												   >	187:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
sieve.mem sieve.mem.f21 differ: byte 7, line 1
sieve (MEM DIFF)
Func: main returns type int [mem: Global loc: 0 size: -2] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 4]
.   .   Child: 0  Var: max of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   Child: 0  Var: max of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Var: k of type int [mem: Local loc: -3 size: 1] [line: 5]				.   .   Sibling: 1  Var: k of type int [mem: Local loc: -3 size: 1] [line: 5]
.   .   Sibling: 2  Var: n of array of type bool [mem: Local loc: -5 size: 202] [line: 6]		.   .   Sibling: 2  Var: n of array of type bool [mem: Local loc: -5 size: 202] [line: 6]
.   .   Child: 1  Assign: = of type int [line: 8]						   |	.   .   Child: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: max of type int [mem: Local loc: -2 size: 1] [line: 8]			.   .   .   Child: 0  Id: max of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   .   Child: 1  Const 200 of type int [line: 8]							.   .   .   Child: 1  Const 200 of type int [line: 8]
.   .   Sibling: 1  Assign: = of type int [line: 10]						   |	.   .   Sibling: 1  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 10]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   .   Child: 1  Const 2 of type int [line: 10]							.   .   .   Child: 1  Const 2 of type int [line: 10]
.   .   Sibling: 2  While [line: 11]									.   .   Sibling: 2  While [line: 11]
.   .   .   Child: 0  Op: <= of type bool [line: 11]							.   .   .   Child: 0  Op: <= of type bool [line: 11]
.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 11]			.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 11]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 11]
.   .   .   .   Child: 1  Assign: = of type bool [line: 11]					   |	.   .   .   .   Child: 1  Assign: := of type bool [line: 11]
.   .   .   .   .   Child: 0  Op: [ of type bool [line: 11]						.   .   .   .   .   Child: 0  Op: [ of type bool [line: 11]
.   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 202] [li	.   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 202] [li
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Const true of type bool [line: 11]					.   .   .   .   .   Child: 1  Const true of type bool [line: 11]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 11]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 11]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Op: + of type int [line: 11]						.   .   .   .   .   Child: 1  Op: + of type int [line: 11]
.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 11]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 11]
.   .   Sibling: 3  Assign: = of type int [line: 13]						   |	.   .   Sibling: 3  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 13]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 13]
.   .   .   Child: 1  Const 2 of type int [line: 13]							.   .   .   Child: 1  Const 2 of type int [line: 13]
.   .   Sibling: 4  While [line: 14]									.   .   Sibling: 4  While [line: 14]
.   .   .   Child: 0  Op: <= of type bool [line: 14]							.   .   .   Child: 0  Op: <= of type bool [line: 14]
.   .   .   .   Child: 0  Op: * of type int [line: 14]							.   .   .   .   Child: 0  Op: * of type int [line: 14]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 14]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 14]			.   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 14]			.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 14]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -207] [line: 14]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -207] [line: 14]
.   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -206 size: 1] [line: 15]			.   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -206 size: 1] [line: 15]
.   .   .   .   Child: 1  Assign: = of type int [line: 17]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 17]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 17]
.   .   .   .   .   Child: 1  Op: * of type int [line: 17]						.   .   .   .   .   Child: 1  Op: * of type int [line: 17]
.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   Sibling: 1  While [line: 18]								.   .   .   .   Sibling: 1  While [line: 18]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 18]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 18]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 18]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 18]
.   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 18]		.   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -207] [line: 18]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -207] [line: 18]
.   .   .   .   .   .   Child: 1  Assign: = of type bool [line: 19]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type bool [line: 19]
.   .   .   .   .   .   .   Child: 0  Op: [ of type bool [line: 19]					.   .   .   .   .   .   .   Child: 0  Op: [ of type bool [line: 19]
.   .   .   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 	.   .   .   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 
.   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -206 size: 1] [line	.   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -206 size: 1] [line
.   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 19]				.   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 19]
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 20]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 20]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 20	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line: 20
.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 20]					.   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 20]
.   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line	.   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -206 size: 1] [line
.   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   Sibling: 2  Assign: = of type int [line: 22]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 22]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 22]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   .   .   .   Child: 1  Op: + of type int [line: 22]						.   .   .   .   .   Child: 1  Op: + of type int [line: 22]
.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 22]		.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 22]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 22]
.   .   .   .   Sibling: 3  While [line: 23]								.   .   .   .   Sibling: 3  While [line: 23]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 23]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 23]
.   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 23]					.   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]		.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 23	.   .   .   .   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 23
.   .   .   .   .   .   Child: 1  Op: not of type bool [line: 23]					.   .   .   .   .   .   Child: 1  Op: not of type bool [line: 23]
.   .   .   .   .   .   .   Child: 0  Op: [ of type bool [line: 23]					.   .   .   .   .   .   .   Child: 0  Op: [ of type bool [line: 23]
.   .   .   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 	.   .   .   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 
.   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   Child: 1  Assign: = of type int [line: 23]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 23]
.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]		.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   .   .   Child: 1  Op: + of type int [line: 23]						.   .   .   .   .   .   Child: 1  Op: + of type int [line: 23]
.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]		.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   Sibling: 5  Assign: = of type int [line: 26]						   |	.   .   Sibling: 5  Assign: := of type int [line: 26]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 26]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 26]
.   .   .   Child: 1  Const 2 of type int [line: 26]							.   .   .   Child: 1  Const 2 of type int [line: 26]
.   .   Sibling: 6  While [line: 27]									.   .   Sibling: 6  While [line: 27]
.   .   .   Child: 0  Op: <= of type bool [line: 27]							.   .   .   Child: 0  Op: <= of type bool [line: 27]
.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]			.   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 27]			.   .   .   .   Child: 1  Id: max of type int [mem: Local loc: -2 size: 1] [line: 27]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 27]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 27]
.   .   .   .   Child: 1  If [line: 27]									.   .   .   .   Child: 1  If [line: 27]
.   .   .   .   .   Child: 0  Op: [ of type bool [line: 27]						.   .   .   .   .   Child: 0  Op: [ of type bool [line: 27]
.   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 202] [li	.   .   .   .   .   .   Child: 0  Id: n of array of type bool [mem: Local loc: -5 size: 202] [li
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 27]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -206] [line: 27]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 27]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 27]
.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]		.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 27]					.   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 27]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 27]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 27]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   .   .   .   Child: 1  Op: + of type int [line: 27]						.   .   .   .   .   Child: 1  Op: + of type int [line: 27]
.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]		.   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -3 size: 1] [line: 27]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 27]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 27]
.   .   Sibling: 7  Return [line: 29]									.   .   Sibling: 7  Return [line: 29]
.   .   .   Child: 0  Const 0 of type int [line: 29]							.   .   .   Child: 0  Const 0 of type int [line: 29]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
sieve.out ztmp23114.txt differ: byte 1, line 1
sieve (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/sieve.tm
Number of errors: 0										   |	2
------------------------------------								   |	3
Loading file: sieve.tm										   |	5
												   >	7
												   >	11
												   >	13
												   >	17
												   >	19
												   >	23
												   >	29
												   >	31
												   >	37
												   >	41
												   >	43
												   >	47
												   >	53
												   >	59
												   >	61
												   >	67
												   >	71
												   >	73
												   >	79
												   >	83
												   >	89
												   >	97
												   >	101
												   >	103
												   >	107
												   >	109
												   >	113
												   >	127
												   >	131
												   >	137
												   >	139
												   >	149
												   >	151
												   >	157
												   >	163
												   >	167
												   >	173
												   >	179
												   >	181
												   >	191
												   >	193
												   >	197
												   >	199
Bye.													Bye.
====================================
FILE: sort2.c-
-rw-------. 1 corg7983 domain_users   481 Nov 17 15:35 sort2.c-
-rw-------. 1 corg7983 domain_users   493 Nov 17 15:35 sort2.c-.f21
-rw-------. 1 corg7983 domain_users   481 Nov 17 15:35 sort2.c-.f22
-rw-------. 1 corg7983 domain_users   456 Nov 17 15:35 sort2.expected
-rw-------. 1 corg7983 domain_users    74 Nov 17 15:35 sort2.in
-rw-------. 1 corg7983 domain_users  7176 Nov 22 12:27 sort2.mem
-rw-------. 1 corg7983 domain_users   760 Nov 17 15:35 sort2.mem.diffs
-rw-------. 1 corg7983 domain_users  8025 Nov 17 15:35 sort2.mem.f21
-rw-------. 1 corg7983 domain_users   750 Nov 22 12:27 sort2.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 sort2.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 sort2.tm.diffs
-rw-------. 1 corg7983 domain_users 13373 Nov 17 15:35 sort2.tm.f21
TM CODE COMPARISON
sort2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  sort2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION swap
												   >	* TOFF set: -5
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-2(1)	Load address of base of array a
												   >	 41:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 42:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -6
												   >	 43:     LD  4,-6(1)	Pop left into ac1 
												   >	 44:    SUB  3,4,3	compute location from index 
												   >	 45:     LD  3,0(3)	Load array element 
												   >	 46:     ST  3,-5(1)	Store variable t
												   >	* EXPRESSION
												   >	 47:     LD  3,-3(1)	Load variable i
												   >	 48:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 49:     LD  3,-2(1)	Load address of base of array a
												   >	 50:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	 51:     LD  3,-4(1)	Load variable j
												   >	* TOFF inc: -7
												   >	 52:     LD  4,-7(1)	Pop left into ac1 
												   >	 53:    SUB  3,4,3	compute location from index 
												   >	 54:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -6
												   >	 55:     LD  4,-6(1)	Pop index 
												   >	 56:     LD  5,-2(1)	Load address of base of array a
												   >	 57:    SUB  5,5,4	Compute offset of value 
												   >	 58:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	 59:     LD  3,-4(1)	Load variable j
												   >	 60:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	 61:     LD  3,-5(1)	Load variable t
												   >	* TOFF inc: -6
												   >	 62:     LD  4,-6(1)	Pop index 
												   >	 63:     LD  5,-2(1)	Load address of base of array a
												   >	 64:    SUB  5,5,4	Compute offset of value 
												   >	 65:     ST  3,0(5)	Store variable a
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 66:    LDC  2,0(6)	Set return value to 0 
												   >	 67:     LD  3,-1(1)	Load return address 
												   >	 68:     LD  1,0(1)	Adjust fp 
												   >	 69:    JMP  7,0(3)	Return 
												   >	* END FUNCTION swap
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION sort
												   >	* TOFF set: -3
												   >	 70:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* TOFF set: -6
												   >	* FOR
												   >	 71:    LDC  3,0(6)	Load integer constant 
												   >	 72:     ST  3,-3(1)	save starting value in index variable 
												   >	 73:     LD  3,-2(1)	Load address of base of array a
												   >	 74:     LD  3,1(3)	Load array size 
												   >	 75:     ST  3,-4(1)	save stop value 
												   >	 76:    LDC  3,1(6)	default increment by 1 
												   >	 77:     ST  3,-5(1)	save step value 
												   >	 78:     LD  4,-3(1)	loop index 
												   >	 79:     LD  5,-4(1)	stop value 
												   >	 80:     LD  3,-5(1)	step value 
												   >	 81:    SLT  3,4,5	Op < 
												   >	 82:    JNZ  3,1(7)	Jump to loop body 
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 84:     LD  3,-3(1)	Load variable i
												   >	 85:     ST  3,-6(1)	Store variable minloc
												   >	* TOFF set: -10
												   >	* FOR
												   >	 86:     LD  3,-3(1)	Load variable i
												   >	 87:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	 88:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -10
												   >	 89:     LD  4,-10(1)	Pop left into ac1 
												   >	 90:    ADD  3,4,3	Op + 
												   >	 91:     ST  3,-7(1)	save starting value in index variable 
												   >	 92:     LD  3,-2(1)	Load address of base of array a
												   >	 93:     LD  3,1(3)	Load array size 
												   >	 94:     ST  3,-8(1)	save stop value 
												   >	 95:    LDC  3,1(6)	default increment by 1 
												   >	 96:     ST  3,-9(1)	save step value 
												   >	 97:     LD  4,-7(1)	loop index 
												   >	 98:     LD  5,-8(1)	stop value 
												   >	 99:     LD  3,-9(1)	step value 
												   >	100:    SLT  3,4,5	Op < 
												   >	101:    JNZ  3,1(7)	Jump to loop body 
												   >	* IF
												   >	103:     LD  3,-2(1)	Load address of base of array a
												   >	104:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	105:     LD  3,-7(1)	Load variable j
												   >	* TOFF inc: -10
												   >	106:     LD  4,-10(1)	Pop left into ac1 
												   >	107:    SUB  3,4,3	compute location from index 
												   >	108:     LD  3,0(3)	Load array element 
												   >	109:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	110:     LD  3,-2(1)	Load address of base of array a
												   >	111:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	112:     LD  3,-6(1)	Load variable minloc
												   >	* TOFF inc: -11
												   >	113:     LD  4,-11(1)	Pop left into ac1 
												   >	114:    SUB  3,4,3	compute location from index 
												   >	115:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -10
												   >	116:     LD  4,-10(1)	Pop left into ac1 
												   >	117:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* EXPRESSION
												   >	119:     LD  3,-7(1)	Load variable j
												   >	120:     ST  3,-6(1)	Store variable minloc
												   >	118:    JZR  3,2(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* Bottom of loop increment and jump
												   >	121:     LD  3,-7(1)	Load index 
												   >	122:     LD  5,-9(1)	Load step 
												   >	123:    ADD  3,3,5	increment 
												   >	124:     ST  3,-7(1)	store back to index 
												   >	125:    JMP  7,-29(7)	go to beginning of loop 
												   >	102:    JMP  7,23(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* EXPRESSION
												   >	* CALL swap
												   >	126:     ST  1,-10(1)	Store fp in ghost frame for swap
												   >	* TOFF dec: -11
												   >	* TOFF dec: -12
												   >	* Param 1
												   >	127:     LD  3,-2(1)	Load address of base of array a
												   >	128:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param 2
												   >	129:     LD  3,-3(1)	Load variable i
												   >	130:     ST  3,-13(1)	Push parameter 
												   >	* TOFF dec: -14
												   >	* Param 3
												   >	131:     LD  3,-6(1)	Load variable minloc
												   >	132:     ST  3,-14(1)	Push parameter 
												   >	* TOFF dec: -15
												   >	* Param end swap
												   >	133:    LDA  1,-10(1)	Ghost frame becomes new active frame 
												   >	134:    LDA  3,1(7)	Return address in ac 
												   >	135:    JMP  7,-97(7)	CALL swap
												   >	136:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end swap
												   >	* TOFF set: -10
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	* Bottom of loop increment and jump
												   >	137:     LD  3,-3(1)	Load index 
												   >	138:     LD  5,-5(1)	Load step 
												   >	139:    ADD  3,3,5	increment 
												   >	140:     ST  3,-3(1)	store back to index 
												   >	141:    JMP  7,-64(7)	go to beginning of loop 
												   >	 83:    JMP  7,58(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	142:    LDC  2,0(6)	Set return value to 0 
												   >	143:     LD  3,-1(1)	Load return address 
												   >	144:     LD  1,0(1)	Adjust fp 
												   >	145:    JMP  7,0(3)	Return 
												   >	* END FUNCTION sort
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION print
												   >	* TOFF set: -3
												   >	146:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* TOFF set: -6
												   >	* FOR
												   >	147:    LDC  3,0(6)	Load integer constant 
												   >	148:     ST  3,-3(1)	save starting value in index variable 
												   >	149:     LD  3,-2(1)	Load address of base of array x
												   >	150:     LD  3,1(3)	Load array size 
												   >	151:     ST  3,-4(1)	save stop value 
												   >	152:    LDC  3,1(6)	default increment by 1 
												   >	153:     ST  3,-5(1)	save step value 
												   >	154:     LD  4,-3(1)	loop index 
												   >	155:     LD  5,-4(1)	stop value 
												   >	156:     LD  3,-5(1)	step value 
												   >	157:    SLT  3,4,5	Op < 
												   >	158:    JNZ  3,1(7)	Jump to loop body 
												   >	* EXPRESSION
												   >	* CALL output
												   >	160:     ST  1,-6(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	161:     LD  3,-2(1)	Load address of base of array x
												   >	162:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	163:     LD  3,-3(1)	Load variable i
												   >	* TOFF inc: -8
												   >	164:     LD  4,-8(1)	Pop left into ac1 
												   >	165:    SUB  3,4,3	compute location from index 
												   >	166:     LD  3,0(3)	Load array element 
												   >	167:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end output
												   >	168:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-165(7)	CALL output
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -6
												   >	* Bottom of loop increment and jump
												   >	172:     LD  3,-3(1)	Load index 
												   >	173:     LD  5,-5(1)	Load step 
												   >	174:    ADD  3,3,5	increment 
												   >	175:     ST  3,-3(1)	store back to index 
												   >	176:    JMP  7,-23(7)	go to beginning of loop 
												   >	159:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	177:     ST  1,-6(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end outnl
												   >	178:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	179:    LDA  3,1(7)	Return address in ac 
												   >	180:    JMP  7,-147(7)	CALL outnl
												   >	181:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -6
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	182:    LDC  2,0(6)	Set return value to 0 
												   >	183:     LD  3,-1(1)	Load return address 
												   >	184:     LD  1,0(1)	Adjust fp 
												   >	185:    JMP  7,0(3)	Return 
												   >	* END FUNCTION print
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	186:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -23
												   >	187:    LDC  3,20(6)	load size of array x
												   >	188:     ST  3,-2(1)	save size of array x
												   >	* Compound Body
												   >	* TOFF set: -26
												   >	* FOR
												   >	189:    LDC  3,0(6)	Load integer constant 
												   >	190:     ST  3,-23(1)	save starting value in index variable 
												   >	191:    LDA  3,-3(1)	Load address of base of array x
												   >	192:     LD  3,1(3)	Load array size 
												   >	193:     ST  3,-24(1)	save stop value 
												   >	194:    LDC  3,1(6)	default increment by 1 
												   >	195:     ST  3,-25(1)	save step value 
												   >	196:     LD  4,-23(1)	loop index 
												   >	197:     LD  5,-24(1)	stop value 
												   >	198:     LD  3,-25(1)	step value 
												   >	199:    SLT  3,4,5	Op < 
												   >	200:    JNZ  3,1(7)	Jump to loop body 
												   >	* EXPRESSION
												   >	202:     LD  3,-23(1)	Load variable i
												   >	203:     ST  3,-26(1)	Push index 
												   >	* TOFF dec: -27
												   >	* CALL input
												   >	204:     ST  1,-27(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -28
												   >	* TOFF dec: -29
												   >	* Param end input
												   >	205:    LDA  1,-27(1)	Ghost frame becomes new active frame 
												   >	206:    LDA  3,1(7)	Return address in ac 
												   >	207:    JMP  7,-207(7)	CALL input
												   >	208:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -27
												   >	* TOFF inc: -26
												   >	209:     LD  4,-26(1)	Pop index 
												   >	210:    LDA  5,-3(1)	Load address of base of array x
												   >	211:    SUB  5,5,4	Compute offset of value 
												   >	212:     ST  3,0(5)	Store variable x
												   >	* Bottom of loop increment and jump
												   >	213:     LD  3,-23(1)	Load index 
												   >	214:     LD  5,-25(1)	Load step 
												   >	215:    ADD  3,3,5	increment 
												   >	216:     ST  3,-23(1)	store back to index 
												   >	217:    JMP  7,-22(7)	go to beginning of loop 
												   >	201:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* EXPRESSION
												   >	* CALL print
												   >	218:     ST  1,-26(1)	Store fp in ghost frame for print
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	219:    LDA  3,-3(1)	Load address of base of array x
												   >	220:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end print
												   >	221:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	222:    LDA  3,1(7)	Return address in ac 
												   >	223:    JMP  7,-78(7)	CALL print
												   >	224:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end print
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL sort
												   >	225:     ST  1,-26(1)	Store fp in ghost frame for sort
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	226:    LDA  3,-3(1)	Load address of base of array x
												   >	227:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end sort
												   >	228:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	229:    LDA  3,1(7)	Return address in ac 
												   >	230:    JMP  7,-161(7)	CALL sort
												   >	231:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sort
												   >	* TOFF set: -26
												   >	* EXPRESSION
												   >	* CALL print
												   >	232:     ST  1,-26(1)	Store fp in ghost frame for print
												   >	* TOFF dec: -27
												   >	* TOFF dec: -28
												   >	* Param 1
												   >	233:    LDA  3,-3(1)	Load address of base of array x
												   >	234:     ST  3,-28(1)	Push parameter 
												   >	* TOFF dec: -29
												   >	* Param end print
												   >	235:    LDA  1,-26(1)	Ghost frame becomes new active frame 
												   >	236:    LDA  3,1(7)	Return address in ac 
												   >	237:    JMP  7,-92(7)	CALL print
												   >	238:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end print
												   >	* TOFF set: -26
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	239:    LDC  2,0(6)	Set return value to 0 
												   >	240:     LD  3,-1(1)	Load return address 
												   >	241:     LD  1,0(1)	Adjust fp 
												   >	242:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,242(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	243:    LDA  1,0(0)	set first frame at end of globals 
												   >	244:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	245:    LDA  3,1(7)	Return address in ac 
												   >	246:    JMP  7,-61(7)	Jump to main 
												   >	247:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
sort2.mem sort2.mem.f21 differ: byte 70, line 2
sort2 (MEM DIFF)
WARNING(33): Variable 'x' may be uninitialized when used here.						WARNING(33): Variable 'x' may be uninitialized when used here.
Func: swap returns type void [mem: Global loc: 0 size: -5] [line: 2]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: swap returns type void [mem: Global loc: 0 size: -5] [line: 2]
.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 2]			.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Sibling: 1  Parm: i of type int [mem: Parameter loc: -3 size: 1] [line: 2]				.   Sibling: 1  Parm: i of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   Sibling: 2  Parm: j of type int [mem: Parameter loc: -4 size: 1] [line: 2]				.   Sibling: 2  Parm: j of type int [mem: Parameter loc: -4 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]
.   .   Child: 0  Var: t of type int [mem: Local loc: -5 size: 1] [line: 4]				.   .   Child: 0  Var: t of type int [mem: Local loc: -5 size: 1] [line: 4]
.   .   Child: 1  Assign: = of type int [line: 6]						   |	.   .   Child: 1  Assign: := of type int [line: 6]
.   .   .   Child: 0  Id: t of type int [mem: Local loc: -5 size: 1] [line: 6]				.   .   .   Child: 0  Id: t of type int [mem: Local loc: -5 size: 1] [line: 6]
.   .   .   Child: 1  Op: [ of type int [line: 6]							.   .   .   Child: 1  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 6]			.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   Sibling: 1  Assign: = of type int [line: 7]						   |	.   .   Sibling: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Op: [ of type int [line: 7]							.   .   .   Child: 0  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 7]			.   .   .   .   Child: 1  Id: i of type int [mem: Parameter loc: -3 size: 1] [line: 7]
.   .   .   Child: 1  Op: [ of type int [line: 7]							.   .   .   Child: 1  Op: [ of type int [line: 7]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 7]
.   .   .   .   Child: 1  Id: j of type int [mem: Parameter loc: -4 size: 1] [line: 7]			.   .   .   .   Child: 1  Id: j of type int [mem: Parameter loc: -4 size: 1] [line: 7]
.   .   Sibling: 2  Assign: = of type int [line: 8]						   |	.   .   Sibling: 2  Assign: := of type int [line: 8]
.   .   .   Child: 0  Op: [ of type int [line: 8]							.   .   .   Child: 0  Op: [ of type int [line: 8]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]		.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   .   .   Child: 1  Id: j of type int [mem: Parameter loc: -4 size: 1] [line: 8]			.   .   .   .   Child: 1  Id: j of type int [mem: Parameter loc: -4 size: 1] [line: 8]
.   .   .   Child: 1  Id: t of type int [mem: Local loc: -5 size: 1] [line: 8]				.   .   .   Child: 1  Id: t of type int [mem: Local loc: -5 size: 1] [line: 8]
Sibling: 1  Func: sort returns type void [mem: Global loc: 0 size: -3] [line: 11]		   |	Sibling: 8  Func: sort returns type void [mem: Global loc: 0 size: -3] [line: 11]
.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 11]			.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 11]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 12]
.   .   Child: 1  For [mem: None loc: 0 size: -4] [line: 13]					   |	.   .   Child: 1  For [mem: None loc: 0 size: -6] [line: 13]
.   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 13]			.   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 13]
.   .   .   Child: 1  Range [line: 13]									.   .   .   Child: 1  Range [line: 13]
.   .   .   .   Child: 0  Const 0 of type int [line: 13]						.   .   .   .   Child: 0  Const 0 of type int [line: 13]
.   .   .   .   Child: 1  Op: sizeof of type int [line: 13]						.   .   .   .   Child: 1  Op: sizeof of type int [line: 13]
.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -5] [line: 13]				   |	.   .   .   Child: 2  Compound [mem: None loc: 0 size: -7] [line: 13]
.   .   .   .   Child: 0  Var: minloc of type int [mem: Local loc: -4 size: 1] [line: 14]	   |	.   .   .   .   Child: 0  Var: minloc of type int [mem: Local loc: -6 size: 1] [line: 14]
.   .   .   .   Child: 1  Assign: = of type int [line: 16]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   .   .   Child: 0  Id: minloc of type int [mem: Local loc: -4 size: 1] [line: 16]	   |	.   .   .   .   .   Child: 0  Id: minloc of type int [mem: Local loc: -6 size: 1] [line: 16]
.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 16]			.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 16]
.   .   .   .   Sibling: 1  For [mem: None loc: 0 size: -6] [line: 17]				   |	.   .   .   .   Sibling: 1  For [mem: None loc: 0 size: -10] [line: 17]
.   .   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -5 size: 1] [line: 17]	   |	.   .   .   .   .   Child: 0  Var: j of type int [mem: Local loc: -7 size: 1] [line: 17]
.   .   .   .   .   Child: 1  Range [line: 17]								.   .   .   .   .   Child: 1  Range [line: 17]
.   .   .   .   .   .   Child: 0  Op: + of type int [line: 17]						.   .   .   .   .   .   Child: 0  Op: + of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 17]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 17]
.   .   .   .   .   .   Child: 1  Op: sizeof of type int [line: 17]					.   .   .   .   .   .   Child: 1  Op: sizeof of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   Child: 2  If [line: 17]								.   .   .   .   .   Child: 2  If [line: 17]
.   .   .   .   .   .   Child: 0  Op: < of type bool [line: 17]						.   .   .   .   .   .   Child: 0  Op: < of type bool [line: 17]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 17]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz	.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz
.   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line:    |	.   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -7 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 17]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 17]
.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz	.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz
.   .   .   .   .   .   .   .   Child: 1  Id: minloc of type int [mem: Local loc: -4 size: 1] [l   |	.   .   .   .   .   .   .   .   Child: 1  Id: minloc of type int [mem: Local loc: -6 size: 1] [l
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 17]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: minloc of type int [mem: Local loc: -4 size: 1] [line:   |	.   .   .   .   .   .   .   Child: 0  Id: minloc of type int [mem: Local loc: -6 size: 1] [line:
.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -5 size: 1] [line: 17]	   |	.   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -7 size: 1] [line: 17]
.   .   .   .   Sibling: 2  Call: swap of type void [line: 18]						.   .   .   .   Sibling: 2  Call: swap of type void [line: 18]
.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 18]		.   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   .   .   Sibling: 2  Id: minloc of type int [mem: Local loc: -4 size: 1] [line: 18]	   |	.   .   .   .   .   Sibling: 2  Id: minloc of type int [mem: Local loc: -6 size: 1] [line: 18]
Sibling: 2  Func: print returns type void [mem: Global loc: 0 size: -3] [line: 22]		   |	Sibling: 9  Func: print returns type void [mem: Global loc: 0 size: -3] [line: 22]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 22]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 22]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 23]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 23]
.   .   Child: 1  For [mem: None loc: 0 size: -4] [line: 24]					   |	.   .   Child: 1  For [mem: None loc: 0 size: -6] [line: 24]
.   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 24]			.   .   .   Child: 0  Var: i of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   .   Child: 1  Range [line: 24]									.   .   .   Child: 1  Range [line: 24]
.   .   .   .   Child: 0  Const 0 of type int [line: 24]						.   .   .   .   Child: 0  Const 0 of type int [line: 24]
.   .   .   .   Child: 1  Op: sizeof of type int [line: 24]						.   .   .   .   Child: 1  Op: sizeof of type int [line: 24]
.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   Child: 2  Call: output of type void [line: 24]						.   .   .   Child: 2  Call: output of type void [line: 24]
.   .   .   .   Child: 0  Op: [ of type int [line: 24]							.   .   .   .   Child: 0  Op: [ of type int [line: 24]
.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 24]			.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   Sibling: 1  Call: outnl of type void [line: 25]							.   .   Sibling: 1  Call: outnl of type void [line: 25]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 29]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 29]
.   Child: 1  Compound [mem: None loc: 0 size: -23] [line: 30]						.   Child: 1  Compound [mem: None loc: 0 size: -23] [line: 30]
.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 21] [line: 30]			.   .   Child: 0  Var: x of array of type int [mem: Local loc: -3 size: 21] [line: 30]
.   .   Child: 1  For [mem: None loc: 0 size: -24] [line: 33]					   |	.   .   Child: 1  For [mem: None loc: 0 size: -26] [line: 33]
.   .   .   Child: 0  Var: i of type int [mem: Local loc: -23 size: 1] [line: 33]			.   .   .   Child: 0  Var: i of type int [mem: Local loc: -23 size: 1] [line: 33]
.   .   .   Child: 1  Range [line: 33]									.   .   .   Child: 1  Range [line: 33]
.   .   .   .   Child: 0  Const 0 of type int [line: 33]						.   .   .   .   Child: 0  Const 0 of type int [line: 33]
.   .   .   .   Child: 1  Op: sizeof of type int [line: 33]						.   .   .   .   Child: 1  Op: sizeof of type int [line: 33]
.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 33	.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 33
.   .   .   Child: 2  Assign: = of type int [line: 33]						   |	.   .   .   Child: 2  Assign: := of type int [line: 33]
.   .   .   .   Child: 0  Op: [ of type int [line: 33]							.   .   .   .   Child: 0  Op: [ of type int [line: 33]
.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 33	.   .   .   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 33
.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 33]		.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -23 size: 1] [line: 33]
.   .   .   .   Child: 1  Call: input of type int [line: 33]						.   .   .   .   Child: 1  Call: input of type int [line: 33]
.   .   Sibling: 1  Call: print of type void [line: 34]							.   .   Sibling: 1  Call: print of type void [line: 34]
.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 34]		.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 34]
.   .   Sibling: 2  Call: sort of type void [line: 35]							.   .   Sibling: 2  Call: sort of type void [line: 35]
.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 35]		.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 35]
.   .   Sibling: 3  Call: print of type void [line: 36]							.   .   Sibling: 3  Call: print of type void [line: 36]
.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 36]		.   .   .   Child: 0  Id: x of array of type int [mem: Local loc: -3 size: 21] [line: 36]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
sort2.out ztmp23114.txt differ: byte 64, line 2
sort2 (Output DIFF)
WARNING(33): Variable 'x' may be uninitialized when used here.						WARNING(33): Variable 'x' may be uninitialized when used here.
Number of warnings: 1										   |	Loading file: BroadTests/sort2.tm
Number of errors: 0										   |	entered: 2
------------------------------------								   |	entered: 91
Loading file: sort2.tm										   |	entered: 25
ERROR: TM Command 2 unknown.									   |	entered: 90
ERROR: TM Command 9 unknown.									   |	entered: 15
ERROR: TM Command 2 unknown.									   |	entered: 42
ERROR: TM Command 9 unknown.									   |	entered: 91
ERROR: TM Command 1 unknown.									   |	entered: 59
ERROR: TM Command 4 unknown.									   |	entered: 90
ERROR: TM Command 9 unknown.									   |	entered: 1
ERROR: TM Command 5 unknown.									   |	entered: 25
ERROR: TM Command 9 unknown.									   |	entered: 18
ERROR: TM Command 1 unknown.									   |	entered: 29
ERROR: TM Command 2 unknown.									   |	entered: 78
ERROR: TM Command 1 unknown.									   |	entered: 47
ERROR: TM Command 2 unknown.									   |	entered: 64
ERROR: TM Command 7 unknown.									   |	entered: 86
ERROR: TM Command 4 unknown.									   |	entered: 78
ERROR: TM Command 6 unknown.									   |	entered: 90
ERROR: TM Command 8 unknown.									   |	entered: 67
ERROR: TM Command 7 unknown.									   |	2 91 25 90 15 42 91 59 90 1 25 18 29 78 47 64 86 78 90 67
ERROR: TM Command 9 unknown.									   |	1 2 15 18 25 25 29 42 47 59 64 67 78 78 86 90 90 90 91 91
ERROR: TM Command 6 unknown.									   <
Bye.													Bye.
====================================
FILE: sort.c-
-rw-------. 1 corg7983 domain_users   702 Nov 17 15:35 sort.c-
-rw-------. 1 corg7983 domain_users   715 Nov 17 15:35 sort.c-.f21
-rw-------. 1 corg7983 domain_users   702 Nov 17 15:35 sort.c-.f22
-rw-------. 1 corg7983 domain_users   188 Nov 17 15:35 sort.expected
-rw-------. 1 corg7983 domain_users    44 Nov 17 15:35 sort.in
-rw-------. 1 corg7983 domain_users  9330 Nov 22 12:27 sort.mem
-rw-------. 1 corg7983 domain_users  1697 Nov 17 15:35 sort.mem.diffs
-rw-------. 1 corg7983 domain_users 10185 Nov 17 15:35 sort.mem.f21
-rw-------. 1 corg7983 domain_users   396 Nov 22 12:27 sort.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 sort.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 sort.tm.diffs
-rw-------. 1 corg7983 domain_users 12274 Nov 17 15:35 sort.tm.f21
TM CODE COMPARISON
sort (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  sort.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION minloc
												   >	* TOFF set: -5
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:     LD  3,-3(1)	Load variable low
												   >	 41:     ST  3,-7(1)	Store variable k
												   >	* EXPRESSION
												   >	 42:     LD  3,-2(1)	Load address of base of array a
												   >	 43:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 44:     LD  3,-3(1)	Load variable low
												   >	* TOFF inc: -8
												   >	 45:     LD  4,-8(1)	Pop left into ac1 
												   >	 46:    SUB  3,4,3	compute location from index 
												   >	 47:     LD  3,0(3)	Load array element 
												   >	 48:     ST  3,-6(1)	Store variable x
												   >	* EXPRESSION
												   >	 49:     LD  3,-3(1)	Load variable low
												   >	 50:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 51:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	 52:     LD  4,-8(1)	Pop left into ac1 
												   >	 53:    ADD  3,4,3	Op + 
												   >	 54:     ST  3,-5(1)	Store variable i
												   >	* WHILE
												   >	 55:     LD  3,-5(1)	Load variable i
												   >	 56:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 57:     LD  3,-4(1)	Load variable high
												   >	* TOFF inc: -8
												   >	 58:     LD  4,-8(1)	Pop left into ac1 
												   >	 59:    TLT  3,4,3	Op < 
												   >	 60:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* IF
												   >	 62:     LD  3,-2(1)	Load address of base of array a
												   >	 63:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 64:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -8
												   >	 65:     LD  4,-8(1)	Pop left into ac1 
												   >	 66:    SUB  3,4,3	compute location from index 
												   >	 67:     LD  3,0(3)	Load array element 
												   >	 68:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 69:     LD  3,-6(1)	Load variable x
												   >	* TOFF inc: -8
												   >	 70:     LD  4,-8(1)	Pop left into ac1 
												   >	 71:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 73:     LD  3,-2(1)	Load address of base of array a
												   >	 74:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	 75:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -8
												   >	 76:     LD  4,-8(1)	Pop left into ac1 
												   >	 77:    SUB  3,4,3	compute location from index 
												   >	 78:     LD  3,0(3)	Load array element 
												   >	 79:     ST  3,-6(1)	Store variable x
												   >	* EXPRESSION
												   >	 80:     LD  3,-5(1)	Load variable i
												   >	 81:     ST  3,-7(1)	Store variable k
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	 72:    JZR  3,9(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 82:     LD  3,-5(1)	load lhs variable i
												   >	 83:    LDA  3,1(3)	increment value of i
												   >	 84:     ST  3,-5(1)	Store variable i
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	 85:    JMP  7,-31(7)	go to beginning of loop 
												   >	 61:    JMP  7,24(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	 86:     LD  3,-7(1)	Load variable k
												   >	 87:    LDA  2,0(3)	Copy result to return register 
												   >	 88:     LD  3,-1(1)	Load return address 
												   >	 89:     LD  1,0(1)	Adjust fp 
												   >	 90:    JMP  7,0(3)	Return 
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 91:    LDC  2,0(6)	Set return value to 0 
												   >	 92:     LD  3,-1(1)	Load return address 
												   >	 93:     LD  1,0(1)	Adjust fp 
												   >	 94:    JMP  7,0(3)	Return 
												   >	* END FUNCTION minloc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION sort
												   >	* TOFF set: -5
												   >	 95:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -7
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 96:     LD  3,-3(1)	Load variable low
												   >	 97:     ST  3,-5(1)	Store variable i
												   >	* WHILE
												   >	 98:     LD  3,-5(1)	Load variable i
												   >	 99:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	100:     LD  3,-4(1)	Load variable high
												   >	101:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	102:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	103:     LD  4,-8(1)	Pop left into ac1 
												   >	104:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -7
												   >	105:     LD  4,-7(1)	Pop left into ac1 
												   >	106:    TLT  3,4,3	Op < 
												   >	107:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL minloc
												   >	109:     ST  1,-8(1)	Store fp in ghost frame for minloc
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	110:     LD  3,-2(1)	Load address of base of array a
												   >	111:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	112:     LD  3,-5(1)	Load variable i
												   >	113:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	114:     LD  3,-4(1)	Load variable high
												   >	115:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end minloc
												   >	116:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	117:    LDA  3,1(7)	Return address in ac 
												   >	118:    JMP  7,-80(7)	CALL minloc
												   >	119:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end minloc
												   >	* TOFF set: -8
												   >	120:     ST  3,-6(1)	Store variable k
												   >	* EXPRESSION
												   >	121:     LD  3,-2(1)	Load address of base of array a
												   >	122:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	123:     LD  3,-6(1)	Load variable k
												   >	* TOFF inc: -8
												   >	124:     LD  4,-8(1)	Pop left into ac1 
												   >	125:    SUB  3,4,3	compute location from index 
												   >	126:     LD  3,0(3)	Load array element 
												   >	127:     ST  3,-7(1)	Store variable t
												   >	* EXPRESSION
												   >	128:     LD  3,-6(1)	Load variable k
												   >	129:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	130:     LD  3,-2(1)	Load address of base of array a
												   >	131:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	132:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -9
												   >	133:     LD  4,-9(1)	Pop left into ac1 
												   >	134:    SUB  3,4,3	compute location from index 
												   >	135:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -8
												   >	136:     LD  4,-8(1)	Pop index 
												   >	137:     LD  5,-2(1)	Load address of base of array a
												   >	138:    SUB  5,5,4	Compute offset of value 
												   >	139:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	140:     LD  3,-5(1)	Load variable i
												   >	141:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	142:     LD  3,-7(1)	Load variable t
												   >	* TOFF inc: -8
												   >	143:     LD  4,-8(1)	Pop index 
												   >	144:     LD  5,-2(1)	Load address of base of array a
												   >	145:    SUB  5,5,4	Compute offset of value 
												   >	146:     ST  3,0(5)	Store variable a
												   >	* EXPRESSION
												   >	147:     LD  3,-5(1)	load lhs variable i
												   >	148:    LDA  3,1(3)	increment value of i
												   >	149:     ST  3,-5(1)	Store variable i
												   >	* TOFF set: -7
												   >	* END COMPOUND
												   >	150:    JMP  7,-53(7)	go to beginning of loop 
												   >	108:    JMP  7,42(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	151:    LDC  2,0(6)	Set return value to 0 
												   >	152:     LD  3,-1(1)	Load return address 
												   >	153:     LD  1,0(1)	Adjust fp 
												   >	154:    JMP  7,0(3)	Return 
												   >	* END FUNCTION sort
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	155:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	156:    LDC  3,0(6)	Load integer constant 
												   >	157:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	158:     LD  3,-2(1)	Load variable i
												   >	159:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	160:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	161:     LD  4,-3(1)	Pop left into ac1 
												   >	162:    TLT  3,4,3	Op < 
												   >	163:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	165:     LD  3,-2(1)	Load variable i
												   >	166:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	* CALL input
												   >	167:     ST  1,-4(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end input
												   >	168:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	169:    LDA  3,1(7)	Return address in ac 
												   >	170:    JMP  7,-170(7)	CALL input
												   >	171:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -4
												   >	* TOFF inc: -3
												   >	172:     LD  4,-3(1)	Pop index 
												   >	173:    LDA  5,-1(0)	Load address of base of array x
												   >	174:    SUB  5,5,4	Compute offset of value 
												   >	175:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	176:     LD  3,-2(1)	load lhs variable i
												   >	177:    LDA  3,1(3)	increment value of i
												   >	178:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	179:    JMP  7,-22(7)	go to beginning of loop 
												   >	164:    JMP  7,15(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL sort
												   >	180:     ST  1,-3(1)	Store fp in ghost frame for sort
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	181:    LDA  3,-1(0)	Load address of base of array x
												   >	182:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param 2
												   >	183:    LDC  3,0(6)	Load integer constant 
												   >	184:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 3
												   >	185:    LDC  3,10(6)	Load integer constant 
												   >	186:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end sort
												   >	187:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	188:    LDA  3,1(7)	Return address in ac 
												   >	189:    JMP  7,-95(7)	CALL sort
												   >	190:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end sort
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	191:    LDC  3,0(6)	Load integer constant 
												   >	192:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	193:     LD  3,-2(1)	Load variable i
												   >	194:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	195:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	196:     LD  4,-3(1)	Pop left into ac1 
												   >	197:    TLT  3,4,3	Op < 
												   >	198:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	200:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	201:    LDA  3,-1(0)	Load address of base of array x
												   >	202:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	203:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -5
												   >	204:     LD  4,-5(1)	Pop left into ac1 
												   >	205:    SUB  3,4,3	compute location from index 
												   >	206:     LD  3,0(3)	Load array element 
												   >	207:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	208:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-205(7)	CALL output
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	212:     LD  3,-2(1)	load lhs variable i
												   >	213:    LDA  3,1(3)	increment value of i
												   >	214:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	215:    JMP  7,-23(7)	go to beginning of loop 
												   >	199:    JMP  7,16(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	216:    LDC  2,0(6)	Set return value to 0 
												   >	217:     LD  3,-1(1)	Load return address 
												   >	218:     LD  1,0(1)	Adjust fp 
												   >	219:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,219(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	220:    LDA  1,-11(0)	set first frame at end of globals 
												   >	221:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	222:    LDC  3,10(6)	load size of array x
												   >	223:     ST  3,0(0)	save size of array x
												   >	* END INIT GLOBALS AND STATICS
												   >	224:    LDA  3,1(7)	Return address in ac 
												   >	225:    JMP  7,-71(7)	Jump to main 
												   >	226:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
sort.mem sort.mem.f21 differ: byte 1, line 1
sort (MEM DIFF)
Var: x of array of type int [mem: Global loc: -1 size: 11] [line: 3]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: minloc returns type int [mem: Global loc: 0 size: -5] [line: 5]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: x of array of type int [mem: Global loc: -1 size: 11] [line: 3]
												   >	Sibling: 8  Func: minloc returns type int [mem: Global loc: 0 size: -5] [line: 5]
.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]			.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   Sibling: 1  Parm: low of type int [mem: Parameter loc: -3 size: 1] [line: 5]			.   Sibling: 1  Parm: low of type int [mem: Parameter loc: -3 size: 1] [line: 5]
.   Sibling: 2  Parm: high of type int [mem: Parameter loc: -4 size: 1] [line: 5]			.   Sibling: 2  Parm: high of type int [mem: Parameter loc: -4 size: 1] [line: 5]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 6]
.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 7]				.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 7]
.   .   Sibling: 1  Var: x of type int [mem: Local loc: -6 size: 1] [line: 7]				.   .   Sibling: 1  Var: x of type int [mem: Local loc: -6 size: 1] [line: 7]
.   .   Sibling: 2  Var: k of type int [mem: Local loc: -7 size: 1] [line: 7]				.   .   Sibling: 2  Var: k of type int [mem: Local loc: -7 size: 1] [line: 7]
.   .   Child: 1  Assign: = of type int [line: 9]						   |	.   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 9]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 9]
.   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 9]			.   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 9]
.   .   Sibling: 1  Assign: = of type int [line: 10]						   |	.   .   Sibling: 1  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -6 size: 1] [line: 10]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -6 size: 1] [line: 10]
.   .   .   Child: 1  Op: [ of type int [line: 10]							.   .   .   Child: 1  Op: [ of type int [line: 10]
.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]	.   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   .   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 10]		.   .   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   .   Sibling: 2  Assign: = of type int [line: 11]						   |	.   .   Sibling: 2  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 11]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 11]
.   .   .   Child: 1  Op: + of type int [line: 11]							.   .   .   Child: 1  Op: + of type int [line: 11]
.   .   .   .   Child: 0  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 11]		.   .   .   .   Child: 0  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   .   .   .   Child: 1  Const 1 of type int [line: 11]						.   .   .   .   Child: 1  Const 1 of type int [line: 11]
.   .   Sibling: 3  While [line: 13]									.   .   Sibling: 3  While [line: 13]
.   .   .   Child: 0  Op: < of type bool [line: 13]							.   .   .   Child: 0  Op: < of type bool [line: 13]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 13]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 13]
.   .   .   .   Child: 1  Id: high of type int [mem: Parameter loc: -4 size: 1] [line: 13]		.   .   .   .   Child: 1  Id: high of type int [mem: Parameter loc: -4 size: 1] [line: 13]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 13]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 13]
.   .   .   .   Child: 1  If [line: 14]									.   .   .   .   Child: 1  If [line: 14]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 14]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 14]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 14]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 14]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 14]
.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -6 size: 1] [line: 14]		.   .   .   .   .   .   Child: 1  Id: x of type int [mem: Local loc: -6 size: 1] [line: 14]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 14]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 14]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 15]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 15]
.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -6 size: 1] [line: 15]		.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -6 size: 1] [line: 15]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 15]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 15]
.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz	.   .   .   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 siz
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 
.   .   .   .   .   .   Sibling: 1  Assign: = of type int [line: 16]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type int [line: 16]
.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 16]		.   .   .   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 16]
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 16]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 16]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 18]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 18]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 18]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 18]
.   .   Sibling: 4  Return [line: 21]									.   .   Sibling: 4  Return [line: 21]
.   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 21]				.   .   .   Child: 0  Id: k of type int [mem: Local loc: -7 size: 1] [line: 21]
Sibling: 2  Func: sort returns type void [mem: Global loc: 0 size: -5] [line: 24]		   |	Sibling: 9  Func: sort returns type void [mem: Global loc: 0 size: -5] [line: 24]
.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 24]			.   Child: 0  Parm: a of array of type int [mem: Parameter loc: -2 size: 1] [line: 24]
.   Sibling: 1  Parm: low of type int [mem: Parameter loc: -3 size: 1] [line: 24]			.   Sibling: 1  Parm: low of type int [mem: Parameter loc: -3 size: 1] [line: 24]
.   Sibling: 2  Parm: high of type int [mem: Parameter loc: -4 size: 1] [line: 24]			.   Sibling: 2  Parm: high of type int [mem: Parameter loc: -4 size: 1] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -7] [line: 25]
.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 26]				.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 26]
.   .   Sibling: 1  Var: k of type int [mem: Local loc: -6 size: 1] [line: 26]				.   .   Sibling: 1  Var: k of type int [mem: Local loc: -6 size: 1] [line: 26]
.   .   Child: 1  Assign: = of type int [line: 28]						   |	.   .   Child: 1  Assign: := of type int [line: 28]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 28]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 28]
.   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 28]			.   .   .   Child: 1  Id: low of type int [mem: Parameter loc: -3 size: 1] [line: 28]
.   .   Sibling: 1  While [line: 29]									.   .   Sibling: 1  While [line: 29]
.   .   .   Child: 0  Op: < of type bool [line: 29]							.   .   .   Child: 0  Op: < of type bool [line: 29]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 29]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 29]
.   .   .   .   Child: 1  Op: - of type int [line: 29]							.   .   .   .   Child: 1  Op: - of type int [line: 29]
.   .   .   .   .   Child: 0  Id: high of type int [mem: Parameter loc: -4 size: 1] [line: 29]		.   .   .   .   .   Child: 0  Id: high of type int [mem: Parameter loc: -4 size: 1] [line: 29]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 29]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 29]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 29]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 29]
.   .   .   .   Child: 0  Var: t of type int [mem: Local loc: -7 size: 1] [line: 30]			.   .   .   .   Child: 0  Var: t of type int [mem: Local loc: -7 size: 1] [line: 30]
.   .   .   .   Child: 1  Assign: = of type int [line: 32]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 32]
.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -6 size: 1] [line: 32]			.   .   .   .   .   Child: 0  Id: k of type int [mem: Local loc: -6 size: 1] [line: 32]
.   .   .   .   .   Child: 1  Call: minloc of type int [line: 32]					.   .   .   .   .   Child: 1  Call: minloc of type int [line: 32]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 32]		.   .   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 32]
.   .   .   .   .   .   Sibling: 2  Id: high of type int [mem: Parameter loc: -4 size: 1] [line:	.   .   .   .   .   .   Sibling: 2  Id: high of type int [mem: Parameter loc: -4 size: 1] [line:
.   .   .   .   Sibling: 1  Assign: = of type int [line: 33]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 33]
.   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -7 size: 1] [line: 33]			.   .   .   .   .   Child: 0  Id: t of type int [mem: Local loc: -7 size: 1] [line: 33]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 33]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 33]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -6 size: 1] [line: 33]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -6 size: 1] [line: 33]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 34]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 34]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 34]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -6 size: 1] [line: 34]		.   .   .   .   .   .   Child: 1  Id: k of type int [mem: Local loc: -6 size: 1] [line: 34]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 34]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 34]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 34]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 34]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 35]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 35]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 35]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 35]
.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: a of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 35]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 35]
.   .   .   .   .   Child: 1  Id: t of type int [mem: Local loc: -7 size: 1] [line: 35]			.   .   .   .   .   Child: 1  Id: t of type int [mem: Local loc: -7 size: 1] [line: 35]
.   .   .   .   Sibling: 4  Assign: ++ of type int [line: 36]						.   .   .   .   Sibling: 4  Assign: ++ of type int [line: 36]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 36]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 36]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 40]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 40]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 41]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 41]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 42]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 42]
.   .   Child: 1  Assign: = of type int [line: 44]						   |	.   .   Child: 1  Assign: := of type int [line: 44]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 44]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 44]
.   .   .   Child: 1  Const 0 of type int [line: 44]							.   .   .   Child: 1  Const 0 of type int [line: 44]
.   .   Sibling: 1  While [line: 45]									.   .   Sibling: 1  While [line: 45]
.   .   .   Child: 0  Op: < of type bool [line: 45]							.   .   .   Child: 0  Op: < of type bool [line: 45]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 45]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 45]
.   .   .   .   Child: 1  Const 10 of type int [line: 45]						.   .   .   .   Child: 1  Const 10 of type int [line: 45]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 45]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 45]
.   .   .   .   Child: 1  Assign: = of type int [line: 46]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 46]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 46]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 46]
.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [lin	.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [lin
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 46]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 46]
.   .   .   .   .   Child: 1  Call: input of type int [line: 46]					.   .   .   .   .   Child: 1  Call: input of type int [line: 46]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 47]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 47]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 47]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 47]
.   .   Sibling: 2  Call: sort of type void [line: 50]							.   .   Sibling: 2  Call: sort of type void [line: 50]
.   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [line: 50]		.   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [line: 50]
.   .   .   Sibling: 1  Const 0 of type int [line: 50]							.   .   .   Sibling: 1  Const 0 of type int [line: 50]
.   .   .   Sibling: 2  Const 10 of type int [line: 50]							.   .   .   Sibling: 2  Const 10 of type int [line: 50]
.   .   Sibling: 3  Assign: = of type int [line: 51]						   |	.   .   Sibling: 3  Assign: := of type int [line: 51]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 51]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 51]
.   .   .   Child: 1  Const 0 of type int [line: 51]							.   .   .   Child: 1  Const 0 of type int [line: 51]
.   .   Sibling: 4  While [line: 52]									.   .   Sibling: 4  While [line: 52]
.   .   .   Child: 0  Op: < of type bool [line: 52]							.   .   .   Child: 0  Op: < of type bool [line: 52]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 52]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 52]
.   .   .   .   Child: 1  Const 10 of type int [line: 52]						.   .   .   .   Child: 1  Const 10 of type int [line: 52]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 52]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 52]
.   .   .   .   Child: 1  Call: output of type void [line: 53]						.   .   .   .   Child: 1  Call: output of type void [line: 53]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 53]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 53]
.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [lin	.   .   .   .   .   .   Child: 0  Id: x of array of type int [mem: Global loc: -1 size: 11] [lin
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 53]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 53]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 54]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 54]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 54]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 54]
Offset for end of global space: -11									Offset for end of global space: -11
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
sort.out ztmp23114.txt differ: byte 1, line 1
sort (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/sort.tm
Number of errors: 0										   |	entered: 31
------------------------------------								   |	entered: 41
Loading file: sort.tm										   |	entered: 59
ERROR: TM Command 3 unknown.									   |	entered: 26
ERROR: TM Command 4 unknown.									   |	entered: 53
ERROR: TM Command 5 unknown.									   |	entered: 58
ERROR: TM Command 2 unknown.									   |	entered: 97
ERROR: TM Command 5 unknown.									   |	entered: 93
ERROR: TM Command 5 unknown.									   |	entered: 23
ERROR: TM Command 9 unknown.									   |	entered: 84
ERROR: TM Command 9 unknown.									   |	23 26 31 41 53 58 59 84 93 97
ERROR: TM Command 2 unknown.									   <
ERROR: TM Command 8 unknown.									   <
Bye.													Bye.
====================================
FILE: sudoku.c-
-rw-------. 1 corg7983 domain_users  5928 Nov 17 15:35 sudoku.c-
-rw-------. 1 corg7983 domain_users  5947 Nov 17 15:35 sudoku.c-.f21
-rw-------. 1 corg7983 domain_users  5928 Nov 17 15:35 sudoku.c-.f22
-rw-------. 1 corg7983 domain_users   197 Nov 17 15:35 sudoku.expected
-rw-------. 1 corg7983 domain_users   177 Nov 17 15:35 sudoku.in
-rw-------. 1 corg7983 domain_users 39340 Nov 22 12:27 sudoku.mem
-rw-------. 1 corg7983 domain_users  6583 Nov 17 15:35 sudoku.mem.diffs
-rw-------. 1 corg7983 domain_users 40207 Nov 17 15:35 sudoku.mem.f21
-rw-------. 1 corg7983 domain_users   103 Nov 22 12:27 sudoku.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 sudoku.tm
-rw-------. 1 corg7983 domain_users   953 Nov 17 15:35 sudoku.tm.diffs
-rw-------. 1 corg7983 domain_users 51406 Nov 17 15:35 sudoku.tm.f21
TM CODE COMPARISON
sudoku (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  sudoku.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION initBoard
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-2(1)	Load variable i
												   >	 43:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 44:    LDC  3,81(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 45:     LD  4,-3(1)	Pop left into ac1 
												   >	 46:    TLT  3,4,3	Op < 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 49:     LD  3,-2(1)	Load variable i
												   >	 50:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	 51:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 52:     LD  4,-3(1)	Pop index 
												   >	 53:    LDA  5,-1(0)	Load address of base of array board
												   >	 54:    SUB  5,5,4	Compute offset of value 
												   >	 55:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	 56:     LD  3,-2(1)	Load variable i
												   >	 57:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	 58:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -3
												   >	 59:     LD  4,-3(1)	Pop index 
												   >	 60:    LDA  5,-83(0)	Load address of base of array locked
												   >	 61:    SUB  5,5,4	Compute offset of value 
												   >	 62:     ST  3,0(5)	Store variable locked
												   >	* EXPRESSION
												   >	 63:     LD  3,-2(1)	load lhs variable i
												   >	 64:    LDA  3,1(3)	increment value of i
												   >	 65:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 66:    JMP  7,-25(7)	go to beginning of loop 
												   >	 48:    JMP  7,18(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 67:    LDC  2,0(6)	Set return value to 0 
												   >	 68:     LD  3,-1(1)	Load return address 
												   >	 69:     LD  1,0(1)	Adjust fp 
												   >	 70:    JMP  7,0(3)	Return 
												   >	* END FUNCTION initBoard
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION setValue
												   >	* TOFF set: -5
												   >	 71:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 72:     LD  3,-2(1)	Load variable row
												   >	 73:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 74:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 75:     LD  4,-5(1)	Pop left into ac1 
												   >	 76:    MUL  3,4,3	Op * 
												   >	 77:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 78:     LD  3,-3(1)	Load variable col
												   >	* TOFF inc: -5
												   >	 79:     LD  4,-5(1)	Pop left into ac1 
												   >	 80:    ADD  3,4,3	Op + 
												   >	 81:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	 82:     LD  3,-4(1)	Load variable value
												   >	* TOFF inc: -5
												   >	 83:     LD  4,-5(1)	Pop index 
												   >	 84:    LDA  5,-1(0)	Load address of base of array board
												   >	 85:    SUB  5,5,4	Compute offset of value 
												   >	 86:     ST  3,0(5)	Store variable board
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 87:    LDC  2,0(6)	Set return value to 0 
												   >	 88:     LD  3,-1(1)	Load return address 
												   >	 89:     LD  1,0(1)	Adjust fp 
												   >	 90:    JMP  7,0(3)	Return 
												   >	* END FUNCTION setValue
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getValue
												   >	* TOFF set: -4
												   >	 91:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	 92:    LDA  3,-1(0)	Load address of base of array board
												   >	 93:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 94:     LD  3,-2(1)	Load variable row
												   >	 95:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 96:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 97:     LD  4,-5(1)	Pop left into ac1 
												   >	 98:    MUL  3,4,3	Op * 
												   >	 99:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	100:     LD  3,-3(1)	Load variable col
												   >	* TOFF inc: -5
												   >	101:     LD  4,-5(1)	Pop left into ac1 
												   >	102:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -4
												   >	103:     LD  4,-4(1)	Pop left into ac1 
												   >	104:    SUB  3,4,3	compute location from index 
												   >	105:     LD  3,0(3)	Load array element 
												   >	106:    LDA  2,0(3)	Copy result to return register 
												   >	107:     LD  3,-1(1)	Load return address 
												   >	108:     LD  1,0(1)	Adjust fp 
												   >	109:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	110:    LDC  2,0(6)	Set return value to 0 
												   >	111:     LD  3,-1(1)	Load return address 
												   >	112:     LD  1,0(1)	Adjust fp 
												   >	113:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getValue
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION setLocked
												   >	* TOFF set: -5
												   >	114:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	115:     LD  3,-2(1)	Load variable row
												   >	116:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	117:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	118:     LD  4,-5(1)	Pop left into ac1 
												   >	119:    MUL  3,4,3	Op * 
												   >	120:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	121:     LD  3,-3(1)	Load variable col
												   >	* TOFF inc: -5
												   >	122:     LD  4,-5(1)	Pop left into ac1 
												   >	123:    ADD  3,4,3	Op + 
												   >	124:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	125:     LD  3,-4(1)	Load variable value
												   >	* TOFF inc: -5
												   >	126:     LD  4,-5(1)	Pop index 
												   >	127:    LDA  5,-83(0)	Load address of base of array locked
												   >	128:    SUB  5,5,4	Compute offset of value 
												   >	129:     ST  3,0(5)	Store variable locked
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	130:    LDC  2,0(6)	Set return value to 0 
												   >	131:     LD  3,-1(1)	Load return address 
												   >	132:     LD  1,0(1)	Adjust fp 
												   >	133:    JMP  7,0(3)	Return 
												   >	* END FUNCTION setLocked
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getLocked
												   >	* TOFF set: -4
												   >	134:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	135:    LDA  3,-83(0)	Load address of base of array locked
												   >	136:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	137:     LD  3,-2(1)	Load variable row
												   >	138:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	139:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	140:     LD  4,-5(1)	Pop left into ac1 
												   >	141:    MUL  3,4,3	Op * 
												   >	142:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	143:     LD  3,-3(1)	Load variable col
												   >	* TOFF inc: -5
												   >	144:     LD  4,-5(1)	Pop left into ac1 
												   >	145:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -4
												   >	146:     LD  4,-4(1)	Pop left into ac1 
												   >	147:    SUB  3,4,3	compute location from index 
												   >	148:     LD  3,0(3)	Load array element 
												   >	149:    LDA  2,0(3)	Copy result to return register 
												   >	150:     LD  3,-1(1)	Load return address 
												   >	151:     LD  1,0(1)	Adjust fp 
												   >	152:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	153:    LDC  2,0(6)	Set return value to 0 
												   >	154:     LD  3,-1(1)	Load return address 
												   >	155:     LD  1,0(1)	Adjust fp 
												   >	156:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getLocked
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION isOkAt
												   >	* TOFF set: -5
												   >	157:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	158:    LDC  3,0(6)	Load integer constant 
												   >	159:     ST  3,-5(1)	Store variable i
												   >	* WHILE
												   >	160:     LD  3,-5(1)	Load variable i
												   >	161:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	162:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	163:     LD  4,-9(1)	Pop left into ac1 
												   >	164:    TLT  3,4,3	Op < 
												   >	165:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* IF
												   >	* CALL getValue
												   >	167:     ST  1,-9(1)	Store fp in ghost frame for getValue
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	168:     LD  3,-5(1)	Load variable i
												   >	169:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	170:     LD  3,-3(1)	Load variable col
												   >	171:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end getValue
												   >	172:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-84(7)	CALL getValue
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getValue
												   >	* TOFF set: -9
												   >	176:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	177:     LD  3,-4(1)	Load variable value
												   >	* TOFF inc: -9
												   >	178:     LD  4,-9(1)	Pop left into ac1 
												   >	179:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	181:    LDC  3,0(6)	Load Boolean constant 
												   >	182:    LDA  2,0(3)	Copy result to return register 
												   >	183:     LD  3,-1(1)	Load return address 
												   >	184:     LD  1,0(1)	Adjust fp 
												   >	185:    JMP  7,0(3)	Return 
												   >	180:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	* CALL getValue
												   >	186:     ST  1,-9(1)	Store fp in ghost frame for getValue
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	187:     LD  3,-2(1)	Load variable row
												   >	188:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	189:     LD  3,-5(1)	Load variable i
												   >	190:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end getValue
												   >	191:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	192:    LDA  3,1(7)	Return address in ac 
												   >	193:    JMP  7,-103(7)	CALL getValue
												   >	194:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getValue
												   >	* TOFF set: -9
												   >	195:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	196:     LD  3,-4(1)	Load variable value
												   >	* TOFF inc: -9
												   >	197:     LD  4,-9(1)	Pop left into ac1 
												   >	198:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	200:    LDC  3,0(6)	Load Boolean constant 
												   >	201:    LDA  2,0(3)	Copy result to return register 
												   >	202:     LD  3,-1(1)	Load return address 
												   >	203:     LD  1,0(1)	Adjust fp 
												   >	204:    JMP  7,0(3)	Return 
												   >	199:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	205:     LD  3,-5(1)	load lhs variable i
												   >	206:    LDA  3,1(3)	increment value of i
												   >	207:     ST  3,-5(1)	Store variable i
												   >	* TOFF set: -9
												   >	* END COMPOUND
												   >	208:    JMP  7,-49(7)	go to beginning of loop 
												   >	166:    JMP  7,42(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	209:     LD  3,-2(1)	Load variable row
												   >	210:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	211:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	212:     LD  4,-9(1)	Pop left into ac1 
												   >	213:    DIV  3,4,3	Op / 
												   >	214:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	215:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	216:     LD  4,-9(1)	Pop left into ac1 
												   >	217:    MUL  3,4,3	Op * 
												   >	218:     ST  3,-7(1)	Store variable boxRowStart
												   >	* EXPRESSION
												   >	219:     LD  3,-3(1)	Load variable col
												   >	220:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	221:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	222:     LD  4,-9(1)	Pop left into ac1 
												   >	223:    DIV  3,4,3	Op / 
												   >	224:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	225:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	226:     LD  4,-9(1)	Pop left into ac1 
												   >	227:    MUL  3,4,3	Op * 
												   >	228:     ST  3,-8(1)	Store variable boxColStart
												   >	* EXPRESSION
												   >	229:    LDC  3,0(6)	Load integer constant 
												   >	230:     ST  3,-5(1)	Store variable i
												   >	* WHILE
												   >	231:     LD  3,-5(1)	Load variable i
												   >	232:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	233:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	234:     LD  4,-9(1)	Pop left into ac1 
												   >	235:    TLT  3,4,3	Op < 
												   >	236:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* EXPRESSION
												   >	238:    LDC  3,0(6)	Load integer constant 
												   >	239:     ST  3,-6(1)	Store variable j
												   >	* WHILE
												   >	240:     LD  3,-6(1)	Load variable j
												   >	241:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	242:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	243:     LD  4,-9(1)	Pop left into ac1 
												   >	244:    TLT  3,4,3	Op < 
												   >	245:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -9
												   >	* Compound Body
												   >	* IF
												   >	* CALL getValue
												   >	247:     ST  1,-9(1)	Store fp in ghost frame for getValue
												   >	* TOFF dec: -10
												   >	* TOFF dec: -11
												   >	* Param 1
												   >	248:     LD  3,-7(1)	Load variable boxRowStart
												   >	249:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	250:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -11
												   >	251:     LD  4,-11(1)	Pop left into ac1 
												   >	252:    ADD  3,4,3	Op + 
												   >	253:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 2
												   >	254:     LD  3,-8(1)	Load variable boxColStart
												   >	255:     ST  3,-12(1)	Push left side 
												   >	* TOFF dec: -13
												   >	256:     LD  3,-6(1)	Load variable j
												   >	* TOFF inc: -12
												   >	257:     LD  4,-12(1)	Pop left into ac1 
												   >	258:    ADD  3,4,3	Op + 
												   >	259:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end getValue
												   >	260:    LDA  1,-9(1)	Ghost frame becomes new active frame 
												   >	261:    LDA  3,1(7)	Return address in ac 
												   >	262:    JMP  7,-172(7)	CALL getValue
												   >	263:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getValue
												   >	* TOFF set: -9
												   >	264:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	265:     LD  3,-4(1)	Load variable value
												   >	* TOFF inc: -9
												   >	266:     LD  4,-9(1)	Pop left into ac1 
												   >	267:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	269:    LDC  3,0(6)	Load Boolean constant 
												   >	270:    LDA  2,0(3)	Copy result to return register 
												   >	271:     LD  3,-1(1)	Load return address 
												   >	272:     LD  1,0(1)	Adjust fp 
												   >	273:    JMP  7,0(3)	Return 
												   >	268:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	274:     LD  3,-6(1)	load lhs variable j
												   >	275:    LDA  3,1(3)	increment value of j
												   >	276:     ST  3,-6(1)	Store variable j
												   >	* TOFF set: -9
												   >	* END COMPOUND
												   >	277:    JMP  7,-38(7)	go to beginning of loop 
												   >	246:    JMP  7,31(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	278:     LD  3,-5(1)	load lhs variable i
												   >	279:    LDA  3,1(3)	increment value of i
												   >	280:     ST  3,-5(1)	Store variable i
												   >	* TOFF set: -9
												   >	* END COMPOUND
												   >	281:    JMP  7,-51(7)	go to beginning of loop 
												   >	237:    JMP  7,44(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	282:    LDC  3,1(6)	Load Boolean constant 
												   >	283:    LDA  2,0(3)	Copy result to return register 
												   >	284:     LD  3,-1(1)	Load return address 
												   >	285:     LD  1,0(1)	Adjust fp 
												   >	286:    JMP  7,0(3)	Return 
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	287:    LDC  2,0(6)	Set return value to 0 
												   >	288:     LD  3,-1(1)	Load return address 
												   >	289:     LD  1,0(1)	Adjust fp 
												   >	290:    JMP  7,0(3)	Return 
												   >	* END FUNCTION isOkAt
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION search
												   >	* TOFF set: -4
												   >	291:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	* CALL getLocked
												   >	292:     ST  1,-4(1)	Store fp in ghost frame for getLocked
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	293:     LD  3,-2(1)	Load variable i
												   >	294:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	295:     LD  3,-3(1)	Load variable j
												   >	296:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end getLocked
												   >	297:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	298:    LDA  3,1(7)	Return address in ac 
												   >	299:    JMP  7,-166(7)	CALL getLocked
												   >	300:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getLocked
												   >	* TOFF set: -4
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	302:     LD  3,-2(1)	Load variable i
												   >	303:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	304:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	305:     LD  4,-4(1)	Pop left into ac1 
												   >	306:    TEQ  3,4,3	Op = 
												   >	307:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	308:     LD  3,-3(1)	Load variable j
												   >	309:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	310:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	311:     LD  4,-5(1)	Pop left into ac1 
												   >	312:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	313:     LD  4,-4(1)	Pop left into ac1 
												   >	314:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* RETURN
												   >	316:    LDC  3,1(6)	Load Boolean constant 
												   >	317:    LDA  2,0(3)	Copy result to return register 
												   >	318:     LD  3,-1(1)	Load return address 
												   >	319:     LD  1,0(1)	Adjust fp 
												   >	320:    JMP  7,0(3)	Return 
												   >	315:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	322:     LD  3,-3(1)	Load variable j
												   >	323:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	324:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	325:     LD  4,-4(1)	Pop left into ac1 
												   >	326:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	* CALL search
												   >	328:     ST  1,-4(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	329:     LD  3,-2(1)	Load variable i
												   >	330:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	331:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	332:     LD  4,-6(1)	Pop left into ac1 
												   >	333:    ADD  3,4,3	Op + 
												   >	334:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	335:    LDC  3,0(6)	Load integer constant 
												   >	336:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end search
												   >	337:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	338:    LDA  3,1(7)	Return address in ac 
												   >	339:    JMP  7,-49(7)	CALL search
												   >	340:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -4
												   >	341:    LDA  2,0(3)	Copy result to return register 
												   >	342:     LD  3,-1(1)	Load return address 
												   >	343:     LD  1,0(1)	Adjust fp 
												   >	344:    JMP  7,0(3)	Return 
												   >	327:    JZR  3,18(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* RETURN
												   >	* CALL search
												   >	346:     ST  1,-4(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	347:     LD  3,-2(1)	Load variable i
												   >	348:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	349:     LD  3,-3(1)	Load variable j
												   >	350:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	351:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	352:     LD  4,-7(1)	Pop left into ac1 
												   >	353:    ADD  3,4,3	Op + 
												   >	354:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end search
												   >	355:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	356:    LDA  3,1(7)	Return address in ac 
												   >	357:    JMP  7,-67(7)	CALL search
												   >	358:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -4
												   >	359:    LDA  2,0(3)	Copy result to return register 
												   >	360:     LD  3,-1(1)	Load return address 
												   >	361:     LD  1,0(1)	Adjust fp 
												   >	362:    JMP  7,0(3)	Return 
												   >	345:    JMP  7,17(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	321:    JMP  7,41(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	301:    JZR  3,62(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	364:    LDC  3,1(6)	Load integer constant 
												   >	365:     ST  3,-4(1)	Store variable n
												   >	* WHILE
												   >	366:     LD  3,-4(1)	Load variable n
												   >	367:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	368:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	369:     LD  4,-6(1)	Pop left into ac1 
												   >	370:    TLE  3,4,3	Op <= 
												   >	371:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	* CALL isOkAt
												   >	373:     ST  1,-6(1)	Store fp in ghost frame for isOkAt
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	374:     LD  3,-2(1)	Load variable i
												   >	375:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	376:     LD  3,-3(1)	Load variable j
												   >	377:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 3
												   >	378:     LD  3,-4(1)	Load variable n
												   >	379:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end isOkAt
												   >	380:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	381:    LDA  3,1(7)	Return address in ac 
												   >	382:    JMP  7,-226(7)	CALL isOkAt
												   >	383:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end isOkAt
												   >	* TOFF set: -6
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	385:     ST  1,-6(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	386:     LD  3,-2(1)	Load variable i
												   >	387:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	388:     LD  3,-3(1)	Load variable j
												   >	389:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 3
												   >	390:     LD  3,-4(1)	Load variable n
												   >	391:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end setValue
												   >	392:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	393:    LDA  3,1(7)	Return address in ac 
												   >	394:    JMP  7,-324(7)	CALL setValue
												   >	395:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -6
												   >	* IF
												   >	396:     LD  3,-2(1)	Load variable i
												   >	397:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	398:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	399:     LD  4,-6(1)	Pop left into ac1 
												   >	400:    TEQ  3,4,3	Op = 
												   >	401:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	402:     LD  3,-3(1)	Load variable j
												   >	403:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	404:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	405:     LD  4,-7(1)	Pop left into ac1 
												   >	406:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -6
												   >	407:     LD  4,-6(1)	Pop left into ac1 
												   >	408:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* RETURN
												   >	410:    LDC  3,1(6)	Load Boolean constant 
												   >	411:    LDA  2,0(3)	Copy result to return register 
												   >	412:     LD  3,-1(1)	Load return address 
												   >	413:     LD  1,0(1)	Adjust fp 
												   >	414:    JMP  7,0(3)	Return 
												   >	409:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	416:     LD  3,-3(1)	Load variable j
												   >	417:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	418:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	419:     LD  4,-6(1)	Pop left into ac1 
												   >	420:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	* CALL search
												   >	422:     ST  1,-6(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	423:     LD  3,-2(1)	Load variable i
												   >	424:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	425:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	426:     LD  4,-8(1)	Pop left into ac1 
												   >	427:    ADD  3,4,3	Op + 
												   >	428:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	429:    LDC  3,0(6)	Load integer constant 
												   >	430:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end search
												   >	431:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	432:    LDA  3,1(7)	Return address in ac 
												   >	433:    JMP  7,-143(7)	CALL search
												   >	434:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -6
												   >	435:     ST  3,-5(1)	Store variable foundOne
												   >	421:    JZR  3,15(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL search
												   >	437:     ST  1,-6(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	438:     LD  3,-2(1)	Load variable i
												   >	439:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	440:     LD  3,-3(1)	Load variable j
												   >	441:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	442:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -9
												   >	443:     LD  4,-9(1)	Pop left into ac1 
												   >	444:    ADD  3,4,3	Op + 
												   >	445:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end search
												   >	446:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	447:    LDA  3,1(7)	Return address in ac 
												   >	448:    JMP  7,-158(7)	CALL search
												   >	449:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -6
												   >	450:     ST  3,-5(1)	Store variable foundOne
												   >	436:    JMP  7,14(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	415:    JMP  7,35(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	451:     LD  3,-5(1)	Load variable foundOne
												   >	* THEN
												   >	* RETURN
												   >	453:    LDC  3,1(6)	Load Boolean constant 
												   >	454:    LDA  2,0(3)	Copy result to return register 
												   >	455:     LD  3,-1(1)	Load return address 
												   >	456:     LD  1,0(1)	Adjust fp 
												   >	457:    JMP  7,0(3)	Return 
												   >	452:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	459:     ST  1,-6(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	460:     LD  3,-2(1)	Load variable i
												   >	461:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	462:     LD  3,-3(1)	Load variable j
												   >	463:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 3
												   >	464:    LDC  3,0(6)	Load integer constant 
												   >	465:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end setValue
												   >	466:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	467:    LDA  3,1(7)	Return address in ac 
												   >	468:    JMP  7,-398(7)	CALL setValue
												   >	469:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -6
												   >	458:    JMP  7,11(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	384:    JZR  3,85(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	470:     LD  3,-4(1)	load lhs variable n
												   >	471:    LDA  3,1(3)	increment value of n
												   >	472:     ST  3,-4(1)	Store variable n
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	473:    JMP  7,-108(7)	go to beginning of loop 
												   >	372:    JMP  7,101(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	363:    JMP  7,110(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	474:    LDC  3,0(6)	Load Boolean constant 
												   >	475:    LDA  2,0(3)	Copy result to return register 
												   >	476:     LD  3,-1(1)	Load return address 
												   >	477:     LD  1,0(1)	Adjust fp 
												   >	478:    JMP  7,0(3)	Return 
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	479:    LDC  2,0(6)	Set return value to 0 
												   >	480:     LD  3,-1(1)	Load return address 
												   >	481:     LD  1,0(1)	Adjust fp 
												   >	482:    JMP  7,0(3)	Return 
												   >	* END FUNCTION search
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION searchTrivial
												   >	* TOFF set: -2
												   >	483:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	484:    LDC  3,1(6)	Load Boolean constant 
												   >	485:     ST  3,-6(1)	Store variable changed
												   >	* WHILE
												   >	486:     LD  3,-6(1)	Load variable changed
												   >	487:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	489:    LDC  3,0(6)	Load Boolean constant 
												   >	490:     ST  3,-6(1)	Store variable changed
												   >	* EXPRESSION
												   >	491:    LDC  3,0(6)	Load integer constant 
												   >	492:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	493:     LD  3,-2(1)	Load variable i
												   >	494:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	495:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	496:     LD  4,-8(1)	Pop left into ac1 
												   >	497:    TLT  3,4,3	Op < 
												   >	498:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	500:    LDC  3,0(6)	Load integer constant 
												   >	501:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	502:     LD  3,-3(1)	Load variable j
												   >	503:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	504:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	505:     LD  4,-8(1)	Pop left into ac1 
												   >	506:    TLT  3,4,3	Op < 
												   >	507:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* IF
												   >	* CALL getLocked
												   >	509:     ST  1,-8(1)	Store fp in ghost frame for getLocked
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	510:     LD  3,-2(1)	Load variable i
												   >	511:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	512:     LD  3,-3(1)	Load variable j
												   >	513:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param end getLocked
												   >	514:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	515:    LDA  3,1(7)	Return address in ac 
												   >	516:    JMP  7,-383(7)	CALL getLocked
												   >	517:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getLocked
												   >	* TOFF set: -8
												   >	518:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	519:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -8
												   >	520:     LD  4,-8(1)	Pop left into ac1 
												   >	521:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	523:    LDC  3,1(6)	Load integer constant 
												   >	524:     ST  3,-4(1)	Store variable test
												   >	* EXPRESSION
												   >	525:    LDC  3,0(6)	Load Boolean constant 
												   >	526:     ST  3,-7(1)	Store variable foundOne
												   >	* WHILE
												   >	527:     LD  3,-4(1)	Load variable test
												   >	528:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	529:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	530:     LD  4,-8(1)	Pop left into ac1 
												   >	531:    TLE  3,4,3	Op <= 
												   >	532:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* IF
												   >	* CALL isOkAt
												   >	534:     ST  1,-8(1)	Store fp in ghost frame for isOkAt
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	535:     LD  3,-2(1)	Load variable i
												   >	536:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	537:     LD  3,-3(1)	Load variable j
												   >	538:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	539:     LD  3,-4(1)	Load variable test
												   >	540:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end isOkAt
												   >	541:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	542:    LDA  3,1(7)	Return address in ac 
												   >	543:    JMP  7,-387(7)	CALL isOkAt
												   >	544:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end isOkAt
												   >	* TOFF set: -8
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* IF
												   >	546:     LD  3,-7(1)	Load variable foundOne
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	548:    LDC  3,0(6)	Load Boolean constant 
												   >	549:     ST  3,-7(1)	Store variable foundOne
												   >	* BREAK
												   >	550:    JMP  7,-18(7)	break 
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	547:    JZR  3,4(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	552:    LDC  3,1(6)	Load Boolean constant 
												   >	553:     ST  3,-7(1)	Store variable foundOne
												   >	* EXPRESSION
												   >	554:     LD  3,-4(1)	Load variable test
												   >	555:     ST  3,-5(1)	Store variable value
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	551:    JMP  7,4(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	545:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	556:     LD  3,-4(1)	load lhs variable test
												   >	557:    LDA  3,1(3)	increment value of test
												   >	558:     ST  3,-4(1)	Store variable test
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	559:    JMP  7,-33(7)	go to beginning of loop 
												   >	533:    JMP  7,26(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	560:     LD  3,-7(1)	Load variable foundOne
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	562:     ST  1,-8(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	563:     LD  3,-2(1)	Load variable i
												   >	564:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	565:     LD  3,-3(1)	Load variable j
												   >	566:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	567:     LD  3,-5(1)	Load variable value
												   >	568:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end setValue
												   >	569:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	570:    LDA  3,1(7)	Return address in ac 
												   >	571:    JMP  7,-501(7)	CALL setValue
												   >	572:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL setLocked
												   >	573:     ST  1,-8(1)	Store fp in ghost frame for setLocked
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	574:     LD  3,-2(1)	Load variable i
												   >	575:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	576:     LD  3,-3(1)	Load variable j
												   >	577:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	578:    LDC  3,1(6)	Load Boolean constant 
												   >	579:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end setLocked
												   >	580:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	581:    LDA  3,1(7)	Return address in ac 
												   >	582:    JMP  7,-469(7)	CALL setLocked
												   >	583:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setLocked
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	584:    LDC  3,1(6)	Load Boolean constant 
												   >	585:     ST  3,-6(1)	Store variable changed
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	561:    JZR  3,24(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	522:    JZR  3,63(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	586:     LD  3,-3(1)	load lhs variable j
												   >	587:    LDA  3,1(3)	increment value of j
												   >	588:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	589:    JMP  7,-88(7)	go to beginning of loop 
												   >	508:    JMP  7,81(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	590:     LD  3,-2(1)	load lhs variable i
												   >	591:    LDA  3,1(3)	increment value of i
												   >	592:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	593:    JMP  7,-101(7)	go to beginning of loop 
												   >	499:    JMP  7,94(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	594:    JMP  7,-109(7)	go to beginning of loop 
												   >	488:    JMP  7,106(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	595:    LDC  2,0(6)	Set return value to 0 
												   >	596:     LD  3,-1(1)	Load return address 
												   >	597:     LD  1,0(1)	Adjust fp 
												   >	598:    JMP  7,0(3)	Return 
												   >	* END FUNCTION searchTrivial
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION solve
												   >	* TOFF set: -2
												   >	599:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	600:    LDC  3,0(6)	Load integer constant 
												   >	601:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	602:     LD  3,-2(1)	Load variable i
												   >	603:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	604:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	605:     LD  4,-5(1)	Pop left into ac1 
												   >	606:    TLT  3,4,3	Op < 
												   >	607:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	609:    LDC  3,0(6)	Load integer constant 
												   >	610:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	611:     LD  3,-3(1)	Load variable j
												   >	612:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	613:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	614:     LD  4,-5(1)	Pop left into ac1 
												   >	615:    TLT  3,4,3	Op < 
												   >	616:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL getValue
												   >	618:     ST  1,-5(1)	Store fp in ghost frame for getValue
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	619:     LD  3,-2(1)	Load variable i
												   >	620:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	621:     LD  3,-3(1)	Load variable j
												   >	622:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end getValue
												   >	623:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	624:    LDA  3,1(7)	Return address in ac 
												   >	625:    JMP  7,-535(7)	CALL getValue
												   >	626:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getValue
												   >	* TOFF set: -5
												   >	627:     ST  3,-4(1)	Store variable n
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	628:     ST  1,-5(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	629:     LD  3,-2(1)	Load variable i
												   >	630:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	631:     LD  3,-3(1)	Load variable j
												   >	632:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 3
												   >	633:    LDC  3,0(6)	Load integer constant 
												   >	634:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end setValue
												   >	635:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	636:    LDA  3,1(7)	Return address in ac 
												   >	637:    JMP  7,-567(7)	CALL setValue
												   >	638:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -5
												   >	* IF
												   >	* CALL getLocked
												   >	639:     ST  1,-5(1)	Store fp in ghost frame for getLocked
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	640:     LD  3,-2(1)	Load variable i
												   >	641:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	642:     LD  3,-3(1)	Load variable j
												   >	643:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end getLocked
												   >	644:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	645:    LDA  3,1(7)	Return address in ac 
												   >	646:    JMP  7,-513(7)	CALL getLocked
												   >	647:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getLocked
												   >	* TOFF set: -5
												   >	648:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	649:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -5
												   >	650:     LD  4,-5(1)	Pop left into ac1 
												   >	651:    TEQ  3,4,3	Op = 
												   >	652:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	* CALL isOkAt
												   >	653:     ST  1,-6(1)	Store fp in ghost frame for isOkAt
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	654:     LD  3,-2(1)	Load variable i
												   >	655:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	656:     LD  3,-3(1)	Load variable j
												   >	657:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param 3
												   >	658:     LD  3,-4(1)	Load variable n
												   >	659:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param end isOkAt
												   >	660:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	661:    LDA  3,1(7)	Return address in ac 
												   >	662:    JMP  7,-506(7)	CALL isOkAt
												   >	663:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end isOkAt
												   >	* TOFF set: -6
												   >	664:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	665:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -6
												   >	666:     LD  4,-6(1)	Pop left into ac1 
												   >	667:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -5
												   >	668:     LD  4,-5(1)	Pop left into ac1 
												   >	669:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* RETURN
												   >	671:    LDC  3,0(6)	Load Boolean constant 
												   >	672:    LDA  2,0(3)	Copy result to return register 
												   >	673:     LD  3,-1(1)	Load return address 
												   >	674:     LD  1,0(1)	Adjust fp 
												   >	675:    JMP  7,0(3)	Return 
												   >	670:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	676:     ST  1,-5(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	677:     LD  3,-2(1)	Load variable i
												   >	678:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	679:     LD  3,-3(1)	Load variable j
												   >	680:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 3
												   >	681:     LD  3,-4(1)	Load variable n
												   >	682:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end setValue
												   >	683:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	684:    LDA  3,1(7)	Return address in ac 
												   >	685:    JMP  7,-615(7)	CALL setValue
												   >	686:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	687:     LD  3,-3(1)	load lhs variable j
												   >	688:    LDA  3,1(3)	increment value of j
												   >	689:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	690:    JMP  7,-80(7)	go to beginning of loop 
												   >	617:    JMP  7,73(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	691:     LD  3,-2(1)	load lhs variable i
												   >	692:    LDA  3,1(3)	increment value of i
												   >	693:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	694:    JMP  7,-93(7)	go to beginning of loop 
												   >	608:    JMP  7,86(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL searchTrivial
												   >	695:     ST  1,-5(1)	Store fp in ghost frame for searchTrivial
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end searchTrivial
												   >	696:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	697:    LDA  3,1(7)	Return address in ac 
												   >	698:    JMP  7,-216(7)	CALL searchTrivial
												   >	699:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end searchTrivial
												   >	* TOFF set: -5
												   >	* RETURN
												   >	* CALL search
												   >	700:     ST  1,-5(1)	Store fp in ghost frame for search
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	701:    LDC  3,0(6)	Load integer constant 
												   >	702:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	703:    LDC  3,0(6)	Load integer constant 
												   >	704:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param end search
												   >	705:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	706:    LDA  3,1(7)	Return address in ac 
												   >	707:    JMP  7,-417(7)	CALL search
												   >	708:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end search
												   >	* TOFF set: -5
												   >	709:    LDA  2,0(3)	Copy result to return register 
												   >	710:     LD  3,-1(1)	Load return address 
												   >	711:     LD  1,0(1)	Adjust fp 
												   >	712:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	713:    LDC  2,0(6)	Set return value to 0 
												   >	714:     LD  3,-1(1)	Load return address 
												   >	715:     LD  1,0(1)	Adjust fp 
												   >	716:    JMP  7,0(3)	Return 
												   >	* END FUNCTION solve
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION showBoard
												   >	* TOFF set: -2
												   >	717:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	718:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	719:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	720:    LDA  3,1(7)	Return address in ac 
												   >	721:    JMP  7,-688(7)	CALL outnl
												   >	722:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	723:    LDC  3,0(6)	Load integer constant 
												   >	724:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	725:     LD  3,-2(1)	Load variable i
												   >	726:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	727:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	728:     LD  4,-4(1)	Pop left into ac1 
												   >	729:    TLT  3,4,3	Op < 
												   >	730:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	732:    LDC  3,0(6)	Load integer constant 
												   >	733:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	734:     LD  3,-3(1)	Load variable j
												   >	735:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	736:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	737:     LD  4,-4(1)	Pop left into ac1 
												   >	738:    TLT  3,4,3	Op < 
												   >	739:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	741:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	* CALL getValue
												   >	742:     ST  1,-6(1)	Store fp in ghost frame for getValue
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	743:     LD  3,-2(1)	Load variable i
												   >	744:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	745:     LD  3,-3(1)	Load variable j
												   >	746:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end getValue
												   >	747:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	748:    LDA  3,1(7)	Return address in ac 
												   >	749:    JMP  7,-659(7)	CALL getValue
												   >	750:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getValue
												   >	* TOFF set: -6
												   >	751:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	752:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	753:    LDA  3,1(7)	Return address in ac 
												   >	754:    JMP  7,-749(7)	CALL output
												   >	755:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	756:     LD  3,-3(1)	load lhs variable j
												   >	757:    LDA  3,1(3)	increment value of j
												   >	758:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	759:    JMP  7,-26(7)	go to beginning of loop 
												   >	740:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	760:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	761:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	762:    LDA  3,1(7)	Return address in ac 
												   >	763:    JMP  7,-730(7)	CALL outnl
												   >	764:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	765:     LD  3,-2(1)	load lhs variable i
												   >	766:    LDA  3,1(3)	increment value of i
												   >	767:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	768:    JMP  7,-44(7)	go to beginning of loop 
												   >	731:    JMP  7,37(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	769:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	770:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	771:    LDA  3,1(7)	Return address in ac 
												   >	772:    JMP  7,-739(7)	CALL outnl
												   >	773:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	774:    LDC  2,0(6)	Set return value to 0 
												   >	775:     LD  3,-1(1)	Load return address 
												   >	776:     LD  1,0(1)	Adjust fp 
												   >	777:    JMP  7,0(3)	Return 
												   >	* END FUNCTION showBoard
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getInput
												   >	* TOFF set: -2
												   >	778:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	779:    LDC  3,0(6)	Load integer constant 
												   >	780:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	781:     LD  3,-2(1)	Load variable i
												   >	782:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	783:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	784:     LD  4,-5(1)	Pop left into ac1 
												   >	785:    TLT  3,4,3	Op < 
												   >	786:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	788:    LDC  3,0(6)	Load integer constant 
												   >	789:     ST  3,-3(1)	Store variable j
												   >	* WHILE
												   >	790:     LD  3,-3(1)	Load variable j
												   >	791:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	792:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	793:     LD  4,-5(1)	Pop left into ac1 
												   >	794:    TLT  3,4,3	Op < 
												   >	795:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	797:     ST  1,-5(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end input
												   >	798:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	799:    LDA  3,1(7)	Return address in ac 
												   >	800:    JMP  7,-800(7)	CALL input
												   >	801:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -5
												   >	802:     ST  3,-4(1)	Store variable inputVal
												   >	* IF
												   >	803:     LD  3,-4(1)	Load variable inputVal
												   >	804:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	805:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	806:     LD  4,-5(1)	Pop left into ac1 
												   >	807:    TGT  3,4,3	Op > 
												   >	808:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	809:     LD  3,-4(1)	Load variable inputVal
												   >	810:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	811:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	812:     LD  4,-6(1)	Pop left into ac1 
												   >	813:    TLT  3,4,3	Op < 
												   >	* TOFF inc: -5
												   >	814:     LD  4,-5(1)	Pop left into ac1 
												   >	815:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL setValue
												   >	817:     ST  1,-5(1)	Store fp in ghost frame for setValue
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	818:     LD  3,-2(1)	Load variable i
												   >	819:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	820:     LD  3,-3(1)	Load variable j
												   >	821:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 3
												   >	822:     LD  3,-4(1)	Load variable inputVal
												   >	823:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end setValue
												   >	824:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	825:    LDA  3,1(7)	Return address in ac 
												   >	826:    JMP  7,-756(7)	CALL setValue
												   >	827:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setValue
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	* CALL setLocked
												   >	828:     ST  1,-5(1)	Store fp in ghost frame for setLocked
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	829:     LD  3,-2(1)	Load variable i
												   >	830:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param 2
												   >	831:     LD  3,-3(1)	Load variable j
												   >	832:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 3
												   >	833:    LDC  3,1(6)	Load Boolean constant 
												   >	834:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end setLocked
												   >	835:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	836:    LDA  3,1(7)	Return address in ac 
												   >	837:    JMP  7,-724(7)	CALL setLocked
												   >	838:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end setLocked
												   >	* TOFF set: -5
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	816:    JZR  3,22(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	839:     LD  3,-3(1)	load lhs variable j
												   >	840:    LDA  3,1(3)	increment value of j
												   >	841:     ST  3,-3(1)	Store variable j
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	842:    JMP  7,-53(7)	go to beginning of loop 
												   >	796:    JMP  7,46(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	843:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	844:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	845:    LDA  3,1(7)	Return address in ac 
												   >	846:    JMP  7,-813(7)	CALL outnl
												   >	847:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	848:     LD  3,-2(1)	load lhs variable i
												   >	849:    LDA  3,1(3)	increment value of i
												   >	850:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	851:    JMP  7,-71(7)	go to beginning of loop 
												   >	787:    JMP  7,64(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	852:    LDC  2,0(6)	Set return value to 0 
												   >	853:     LD  3,-1(1)	Load return address 
												   >	854:     LD  1,0(1)	Adjust fp 
												   >	855:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getInput
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	856:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL initBoard
												   >	857:     ST  1,-2(1)	Store fp in ghost frame for initBoard
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end initBoard
												   >	858:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	859:    LDA  3,1(7)	Return address in ac 
												   >	860:    JMP  7,-822(7)	CALL initBoard
												   >	861:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end initBoard
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL getInput
												   >	862:     ST  1,-2(1)	Store fp in ghost frame for getInput
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end getInput
												   >	863:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	864:    LDA  3,1(7)	Return address in ac 
												   >	865:    JMP  7,-88(7)	CALL getInput
												   >	866:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getInput
												   >	* TOFF set: -2
												   >	* IF
												   >	* CALL solve
												   >	867:     ST  1,-2(1)	Store fp in ghost frame for solve
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end solve
												   >	868:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	869:    LDA  3,1(7)	Return address in ac 
												   >	870:    JMP  7,-272(7)	CALL solve
												   >	871:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end solve
												   >	* TOFF set: -2
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL showBoard
												   >	873:     ST  1,-2(1)	Store fp in ghost frame for showBoard
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end showBoard
												   >	874:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	875:    LDA  3,1(7)	Return address in ac 
												   >	876:    JMP  7,-160(7)	CALL showBoard
												   >	877:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end showBoard
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	872:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	879:     ST  1,-2(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param 1
												   >	880:    LDC  3,0(6)	Load Boolean constant 
												   >	881:     ST  3,-4(1)	Push parameter 
												   >	* TOFF dec: -5
												   >	* Param end outputb
												   >	882:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	883:    LDA  3,1(7)	Return address in ac 
												   >	884:    JMP  7,-868(7)	CALL outputb
												   >	885:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -2
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	886:     ST  1,-2(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end outnl
												   >	887:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	888:    LDA  3,1(7)	Return address in ac 
												   >	889:    JMP  7,-856(7)	CALL outnl
												   >	890:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	878:    JMP  7,12(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	891:    LDC  3,0(6)	Load integer constant 
												   >	892:    LDA  2,0(3)	Copy result to return register 
												   >	893:     LD  3,-1(1)	Load return address 
												   >	894:     LD  1,0(1)	Adjust fp 
												   >	895:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	896:    LDC  2,0(6)	Set return value to 0 
												   >	897:     LD  3,-1(1)	Load return address 
												   >	898:     LD  1,0(1)	Adjust fp 
												   >	899:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,899(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	900:    LDA  1,-164(0)	set first frame at end of globals 
												   >	901:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	902:    LDC  3,81(6)	load size of array board
												   >	903:     ST  3,0(0)	save size of array board
												   >	904:    LDC  3,81(6)	load size of array locked
												   >	905:     ST  3,-82(0)	save size of array locked
												   >	* END INIT GLOBALS AND STATICS
												   >	906:    LDA  3,1(7)	Return address in ac 
												   >	907:    JMP  7,-52(7)	Jump to main 
												   >	908:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
sudoku.mem sudoku.mem.f21 differ: byte 1, line 1
sudoku (MEM DIFF)
Var: board of array of type int [mem: Global loc: -1 size: 82] [line: 20]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: locked of array of type bool [mem: Global loc: -83 size: 82] [line: 21]	   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: initBoard returns type void [mem: Global loc: 0 size: -2] [line: 24]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: board of array of type int [mem: Global loc: -1 size: 82] [line: 20]
												   >	Sibling: 8  Var: locked of array of type bool [mem: Global loc: -83 size: 82] [line: 21]
												   >	Sibling: 9  Func: initBoard returns type void [mem: Global loc: 0 size: -2] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 25]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 26]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   Child: 1  Assign: = of type int [line: 27]						   |	.   .   Child: 1  Assign: := of type int [line: 27]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 27]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 27]
.   .   .   Child: 1  Const 0 of type int [line: 27]							.   .   .   Child: 1  Const 0 of type int [line: 27]
.   .   Sibling: 1  While [line: 28]									.   .   Sibling: 1  While [line: 28]
.   .   .   Child: 0  Op: < of type bool [line: 28]							.   .   .   Child: 0  Op: < of type bool [line: 28]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 28]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 28]
.   .   .   .   Child: 1  Const 81 of type int [line: 28]						.   .   .   .   Child: 1  Const 81 of type int [line: 28]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 28]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 28]
.   .   .   .   Child: 1  Assign: = of type int [line: 29]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 29]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 29]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 29]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] 
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 29]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 29]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 29]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 29]
.   .   .   .   Sibling: 1  Assign: = of type bool [line: 30]					   |	.   .   .   .   Sibling: 1  Assign: := of type bool [line: 30]
.   .   .   .   .   Child: 0  Op: [ of type bool [line: 30]						.   .   .   .   .   Child: 0  Op: [ of type bool [line: 30]
.   .   .   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 8	.   .   .   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 8
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 30]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 30]
.   .   .   .   .   Child: 1  Const false of type bool [line: 30]					.   .   .   .   .   Child: 1  Const false of type bool [line: 30]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 31]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 31]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 31]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 31]
Sibling: 3  Func: setValue returns type void [mem: Global loc: 0 size: -5] [line: 36]		   |	Sibling: 10  Func: setValue returns type void [mem: Global loc: 0 size: -5] [line: 36]
.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 36]				.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 36]
.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 36]			.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 36]
.   Sibling: 2  Parm: value of type int [mem: Parameter loc: -4 size: 1] [line: 36]			.   Sibling: 2  Parm: value of type int [mem: Parameter loc: -4 size: 1] [line: 36]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 37]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 37]
.   .   Child: 1  Assign: = of type int [line: 38]						   |	.   .   Child: 1  Assign: := of type int [line: 38]
.   .   .   Child: 0  Op: [ of type int [line: 38]							.   .   .   Child: 0  Op: [ of type int [line: 38]
.   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] [line: 3	.   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] [line: 3
.   .   .   .   Child: 1  Op: + of type int [line: 38]							.   .   .   .   Child: 1  Op: + of type int [line: 38]
.   .   .   .   .   Child: 0  Op: * of type int [line: 38]						.   .   .   .   .   Child: 0  Op: * of type int [line: 38]
.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 38	.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 38
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 38]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 38]
.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 38]		.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 38]
.   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 38]			.   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 38]
Sibling: 4  Func: getValue returns type int [mem: Global loc: 0 size: -4] [line: 42]		   |	Sibling: 11  Func: getValue returns type int [mem: Global loc: 0 size: -4] [line: 42]
.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 42]				.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 42]
.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 42]			.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 42]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 43]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 43]
.   .   Child: 1  Return [line: 44]									.   .   Child: 1  Return [line: 44]
.   .   .   Child: 0  Op: [ of type int [line: 44]							.   .   .   Child: 0  Op: [ of type int [line: 44]
.   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] [line: 4	.   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 82] [line: 4
.   .   .   .   Child: 1  Op: + of type int [line: 44]							.   .   .   .   Child: 1  Op: + of type int [line: 44]
.   .   .   .   .   Child: 0  Op: * of type int [line: 44]						.   .   .   .   .   Child: 0  Op: * of type int [line: 44]
.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 44	.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 44
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 44]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 44]
.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 44]		.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 44]
Sibling: 5  Func: setLocked returns type void [mem: Global loc: 0 size: -5] [line: 48]		   |	Sibling: 12  Func: setLocked returns type void [mem: Global loc: 0 size: -5] [line: 48]
.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 48]				.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 48]
.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 48]			.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 48]
.   Sibling: 2  Parm: value of type bool [mem: Parameter loc: -4 size: 1] [line: 48]			.   Sibling: 2  Parm: value of type bool [mem: Parameter loc: -4 size: 1] [line: 48]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 49]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 49]
.   .   Child: 1  Assign: = of type bool [line: 50]						   |	.   .   Child: 1  Assign: := of type bool [line: 50]
.   .   .   Child: 0  Op: [ of type bool [line: 50]							.   .   .   Child: 0  Op: [ of type bool [line: 50]
.   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 82] [line	.   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 82] [line
.   .   .   .   Child: 1  Op: + of type int [line: 50]							.   .   .   .   Child: 1  Op: + of type int [line: 50]
.   .   .   .   .   Child: 0  Op: * of type int [line: 50]						.   .   .   .   .   Child: 0  Op: * of type int [line: 50]
.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 50	.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 50
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 50]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 50]
.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 50]		.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 50]
.   .   .   Child: 1  Id: value of type bool [mem: Parameter loc: -4 size: 1] [line: 50]		.   .   .   Child: 1  Id: value of type bool [mem: Parameter loc: -4 size: 1] [line: 50]
Sibling: 6  Func: getLocked returns type bool [mem: Global loc: 0 size: -4] [line: 54]		   |	Sibling: 13  Func: getLocked returns type bool [mem: Global loc: 0 size: -4] [line: 54]
.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 54]				.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 54]
.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 54]			.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 54]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 55]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 55]
.   .   Child: 1  Return [line: 56]									.   .   Child: 1  Return [line: 56]
.   .   .   Child: 0  Op: [ of type bool [line: 56]							.   .   .   Child: 0  Op: [ of type bool [line: 56]
.   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 82] [line	.   .   .   .   Child: 0  Id: locked of array of type bool [mem: Global loc: -83 size: 82] [line
.   .   .   .   Child: 1  Op: + of type int [line: 56]							.   .   .   .   Child: 1  Op: + of type int [line: 56]
.   .   .   .   .   Child: 0  Op: * of type int [line: 56]						.   .   .   .   .   Child: 0  Op: * of type int [line: 56]
.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 56	.   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 56
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 56]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 56]
.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 56]		.   .   .   .   .   Child: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 56]
Sibling: 7  Func: isOkAt returns type bool [mem: Global loc: 0 size: -5] [line: 60]		   |	Sibling: 14  Func: isOkAt returns type bool [mem: Global loc: 0 size: -5] [line: 60]
.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 60]				.   Child: 0  Parm: row of type int [mem: Parameter loc: -2 size: 1] [line: 60]
.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 60]			.   Sibling: 1  Parm: col of type int [mem: Parameter loc: -3 size: 1] [line: 60]
.   Sibling: 2  Parm: value of type int [mem: Parameter loc: -4 size: 1] [line: 60]			.   Sibling: 2  Parm: value of type int [mem: Parameter loc: -4 size: 1] [line: 60]
.   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 61]						.   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 61]
.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 62]				.   .   Child: 0  Var: i of type int [mem: Local loc: -5 size: 1] [line: 62]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -6 size: 1] [line: 62]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -6 size: 1] [line: 62]
.   .   Sibling: 2  Var: boxRowStart of type int [mem: Local loc: -7 size: 1] [line: 62]		.   .   Sibling: 2  Var: boxRowStart of type int [mem: Local loc: -7 size: 1] [line: 62]
.   .   Sibling: 3  Var: boxColStart of type int [mem: Local loc: -8 size: 1] [line: 62]		.   .   Sibling: 3  Var: boxColStart of type int [mem: Local loc: -8 size: 1] [line: 62]
.   .   Child: 1  Assign: = of type int [line: 65]						   |	.   .   Child: 1  Assign: := of type int [line: 65]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 65]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 65]
.   .   .   Child: 1  Const 0 of type int [line: 65]							.   .   .   Child: 1  Const 0 of type int [line: 65]
.   .   Sibling: 1  While [line: 66]									.   .   Sibling: 1  While [line: 66]
.   .   .   Child: 0  Op: < of type bool [line: 66]							.   .   .   Child: 0  Op: < of type bool [line: 66]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 66]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 66]
.   .   .   .   Child: 1  Const 9 of type int [line: 66]						.   .   .   .   Child: 1  Const 9 of type int [line: 66]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 66]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 66]
.   .   .   .   Child: 1  If [line: 67]									.   .   .   .   Child: 1  If [line: 67]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 67]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 67]
.   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 67]					.   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 67]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 67]		.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 67]
.   .   .   .   .   .   .   Sibling: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [li	.   .   .   .   .   .   .   Sibling: 1  Id: col of type int [mem: Parameter loc: -3 size: 1] [li
.   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 	.   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 
.   .   .   .   .   Child: 1  Return [line: 67]								.   .   .   .   .   Child: 1  Return [line: 67]
.   .   .   .   .   .   Child: 0  Const false of type bool [line: 67]					.   .   .   .   .   .   Child: 0  Const false of type bool [line: 67]
.   .   .   .   Sibling: 1  If [line: 68]								.   .   .   .   Sibling: 1  If [line: 68]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 68]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 68]
.   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 68]					.   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 68]
.   .   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line	.   .   .   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line
.   .   .   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 68	.   .   .   .   .   .   .   Sibling: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 68
.   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 	.   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1] [line: 
.   .   .   .   .   Child: 1  Return [line: 68]								.   .   .   .   .   Child: 1  Return [line: 68]
.   .   .   .   .   .   Child: 0  Const false of type bool [line: 68]					.   .   .   .   .   .   Child: 0  Const false of type bool [line: 68]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 69]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 69]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 69]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 69]
.   .   Sibling: 2  Assign: = of type int [line: 73]						   |	.   .   Sibling: 2  Assign: := of type int [line: 73]
.   .   .   Child: 0  Id: boxRowStart of type int [mem: Local loc: -7 size: 1] [line: 73]		.   .   .   Child: 0  Id: boxRowStart of type int [mem: Local loc: -7 size: 1] [line: 73]
.   .   .   Child: 1  Op: * of type int [line: 73]							.   .   .   Child: 1  Op: * of type int [line: 73]
.   .   .   .   Child: 0  Op: / of type int [line: 73]							.   .   .   .   Child: 0  Op: / of type int [line: 73]
.   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 73]		.   .   .   .   .   Child: 0  Id: row of type int [mem: Parameter loc: -2 size: 1] [line: 73]
.   .   .   .   .   Child: 1  Const 3 of type int [line: 73]						.   .   .   .   .   Child: 1  Const 3 of type int [line: 73]
.   .   .   .   Child: 1  Const 3 of type int [line: 73]						.   .   .   .   Child: 1  Const 3 of type int [line: 73]
.   .   Sibling: 3  Assign: = of type int [line: 74]						   |	.   .   Sibling: 3  Assign: := of type int [line: 74]
.   .   .   Child: 0  Id: boxColStart of type int [mem: Local loc: -8 size: 1] [line: 74]		.   .   .   Child: 0  Id: boxColStart of type int [mem: Local loc: -8 size: 1] [line: 74]
.   .   .   Child: 1  Op: * of type int [line: 74]							.   .   .   Child: 1  Op: * of type int [line: 74]
.   .   .   .   Child: 0  Op: / of type int [line: 74]							.   .   .   .   Child: 0  Op: / of type int [line: 74]
.   .   .   .   .   Child: 0  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 74]		.   .   .   .   .   Child: 0  Id: col of type int [mem: Parameter loc: -3 size: 1] [line: 74]
.   .   .   .   .   Child: 1  Const 3 of type int [line: 74]						.   .   .   .   .   Child: 1  Const 3 of type int [line: 74]
.   .   .   .   Child: 1  Const 3 of type int [line: 74]						.   .   .   .   Child: 1  Const 3 of type int [line: 74]
.   .   Sibling: 4  Assign: = of type int [line: 75]						   |	.   .   Sibling: 4  Assign: := of type int [line: 75]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 75]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 75]
.   .   .   Child: 1  Const 0 of type int [line: 75]							.   .   .   Child: 1  Const 0 of type int [line: 75]
.   .   Sibling: 5  While [line: 76]									.   .   Sibling: 5  While [line: 76]
.   .   .   Child: 0  Op: < of type bool [line: 76]							.   .   .   Child: 0  Op: < of type bool [line: 76]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 76]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 76]
.   .   .   .   Child: 1  Const 3 of type int [line: 76]						.   .   .   .   Child: 1  Const 3 of type int [line: 76]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 76]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 76]
.   .   .   .   Child: 1  Assign: = of type int [line: 77]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 77]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 77]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 77]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 77]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 77]
.   .   .   .   Sibling: 1  While [line: 78]								.   .   .   .   Sibling: 1  While [line: 78]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 78]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 78]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 78]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 78]
.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 78]					.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 78]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 78]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -9] [line: 78]
.   .   .   .   .   .   Child: 1  If [line: 79]								.   .   .   .   .   .   Child: 1  If [line: 79]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 79]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 79]
.   .   .   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 79]				.   .   .   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 79]
.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 79]				.   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: boxRowStart of type int [mem: Local loc: -	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: boxRowStart of type int [mem: Local loc: -
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 79]				.   .   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: boxColStart of type int [mem: Local loc: -	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: boxColStart of type int [mem: Local loc: -
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -6 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: j of type int [mem: Local loc: -6 size: 1]
.   .   .   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1]	.   .   .   .   .   .   .   .   Child: 1  Id: value of type int [mem: Parameter loc: -4 size: 1]
.   .   .   .   .   .   .   Child: 1  Return [line: 79]							.   .   .   .   .   .   .   Child: 1  Return [line: 79]
.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 79]				.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 79]
.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 80]					.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 80]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 80]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -6 size: 1] [line: 80]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 82]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 82]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 82]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 82]
.   .   Sibling: 6  Return [line: 85]									.   .   Sibling: 6  Return [line: 85]
.   .   .   Child: 0  Const true of type bool [line: 85]						.   .   .   Child: 0  Const true of type bool [line: 85]
Sibling: 8  Func: search returns type bool [mem: Global loc: 0 size: -4] [line: 89]		   |	Sibling: 15  Func: search returns type bool [mem: Global loc: 0 size: -4] [line: 89]
.   Child: 0  Parm: i of type int [mem: Parameter loc: -2 size: 1] [line: 89]				.   Child: 0  Parm: i of type int [mem: Parameter loc: -2 size: 1] [line: 89]
.   Sibling: 1  Parm: j of type int [mem: Parameter loc: -3 size: 1] [line: 89]				.   Sibling: 1  Parm: j of type int [mem: Parameter loc: -3 size: 1] [line: 89]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 90]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 90]
.   .   Child: 1  If [line: 91]										.   .   Child: 1  If [line: 91]
.   .   .   Child: 0  Call: getLocked of type bool [line: 91]						.   .   .   Child: 0  Call: getLocked of type bool [line: 91]
.   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [line: 91]			.   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [line: 91]
.   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 91]		.   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 91]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 92]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 92]
.   .   .   .   Child: 1  If [line: 93]									.   .   .   .   Child: 1  If [line: 93]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 93]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 93]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 93]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 93]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 93]					.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 93]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 93]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 93]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 93]					.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 93]
.   .   .   .   .   Child: 1  Return [line: 93]								.   .   .   .   .   Child: 1  Return [line: 93]
.   .   .   .   .   .   Child: 0  Const true of type bool [line: 93]					.   .   .   .   .   .   Child: 0  Const true of type bool [line: 93]
.   .   .   .   .   Child: 2  If [line: 94]								.   .   .   .   .   Child: 2  If [line: 94]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 94]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 94]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 94]					.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 94]
.   .   .   .   .   .   Child: 1  Return [line: 94]							.   .   .   .   .   .   Child: 1  Return [line: 94]
.   .   .   .   .   .   .   Child: 0  Call: search of type bool [line: 94]				.   .   .   .   .   .   .   Child: 0  Call: search of type bool [line: 94]
.   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 94]					.   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 94]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 94]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 94]
.   .   .   .   .   .   .   .   Sibling: 1  Const 0 of type int [line: 94]				.   .   .   .   .   .   .   .   Sibling: 1  Const 0 of type int [line: 94]
.   .   .   .   .   .   Child: 2  Return [line: 95]							.   .   .   .   .   .   Child: 2  Return [line: 95]
.   .   .   .   .   .   .   Child: 0  Call: search of type bool [line: 95]				.   .   .   .   .   .   .   Child: 0  Call: search of type bool [line: 95]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 95]				.   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 95]
.   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 size: 1]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 95]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 95]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -6] [line: 98]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -6] [line: 98]
.   .   .   .   Child: 0  Var: n of type int [mem: Local loc: -4 size: 1] [line: 99]			.   .   .   .   Child: 0  Var: n of type int [mem: Local loc: -4 size: 1] [line: 99]
.   .   .   .   Sibling: 1  Var: foundOne of type bool [mem: Local loc: -5 size: 1] [line: 100]		.   .   .   .   Sibling: 1  Var: foundOne of type bool [mem: Local loc: -5 size: 1] [line: 100]
.   .   .   .   Child: 1  Assign: = of type int [line: 101]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 101]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 101]		.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 101]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 101]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 101]
.   .   .   .   Sibling: 1  While [line: 102]								.   .   .   .   Sibling: 1  While [line: 102]
.   .   .   .   .   Child: 0  Op: <= of type bool [line: 102]						.   .   .   .   .   Child: 0  Op: <= of type bool [line: 102]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 102]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 102]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 102]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 102]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 102]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 102]
.   .   .   .   .   .   Child: 1  If [line: 103]							.   .   .   .   .   .   Child: 1  If [line: 103]
.   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 103]				.   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 103]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 1] [	.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 1] [
.   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [line	.   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [line
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 103]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 103]
.   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 104]			.   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 104]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 size: 
.   .   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [	.   .   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [
.   .   .   .   .   .   .   .   Sibling: 1  If [line: 105]						.   .   .   .   .   .   .   .   Sibling: 1  If [line: 105]
.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 105]				.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 105]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 105]		   |	.   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 105]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 105]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 105]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 105]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 105]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 105]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 105]
.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 105]					.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 105]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 105]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 105]
.   .   .   .   .   .   .   .   .   Child: 2  If [line: 106]						.   .   .   .   .   .   .   .   .   Child: 2  If [line: 106]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 106]		   |	.   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 106]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter loc: -3 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 106]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 106]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type bool [line: 106]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type bool [line: 106]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: search of type bool [line: 106]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: search of type bool [line: 106]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 106]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: + of type int [line: 106]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 106]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 106]
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Const 0 of type int [line: 106]		.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Const 0 of type int [line: 106]
.   .   .   .   .   .   .   .   .   .   Child: 2  Assign: = of type bool [line: 107]		   |	.   .   .   .   .   .   .   .   .   .   Child: 2  Assign: := of type bool [line: 107]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: search of type bool [line: 107]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: search of type bool [line: 107]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc:	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc:
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 107]		.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Op: + of type int [line: 107]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter 	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Parameter 
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 107]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 107]
.   .   .   .   .   .   .   .   Sibling: 2  If [line: 108]						.   .   .   .   .   .   .   .   Sibling: 2  If [line: 108]
.   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc: -5 size	.   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc: -5 size
.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 108]					.   .   .   .   .   .   .   .   .   Child: 1  Return [line: 108]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 108]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 108]
.   .   .   .   .   .   .   .   .   Child: 2  Call: setValue of type void [line: 109]			.   .   .   .   .   .   .   .   .   Child: 2  Call: setValue of type void [line: 109]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Parameter loc: -2 size
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 si	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Parameter loc: -3 si
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Const 0 of type int [line: 109]			.   .   .   .   .   .   .   .   .   .   Sibling: 2  Const 0 of type int [line: 109]
.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 111]					.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 111]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 111]	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 111]
.   .   Sibling: 1  Return [line: 114]									.   .   Sibling: 1  Return [line: 114]
.   .   .   Child: 0  Const false of type bool [line: 114]						.   .   .   Child: 0  Const false of type bool [line: 114]
Sibling: 9  Func: searchTrivial returns type void [mem: Global loc: 0 size: -2] [line: 118]	   |	Sibling: 16  Func: searchTrivial returns type void [mem: Global loc: 0 size: -2] [line: 118]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 119]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 119]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 120]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 120]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 120]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 120]
.   .   Sibling: 2  Var: test of type int [mem: Local loc: -4 size: 1] [line: 120]			.   .   Sibling: 2  Var: test of type int [mem: Local loc: -4 size: 1] [line: 120]
.   .   Sibling: 3  Var: value of type int [mem: Local loc: -5 size: 1] [line: 120]			.   .   Sibling: 3  Var: value of type int [mem: Local loc: -5 size: 1] [line: 120]
.   .   Sibling: 4  Var: changed of type bool [mem: Local loc: -6 size: 1] [line: 121]			.   .   Sibling: 4  Var: changed of type bool [mem: Local loc: -6 size: 1] [line: 121]
.   .   Sibling: 5  Var: foundOne of type bool [mem: Local loc: -7 size: 1] [line: 121]			.   .   Sibling: 5  Var: foundOne of type bool [mem: Local loc: -7 size: 1] [line: 121]
.   .   Child: 1  Assign: = of type bool [line: 123]						   |	.   .   Child: 1  Assign: := of type bool [line: 123]
.   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 123]			.   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 123]
.   .   .   Child: 1  Const true of type bool [line: 123]						.   .   .   Child: 1  Const true of type bool [line: 123]
.   .   Sibling: 1  While [line: 124]									.   .   Sibling: 1  While [line: 124]
.   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 124]			.   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 124]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 124]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 124]
.   .   .   .   Child: 1  Assign: = of type bool [line: 125]					   |	.   .   .   .   Child: 1  Assign: := of type bool [line: 125]
.   .   .   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 125]		.   .   .   .   .   Child: 0  Id: changed of type bool [mem: Local loc: -6 size: 1] [line: 125]
.   .   .   .   .   Child: 1  Const false of type bool [line: 125]					.   .   .   .   .   Child: 1  Const false of type bool [line: 125]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 126]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 126]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 126]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 126]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 126]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 126]
.   .   .   .   Sibling: 2  While [line: 127]								.   .   .   .   Sibling: 2  While [line: 127]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 127]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 127]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 127]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 127]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 127]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 127]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 127]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 127]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 128]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 128]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 128]	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 128]
.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 128]					.   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 128]
.   .   .   .   .   .   Sibling: 1  While [line: 129]							.   .   .   .   .   .   Sibling: 1  While [line: 129]
.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 129]					.   .   .   .   .   .   .   Child: 0  Op: < of type bool [line: 129]
.   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 9 of type int [line: 129]				.   .   .   .   .   .   .   .   Child: 1  Const 9 of type int [line: 129]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 129]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 129]
.   .   .   .   .   .   .   .   Child: 1  If [line: 130]						.   .   .   .   .   .   .   .   Child: 1  If [line: 130]
.   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 130]			   |	.   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 130]
.   .   .   .   .   .   .   .   .   .   Child: 0  Call: getLocked of type bool [line: 130]		.   .   .   .   .   .   .   .   .   .   Child: 0  Call: getLocked of type bool [line: 130]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size
.   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 si	.   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 si
.   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 130]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 130]
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 130]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 130]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 131]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 131]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local loc: -4 s	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local loc: -4 s
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 131]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 131]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 132]		   |	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 132]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 132]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 132]
.   .   .   .   .   .   .   .   .   .   Sibling: 2  While [line: 133]					.   .   .   .   .   .   .   .   .   .   Sibling: 2  While [line: 133]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 133]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: <= of type bool [line: 133]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local loc: 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local loc: 
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 9 of type int [line: 133]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 9 of type int [line: 133]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 134]				.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 134]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: test of type int [mem: L	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: test of type int [mem: L
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 135]			.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 135]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type bool   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type boo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of ty	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of ty
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Break [line: 137]		.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Break [line: 137]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type bool   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type boo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of ty	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of ty
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type in   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type i
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: value of type 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: value of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: test of type i	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: test of type i
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 144]		.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 144]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local l	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: test of type int [mem: Local l
.   .   .   .   .   .   .   .   .   .   Sibling: 3  If [line: 146]					.   .   .   .   .   .   .   .   .   .   Sibling: 3  If [line: 146]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: foundOne of type bool [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 147	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 147
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local lo	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local lo
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: value of type int [mem: Loca	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: value of type int [mem: Loca
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: setLocked of type void [line: 	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Call: setLocked of type void [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc:
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local lo	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local lo
.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Const true of type bool [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Const true of type bool [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: = of type bool [line: 149]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 2  Assign: := of type bool [line: 149]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: changed of type bool [mem: Loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: changed of type bool [mem: Loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 149	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 149
.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 152]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 152]
.   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [li
.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 154]					.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 154]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 154]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 154]
Sibling: 10  Func: solve returns type bool [mem: Global loc: 0 size: -2] [line: 160]		   |	Sibling: 17  Func: solve returns type bool [mem: Global loc: 0 size: -2] [line: 160]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 161]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 161]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 162]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 162]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 162]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 162]
.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 162]				.   .   Sibling: 2  Var: n of type int [mem: Local loc: -4 size: 1] [line: 162]
.   .   Child: 1  Assign: = of type int [line: 163]						   |	.   .   Child: 1  Assign: := of type int [line: 163]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 163]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 163]
.   .   .   Child: 1  Const 0 of type int [line: 163]							.   .   .   Child: 1  Const 0 of type int [line: 163]
.   .   Sibling: 1  While [line: 166]									.   .   Sibling: 1  While [line: 166]
.   .   .   Child: 0  Op: < of type bool [line: 166]							.   .   .   Child: 0  Op: < of type bool [line: 166]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 166]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 166]
.   .   .   .   Child: 1  Const 9 of type int [line: 166]						.   .   .   .   Child: 1  Const 9 of type int [line: 166]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 166]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 166]
.   .   .   .   Child: 1  Assign: = of type int [line: 167]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 167]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 167]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 167]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 167]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 167]
.   .   .   .   Sibling: 1  While [line: 168]								.   .   .   .   Sibling: 1  While [line: 168]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 168]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 168]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 168]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 168]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 168]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 168]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 168]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 168]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 169]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 169]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 169]	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -4 size: 1] [line: 169]
.   .   .   .   .   .   .   Child: 1  Call: getValue of type int [line: 169]				.   .   .   .   .   .   .   Child: 1  Call: getValue of type int [line: 169]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line	.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line
.   .   .   .   .   .   Sibling: 1  Call: setValue of type void [line: 170]				.   .   .   .   .   .   Sibling: 1  Call: setValue of type void [line: 170]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 170]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 170]
.   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17	.   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17
.   .   .   .   .   .   .   Sibling: 2  Const 0 of type int [line: 170]					.   .   .   .   .   .   .   Sibling: 2  Const 0 of type int [line: 170]
.   .   .   .   .   .   Sibling: 2  If [line: 171]							.   .   .   .   .   .   Sibling: 2  If [line: 171]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 171]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 171]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 171]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 171]
.   .   .   .   .   .   .   .   .   Child: 0  Call: getLocked of type bool [line: 171]			.   .   .   .   .   .   .   .   .   Child: 0  Call: getLocked of type bool [line: 171]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 
.   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 171]			.   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 171]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 171]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 171]
.   .   .   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 171]			.   .   .   .   .   .   .   .   .   Child: 0  Call: isOkAt of type bool [line: 171]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1]	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 
.   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 	.   .   .   .   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 
.   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 171]			.   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 171]
.   .   .   .   .   .   .   Child: 1  Return [line: 172]						.   .   .   .   .   .   .   Child: 1  Return [line: 172]
.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 172]				.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 172]
.   .   .   .   .   .   Sibling: 3  Call: setValue of type void [line: 173]				.   .   .   .   .   .   Sibling: 3  Call: setValue of type void [line: 173]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 173]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 173]
.   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17	.   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line: 17
.   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [line: 17	.   .   .   .   .   .   .   Sibling: 2  Id: n of type int [mem: Local loc: -4 size: 1] [line: 17
.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 174]					.   .   .   .   .   .   Sibling: 4  Assign: ++ of type int [line: 174]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 174]	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 174]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 176]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 176]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 176]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 176]
.   .   Sibling: 2  Call: searchTrivial of type void [line: 179]					.   .   Sibling: 2  Call: searchTrivial of type void [line: 179]
.   .   Sibling: 3  Return [line: 180]									.   .   Sibling: 3  Return [line: 180]
.   .   .   Child: 0  Call: search of type bool [line: 180]						.   .   .   Child: 0  Call: search of type bool [line: 180]
.   .   .   .   Child: 0  Const 0 of type int [line: 180]						.   .   .   .   Child: 0  Const 0 of type int [line: 180]
.   .   .   .   Sibling: 1  Const 0 of type int [line: 180]						.   .   .   .   Sibling: 1  Const 0 of type int [line: 180]
Sibling: 11  Func: showBoard returns type void [mem: Global loc: 0 size: -2] [line: 184]	   |	Sibling: 18  Func: showBoard returns type void [mem: Global loc: 0 size: -2] [line: 184]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 185]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 185]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 186]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 186]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 186]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 186]
.   .   Child: 1  Call: outnl of type void [line: 187]							.   .   Child: 1  Call: outnl of type void [line: 187]
.   .   Sibling: 1  Assign: = of type int [line: 188]						   |	.   .   Sibling: 1  Assign: := of type int [line: 188]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 188]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 188]
.   .   .   Child: 1  Const 0 of type int [line: 188]							.   .   .   Child: 1  Const 0 of type int [line: 188]
.   .   Sibling: 2  While [line: 189]									.   .   Sibling: 2  While [line: 189]
.   .   .   Child: 0  Op: < of type bool [line: 189]							.   .   .   Child: 0  Op: < of type bool [line: 189]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 189]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 189]
.   .   .   .   Child: 1  Const 9 of type int [line: 189]						.   .   .   .   Child: 1  Const 9 of type int [line: 189]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 189]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 189]
.   .   .   .   Child: 1  Assign: = of type int [line: 190]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 190]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 190]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 190]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 190]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 190]
.   .   .   .   Sibling: 1  While [line: 191]								.   .   .   .   Sibling: 1  While [line: 191]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 191]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 191]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 191]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 191]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 191]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 191]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 191]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 191]
.   .   .   .   .   .   Child: 1  Call: output of type void [line: 192]					.   .   .   .   .   .   Child: 1  Call: output of type void [line: 192]
.   .   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 192]				.   .   .   .   .   .   .   Child: 0  Call: getValue of type int [line: 192]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line	.   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [line
.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 193]					.   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 193]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 193]	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 193]
.   .   .   .   Sibling: 2  Call: outnl of type void [line: 195]					.   .   .   .   Sibling: 2  Call: outnl of type void [line: 195]
.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 196]						.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 196]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 196]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 196]
.   .   Sibling: 3  Call: outnl of type void [line: 198]						.   .   Sibling: 3  Call: outnl of type void [line: 198]
Sibling: 12  Func: getInput returns type void [mem: Global loc: 0 size: -2] [line: 202]		   |	Sibling: 19  Func: getInput returns type void [mem: Global loc: 0 size: -2] [line: 202]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 203]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 203]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 204]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 204]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 204]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -3 size: 1] [line: 204]
.   .   Sibling: 2  Var: inputVal of type int [mem: Local loc: -4 size: 1] [line: 204]			.   .   Sibling: 2  Var: inputVal of type int [mem: Local loc: -4 size: 1] [line: 204]
.   .   Child: 1  Assign: = of type int [line: 205]						   |	.   .   Child: 1  Assign: := of type int [line: 205]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 205]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 205]
.   .   .   Child: 1  Const 0 of type int [line: 205]							.   .   .   Child: 1  Const 0 of type int [line: 205]
.   .   Sibling: 1  While [line: 206]									.   .   Sibling: 1  While [line: 206]
.   .   .   Child: 0  Op: < of type bool [line: 206]							.   .   .   Child: 0  Op: < of type bool [line: 206]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 206]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 206]
.   .   .   .   Child: 1  Const 9 of type int [line: 206]						.   .   .   .   Child: 1  Const 9 of type int [line: 206]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 206]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 206]
.   .   .   .   Child: 1  Assign: = of type int [line: 207]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 207]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 207]		.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 207]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 207]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 207]
.   .   .   .   Sibling: 1  While [line: 208]								.   .   .   .   Sibling: 1  While [line: 208]
.   .   .   .   .   Child: 0  Op: < of type bool [line: 208]						.   .   .   .   .   Child: 0  Op: < of type bool [line: 208]
.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 208]		.   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 208]
.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 208]					.   .   .   .   .   .   Child: 1  Const 9 of type int [line: 208]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 208]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 208]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 209]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 209]
.   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size: 1] [lin	.   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size: 1] [lin
.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 209]				.   .   .   .   .   .   .   Child: 1  Call: input of type int [line: 209]
.   .   .   .   .   .   Sibling: 1  If [line: 210]							.   .   .   .   .   .   Sibling: 1  If [line: 210]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 210]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 210]
.   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 210]				.   .   .   .   .   .   .   .   Child: 0  Op: > of type bool [line: 210]
.   .   .   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size:	.   .   .   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size:
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 210]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 210]
.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 210]				.   .   .   .   .   .   .   .   Child: 1  Op: < of type bool [line: 210]
.   .   .   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size:	.   .   .   .   .   .   .   .   .   Child: 0  Id: inputVal of type int [mem: Local loc: -4 size:
.   .   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 210]				.   .   .   .   .   .   .   .   .   Child: 1  Const 10 of type int [line: 210]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 211]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 211]
.   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 212]			.   .   .   .   .   .   .   .   Child: 1  Call: setValue of type void [line: 212]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [
.   .   .   .   .   .   .   .   .   Sibling: 2  Id: inputVal of type int [mem: Local loc: -4 siz	.   .   .   .   .   .   .   .   .   Sibling: 2  Id: inputVal of type int [mem: Local loc: -4 siz
.   .   .   .   .   .   .   .   Sibling: 1  Call: setLocked of type void [line: 213]			.   .   .   .   .   .   .   .   Sibling: 1  Call: setLocked of type void [line: 213]
.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [li
.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [	.   .   .   .   .   .   .   .   .   Sibling: 1  Id: j of type int [mem: Local loc: -3 size: 1] [
.   .   .   .   .   .   .   .   .   Sibling: 2  Const true of type bool [line: 213]			.   .   .   .   .   .   .   .   .   Sibling: 2  Const true of type bool [line: 213]
.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 215]					.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 215]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 215]	.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -3 size: 1] [line: 215]
.   .   .   .   Sibling: 2  Call: outnl of type void [line: 217]					.   .   .   .   Sibling: 2  Call: outnl of type void [line: 217]
.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 218]						.   .   .   .   Sibling: 3  Assign: ++ of type int [line: 218]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 218]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 218]
Sibling: 13  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 222]		   |	Sibling: 20  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 222]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 223]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 223]
.   .   Child: 1  Call: initBoard of type void [line: 224]						.   .   Child: 1  Call: initBoard of type void [line: 224]
.   .   Sibling: 1  Call: getInput of type void [line: 225]						.   .   Sibling: 1  Call: getInput of type void [line: 225]
.   .   Sibling: 2  If [line: 226]									.   .   Sibling: 2  If [line: 226]
.   .   .   Child: 0  Call: solve of type bool [line: 226]						.   .   .   Child: 0  Call: solve of type bool [line: 226]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 226]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 226]
.   .   .   .   Child: 1  Call: showBoard of type void [line: 227]					.   .   .   .   Child: 1  Call: showBoard of type void [line: 227]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 229]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 229]
.   .   .   .   Child: 1  Call: outputb of type void [line: 230]					.   .   .   .   Child: 1  Call: outputb of type void [line: 230]
.   .   .   .   .   Child: 0  Const false of type bool [line: 230]					.   .   .   .   .   Child: 0  Const false of type bool [line: 230]
.   .   .   .   Sibling: 1  Call: outnl of type void [line: 231]					.   .   .   .   Sibling: 1  Call: outnl of type void [line: 231]
.   .   Sibling: 3  Return [line: 233]									.   .   Sibling: 3  Return [line: 233]
.   .   .   Child: 0  Const 0 of type int [line: 233]							.   .   .   Child: 0  Const 0 of type int [line: 233]
Offset for end of global space: -164									Offset for end of global space: -164
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
sudoku.out ztmp23114.txt differ: byte 1, line 1
sudoku (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/sudoku.tm
Number of errors: 0										   |	2 1 7 3 9 6 5 8 4
------------------------------------								   |	6 5 8 2 1 4 9 7 3
Loading file: sudoku.tm										   |	4 3 9 5 8 7 1 6 2
												   >	3 2 5 9 4 8 7 1 6
												   >	7 9 4 6 3 1 8 2 5
												   >	8 6 1 7 2 5 4 3 9
												   >	9 8 3 1 5 2 6 4 7
												   >	1 7 2 4 6 9 3 5 8
												   >	5 4 6 8 7 3 2 9 1
====================================
FILE: tictactoe.c-
-rw-------. 1 corg7983 domain_users  10512 Nov 17 15:35 tictactoe.c-
-rw-------. 1 corg7983 domain_users  10425 Nov 17 15:35 tictactoe.c-.f21
-rw-------. 1 corg7983 domain_users  10512 Nov 17 15:35 tictactoe.c-.f22
-rw-------. 1 corg7983 domain_users    177 Nov 17 15:35 tictactoe.expected
-rw-------. 1 corg7983 domain_users     22 Nov 17 15:35 tictactoe.in
-rw-------. 1 corg7983 domain_users 124294 Nov 22 12:27 tictactoe.mem
-rw-------. 1 corg7983 domain_users  38129 Nov 17 15:35 tictactoe.mem.diffs
-rw-------. 1 corg7983 domain_users 125055 Nov 17 15:35 tictactoe.mem.f21
-rw-------. 1 corg7983 domain_users    227 Nov 22 12:27 tictactoe.out
-rw-------. 1 corg7983 domain_users      0 Nov 22 12:27 tictactoe.tm
-rw-------. 1 corg7983 domain_users  10387 Nov 17 15:35 tictactoe.tm.diffs
-rw-------. 1 corg7983 domain_users 127537 Nov 17 15:35 tictactoe.tm.f21
TM CODE COMPARISON
tictactoe (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  tictactoe.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION move
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,0(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-2(1)	Load variable i
												   >	 43:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 44:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 45:     LD  4,-3(1)	Pop left into ac1 
												   >	 46:    TLT  3,4,3	Op < 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	 49:    LDA  3,-1(0)	Load address of base of array board
												   >	 50:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 51:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	 52:     LD  4,-3(1)	Pop left into ac1 
												   >	 53:    SUB  3,4,3	compute location from index 
												   >	 54:     LD  3,0(3)	Load array element 
												   >	 55:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 56:    LDC  3,1(6)	Load integer constant 
												   >	 57:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	 58:     LD  4,-3(1)	Pop left into ac1 
												   >	 59:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* BREAK
												   >	 61:    JMP  7,-14(7)	break 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 60:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 62:     LD  3,-2(1)	load lhs variable i
												   >	 63:    LDA  3,1(3)	increment value of i
												   >	 64:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 65:    JMP  7,-24(7)	go to beginning of loop 
												   >	 48:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	 66:     LD  3,-2(1)	Load variable i
												   >	 67:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 68:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 69:     LD  4,-3(1)	Pop left into ac1 
												   >	 70:    TLT  3,4,3	Op < 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 72:     LD  3,-2(1)	Load variable i
												   >	 73:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	 74:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 75:     LD  4,-3(1)	Pop index 
												   >	 76:    LDA  5,-1(0)	Load address of base of array board
												   >	 77:    SUB  5,5,4	Compute offset of value 
												   >	 78:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	 79:    LDC  3,1(6)	Load Boolean constant 
												   >	 80:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 71:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 82:    LDC  3,0(6)	Load Boolean constant 
												   >	 83:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 81:    JMP  7,2(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 84:    LDC  2,0(6)	Set return value to 0 
												   >	 85:     LD  3,-1(1)	Load return address 
												   >	 86:     LD  1,0(1)	Adjust fp 
												   >	 87:    JMP  7,0(3)	Return 
												   >	* END FUNCTION move
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION win
												   >	* TOFF set: -2
												   >	 88:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	 89:    LDA  3,-1(0)	Load address of base of array board
												   >	 90:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 91:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 92:     LD  4,-2(1)	Pop left into ac1 
												   >	 93:    SUB  3,4,3	compute location from index 
												   >	 94:     LD  3,0(3)	Load array element 
												   >	 95:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	 96:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	 97:     LD  4,-2(1)	Pop left into ac1 
												   >	 98:    TEQ  3,4,3	Op = 
												   >	 99:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	100:    LDA  3,-1(0)	Load address of base of array board
												   >	101:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	102:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	103:     LD  4,-3(1)	Pop left into ac1 
												   >	104:    SUB  3,4,3	compute location from index 
												   >	105:     LD  3,0(3)	Load array element 
												   >	106:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	107:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	108:     LD  4,-3(1)	Pop left into ac1 
												   >	109:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	110:     LD  4,-2(1)	Pop left into ac1 
												   >	111:    AND  3,4,3	Op AND 
												   >	112:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	113:    LDA  3,-1(0)	Load address of base of array board
												   >	114:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	115:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	116:     LD  4,-3(1)	Pop left into ac1 
												   >	117:    SUB  3,4,3	compute location from index 
												   >	118:     LD  3,0(3)	Load array element 
												   >	119:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	120:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	121:     LD  4,-3(1)	Pop left into ac1 
												   >	122:    TEQ  3,4,3	Op = 
												   >	123:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	124:    LDA  3,-1(0)	Load address of base of array board
												   >	125:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	126:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	127:     LD  4,-4(1)	Pop left into ac1 
												   >	128:    SUB  3,4,3	compute location from index 
												   >	129:     LD  3,0(3)	Load array element 
												   >	130:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	131:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	132:     LD  4,-4(1)	Pop left into ac1 
												   >	133:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	134:     LD  4,-3(1)	Pop left into ac1 
												   >	135:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	136:     LD  4,-2(1)	Pop left into ac1 
												   >	137:     OR  3,4,3	Op OR 
												   >	138:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	139:    LDA  3,-1(0)	Load address of base of array board
												   >	140:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	141:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	142:     LD  4,-3(1)	Pop left into ac1 
												   >	143:    SUB  3,4,3	compute location from index 
												   >	144:     LD  3,0(3)	Load array element 
												   >	145:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	146:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	147:     LD  4,-3(1)	Pop left into ac1 
												   >	148:    TEQ  3,4,3	Op = 
												   >	149:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	150:    LDA  3,-1(0)	Load address of base of array board
												   >	151:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	152:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	153:     LD  4,-4(1)	Pop left into ac1 
												   >	154:    SUB  3,4,3	compute location from index 
												   >	155:     LD  3,0(3)	Load array element 
												   >	156:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	157:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	158:     LD  4,-4(1)	Pop left into ac1 
												   >	159:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	160:     LD  4,-3(1)	Pop left into ac1 
												   >	161:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	162:     LD  4,-2(1)	Pop left into ac1 
												   >	163:     OR  3,4,3	Op OR 
												   >	164:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	165:    LDA  3,-1(0)	Load address of base of array board
												   >	166:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	167:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	168:     LD  4,-3(1)	Pop left into ac1 
												   >	169:    SUB  3,4,3	compute location from index 
												   >	170:     LD  3,0(3)	Load array element 
												   >	171:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	172:    LDC  3,1(6)	Load integer constant 
												   >	173:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	174:     LD  4,-3(1)	Pop left into ac1 
												   >	175:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	176:     LD  4,-2(1)	Pop left into ac1 
												   >	177:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	179:    LDC  3,2(6)	Load integer constant 
												   >	180:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	181:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	182:     LD  4,-2(1)	Pop index 
												   >	183:    LDA  5,-1(0)	Load address of base of array board
												   >	184:    SUB  5,5,4	Compute offset of value 
												   >	185:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	186:    LDC  3,0(6)	Load Boolean constant 
												   >	187:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	178:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	189:    LDA  3,-1(0)	Load address of base of array board
												   >	190:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	191:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	192:     LD  4,-2(1)	Pop left into ac1 
												   >	193:    SUB  3,4,3	compute location from index 
												   >	194:     LD  3,0(3)	Load array element 
												   >	195:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	196:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	197:     LD  4,-2(1)	Pop left into ac1 
												   >	198:    TEQ  3,4,3	Op = 
												   >	199:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	200:    LDA  3,-1(0)	Load address of base of array board
												   >	201:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	202:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	203:     LD  4,-3(1)	Pop left into ac1 
												   >	204:    SUB  3,4,3	compute location from index 
												   >	205:     LD  3,0(3)	Load array element 
												   >	206:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	207:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	208:     LD  4,-3(1)	Pop left into ac1 
												   >	209:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	210:     LD  4,-2(1)	Pop left into ac1 
												   >	211:    AND  3,4,3	Op AND 
												   >	212:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	213:    LDA  3,-1(0)	Load address of base of array board
												   >	214:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	215:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	216:     LD  4,-3(1)	Pop left into ac1 
												   >	217:    SUB  3,4,3	compute location from index 
												   >	218:     LD  3,0(3)	Load array element 
												   >	219:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	220:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	221:     LD  4,-3(1)	Pop left into ac1 
												   >	222:    TEQ  3,4,3	Op = 
												   >	223:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	224:    LDA  3,-1(0)	Load address of base of array board
												   >	225:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	226:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	227:     LD  4,-4(1)	Pop left into ac1 
												   >	228:    SUB  3,4,3	compute location from index 
												   >	229:     LD  3,0(3)	Load array element 
												   >	230:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	231:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	232:     LD  4,-4(1)	Pop left into ac1 
												   >	233:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	234:     LD  4,-3(1)	Pop left into ac1 
												   >	235:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	236:     LD  4,-2(1)	Pop left into ac1 
												   >	237:     OR  3,4,3	Op OR 
												   >	238:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	239:    LDA  3,-1(0)	Load address of base of array board
												   >	240:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	241:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	242:     LD  4,-3(1)	Pop left into ac1 
												   >	243:    SUB  3,4,3	compute location from index 
												   >	244:     LD  3,0(3)	Load array element 
												   >	245:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	246:    LDC  3,1(6)	Load integer constant 
												   >	247:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	248:     LD  4,-3(1)	Pop left into ac1 
												   >	249:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	250:     LD  4,-2(1)	Pop left into ac1 
												   >	251:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	253:    LDC  3,1(6)	Load integer constant 
												   >	254:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	255:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	256:     LD  4,-2(1)	Pop index 
												   >	257:    LDA  5,-1(0)	Load address of base of array board
												   >	258:    SUB  5,5,4	Compute offset of value 
												   >	259:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	260:    LDC  3,0(6)	Load Boolean constant 
												   >	261:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	252:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	263:    LDA  3,-1(0)	Load address of base of array board
												   >	264:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	265:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	266:     LD  4,-2(1)	Pop left into ac1 
												   >	267:    SUB  3,4,3	compute location from index 
												   >	268:     LD  3,0(3)	Load array element 
												   >	269:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	270:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	271:     LD  4,-2(1)	Pop left into ac1 
												   >	272:    TEQ  3,4,3	Op = 
												   >	273:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	274:    LDA  3,-1(0)	Load address of base of array board
												   >	275:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	276:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	277:     LD  4,-3(1)	Pop left into ac1 
												   >	278:    SUB  3,4,3	compute location from index 
												   >	279:     LD  3,0(3)	Load array element 
												   >	280:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	281:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	282:     LD  4,-3(1)	Pop left into ac1 
												   >	283:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	284:     LD  4,-2(1)	Pop left into ac1 
												   >	285:    AND  3,4,3	Op AND 
												   >	286:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	287:    LDA  3,-1(0)	Load address of base of array board
												   >	288:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	289:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	290:     LD  4,-3(1)	Pop left into ac1 
												   >	291:    SUB  3,4,3	compute location from index 
												   >	292:     LD  3,0(3)	Load array element 
												   >	293:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	294:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	295:     LD  4,-3(1)	Pop left into ac1 
												   >	296:    TEQ  3,4,3	Op = 
												   >	297:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	298:    LDA  3,-1(0)	Load address of base of array board
												   >	299:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	300:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	301:     LD  4,-4(1)	Pop left into ac1 
												   >	302:    SUB  3,4,3	compute location from index 
												   >	303:     LD  3,0(3)	Load array element 
												   >	304:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	305:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	306:     LD  4,-4(1)	Pop left into ac1 
												   >	307:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	308:     LD  4,-3(1)	Pop left into ac1 
												   >	309:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	310:     LD  4,-2(1)	Pop left into ac1 
												   >	311:     OR  3,4,3	Op OR 
												   >	312:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	313:    LDA  3,-1(0)	Load address of base of array board
												   >	314:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	315:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	316:     LD  4,-3(1)	Pop left into ac1 
												   >	317:    SUB  3,4,3	compute location from index 
												   >	318:     LD  3,0(3)	Load array element 
												   >	319:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	320:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	321:     LD  4,-3(1)	Pop left into ac1 
												   >	322:    TEQ  3,4,3	Op = 
												   >	323:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	324:    LDA  3,-1(0)	Load address of base of array board
												   >	325:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	326:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	327:     LD  4,-4(1)	Pop left into ac1 
												   >	328:    SUB  3,4,3	compute location from index 
												   >	329:     LD  3,0(3)	Load array element 
												   >	330:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	331:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	332:     LD  4,-4(1)	Pop left into ac1 
												   >	333:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	334:     LD  4,-3(1)	Pop left into ac1 
												   >	335:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	336:     LD  4,-2(1)	Pop left into ac1 
												   >	337:     OR  3,4,3	Op OR 
												   >	338:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	339:    LDA  3,-1(0)	Load address of base of array board
												   >	340:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	341:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	342:     LD  4,-3(1)	Pop left into ac1 
												   >	343:    SUB  3,4,3	compute location from index 
												   >	344:     LD  3,0(3)	Load array element 
												   >	345:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	346:    LDC  3,1(6)	Load integer constant 
												   >	347:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	348:     LD  4,-3(1)	Pop left into ac1 
												   >	349:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	350:     LD  4,-2(1)	Pop left into ac1 
												   >	351:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	353:    LDC  3,0(6)	Load integer constant 
												   >	354:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	355:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	356:     LD  4,-2(1)	Pop index 
												   >	357:    LDA  5,-1(0)	Load address of base of array board
												   >	358:    SUB  5,5,4	Compute offset of value 
												   >	359:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	360:    LDC  3,0(6)	Load Boolean constant 
												   >	361:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	352:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	363:    LDA  3,-1(0)	Load address of base of array board
												   >	364:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	365:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	366:     LD  4,-2(1)	Pop left into ac1 
												   >	367:    SUB  3,4,3	compute location from index 
												   >	368:     LD  3,0(3)	Load array element 
												   >	369:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	370:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	371:     LD  4,-2(1)	Pop left into ac1 
												   >	372:    TEQ  3,4,3	Op = 
												   >	373:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	374:    LDA  3,-1(0)	Load address of base of array board
												   >	375:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	376:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	377:     LD  4,-3(1)	Pop left into ac1 
												   >	378:    SUB  3,4,3	compute location from index 
												   >	379:     LD  3,0(3)	Load array element 
												   >	380:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	381:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	382:     LD  4,-3(1)	Pop left into ac1 
												   >	383:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	384:     LD  4,-2(1)	Pop left into ac1 
												   >	385:    AND  3,4,3	Op AND 
												   >	386:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	387:    LDA  3,-1(0)	Load address of base of array board
												   >	388:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	389:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	390:     LD  4,-3(1)	Pop left into ac1 
												   >	391:    SUB  3,4,3	compute location from index 
												   >	392:     LD  3,0(3)	Load array element 
												   >	393:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	394:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	395:     LD  4,-3(1)	Pop left into ac1 
												   >	396:    TEQ  3,4,3	Op = 
												   >	397:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	398:    LDA  3,-1(0)	Load address of base of array board
												   >	399:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	400:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	401:     LD  4,-4(1)	Pop left into ac1 
												   >	402:    SUB  3,4,3	compute location from index 
												   >	403:     LD  3,0(3)	Load array element 
												   >	404:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	405:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	406:     LD  4,-4(1)	Pop left into ac1 
												   >	407:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	408:     LD  4,-3(1)	Pop left into ac1 
												   >	409:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	410:     LD  4,-2(1)	Pop left into ac1 
												   >	411:     OR  3,4,3	Op OR 
												   >	412:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	413:    LDA  3,-1(0)	Load address of base of array board
												   >	414:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	415:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	416:     LD  4,-3(1)	Pop left into ac1 
												   >	417:    SUB  3,4,3	compute location from index 
												   >	418:     LD  3,0(3)	Load array element 
												   >	419:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	420:    LDC  3,1(6)	Load integer constant 
												   >	421:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	422:     LD  4,-3(1)	Pop left into ac1 
												   >	423:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	424:     LD  4,-2(1)	Pop left into ac1 
												   >	425:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	427:    LDC  3,5(6)	Load integer constant 
												   >	428:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	429:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	430:     LD  4,-2(1)	Pop index 
												   >	431:    LDA  5,-1(0)	Load address of base of array board
												   >	432:    SUB  5,5,4	Compute offset of value 
												   >	433:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	434:    LDC  3,0(6)	Load Boolean constant 
												   >	435:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	426:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	437:    LDA  3,-1(0)	Load address of base of array board
												   >	438:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	439:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	440:     LD  4,-2(1)	Pop left into ac1 
												   >	441:    SUB  3,4,3	compute location from index 
												   >	442:     LD  3,0(3)	Load array element 
												   >	443:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	444:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	445:     LD  4,-2(1)	Pop left into ac1 
												   >	446:    TEQ  3,4,3	Op = 
												   >	447:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	448:    LDA  3,-1(0)	Load address of base of array board
												   >	449:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	450:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	451:     LD  4,-3(1)	Pop left into ac1 
												   >	452:    SUB  3,4,3	compute location from index 
												   >	453:     LD  3,0(3)	Load array element 
												   >	454:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	455:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	456:     LD  4,-3(1)	Pop left into ac1 
												   >	457:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	458:     LD  4,-2(1)	Pop left into ac1 
												   >	459:    AND  3,4,3	Op AND 
												   >	460:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	461:    LDA  3,-1(0)	Load address of base of array board
												   >	462:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	463:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	464:     LD  4,-3(1)	Pop left into ac1 
												   >	465:    SUB  3,4,3	compute location from index 
												   >	466:     LD  3,0(3)	Load array element 
												   >	467:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	468:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	469:     LD  4,-3(1)	Pop left into ac1 
												   >	470:    TEQ  3,4,3	Op = 
												   >	471:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	472:    LDA  3,-1(0)	Load address of base of array board
												   >	473:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	474:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	475:     LD  4,-4(1)	Pop left into ac1 
												   >	476:    SUB  3,4,3	compute location from index 
												   >	477:     LD  3,0(3)	Load array element 
												   >	478:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	479:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	480:     LD  4,-4(1)	Pop left into ac1 
												   >	481:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	482:     LD  4,-3(1)	Pop left into ac1 
												   >	483:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	484:     LD  4,-2(1)	Pop left into ac1 
												   >	485:     OR  3,4,3	Op OR 
												   >	486:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	487:    LDA  3,-1(0)	Load address of base of array board
												   >	488:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	489:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	490:     LD  4,-3(1)	Pop left into ac1 
												   >	491:    SUB  3,4,3	compute location from index 
												   >	492:     LD  3,0(3)	Load array element 
												   >	493:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	494:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	495:     LD  4,-3(1)	Pop left into ac1 
												   >	496:    TEQ  3,4,3	Op = 
												   >	497:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	498:    LDA  3,-1(0)	Load address of base of array board
												   >	499:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	500:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	501:     LD  4,-4(1)	Pop left into ac1 
												   >	502:    SUB  3,4,3	compute location from index 
												   >	503:     LD  3,0(3)	Load array element 
												   >	504:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	505:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	506:     LD  4,-4(1)	Pop left into ac1 
												   >	507:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	508:     LD  4,-3(1)	Pop left into ac1 
												   >	509:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	510:     LD  4,-2(1)	Pop left into ac1 
												   >	511:     OR  3,4,3	Op OR 
												   >	512:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	513:    LDA  3,-1(0)	Load address of base of array board
												   >	514:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	515:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	516:     LD  4,-3(1)	Pop left into ac1 
												   >	517:    SUB  3,4,3	compute location from index 
												   >	518:     LD  3,0(3)	Load array element 
												   >	519:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	520:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	521:     LD  4,-3(1)	Pop left into ac1 
												   >	522:    TEQ  3,4,3	Op = 
												   >	523:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	524:    LDA  3,-1(0)	Load address of base of array board
												   >	525:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	526:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	527:     LD  4,-4(1)	Pop left into ac1 
												   >	528:    SUB  3,4,3	compute location from index 
												   >	529:     LD  3,0(3)	Load array element 
												   >	530:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	531:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	532:     LD  4,-4(1)	Pop left into ac1 
												   >	533:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	534:     LD  4,-3(1)	Pop left into ac1 
												   >	535:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	536:     LD  4,-2(1)	Pop left into ac1 
												   >	537:     OR  3,4,3	Op OR 
												   >	538:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	539:    LDA  3,-1(0)	Load address of base of array board
												   >	540:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	541:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	542:     LD  4,-3(1)	Pop left into ac1 
												   >	543:    SUB  3,4,3	compute location from index 
												   >	544:     LD  3,0(3)	Load array element 
												   >	545:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	546:    LDC  3,1(6)	Load integer constant 
												   >	547:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	548:     LD  4,-3(1)	Pop left into ac1 
												   >	549:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	550:     LD  4,-2(1)	Pop left into ac1 
												   >	551:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	553:    LDC  3,4(6)	Load integer constant 
												   >	554:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	555:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	556:     LD  4,-2(1)	Pop index 
												   >	557:    LDA  5,-1(0)	Load address of base of array board
												   >	558:    SUB  5,5,4	Compute offset of value 
												   >	559:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	560:    LDC  3,0(6)	Load Boolean constant 
												   >	561:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	552:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	563:    LDA  3,-1(0)	Load address of base of array board
												   >	564:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	565:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	566:     LD  4,-2(1)	Pop left into ac1 
												   >	567:    SUB  3,4,3	compute location from index 
												   >	568:     LD  3,0(3)	Load array element 
												   >	569:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	570:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	571:     LD  4,-2(1)	Pop left into ac1 
												   >	572:    TEQ  3,4,3	Op = 
												   >	573:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	574:    LDA  3,-1(0)	Load address of base of array board
												   >	575:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	576:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	577:     LD  4,-3(1)	Pop left into ac1 
												   >	578:    SUB  3,4,3	compute location from index 
												   >	579:     LD  3,0(3)	Load array element 
												   >	580:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	581:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	582:     LD  4,-3(1)	Pop left into ac1 
												   >	583:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	584:     LD  4,-2(1)	Pop left into ac1 
												   >	585:    AND  3,4,3	Op AND 
												   >	586:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	587:    LDA  3,-1(0)	Load address of base of array board
												   >	588:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	589:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	590:     LD  4,-3(1)	Pop left into ac1 
												   >	591:    SUB  3,4,3	compute location from index 
												   >	592:     LD  3,0(3)	Load array element 
												   >	593:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	594:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	595:     LD  4,-3(1)	Pop left into ac1 
												   >	596:    TEQ  3,4,3	Op = 
												   >	597:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	598:    LDA  3,-1(0)	Load address of base of array board
												   >	599:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	600:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	601:     LD  4,-4(1)	Pop left into ac1 
												   >	602:    SUB  3,4,3	compute location from index 
												   >	603:     LD  3,0(3)	Load array element 
												   >	604:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	605:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	606:     LD  4,-4(1)	Pop left into ac1 
												   >	607:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	608:     LD  4,-3(1)	Pop left into ac1 
												   >	609:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	610:     LD  4,-2(1)	Pop left into ac1 
												   >	611:     OR  3,4,3	Op OR 
												   >	612:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	613:    LDA  3,-1(0)	Load address of base of array board
												   >	614:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	615:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	616:     LD  4,-3(1)	Pop left into ac1 
												   >	617:    SUB  3,4,3	compute location from index 
												   >	618:     LD  3,0(3)	Load array element 
												   >	619:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	620:    LDC  3,1(6)	Load integer constant 
												   >	621:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	622:     LD  4,-3(1)	Pop left into ac1 
												   >	623:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	624:     LD  4,-2(1)	Pop left into ac1 
												   >	625:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	627:    LDC  3,3(6)	Load integer constant 
												   >	628:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	629:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	630:     LD  4,-2(1)	Pop index 
												   >	631:    LDA  5,-1(0)	Load address of base of array board
												   >	632:    SUB  5,5,4	Compute offset of value 
												   >	633:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	634:    LDC  3,0(6)	Load Boolean constant 
												   >	635:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	626:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	637:    LDA  3,-1(0)	Load address of base of array board
												   >	638:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	639:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	640:     LD  4,-2(1)	Pop left into ac1 
												   >	641:    SUB  3,4,3	compute location from index 
												   >	642:     LD  3,0(3)	Load array element 
												   >	643:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	644:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	645:     LD  4,-2(1)	Pop left into ac1 
												   >	646:    TEQ  3,4,3	Op = 
												   >	647:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	648:    LDA  3,-1(0)	Load address of base of array board
												   >	649:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	650:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	651:     LD  4,-3(1)	Pop left into ac1 
												   >	652:    SUB  3,4,3	compute location from index 
												   >	653:     LD  3,0(3)	Load array element 
												   >	654:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	655:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	656:     LD  4,-3(1)	Pop left into ac1 
												   >	657:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	658:     LD  4,-2(1)	Pop left into ac1 
												   >	659:    AND  3,4,3	Op AND 
												   >	660:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	661:    LDA  3,-1(0)	Load address of base of array board
												   >	662:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	663:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	664:     LD  4,-3(1)	Pop left into ac1 
												   >	665:    SUB  3,4,3	compute location from index 
												   >	666:     LD  3,0(3)	Load array element 
												   >	667:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	668:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	669:     LD  4,-3(1)	Pop left into ac1 
												   >	670:    TEQ  3,4,3	Op = 
												   >	671:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	672:    LDA  3,-1(0)	Load address of base of array board
												   >	673:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	674:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	675:     LD  4,-4(1)	Pop left into ac1 
												   >	676:    SUB  3,4,3	compute location from index 
												   >	677:     LD  3,0(3)	Load array element 
												   >	678:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	679:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	680:     LD  4,-4(1)	Pop left into ac1 
												   >	681:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	682:     LD  4,-3(1)	Pop left into ac1 
												   >	683:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	684:     LD  4,-2(1)	Pop left into ac1 
												   >	685:     OR  3,4,3	Op OR 
												   >	686:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	687:    LDA  3,-1(0)	Load address of base of array board
												   >	688:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	689:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	690:     LD  4,-3(1)	Pop left into ac1 
												   >	691:    SUB  3,4,3	compute location from index 
												   >	692:     LD  3,0(3)	Load array element 
												   >	693:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	694:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	695:     LD  4,-3(1)	Pop left into ac1 
												   >	696:    TEQ  3,4,3	Op = 
												   >	697:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	698:    LDA  3,-1(0)	Load address of base of array board
												   >	699:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	700:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	701:     LD  4,-4(1)	Pop left into ac1 
												   >	702:    SUB  3,4,3	compute location from index 
												   >	703:     LD  3,0(3)	Load array element 
												   >	704:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	705:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	706:     LD  4,-4(1)	Pop left into ac1 
												   >	707:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	708:     LD  4,-3(1)	Pop left into ac1 
												   >	709:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	710:     LD  4,-2(1)	Pop left into ac1 
												   >	711:     OR  3,4,3	Op OR 
												   >	712:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	713:    LDA  3,-1(0)	Load address of base of array board
												   >	714:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	715:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	716:     LD  4,-3(1)	Pop left into ac1 
												   >	717:    SUB  3,4,3	compute location from index 
												   >	718:     LD  3,0(3)	Load array element 
												   >	719:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	720:    LDC  3,1(6)	Load integer constant 
												   >	721:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	722:     LD  4,-3(1)	Pop left into ac1 
												   >	723:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	724:     LD  4,-2(1)	Pop left into ac1 
												   >	725:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	727:    LDC  3,8(6)	Load integer constant 
												   >	728:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	729:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	730:     LD  4,-2(1)	Pop index 
												   >	731:    LDA  5,-1(0)	Load address of base of array board
												   >	732:    SUB  5,5,4	Compute offset of value 
												   >	733:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	734:    LDC  3,0(6)	Load Boolean constant 
												   >	735:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	726:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	737:    LDA  3,-1(0)	Load address of base of array board
												   >	738:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	739:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	740:     LD  4,-2(1)	Pop left into ac1 
												   >	741:    SUB  3,4,3	compute location from index 
												   >	742:     LD  3,0(3)	Load array element 
												   >	743:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	744:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	745:     LD  4,-2(1)	Pop left into ac1 
												   >	746:    TEQ  3,4,3	Op = 
												   >	747:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	748:    LDA  3,-1(0)	Load address of base of array board
												   >	749:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	750:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	751:     LD  4,-3(1)	Pop left into ac1 
												   >	752:    SUB  3,4,3	compute location from index 
												   >	753:     LD  3,0(3)	Load array element 
												   >	754:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	755:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	756:     LD  4,-3(1)	Pop left into ac1 
												   >	757:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	758:     LD  4,-2(1)	Pop left into ac1 
												   >	759:    AND  3,4,3	Op AND 
												   >	760:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	761:    LDA  3,-1(0)	Load address of base of array board
												   >	762:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	763:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	764:     LD  4,-3(1)	Pop left into ac1 
												   >	765:    SUB  3,4,3	compute location from index 
												   >	766:     LD  3,0(3)	Load array element 
												   >	767:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	768:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	769:     LD  4,-3(1)	Pop left into ac1 
												   >	770:    TEQ  3,4,3	Op = 
												   >	771:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	772:    LDA  3,-1(0)	Load address of base of array board
												   >	773:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	774:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	775:     LD  4,-4(1)	Pop left into ac1 
												   >	776:    SUB  3,4,3	compute location from index 
												   >	777:     LD  3,0(3)	Load array element 
												   >	778:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	779:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	780:     LD  4,-4(1)	Pop left into ac1 
												   >	781:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	782:     LD  4,-3(1)	Pop left into ac1 
												   >	783:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	784:     LD  4,-2(1)	Pop left into ac1 
												   >	785:     OR  3,4,3	Op OR 
												   >	786:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	787:    LDA  3,-1(0)	Load address of base of array board
												   >	788:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	789:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	790:     LD  4,-3(1)	Pop left into ac1 
												   >	791:    SUB  3,4,3	compute location from index 
												   >	792:     LD  3,0(3)	Load array element 
												   >	793:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	794:    LDC  3,1(6)	Load integer constant 
												   >	795:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	796:     LD  4,-3(1)	Pop left into ac1 
												   >	797:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	798:     LD  4,-2(1)	Pop left into ac1 
												   >	799:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	801:    LDC  3,7(6)	Load integer constant 
												   >	802:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	803:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	804:     LD  4,-2(1)	Pop index 
												   >	805:    LDA  5,-1(0)	Load address of base of array board
												   >	806:    SUB  5,5,4	Compute offset of value 
												   >	807:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	808:    LDC  3,0(6)	Load Boolean constant 
												   >	809:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	800:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	811:    LDA  3,-1(0)	Load address of base of array board
												   >	812:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	813:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	814:     LD  4,-2(1)	Pop left into ac1 
												   >	815:    SUB  3,4,3	compute location from index 
												   >	816:     LD  3,0(3)	Load array element 
												   >	817:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	818:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	819:     LD  4,-2(1)	Pop left into ac1 
												   >	820:    TEQ  3,4,3	Op = 
												   >	821:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	822:    LDA  3,-1(0)	Load address of base of array board
												   >	823:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	824:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	825:     LD  4,-3(1)	Pop left into ac1 
												   >	826:    SUB  3,4,3	compute location from index 
												   >	827:     LD  3,0(3)	Load array element 
												   >	828:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	829:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	830:     LD  4,-3(1)	Pop left into ac1 
												   >	831:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	832:     LD  4,-2(1)	Pop left into ac1 
												   >	833:    AND  3,4,3	Op AND 
												   >	834:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	835:    LDA  3,-1(0)	Load address of base of array board
												   >	836:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	837:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	838:     LD  4,-3(1)	Pop left into ac1 
												   >	839:    SUB  3,4,3	compute location from index 
												   >	840:     LD  3,0(3)	Load array element 
												   >	841:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	842:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	843:     LD  4,-3(1)	Pop left into ac1 
												   >	844:    TEQ  3,4,3	Op = 
												   >	845:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	846:    LDA  3,-1(0)	Load address of base of array board
												   >	847:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	848:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	849:     LD  4,-4(1)	Pop left into ac1 
												   >	850:    SUB  3,4,3	compute location from index 
												   >	851:     LD  3,0(3)	Load array element 
												   >	852:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	853:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	854:     LD  4,-4(1)	Pop left into ac1 
												   >	855:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	856:     LD  4,-3(1)	Pop left into ac1 
												   >	857:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	858:     LD  4,-2(1)	Pop left into ac1 
												   >	859:     OR  3,4,3	Op OR 
												   >	860:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	861:    LDA  3,-1(0)	Load address of base of array board
												   >	862:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	863:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	864:     LD  4,-3(1)	Pop left into ac1 
												   >	865:    SUB  3,4,3	compute location from index 
												   >	866:     LD  3,0(3)	Load array element 
												   >	867:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	868:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	869:     LD  4,-3(1)	Pop left into ac1 
												   >	870:    TEQ  3,4,3	Op = 
												   >	871:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	872:    LDA  3,-1(0)	Load address of base of array board
												   >	873:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	874:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	875:     LD  4,-4(1)	Pop left into ac1 
												   >	876:    SUB  3,4,3	compute location from index 
												   >	877:     LD  3,0(3)	Load array element 
												   >	878:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	879:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	880:     LD  4,-4(1)	Pop left into ac1 
												   >	881:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	882:     LD  4,-3(1)	Pop left into ac1 
												   >	883:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -2
												   >	884:     LD  4,-2(1)	Pop left into ac1 
												   >	885:     OR  3,4,3	Op OR 
												   >	886:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	887:    LDA  3,-1(0)	Load address of base of array board
												   >	888:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	889:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	890:     LD  4,-3(1)	Pop left into ac1 
												   >	891:    SUB  3,4,3	compute location from index 
												   >	892:     LD  3,0(3)	Load array element 
												   >	893:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	894:    LDC  3,1(6)	Load integer constant 
												   >	895:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	896:     LD  4,-3(1)	Pop left into ac1 
												   >	897:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -2
												   >	898:     LD  4,-2(1)	Pop left into ac1 
												   >	899:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	901:    LDC  3,6(6)	Load integer constant 
												   >	902:     ST  3,-2(1)	Push index 
												   >	* TOFF dec: -3
												   >	903:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -2
												   >	904:     LD  4,-2(1)	Pop index 
												   >	905:    LDA  5,-1(0)	Load address of base of array board
												   >	906:    SUB  5,5,4	Compute offset of value 
												   >	907:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	908:    LDC  3,0(6)	Load Boolean constant 
												   >	909:     ST  3,-10(0)	Store variable gamenotdone
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	900:    JZR  3,9(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	810:    JMP  7,99(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	736:    JMP  7,173(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	636:    JMP  7,273(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	562:    JMP  7,347(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	436:    JMP  7,473(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	362:    JMP  7,547(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	262:    JMP  7,647(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	188:    JMP  7,721(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	910:     LD  3,-10(0)	Load variable gamenotdone
												   >	911:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	912:    LDC  3,0(6)	Load Boolean constant 
												   >	* TOFF inc: -2
												   >	913:     LD  4,-2(1)	Pop left into ac1 
												   >	914:    TNE  3,4,3	Op >< 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* RETURN
												   >	916:    LDC  3,0(6)	Load Boolean constant 
												   >	917:    LDA  2,0(3)	Copy result to return register 
												   >	918:     LD  3,-1(1)	Load return address 
												   >	919:     LD  1,0(1)	Adjust fp 
												   >	920:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	915:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	921:    LDC  3,1(6)	Load Boolean constant 
												   >	922:    LDA  2,0(3)	Copy result to return register 
												   >	923:     LD  3,-1(1)	Load return address 
												   >	924:     LD  1,0(1)	Adjust fp 
												   >	925:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	926:    LDC  2,0(6)	Set return value to 0 
												   >	927:     LD  3,-1(1)	Load return address 
												   >	928:     LD  1,0(1)	Adjust fp 
												   >	929:    JMP  7,0(3)	Return 
												   >	* END FUNCTION win
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION blockplayer
												   >	* TOFF set: -2
												   >	930:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	931:    LDC  3,0(6)	Load Boolean constant 
												   >	932:     ST  3,-2(1)	Store variable blocked
												   >	* IF
												   >	933:    LDA  3,-1(0)	Load address of base of array board
												   >	934:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	935:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	936:     LD  4,-3(1)	Pop left into ac1 
												   >	937:    SUB  3,4,3	compute location from index 
												   >	938:     LD  3,0(3)	Load array element 
												   >	939:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	940:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	941:     LD  4,-3(1)	Pop left into ac1 
												   >	942:    TEQ  3,4,3	Op = 
												   >	943:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	944:    LDA  3,-1(0)	Load address of base of array board
												   >	945:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	946:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	947:     LD  4,-4(1)	Pop left into ac1 
												   >	948:    SUB  3,4,3	compute location from index 
												   >	949:     LD  3,0(3)	Load array element 
												   >	950:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	951:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	952:     LD  4,-4(1)	Pop left into ac1 
												   >	953:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	954:     LD  4,-3(1)	Pop left into ac1 
												   >	955:    AND  3,4,3	Op AND 
												   >	956:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	957:    LDA  3,-1(0)	Load address of base of array board
												   >	958:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	959:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	960:     LD  4,-4(1)	Pop left into ac1 
												   >	961:    SUB  3,4,3	compute location from index 
												   >	962:     LD  3,0(3)	Load array element 
												   >	963:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	964:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	965:     LD  4,-4(1)	Pop left into ac1 
												   >	966:    TEQ  3,4,3	Op = 
												   >	967:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	968:    LDA  3,-1(0)	Load address of base of array board
												   >	969:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	970:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	971:     LD  4,-5(1)	Pop left into ac1 
												   >	972:    SUB  3,4,3	compute location from index 
												   >	973:     LD  3,0(3)	Load array element 
												   >	974:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	975:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	976:     LD  4,-5(1)	Pop left into ac1 
												   >	977:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	978:     LD  4,-4(1)	Pop left into ac1 
												   >	979:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	980:     LD  4,-3(1)	Pop left into ac1 
												   >	981:     OR  3,4,3	Op OR 
												   >	982:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	983:    LDA  3,-1(0)	Load address of base of array board
												   >	984:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	985:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	986:     LD  4,-4(1)	Pop left into ac1 
												   >	987:    SUB  3,4,3	compute location from index 
												   >	988:     LD  3,0(3)	Load array element 
												   >	989:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	990:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	991:     LD  4,-4(1)	Pop left into ac1 
												   >	992:    TEQ  3,4,3	Op = 
												   >	993:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	994:    LDA  3,-1(0)	Load address of base of array board
												   >	995:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	996:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	997:     LD  4,-5(1)	Pop left into ac1 
												   >	998:    SUB  3,4,3	compute location from index 
												   >	999:     LD  3,0(3)	Load array element 
												   >	1000:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1001:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1002:     LD  4,-5(1)	Pop left into ac1 
												   >	1003:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1004:     LD  4,-4(1)	Pop left into ac1 
												   >	1005:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1006:     LD  4,-3(1)	Pop left into ac1 
												   >	1007:     OR  3,4,3	Op OR 
												   >	1008:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1009:    LDA  3,-1(0)	Load address of base of array board
												   >	1010:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1011:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1012:     LD  4,-4(1)	Pop left into ac1 
												   >	1013:    SUB  3,4,3	compute location from index 
												   >	1014:     LD  3,0(3)	Load array element 
												   >	1015:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1016:    LDC  3,1(6)	Load integer constant 
												   >	1017:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1018:     LD  4,-4(1)	Pop left into ac1 
												   >	1019:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1020:     LD  4,-3(1)	Pop left into ac1 
												   >	1021:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1023:    LDC  3,2(6)	Load integer constant 
												   >	1024:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1025:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1026:     LD  4,-3(1)	Pop index 
												   >	1027:    LDA  5,-1(0)	Load address of base of array board
												   >	1028:    SUB  5,5,4	Compute offset of value 
												   >	1029:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1030:    LDC  3,1(6)	Load Boolean constant 
												   >	1031:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1022:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1033:    LDA  3,-1(0)	Load address of base of array board
												   >	1034:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1035:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1036:     LD  4,-3(1)	Pop left into ac1 
												   >	1037:    SUB  3,4,3	compute location from index 
												   >	1038:     LD  3,0(3)	Load array element 
												   >	1039:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1040:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1041:     LD  4,-3(1)	Pop left into ac1 
												   >	1042:    TEQ  3,4,3	Op = 
												   >	1043:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1044:    LDA  3,-1(0)	Load address of base of array board
												   >	1045:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1046:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1047:     LD  4,-4(1)	Pop left into ac1 
												   >	1048:    SUB  3,4,3	compute location from index 
												   >	1049:     LD  3,0(3)	Load array element 
												   >	1050:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1051:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1052:     LD  4,-4(1)	Pop left into ac1 
												   >	1053:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1054:     LD  4,-3(1)	Pop left into ac1 
												   >	1055:    AND  3,4,3	Op AND 
												   >	1056:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1057:    LDA  3,-1(0)	Load address of base of array board
												   >	1058:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1059:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1060:     LD  4,-4(1)	Pop left into ac1 
												   >	1061:    SUB  3,4,3	compute location from index 
												   >	1062:     LD  3,0(3)	Load array element 
												   >	1063:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1064:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1065:     LD  4,-4(1)	Pop left into ac1 
												   >	1066:    TEQ  3,4,3	Op = 
												   >	1067:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1068:    LDA  3,-1(0)	Load address of base of array board
												   >	1069:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1070:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1071:     LD  4,-5(1)	Pop left into ac1 
												   >	1072:    SUB  3,4,3	compute location from index 
												   >	1073:     LD  3,0(3)	Load array element 
												   >	1074:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1075:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1076:     LD  4,-5(1)	Pop left into ac1 
												   >	1077:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1078:     LD  4,-4(1)	Pop left into ac1 
												   >	1079:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1080:     LD  4,-3(1)	Pop left into ac1 
												   >	1081:     OR  3,4,3	Op OR 
												   >	1082:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1083:    LDA  3,-1(0)	Load address of base of array board
												   >	1084:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1085:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1086:     LD  4,-4(1)	Pop left into ac1 
												   >	1087:    SUB  3,4,3	compute location from index 
												   >	1088:     LD  3,0(3)	Load array element 
												   >	1089:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1090:    LDC  3,1(6)	Load integer constant 
												   >	1091:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1092:     LD  4,-4(1)	Pop left into ac1 
												   >	1093:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1094:     LD  4,-3(1)	Pop left into ac1 
												   >	1095:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1097:    LDC  3,1(6)	Load integer constant 
												   >	1098:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1099:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1100:     LD  4,-3(1)	Pop index 
												   >	1101:    LDA  5,-1(0)	Load address of base of array board
												   >	1102:    SUB  5,5,4	Compute offset of value 
												   >	1103:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1104:    LDC  3,1(6)	Load Boolean constant 
												   >	1105:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1096:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1107:    LDA  3,-1(0)	Load address of base of array board
												   >	1108:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1109:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1110:     LD  4,-3(1)	Pop left into ac1 
												   >	1111:    SUB  3,4,3	compute location from index 
												   >	1112:     LD  3,0(3)	Load array element 
												   >	1113:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1114:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1115:     LD  4,-3(1)	Pop left into ac1 
												   >	1116:    TEQ  3,4,3	Op = 
												   >	1117:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1118:    LDA  3,-1(0)	Load address of base of array board
												   >	1119:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1120:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1121:     LD  4,-4(1)	Pop left into ac1 
												   >	1122:    SUB  3,4,3	compute location from index 
												   >	1123:     LD  3,0(3)	Load array element 
												   >	1124:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1125:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1126:     LD  4,-4(1)	Pop left into ac1 
												   >	1127:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1128:     LD  4,-3(1)	Pop left into ac1 
												   >	1129:    AND  3,4,3	Op AND 
												   >	1130:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1131:    LDA  3,-1(0)	Load address of base of array board
												   >	1132:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1133:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1134:     LD  4,-4(1)	Pop left into ac1 
												   >	1135:    SUB  3,4,3	compute location from index 
												   >	1136:     LD  3,0(3)	Load array element 
												   >	1137:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1138:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1139:     LD  4,-4(1)	Pop left into ac1 
												   >	1140:    TEQ  3,4,3	Op = 
												   >	1141:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1142:    LDA  3,-1(0)	Load address of base of array board
												   >	1143:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1144:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1145:     LD  4,-5(1)	Pop left into ac1 
												   >	1146:    SUB  3,4,3	compute location from index 
												   >	1147:     LD  3,0(3)	Load array element 
												   >	1148:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1149:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1150:     LD  4,-5(1)	Pop left into ac1 
												   >	1151:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1152:     LD  4,-4(1)	Pop left into ac1 
												   >	1153:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1154:     LD  4,-3(1)	Pop left into ac1 
												   >	1155:     OR  3,4,3	Op OR 
												   >	1156:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1157:    LDA  3,-1(0)	Load address of base of array board
												   >	1158:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1159:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1160:     LD  4,-4(1)	Pop left into ac1 
												   >	1161:    SUB  3,4,3	compute location from index 
												   >	1162:     LD  3,0(3)	Load array element 
												   >	1163:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1164:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1165:     LD  4,-4(1)	Pop left into ac1 
												   >	1166:    TEQ  3,4,3	Op = 
												   >	1167:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1168:    LDA  3,-1(0)	Load address of base of array board
												   >	1169:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1170:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1171:     LD  4,-5(1)	Pop left into ac1 
												   >	1172:    SUB  3,4,3	compute location from index 
												   >	1173:     LD  3,0(3)	Load array element 
												   >	1174:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1175:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1176:     LD  4,-5(1)	Pop left into ac1 
												   >	1177:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1178:     LD  4,-4(1)	Pop left into ac1 
												   >	1179:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1180:     LD  4,-3(1)	Pop left into ac1 
												   >	1181:     OR  3,4,3	Op OR 
												   >	1182:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1183:    LDA  3,-1(0)	Load address of base of array board
												   >	1184:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1185:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1186:     LD  4,-4(1)	Pop left into ac1 
												   >	1187:    SUB  3,4,3	compute location from index 
												   >	1188:     LD  3,0(3)	Load array element 
												   >	1189:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1190:    LDC  3,1(6)	Load integer constant 
												   >	1191:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1192:     LD  4,-4(1)	Pop left into ac1 
												   >	1193:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1194:     LD  4,-3(1)	Pop left into ac1 
												   >	1195:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1197:    LDC  3,0(6)	Load integer constant 
												   >	1198:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1199:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1200:     LD  4,-3(1)	Pop index 
												   >	1201:    LDA  5,-1(0)	Load address of base of array board
												   >	1202:    SUB  5,5,4	Compute offset of value 
												   >	1203:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1204:    LDC  3,1(6)	Load Boolean constant 
												   >	1205:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1196:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1207:    LDA  3,-1(0)	Load address of base of array board
												   >	1208:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1209:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1210:     LD  4,-3(1)	Pop left into ac1 
												   >	1211:    SUB  3,4,3	compute location from index 
												   >	1212:     LD  3,0(3)	Load array element 
												   >	1213:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1214:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1215:     LD  4,-3(1)	Pop left into ac1 
												   >	1216:    TEQ  3,4,3	Op = 
												   >	1217:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1218:    LDA  3,-1(0)	Load address of base of array board
												   >	1219:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1220:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1221:     LD  4,-4(1)	Pop left into ac1 
												   >	1222:    SUB  3,4,3	compute location from index 
												   >	1223:     LD  3,0(3)	Load array element 
												   >	1224:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1225:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1226:     LD  4,-4(1)	Pop left into ac1 
												   >	1227:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1228:     LD  4,-3(1)	Pop left into ac1 
												   >	1229:    AND  3,4,3	Op AND 
												   >	1230:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1231:    LDA  3,-1(0)	Load address of base of array board
												   >	1232:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1233:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1234:     LD  4,-4(1)	Pop left into ac1 
												   >	1235:    SUB  3,4,3	compute location from index 
												   >	1236:     LD  3,0(3)	Load array element 
												   >	1237:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1238:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1239:     LD  4,-4(1)	Pop left into ac1 
												   >	1240:    TEQ  3,4,3	Op = 
												   >	1241:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1242:    LDA  3,-1(0)	Load address of base of array board
												   >	1243:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1244:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1245:     LD  4,-5(1)	Pop left into ac1 
												   >	1246:    SUB  3,4,3	compute location from index 
												   >	1247:     LD  3,0(3)	Load array element 
												   >	1248:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1249:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1250:     LD  4,-5(1)	Pop left into ac1 
												   >	1251:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1252:     LD  4,-4(1)	Pop left into ac1 
												   >	1253:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1254:     LD  4,-3(1)	Pop left into ac1 
												   >	1255:     OR  3,4,3	Op OR 
												   >	1256:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1257:    LDA  3,-1(0)	Load address of base of array board
												   >	1258:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1259:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1260:     LD  4,-4(1)	Pop left into ac1 
												   >	1261:    SUB  3,4,3	compute location from index 
												   >	1262:     LD  3,0(3)	Load array element 
												   >	1263:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1264:    LDC  3,1(6)	Load integer constant 
												   >	1265:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1266:     LD  4,-4(1)	Pop left into ac1 
												   >	1267:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1268:     LD  4,-3(1)	Pop left into ac1 
												   >	1269:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1271:    LDC  3,5(6)	Load integer constant 
												   >	1272:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1273:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1274:     LD  4,-3(1)	Pop index 
												   >	1275:    LDA  5,-1(0)	Load address of base of array board
												   >	1276:    SUB  5,5,4	Compute offset of value 
												   >	1277:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1278:    LDC  3,1(6)	Load Boolean constant 
												   >	1279:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1270:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1281:    LDA  3,-1(0)	Load address of base of array board
												   >	1282:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1283:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1284:     LD  4,-3(1)	Pop left into ac1 
												   >	1285:    SUB  3,4,3	compute location from index 
												   >	1286:     LD  3,0(3)	Load array element 
												   >	1287:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1288:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1289:     LD  4,-3(1)	Pop left into ac1 
												   >	1290:    TEQ  3,4,3	Op = 
												   >	1291:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1292:    LDA  3,-1(0)	Load address of base of array board
												   >	1293:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1294:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1295:     LD  4,-4(1)	Pop left into ac1 
												   >	1296:    SUB  3,4,3	compute location from index 
												   >	1297:     LD  3,0(3)	Load array element 
												   >	1298:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1299:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1300:     LD  4,-4(1)	Pop left into ac1 
												   >	1301:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1302:     LD  4,-3(1)	Pop left into ac1 
												   >	1303:    AND  3,4,3	Op AND 
												   >	1304:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1305:    LDA  3,-1(0)	Load address of base of array board
												   >	1306:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1307:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1308:     LD  4,-4(1)	Pop left into ac1 
												   >	1309:    SUB  3,4,3	compute location from index 
												   >	1310:     LD  3,0(3)	Load array element 
												   >	1311:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1312:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1313:     LD  4,-4(1)	Pop left into ac1 
												   >	1314:    TEQ  3,4,3	Op = 
												   >	1315:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1316:    LDA  3,-1(0)	Load address of base of array board
												   >	1317:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1318:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1319:     LD  4,-5(1)	Pop left into ac1 
												   >	1320:    SUB  3,4,3	compute location from index 
												   >	1321:     LD  3,0(3)	Load array element 
												   >	1322:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1323:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1324:     LD  4,-5(1)	Pop left into ac1 
												   >	1325:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1326:     LD  4,-4(1)	Pop left into ac1 
												   >	1327:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1328:     LD  4,-3(1)	Pop left into ac1 
												   >	1329:     OR  3,4,3	Op OR 
												   >	1330:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1331:    LDA  3,-1(0)	Load address of base of array board
												   >	1332:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1333:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1334:     LD  4,-4(1)	Pop left into ac1 
												   >	1335:    SUB  3,4,3	compute location from index 
												   >	1336:     LD  3,0(3)	Load array element 
												   >	1337:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1338:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1339:     LD  4,-4(1)	Pop left into ac1 
												   >	1340:    TEQ  3,4,3	Op = 
												   >	1341:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1342:    LDA  3,-1(0)	Load address of base of array board
												   >	1343:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1344:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1345:     LD  4,-5(1)	Pop left into ac1 
												   >	1346:    SUB  3,4,3	compute location from index 
												   >	1347:     LD  3,0(3)	Load array element 
												   >	1348:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1349:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1350:     LD  4,-5(1)	Pop left into ac1 
												   >	1351:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1352:     LD  4,-4(1)	Pop left into ac1 
												   >	1353:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1354:     LD  4,-3(1)	Pop left into ac1 
												   >	1355:     OR  3,4,3	Op OR 
												   >	1356:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1357:    LDA  3,-1(0)	Load address of base of array board
												   >	1358:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1359:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1360:     LD  4,-4(1)	Pop left into ac1 
												   >	1361:    SUB  3,4,3	compute location from index 
												   >	1362:     LD  3,0(3)	Load array element 
												   >	1363:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1364:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1365:     LD  4,-4(1)	Pop left into ac1 
												   >	1366:    TEQ  3,4,3	Op = 
												   >	1367:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1368:    LDA  3,-1(0)	Load address of base of array board
												   >	1369:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1370:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1371:     LD  4,-5(1)	Pop left into ac1 
												   >	1372:    SUB  3,4,3	compute location from index 
												   >	1373:     LD  3,0(3)	Load array element 
												   >	1374:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1375:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1376:     LD  4,-5(1)	Pop left into ac1 
												   >	1377:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1378:     LD  4,-4(1)	Pop left into ac1 
												   >	1379:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1380:     LD  4,-3(1)	Pop left into ac1 
												   >	1381:     OR  3,4,3	Op OR 
												   >	1382:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1383:    LDA  3,-1(0)	Load address of base of array board
												   >	1384:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1385:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1386:     LD  4,-4(1)	Pop left into ac1 
												   >	1387:    SUB  3,4,3	compute location from index 
												   >	1388:     LD  3,0(3)	Load array element 
												   >	1389:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1390:    LDC  3,1(6)	Load integer constant 
												   >	1391:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1392:     LD  4,-4(1)	Pop left into ac1 
												   >	1393:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1394:     LD  4,-3(1)	Pop left into ac1 
												   >	1395:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1397:    LDC  3,4(6)	Load integer constant 
												   >	1398:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1399:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1400:     LD  4,-3(1)	Pop index 
												   >	1401:    LDA  5,-1(0)	Load address of base of array board
												   >	1402:    SUB  5,5,4	Compute offset of value 
												   >	1403:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1404:    LDC  3,1(6)	Load Boolean constant 
												   >	1405:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1396:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1407:    LDA  3,-1(0)	Load address of base of array board
												   >	1408:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1409:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1410:     LD  4,-3(1)	Pop left into ac1 
												   >	1411:    SUB  3,4,3	compute location from index 
												   >	1412:     LD  3,0(3)	Load array element 
												   >	1413:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1414:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1415:     LD  4,-3(1)	Pop left into ac1 
												   >	1416:    TEQ  3,4,3	Op = 
												   >	1417:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1418:    LDA  3,-1(0)	Load address of base of array board
												   >	1419:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1420:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1421:     LD  4,-4(1)	Pop left into ac1 
												   >	1422:    SUB  3,4,3	compute location from index 
												   >	1423:     LD  3,0(3)	Load array element 
												   >	1424:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1425:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1426:     LD  4,-4(1)	Pop left into ac1 
												   >	1427:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1428:     LD  4,-3(1)	Pop left into ac1 
												   >	1429:    AND  3,4,3	Op AND 
												   >	1430:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1431:    LDA  3,-1(0)	Load address of base of array board
												   >	1432:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1433:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1434:     LD  4,-4(1)	Pop left into ac1 
												   >	1435:    SUB  3,4,3	compute location from index 
												   >	1436:     LD  3,0(3)	Load array element 
												   >	1437:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1438:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1439:     LD  4,-4(1)	Pop left into ac1 
												   >	1440:    TEQ  3,4,3	Op = 
												   >	1441:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1442:    LDA  3,-1(0)	Load address of base of array board
												   >	1443:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1444:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1445:     LD  4,-5(1)	Pop left into ac1 
												   >	1446:    SUB  3,4,3	compute location from index 
												   >	1447:     LD  3,0(3)	Load array element 
												   >	1448:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1449:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1450:     LD  4,-5(1)	Pop left into ac1 
												   >	1451:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1452:     LD  4,-4(1)	Pop left into ac1 
												   >	1453:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1454:     LD  4,-3(1)	Pop left into ac1 
												   >	1455:     OR  3,4,3	Op OR 
												   >	1456:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1457:    LDA  3,-1(0)	Load address of base of array board
												   >	1458:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1459:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1460:     LD  4,-4(1)	Pop left into ac1 
												   >	1461:    SUB  3,4,3	compute location from index 
												   >	1462:     LD  3,0(3)	Load array element 
												   >	1463:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1464:    LDC  3,1(6)	Load integer constant 
												   >	1465:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1466:     LD  4,-4(1)	Pop left into ac1 
												   >	1467:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1468:     LD  4,-3(1)	Pop left into ac1 
												   >	1469:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1471:    LDC  3,3(6)	Load integer constant 
												   >	1472:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1473:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1474:     LD  4,-3(1)	Pop index 
												   >	1475:    LDA  5,-1(0)	Load address of base of array board
												   >	1476:    SUB  5,5,4	Compute offset of value 
												   >	1477:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1478:    LDC  3,1(6)	Load Boolean constant 
												   >	1479:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1470:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1481:    LDA  3,-1(0)	Load address of base of array board
												   >	1482:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1483:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1484:     LD  4,-3(1)	Pop left into ac1 
												   >	1485:    SUB  3,4,3	compute location from index 
												   >	1486:     LD  3,0(3)	Load array element 
												   >	1487:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1488:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1489:     LD  4,-3(1)	Pop left into ac1 
												   >	1490:    TEQ  3,4,3	Op = 
												   >	1491:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1492:    LDA  3,-1(0)	Load address of base of array board
												   >	1493:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1494:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1495:     LD  4,-4(1)	Pop left into ac1 
												   >	1496:    SUB  3,4,3	compute location from index 
												   >	1497:     LD  3,0(3)	Load array element 
												   >	1498:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1499:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1500:     LD  4,-4(1)	Pop left into ac1 
												   >	1501:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1502:     LD  4,-3(1)	Pop left into ac1 
												   >	1503:    AND  3,4,3	Op AND 
												   >	1504:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1505:    LDA  3,-1(0)	Load address of base of array board
												   >	1506:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1507:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1508:     LD  4,-4(1)	Pop left into ac1 
												   >	1509:    SUB  3,4,3	compute location from index 
												   >	1510:     LD  3,0(3)	Load array element 
												   >	1511:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1512:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1513:     LD  4,-4(1)	Pop left into ac1 
												   >	1514:    TEQ  3,4,3	Op = 
												   >	1515:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1516:    LDA  3,-1(0)	Load address of base of array board
												   >	1517:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1518:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1519:     LD  4,-5(1)	Pop left into ac1 
												   >	1520:    SUB  3,4,3	compute location from index 
												   >	1521:     LD  3,0(3)	Load array element 
												   >	1522:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1523:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1524:     LD  4,-5(1)	Pop left into ac1 
												   >	1525:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1526:     LD  4,-4(1)	Pop left into ac1 
												   >	1527:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1528:     LD  4,-3(1)	Pop left into ac1 
												   >	1529:     OR  3,4,3	Op OR 
												   >	1530:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1531:    LDA  3,-1(0)	Load address of base of array board
												   >	1532:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1533:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1534:     LD  4,-4(1)	Pop left into ac1 
												   >	1535:    SUB  3,4,3	compute location from index 
												   >	1536:     LD  3,0(3)	Load array element 
												   >	1537:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1538:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1539:     LD  4,-4(1)	Pop left into ac1 
												   >	1540:    TEQ  3,4,3	Op = 
												   >	1541:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1542:    LDA  3,-1(0)	Load address of base of array board
												   >	1543:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1544:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1545:     LD  4,-5(1)	Pop left into ac1 
												   >	1546:    SUB  3,4,3	compute location from index 
												   >	1547:     LD  3,0(3)	Load array element 
												   >	1548:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1549:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1550:     LD  4,-5(1)	Pop left into ac1 
												   >	1551:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1552:     LD  4,-4(1)	Pop left into ac1 
												   >	1553:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1554:     LD  4,-3(1)	Pop left into ac1 
												   >	1555:     OR  3,4,3	Op OR 
												   >	1556:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1557:    LDA  3,-1(0)	Load address of base of array board
												   >	1558:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1559:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1560:     LD  4,-4(1)	Pop left into ac1 
												   >	1561:    SUB  3,4,3	compute location from index 
												   >	1562:     LD  3,0(3)	Load array element 
												   >	1563:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1564:    LDC  3,1(6)	Load integer constant 
												   >	1565:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1566:     LD  4,-4(1)	Pop left into ac1 
												   >	1567:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1568:     LD  4,-3(1)	Pop left into ac1 
												   >	1569:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1571:    LDC  3,8(6)	Load integer constant 
												   >	1572:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1573:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1574:     LD  4,-3(1)	Pop index 
												   >	1575:    LDA  5,-1(0)	Load address of base of array board
												   >	1576:    SUB  5,5,4	Compute offset of value 
												   >	1577:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1578:    LDC  3,1(6)	Load Boolean constant 
												   >	1579:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1570:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1581:    LDA  3,-1(0)	Load address of base of array board
												   >	1582:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1583:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1584:     LD  4,-3(1)	Pop left into ac1 
												   >	1585:    SUB  3,4,3	compute location from index 
												   >	1586:     LD  3,0(3)	Load array element 
												   >	1587:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1588:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1589:     LD  4,-3(1)	Pop left into ac1 
												   >	1590:    TEQ  3,4,3	Op = 
												   >	1591:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1592:    LDA  3,-1(0)	Load address of base of array board
												   >	1593:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1594:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1595:     LD  4,-4(1)	Pop left into ac1 
												   >	1596:    SUB  3,4,3	compute location from index 
												   >	1597:     LD  3,0(3)	Load array element 
												   >	1598:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1599:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1600:     LD  4,-4(1)	Pop left into ac1 
												   >	1601:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1602:     LD  4,-3(1)	Pop left into ac1 
												   >	1603:    AND  3,4,3	Op AND 
												   >	1604:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1605:    LDA  3,-1(0)	Load address of base of array board
												   >	1606:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1607:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1608:     LD  4,-4(1)	Pop left into ac1 
												   >	1609:    SUB  3,4,3	compute location from index 
												   >	1610:     LD  3,0(3)	Load array element 
												   >	1611:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1612:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1613:     LD  4,-4(1)	Pop left into ac1 
												   >	1614:    TEQ  3,4,3	Op = 
												   >	1615:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1616:    LDA  3,-1(0)	Load address of base of array board
												   >	1617:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1618:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1619:     LD  4,-5(1)	Pop left into ac1 
												   >	1620:    SUB  3,4,3	compute location from index 
												   >	1621:     LD  3,0(3)	Load array element 
												   >	1622:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1623:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1624:     LD  4,-5(1)	Pop left into ac1 
												   >	1625:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1626:     LD  4,-4(1)	Pop left into ac1 
												   >	1627:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1628:     LD  4,-3(1)	Pop left into ac1 
												   >	1629:     OR  3,4,3	Op OR 
												   >	1630:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1631:    LDA  3,-1(0)	Load address of base of array board
												   >	1632:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1633:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1634:     LD  4,-4(1)	Pop left into ac1 
												   >	1635:    SUB  3,4,3	compute location from index 
												   >	1636:     LD  3,0(3)	Load array element 
												   >	1637:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1638:    LDC  3,1(6)	Load integer constant 
												   >	1639:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1640:     LD  4,-4(1)	Pop left into ac1 
												   >	1641:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1642:     LD  4,-3(1)	Pop left into ac1 
												   >	1643:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1645:    LDC  3,7(6)	Load integer constant 
												   >	1646:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1647:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1648:     LD  4,-3(1)	Pop index 
												   >	1649:    LDA  5,-1(0)	Load address of base of array board
												   >	1650:    SUB  5,5,4	Compute offset of value 
												   >	1651:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1652:    LDC  3,1(6)	Load Boolean constant 
												   >	1653:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1644:    JZR  3,10(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1655:    LDA  3,-1(0)	Load address of base of array board
												   >	1656:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1657:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1658:     LD  4,-3(1)	Pop left into ac1 
												   >	1659:    SUB  3,4,3	compute location from index 
												   >	1660:     LD  3,0(3)	Load array element 
												   >	1661:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1662:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1663:     LD  4,-3(1)	Pop left into ac1 
												   >	1664:    TEQ  3,4,3	Op = 
												   >	1665:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1666:    LDA  3,-1(0)	Load address of base of array board
												   >	1667:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1668:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1669:     LD  4,-4(1)	Pop left into ac1 
												   >	1670:    SUB  3,4,3	compute location from index 
												   >	1671:     LD  3,0(3)	Load array element 
												   >	1672:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1673:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1674:     LD  4,-4(1)	Pop left into ac1 
												   >	1675:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1676:     LD  4,-3(1)	Pop left into ac1 
												   >	1677:    AND  3,4,3	Op AND 
												   >	1678:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1679:    LDA  3,-1(0)	Load address of base of array board
												   >	1680:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1681:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1682:     LD  4,-4(1)	Pop left into ac1 
												   >	1683:    SUB  3,4,3	compute location from index 
												   >	1684:     LD  3,0(3)	Load array element 
												   >	1685:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1686:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1687:     LD  4,-4(1)	Pop left into ac1 
												   >	1688:    TEQ  3,4,3	Op = 
												   >	1689:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1690:    LDA  3,-1(0)	Load address of base of array board
												   >	1691:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1692:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1693:     LD  4,-5(1)	Pop left into ac1 
												   >	1694:    SUB  3,4,3	compute location from index 
												   >	1695:     LD  3,0(3)	Load array element 
												   >	1696:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1697:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1698:     LD  4,-5(1)	Pop left into ac1 
												   >	1699:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1700:     LD  4,-4(1)	Pop left into ac1 
												   >	1701:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1702:     LD  4,-3(1)	Pop left into ac1 
												   >	1703:     OR  3,4,3	Op OR 
												   >	1704:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1705:    LDA  3,-1(0)	Load address of base of array board
												   >	1706:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1707:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1708:     LD  4,-4(1)	Pop left into ac1 
												   >	1709:    SUB  3,4,3	compute location from index 
												   >	1710:     LD  3,0(3)	Load array element 
												   >	1711:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1712:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1713:     LD  4,-4(1)	Pop left into ac1 
												   >	1714:    TEQ  3,4,3	Op = 
												   >	1715:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1716:    LDA  3,-1(0)	Load address of base of array board
												   >	1717:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1718:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1719:     LD  4,-5(1)	Pop left into ac1 
												   >	1720:    SUB  3,4,3	compute location from index 
												   >	1721:     LD  3,0(3)	Load array element 
												   >	1722:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1723:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1724:     LD  4,-5(1)	Pop left into ac1 
												   >	1725:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1726:     LD  4,-4(1)	Pop left into ac1 
												   >	1727:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	1728:     LD  4,-3(1)	Pop left into ac1 
												   >	1729:     OR  3,4,3	Op OR 
												   >	1730:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1731:    LDA  3,-1(0)	Load address of base of array board
												   >	1732:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1733:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1734:     LD  4,-4(1)	Pop left into ac1 
												   >	1735:    SUB  3,4,3	compute location from index 
												   >	1736:     LD  3,0(3)	Load array element 
												   >	1737:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1738:    LDC  3,1(6)	Load integer constant 
												   >	1739:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -4
												   >	1740:     LD  4,-4(1)	Pop left into ac1 
												   >	1741:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1742:     LD  4,-3(1)	Pop left into ac1 
												   >	1743:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1745:    LDC  3,6(6)	Load integer constant 
												   >	1746:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	1747:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1748:     LD  4,-3(1)	Pop index 
												   >	1749:    LDA  5,-1(0)	Load address of base of array board
												   >	1750:    SUB  5,5,4	Compute offset of value 
												   >	1751:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1752:    LDC  3,1(6)	Load Boolean constant 
												   >	1753:     ST  3,-2(1)	Store variable blocked
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1744:    JZR  3,9(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1654:    JMP  7,99(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1580:    JMP  7,173(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1480:    JMP  7,273(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1406:    JMP  7,347(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1280:    JMP  7,473(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1206:    JMP  7,547(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1106:    JMP  7,647(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1032:    JMP  7,721(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	1754:     LD  3,-2(1)	Load variable blocked
												   >	1755:    LDA  2,0(3)	Copy result to return register 
												   >	1756:     LD  3,-1(1)	Load return address 
												   >	1757:     LD  1,0(1)	Adjust fp 
												   >	1758:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	1759:    LDC  2,0(6)	Set return value to 0 
												   >	1760:     LD  3,-1(1)	Load return address 
												   >	1761:     LD  1,0(1)	Adjust fp 
												   >	1762:    JMP  7,0(3)	Return 
												   >	* END FUNCTION blockplayer
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION placey
												   >	* TOFF set: -2
												   >	1763:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	* CALL win
												   >	1764:     ST  1,-2(1)	Store fp in ghost frame for win
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end win
												   >	1765:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	1766:    LDA  3,1(7)	Return address in ac 
												   >	1767:    JMP  7,-1680(7)	CALL win
												   >	1768:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end win
												   >	* TOFF set: -2
												   >	1769:    LDC  4,1(6)	Load 1 
												   >	1770:    XOR  3,3,4	Op XOR to get logical not 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* IF
												   >	* CALL blockplayer
												   >	1772:     ST  1,-2(1)	Store fp in ghost frame for blockplayer
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end blockplayer
												   >	1773:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	1774:    LDA  3,1(7)	Return address in ac 
												   >	1775:    JMP  7,-846(7)	CALL blockplayer
												   >	1776:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end blockplayer
												   >	* TOFF set: -2
												   >	1777:    LDC  4,1(6)	Load 1 
												   >	1778:    XOR  3,3,4	Op XOR to get logical not 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -2
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL move
												   >	1780:     ST  1,-2(1)	Store fp in ghost frame for move
												   >	* TOFF dec: -3
												   >	* TOFF dec: -4
												   >	* Param end move
												   >	1781:    LDA  1,-2(1)	Ghost frame becomes new active frame 
												   >	1782:    LDA  3,1(7)	Return address in ac 
												   >	1783:    JMP  7,-1745(7)	CALL move
												   >	1784:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end move
												   >	* TOFF set: -2
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	1779:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	1771:    JZR  3,13(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	1785:    LDC  2,0(6)	Set return value to 0 
												   >	1786:     LD  3,-1(1)	Load return address 
												   >	1787:     LD  1,0(1)	Adjust fp 
												   >	1788:    JMP  7,0(3)	Return 
												   >	* END FUNCTION placey
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION xingrid
												   >	* TOFF set: -3
												   >	1789:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1790:    LDC  3,0(6)	Load Boolean constant 
												   >	1791:     ST  3,-3(1)	Store variable retval
												   >	* IF
												   >	1792:     LD  3,-2(1)	Load variable x
												   >	1793:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1794:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1795:     LD  4,-4(1)	Pop left into ac1 
												   >	1796:    TGE  3,4,3	Op >= 
												   >	1797:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1798:     LD  3,-2(1)	Load variable x
												   >	1799:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1800:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1801:     LD  4,-5(1)	Pop left into ac1 
												   >	1802:    TLE  3,4,3	Op <= 
												   >	* TOFF inc: -4
												   >	1803:     LD  4,-4(1)	Pop left into ac1 
												   >	1804:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* IF
												   >	1806:    LDA  3,-1(0)	Load address of base of array board
												   >	1807:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1808:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -4
												   >	1809:     LD  4,-4(1)	Pop left into ac1 
												   >	1810:    SUB  3,4,3	compute location from index 
												   >	1811:     LD  3,0(3)	Load array element 
												   >	1812:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1813:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1814:     LD  4,-4(1)	Pop left into ac1 
												   >	1815:    TNE  3,4,3	Op >< 
												   >	1816:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1817:    LDA  3,-1(0)	Load address of base of array board
												   >	1818:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1819:     LD  3,-2(1)	Load variable x
												   >	* TOFF inc: -5
												   >	1820:     LD  4,-5(1)	Pop left into ac1 
												   >	1821:    SUB  3,4,3	compute location from index 
												   >	1822:     LD  3,0(3)	Load array element 
												   >	1823:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1824:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1825:     LD  4,-5(1)	Pop left into ac1 
												   >	1826:    TNE  3,4,3	Op >< 
												   >	* TOFF inc: -4
												   >	1827:     LD  4,-4(1)	Pop left into ac1 
												   >	1828:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1830:     LD  3,-2(1)	Load variable x
												   >	1831:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	1832:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1833:     LD  4,-4(1)	Pop index 
												   >	1834:    LDA  5,-1(0)	Load address of base of array board
												   >	1835:    SUB  5,5,4	Compute offset of value 
												   >	1836:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	1837:    LDC  3,1(6)	Load Boolean constant 
												   >	1838:     ST  3,-3(1)	Store variable retval
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	1829:    JZR  3,9(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	1805:    JZR  3,33(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* RETURN
												   >	1839:     LD  3,-3(1)	Load variable retval
												   >	1840:    LDA  2,0(3)	Copy result to return register 
												   >	1841:     LD  3,-1(1)	Load return address 
												   >	1842:     LD  1,0(1)	Adjust fp 
												   >	1843:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	1844:    LDC  2,0(6)	Set return value to 0 
												   >	1845:     LD  3,-1(1)	Load return address 
												   >	1846:     LD  1,0(1)	Adjust fp 
												   >	1847:    JMP  7,0(3)	Return 
												   >	* END FUNCTION xingrid
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION printboard
												   >	* TOFF set: -2
												   >	1848:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1849:    LDC  3,0(6)	Load integer constant 
												   >	1850:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	1851:     LD  3,-2(1)	Load variable i
												   >	1852:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1853:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1854:     LD  4,-3(1)	Pop left into ac1 
												   >	1855:    TLT  3,4,3	Op < 
												   >	1856:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* IF
												   >	1858:    LDA  3,-1(0)	Load address of base of array board
												   >	1859:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1860:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	1861:     LD  4,-3(1)	Pop left into ac1 
												   >	1862:    SUB  3,4,3	compute location from index 
												   >	1863:     LD  3,0(3)	Load array element 
												   >	1864:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1865:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1866:     LD  4,-3(1)	Pop left into ac1 
												   >	1867:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	1869:     ST  1,-3(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	1870:    LDC  3,1(6)	Load Boolean constant 
												   >	1871:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end outputb
												   >	1872:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	1873:    LDA  3,1(7)	Return address in ac 
												   >	1874:    JMP  7,-1858(7)	CALL outputb
												   >	1875:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1868:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* IF
												   >	1877:    LDA  3,-1(0)	Load address of base of array board
												   >	1878:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1879:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	1880:     LD  4,-3(1)	Pop left into ac1 
												   >	1881:    SUB  3,4,3	compute location from index 
												   >	1882:     LD  3,0(3)	Load array element 
												   >	1883:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1884:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1885:     LD  4,-3(1)	Pop left into ac1 
												   >	1886:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	1888:     ST  1,-3(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	1889:    LDC  3,0(6)	Load Boolean constant 
												   >	1890:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end outputb
												   >	1891:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	1892:    LDA  3,1(7)	Return address in ac 
												   >	1893:    JMP  7,-1877(7)	CALL outputb
												   >	1894:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1887:    JZR  3,8(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	1896:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	1897:     LD  3,-2(1)	Load variable i
												   >	1898:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	1899:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	1900:    LDA  3,1(7)	Return address in ac 
												   >	1901:    JMP  7,-1896(7)	CALL output
												   >	1902:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1895:    JMP  7,7(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	1876:    JMP  7,26(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* IF
												   >	1903:     LD  3,-2(1)	Load variable i
												   >	1904:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1905:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1906:     LD  4,-3(1)	Pop left into ac1 
												   >	1907:    TEQ  3,4,3	Op = 
												   >	1908:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1909:     LD  3,-2(1)	Load variable i
												   >	1910:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1911:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1912:     LD  4,-4(1)	Pop left into ac1 
												   >	1913:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1914:     LD  4,-3(1)	Pop left into ac1 
												   >	1915:     OR  3,4,3	Op OR 
												   >	1916:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1917:     LD  3,-2(1)	Load variable i
												   >	1918:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1919:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1920:     LD  4,-4(1)	Pop left into ac1 
												   >	1921:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	1922:     LD  4,-3(1)	Pop left into ac1 
												   >	1923:     OR  3,4,3	Op OR 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	1925:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	1926:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	1927:    LDA  3,1(7)	Return address in ac 
												   >	1928:    JMP  7,-1895(7)	CALL outnl
												   >	1929:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1924:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	1930:     LD  3,-2(1)	load lhs variable i
												   >	1931:    LDA  3,1(3)	increment value of i
												   >	1932:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	1933:    JMP  7,-83(7)	go to beginning of loop 
												   >	1857:    JMP  7,76(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	1934:    LDC  2,0(6)	Set return value to 0 
												   >	1935:     LD  3,-1(1)	Load return address 
												   >	1936:     LD  1,0(1)	Adjust fp 
												   >	1937:    JMP  7,0(3)	Return 
												   >	* END FUNCTION printboard
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION finished
												   >	* TOFF set: -2
												   >	1938:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	1939:    LDC  3,0(6)	Load integer constant 
												   >	1940:     ST  3,-2(1)	Store variable i
												   >	* IF
												   >	1941:    LDA  3,-1(0)	Load address of base of array board
												   >	1942:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1943:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	1944:     LD  4,-3(1)	Pop left into ac1 
												   >	1945:    SUB  3,4,3	compute location from index 
												   >	1946:     LD  3,0(3)	Load array element 
												   >	1947:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1948:    LDC  3,1(6)	Load integer constant 
												   >	1949:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	1950:     LD  4,-3(1)	Pop left into ac1 
												   >	1951:    TNE  3,4,3	Op >< 
												   >	1952:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	1953:    LDA  3,-1(0)	Load address of base of array board
												   >	1954:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1955:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	1956:     LD  4,-4(1)	Pop left into ac1 
												   >	1957:    SUB  3,4,3	compute location from index 
												   >	1958:     LD  3,0(3)	Load array element 
												   >	1959:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1960:    LDA  3,-1(0)	Load address of base of array board
												   >	1961:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1962:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1963:     LD  4,-5(1)	Pop left into ac1 
												   >	1964:    SUB  3,4,3	compute location from index 
												   >	1965:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	1966:     LD  4,-4(1)	Pop left into ac1 
												   >	1967:    TEQ  3,4,3	Op = 
												   >	1968:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1969:    LDA  3,-1(0)	Load address of base of array board
												   >	1970:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1971:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1972:     LD  4,-5(1)	Pop left into ac1 
												   >	1973:    SUB  3,4,3	compute location from index 
												   >	1974:     LD  3,0(3)	Load array element 
												   >	1975:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1976:    LDA  3,-1(0)	Load address of base of array board
												   >	1977:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	1978:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	1979:     LD  4,-6(1)	Pop left into ac1 
												   >	1980:    SUB  3,4,3	compute location from index 
												   >	1981:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	1982:     LD  4,-5(1)	Pop left into ac1 
												   >	1983:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	1984:     LD  4,-4(1)	Pop left into ac1 
												   >	1985:    AND  3,4,3	Op AND 
												   >	1986:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	1987:    LDA  3,-1(0)	Load address of base of array board
												   >	1988:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1989:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	1990:     LD  4,-5(1)	Pop left into ac1 
												   >	1991:    SUB  3,4,3	compute location from index 
												   >	1992:     LD  3,0(3)	Load array element 
												   >	1993:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	1994:    LDA  3,-1(0)	Load address of base of array board
												   >	1995:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	1996:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	1997:     LD  4,-6(1)	Pop left into ac1 
												   >	1998:    SUB  3,4,3	compute location from index 
												   >	1999:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2000:     LD  4,-5(1)	Pop left into ac1 
												   >	2001:    TEQ  3,4,3	Op = 
												   >	2002:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2003:    LDA  3,-1(0)	Load address of base of array board
												   >	2004:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2005:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2006:     LD  4,-6(1)	Pop left into ac1 
												   >	2007:    SUB  3,4,3	compute location from index 
												   >	2008:     LD  3,0(3)	Load array element 
												   >	2009:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2010:    LDA  3,-1(0)	Load address of base of array board
												   >	2011:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	2012:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	2013:     LD  4,-7(1)	Pop left into ac1 
												   >	2014:    SUB  3,4,3	compute location from index 
												   >	2015:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -6
												   >	2016:     LD  4,-6(1)	Pop left into ac1 
												   >	2017:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -5
												   >	2018:     LD  4,-5(1)	Pop left into ac1 
												   >	2019:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -4
												   >	2020:     LD  4,-4(1)	Pop left into ac1 
												   >	2021:     OR  3,4,3	Op OR 
												   >	2022:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2023:    LDA  3,-1(0)	Load address of base of array board
												   >	2024:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2025:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2026:     LD  4,-5(1)	Pop left into ac1 
												   >	2027:    SUB  3,4,3	compute location from index 
												   >	2028:     LD  3,0(3)	Load array element 
												   >	2029:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2030:    LDA  3,-1(0)	Load address of base of array board
												   >	2031:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2032:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2033:     LD  4,-6(1)	Pop left into ac1 
												   >	2034:    SUB  3,4,3	compute location from index 
												   >	2035:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2036:     LD  4,-5(1)	Pop left into ac1 
												   >	2037:    TEQ  3,4,3	Op = 
												   >	2038:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2039:    LDA  3,-1(0)	Load address of base of array board
												   >	2040:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2041:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2042:     LD  4,-6(1)	Pop left into ac1 
												   >	2043:    SUB  3,4,3	compute location from index 
												   >	2044:     LD  3,0(3)	Load array element 
												   >	2045:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2046:    LDA  3,-1(0)	Load address of base of array board
												   >	2047:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	2048:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	2049:     LD  4,-7(1)	Pop left into ac1 
												   >	2050:    SUB  3,4,3	compute location from index 
												   >	2051:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -6
												   >	2052:     LD  4,-6(1)	Pop left into ac1 
												   >	2053:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -5
												   >	2054:     LD  4,-5(1)	Pop left into ac1 
												   >	2055:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -4
												   >	2056:     LD  4,-4(1)	Pop left into ac1 
												   >	2057:     OR  3,4,3	Op OR 
												   >	* TOFF inc: -3
												   >	2058:     LD  4,-3(1)	Pop left into ac1 
												   >	2059:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2061:    LDC  3,1(6)	Load Boolean constant 
												   >	2062:    LDA  2,0(3)	Copy result to return register 
												   >	2063:     LD  3,-1(1)	Load return address 
												   >	2064:     LD  1,0(1)	Adjust fp 
												   >	2065:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2060:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	2066:    LDA  3,-1(0)	Load address of base of array board
												   >	2067:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2068:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2069:     LD  4,-3(1)	Pop left into ac1 
												   >	2070:    SUB  3,4,3	compute location from index 
												   >	2071:     LD  3,0(3)	Load array element 
												   >	2072:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2073:    LDC  3,1(6)	Load integer constant 
												   >	2074:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2075:     LD  4,-3(1)	Pop left into ac1 
												   >	2076:    TNE  3,4,3	Op >< 
												   >	2077:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2078:    LDA  3,-1(0)	Load address of base of array board
												   >	2079:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2080:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	2081:     LD  4,-4(1)	Pop left into ac1 
												   >	2082:    SUB  3,4,3	compute location from index 
												   >	2083:     LD  3,0(3)	Load array element 
												   >	2084:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2085:    LDA  3,-1(0)	Load address of base of array board
												   >	2086:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2087:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2088:     LD  4,-5(1)	Pop left into ac1 
												   >	2089:    SUB  3,4,3	compute location from index 
												   >	2090:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	2091:     LD  4,-4(1)	Pop left into ac1 
												   >	2092:    TEQ  3,4,3	Op = 
												   >	2093:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2094:    LDA  3,-1(0)	Load address of base of array board
												   >	2095:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2096:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2097:     LD  4,-5(1)	Pop left into ac1 
												   >	2098:    SUB  3,4,3	compute location from index 
												   >	2099:     LD  3,0(3)	Load array element 
												   >	2100:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2101:    LDA  3,-1(0)	Load address of base of array board
												   >	2102:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2103:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2104:     LD  4,-6(1)	Pop left into ac1 
												   >	2105:    SUB  3,4,3	compute location from index 
												   >	2106:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2107:     LD  4,-5(1)	Pop left into ac1 
												   >	2108:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	2109:     LD  4,-4(1)	Pop left into ac1 
												   >	2110:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	2111:     LD  4,-3(1)	Pop left into ac1 
												   >	2112:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2114:    LDC  3,1(6)	Load Boolean constant 
												   >	2115:    LDA  2,0(3)	Copy result to return register 
												   >	2116:     LD  3,-1(1)	Load return address 
												   >	2117:     LD  1,0(1)	Adjust fp 
												   >	2118:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2113:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	2119:    LDA  3,-1(0)	Load address of base of array board
												   >	2120:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2121:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2122:     LD  4,-3(1)	Pop left into ac1 
												   >	2123:    SUB  3,4,3	compute location from index 
												   >	2124:     LD  3,0(3)	Load array element 
												   >	2125:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2126:    LDC  3,1(6)	Load integer constant 
												   >	2127:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2128:     LD  4,-3(1)	Pop left into ac1 
												   >	2129:    TNE  3,4,3	Op >< 
												   >	2130:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2131:    LDA  3,-1(0)	Load address of base of array board
												   >	2132:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2133:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	2134:     LD  4,-4(1)	Pop left into ac1 
												   >	2135:    SUB  3,4,3	compute location from index 
												   >	2136:     LD  3,0(3)	Load array element 
												   >	2137:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2138:    LDA  3,-1(0)	Load address of base of array board
												   >	2139:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2140:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2141:     LD  4,-5(1)	Pop left into ac1 
												   >	2142:    SUB  3,4,3	compute location from index 
												   >	2143:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	2144:     LD  4,-4(1)	Pop left into ac1 
												   >	2145:    TEQ  3,4,3	Op = 
												   >	2146:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2147:    LDA  3,-1(0)	Load address of base of array board
												   >	2148:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2149:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2150:     LD  4,-5(1)	Pop left into ac1 
												   >	2151:    SUB  3,4,3	compute location from index 
												   >	2152:     LD  3,0(3)	Load array element 
												   >	2153:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2154:    LDA  3,-1(0)	Load address of base of array board
												   >	2155:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2156:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2157:     LD  4,-6(1)	Pop left into ac1 
												   >	2158:    SUB  3,4,3	compute location from index 
												   >	2159:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2160:     LD  4,-5(1)	Pop left into ac1 
												   >	2161:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	2162:     LD  4,-4(1)	Pop left into ac1 
												   >	2163:    AND  3,4,3	Op AND 
												   >	2164:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2165:    LDA  3,-1(0)	Load address of base of array board
												   >	2166:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2167:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2168:     LD  4,-5(1)	Pop left into ac1 
												   >	2169:    SUB  3,4,3	compute location from index 
												   >	2170:     LD  3,0(3)	Load array element 
												   >	2171:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2172:    LDA  3,-1(0)	Load address of base of array board
												   >	2173:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2174:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2175:     LD  4,-6(1)	Pop left into ac1 
												   >	2176:    SUB  3,4,3	compute location from index 
												   >	2177:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2178:     LD  4,-5(1)	Pop left into ac1 
												   >	2179:    TEQ  3,4,3	Op = 
												   >	2180:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2181:    LDA  3,-1(0)	Load address of base of array board
												   >	2182:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2183:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2184:     LD  4,-6(1)	Pop left into ac1 
												   >	2185:    SUB  3,4,3	compute location from index 
												   >	2186:     LD  3,0(3)	Load array element 
												   >	2187:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2188:    LDA  3,-1(0)	Load address of base of array board
												   >	2189:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	2190:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -7
												   >	2191:     LD  4,-7(1)	Pop left into ac1 
												   >	2192:    SUB  3,4,3	compute location from index 
												   >	2193:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -6
												   >	2194:     LD  4,-6(1)	Pop left into ac1 
												   >	2195:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -5
												   >	2196:     LD  4,-5(1)	Pop left into ac1 
												   >	2197:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -4
												   >	2198:     LD  4,-4(1)	Pop left into ac1 
												   >	2199:     OR  3,4,3	Op OR 
												   >	* TOFF inc: -3
												   >	2200:     LD  4,-3(1)	Pop left into ac1 
												   >	2201:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2203:    LDC  3,1(6)	Load Boolean constant 
												   >	2204:    LDA  2,0(3)	Copy result to return register 
												   >	2205:     LD  3,-1(1)	Load return address 
												   >	2206:     LD  1,0(1)	Adjust fp 
												   >	2207:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2202:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	2208:    LDA  3,-1(0)	Load address of base of array board
												   >	2209:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2210:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2211:     LD  4,-3(1)	Pop left into ac1 
												   >	2212:    SUB  3,4,3	compute location from index 
												   >	2213:     LD  3,0(3)	Load array element 
												   >	2214:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2215:    LDC  3,1(6)	Load integer constant 
												   >	2216:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2217:     LD  4,-3(1)	Pop left into ac1 
												   >	2218:    TNE  3,4,3	Op >< 
												   >	2219:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2220:    LDA  3,-1(0)	Load address of base of array board
												   >	2221:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2222:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	2223:     LD  4,-4(1)	Pop left into ac1 
												   >	2224:    SUB  3,4,3	compute location from index 
												   >	2225:     LD  3,0(3)	Load array element 
												   >	2226:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2227:    LDA  3,-1(0)	Load address of base of array board
												   >	2228:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2229:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2230:     LD  4,-5(1)	Pop left into ac1 
												   >	2231:    SUB  3,4,3	compute location from index 
												   >	2232:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	2233:     LD  4,-4(1)	Pop left into ac1 
												   >	2234:    TEQ  3,4,3	Op = 
												   >	2235:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2236:    LDA  3,-1(0)	Load address of base of array board
												   >	2237:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2238:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2239:     LD  4,-5(1)	Pop left into ac1 
												   >	2240:    SUB  3,4,3	compute location from index 
												   >	2241:     LD  3,0(3)	Load array element 
												   >	2242:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2243:    LDA  3,-1(0)	Load address of base of array board
												   >	2244:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2245:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2246:     LD  4,-6(1)	Pop left into ac1 
												   >	2247:    SUB  3,4,3	compute location from index 
												   >	2248:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2249:     LD  4,-5(1)	Pop left into ac1 
												   >	2250:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	2251:     LD  4,-4(1)	Pop left into ac1 
												   >	2252:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	2253:     LD  4,-3(1)	Pop left into ac1 
												   >	2254:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2256:    LDC  3,1(6)	Load Boolean constant 
												   >	2257:    LDA  2,0(3)	Copy result to return register 
												   >	2258:     LD  3,-1(1)	Load return address 
												   >	2259:     LD  1,0(1)	Adjust fp 
												   >	2260:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2255:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* IF
												   >	2261:    LDA  3,-1(0)	Load address of base of array board
												   >	2262:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2263:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2264:     LD  4,-3(1)	Pop left into ac1 
												   >	2265:    SUB  3,4,3	compute location from index 
												   >	2266:     LD  3,0(3)	Load array element 
												   >	2267:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2268:    LDC  3,1(6)	Load integer constant 
												   >	2269:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2270:     LD  4,-3(1)	Pop left into ac1 
												   >	2271:    TNE  3,4,3	Op >< 
												   >	2272:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2273:    LDA  3,-1(0)	Load address of base of array board
												   >	2274:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2275:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	2276:     LD  4,-4(1)	Pop left into ac1 
												   >	2277:    SUB  3,4,3	compute location from index 
												   >	2278:     LD  3,0(3)	Load array element 
												   >	2279:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2280:    LDA  3,-1(0)	Load address of base of array board
												   >	2281:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2282:    LDC  3,7(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2283:     LD  4,-5(1)	Pop left into ac1 
												   >	2284:    SUB  3,4,3	compute location from index 
												   >	2285:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -4
												   >	2286:     LD  4,-4(1)	Pop left into ac1 
												   >	2287:    TEQ  3,4,3	Op = 
												   >	2288:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2289:    LDA  3,-1(0)	Load address of base of array board
												   >	2290:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2291:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	2292:     LD  4,-5(1)	Pop left into ac1 
												   >	2293:    SUB  3,4,3	compute location from index 
												   >	2294:     LD  3,0(3)	Load array element 
												   >	2295:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	2296:    LDA  3,-1(0)	Load address of base of array board
												   >	2297:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	2298:    LDC  3,8(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	2299:     LD  4,-6(1)	Pop left into ac1 
												   >	2300:    SUB  3,4,3	compute location from index 
												   >	2301:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -5
												   >	2302:     LD  4,-5(1)	Pop left into ac1 
												   >	2303:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -4
												   >	2304:     LD  4,-4(1)	Pop left into ac1 
												   >	2305:    AND  3,4,3	Op AND 
												   >	* TOFF inc: -3
												   >	2306:     LD  4,-3(1)	Pop left into ac1 
												   >	2307:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2309:    LDC  3,1(6)	Load Boolean constant 
												   >	2310:    LDA  2,0(3)	Copy result to return register 
												   >	2311:     LD  3,-1(1)	Load return address 
												   >	2312:     LD  1,0(1)	Adjust fp 
												   >	2313:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2308:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* WHILE
												   >	2314:    LDA  3,-1(0)	Load address of base of array board
												   >	2315:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2316:     LD  3,-2(1)	Load variable i
												   >	* TOFF inc: -3
												   >	2317:     LD  4,-3(1)	Pop left into ac1 
												   >	2318:    SUB  3,4,3	compute location from index 
												   >	2319:     LD  3,0(3)	Load array element 
												   >	2320:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2321:    LDC  3,1(6)	Load integer constant 
												   >	2322:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2323:     LD  4,-3(1)	Pop left into ac1 
												   >	2324:    TNE  3,4,3	Op >< 
												   >	2325:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2326:     LD  3,-2(1)	Load variable i
												   >	2327:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2328:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	2329:     LD  4,-4(1)	Pop left into ac1 
												   >	2330:    TLT  3,4,3	Op < 
												   >	* TOFF inc: -3
												   >	2331:     LD  4,-3(1)	Pop left into ac1 
												   >	2332:    AND  3,4,3	Op AND 
												   >	2333:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	2335:     LD  3,-2(1)	load lhs variable i
												   >	2336:    LDA  3,1(3)	increment value of i
												   >	2337:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2338:    JMP  7,-25(7)	go to beginning of loop 
												   >	2334:    JMP  7,4(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* IF
												   >	2339:     LD  3,-2(1)	Load variable i
												   >	2340:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2341:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2342:     LD  4,-3(1)	Pop left into ac1 
												   >	2343:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2345:    LDC  3,1(6)	Load Boolean constant 
												   >	2346:    LDA  2,0(3)	Copy result to return register 
												   >	2347:     LD  3,-1(1)	Load return address 
												   >	2348:     LD  1,0(1)	Adjust fp 
												   >	2349:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2344:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* ELSE
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	2351:    LDC  3,0(6)	Load Boolean constant 
												   >	2352:    LDA  2,0(3)	Copy result to return register 
												   >	2353:     LD  3,-1(1)	Load return address 
												   >	2354:     LD  1,0(1)	Adjust fp 
												   >	2355:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2350:    JMP  7,5(7)	Jump around the ELSE [backpatch] 
												   >	* END IF
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	2356:    LDC  2,0(6)	Set return value to 0 
												   >	2357:     LD  3,-1(1)	Load return address 
												   >	2358:     LD  1,0(1)	Adjust fp 
												   >	2359:    JMP  7,0(3)	Return 
												   >	* END FUNCTION finished
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION playgame
												   >	* TOFF set: -2
												   >	2360:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	2361:    LDC  3,9(6)	Load integer constant 
												   >	2362:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	2363:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	2364:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2365:    LDA  3,1(7)	Return address in ac 
												   >	2366:    JMP  7,-2333(7)	CALL outnl
												   >	2367:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL printboard
												   >	2368:     ST  1,-3(1)	Store fp in ghost frame for printboard
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end printboard
												   >	2369:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2370:    LDA  3,1(7)	Return address in ac 
												   >	2371:    JMP  7,-524(7)	CALL printboard
												   >	2372:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printboard
												   >	* TOFF set: -3
												   >	* WHILE
												   >	* CALL finished
												   >	2373:     ST  1,-3(1)	Store fp in ghost frame for finished
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end finished
												   >	2374:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2375:    LDA  3,1(7)	Return address in ac 
												   >	2376:    JMP  7,-439(7)	CALL finished
												   >	2377:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end finished
												   >	* TOFF set: -3
												   >	2378:    LDC  4,1(6)	Load 1 
												   >	2379:    XOR  3,3,4	Op XOR to get logical not 
												   >	2380:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2381:     LD  3,-10(0)	Load variable gamenotdone
												   >	2382:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	2383:    LDC  3,1(6)	Load Boolean constant 
												   >	* TOFF inc: -4
												   >	2384:     LD  4,-4(1)	Pop left into ac1 
												   >	2385:    TEQ  3,4,3	Op = 
												   >	* TOFF inc: -3
												   >	2386:     LD  4,-3(1)	Pop left into ac1 
												   >	2387:    AND  3,4,3	Op AND 
												   >	2388:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	2390:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	2391:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2392:    LDA  3,1(7)	Return address in ac 
												   >	2393:    JMP  7,-2393(7)	CALL input
												   >	2394:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	2395:     ST  3,-2(1)	Store variable x
												   >	* IF
												   >	* CALL xingrid
												   >	2396:     ST  1,-3(1)	Store fp in ghost frame for xingrid
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	2397:     LD  3,-2(1)	Load variable x
												   >	2398:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end xingrid
												   >	2399:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2400:    LDA  3,1(7)	Return address in ac 
												   >	2401:    JMP  7,-613(7)	CALL xingrid
												   >	2402:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end xingrid
												   >	* TOFF set: -3
												   >	2403:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	* CALL finished
												   >	2404:     ST  1,-4(1)	Store fp in ghost frame for finished
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end finished
												   >	2405:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	2406:    LDA  3,1(7)	Return address in ac 
												   >	2407:    JMP  7,-470(7)	CALL finished
												   >	2408:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end finished
												   >	* TOFF set: -4
												   >	2409:    LDC  4,1(6)	Load 1 
												   >	2410:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -3
												   >	2411:     LD  4,-3(1)	Pop left into ac1 
												   >	2412:    AND  3,4,3	Op AND 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL placey
												   >	2414:     ST  1,-3(1)	Store fp in ghost frame for placey
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end placey
												   >	2415:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2416:    LDA  3,1(7)	Return address in ac 
												   >	2417:    JMP  7,-655(7)	CALL placey
												   >	2418:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end placey
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	2419:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	2420:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2421:    LDA  3,1(7)	Return address in ac 
												   >	2422:    JMP  7,-2389(7)	CALL outnl
												   >	2423:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL printboard
												   >	2424:     ST  1,-3(1)	Store fp in ghost frame for printboard
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end printboard
												   >	2425:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2426:    LDA  3,1(7)	Return address in ac 
												   >	2427:    JMP  7,-580(7)	CALL printboard
												   >	2428:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printboard
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	2429:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	2430:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2431:    LDA  3,1(7)	Return address in ac 
												   >	2432:    JMP  7,-2399(7)	CALL outnl
												   >	2433:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2413:    JZR  3,20(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2434:    JMP  7,-62(7)	go to beginning of loop 
												   >	2389:    JMP  7,45(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	2435:    LDC  2,0(6)	Set return value to 0 
												   >	2436:     LD  3,-1(1)	Load return address 
												   >	2437:     LD  1,0(1)	Adjust fp 
												   >	2438:    JMP  7,0(3)	Return 
												   >	* END FUNCTION playgame
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	2439:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	2440:    LDC  3,0(6)	Load integer constant 
												   >	2441:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	2442:     LD  3,-2(1)	Load variable i
												   >	2443:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	2444:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	2445:     LD  4,-3(1)	Pop left into ac1 
												   >	2446:    TLT  3,4,3	Op < 
												   >	2447:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	2449:     LD  3,-2(1)	Load variable i
												   >	2450:     ST  3,-3(1)	Push index 
												   >	* TOFF dec: -4
												   >	2451:    LDC  3,1(6)	Load integer constant 
												   >	2452:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -3
												   >	2453:     LD  4,-3(1)	Pop index 
												   >	2454:    LDA  5,-1(0)	Load address of base of array board
												   >	2455:    SUB  5,5,4	Compute offset of value 
												   >	2456:     ST  3,0(5)	Store variable board
												   >	* EXPRESSION
												   >	2457:     LD  3,-2(1)	load lhs variable i
												   >	2458:    LDA  3,1(3)	increment value of i
												   >	2459:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	2460:    JMP  7,-19(7)	go to beginning of loop 
												   >	2448:    JMP  7,12(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	2461:    LDC  3,1(6)	Load Boolean constant 
												   >	2462:     ST  3,-10(0)	Store variable gamenotdone
												   >	* EXPRESSION
												   >	* CALL playgame
												   >	2463:     ST  1,-3(1)	Store fp in ghost frame for playgame
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end playgame
												   >	2464:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2465:    LDA  3,1(7)	Return address in ac 
												   >	2466:    JMP  7,-107(7)	CALL playgame
												   >	2467:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end playgame
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	2468:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	2469:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2470:    LDA  3,1(7)	Return address in ac 
												   >	2471:    JMP  7,-2438(7)	CALL outnl
												   >	2472:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL printboard
												   >	2473:     ST  1,-3(1)	Store fp in ghost frame for printboard
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end printboard
												   >	2474:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2475:    LDA  3,1(7)	Return address in ac 
												   >	2476:    JMP  7,-629(7)	CALL printboard
												   >	2477:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printboard
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	2478:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	2479:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	2480:    LDA  3,1(7)	Return address in ac 
												   >	2481:    JMP  7,-2448(7)	CALL outnl
												   >	2482:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	2483:    LDC  2,0(6)	Set return value to 0 
												   >	2484:     LD  3,-1(1)	Load return address 
												   >	2485:     LD  1,0(1)	Adjust fp 
												   >	2486:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,2486(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	2487:    LDA  1,-11(0)	set first frame at end of globals 
												   >	2488:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	2489:    LDC  3,9(6)	load size of array board
												   >	2490:     ST  3,0(0)	save size of array board
												   >	* END INIT GLOBALS AND STATICS
												   >	2491:    LDA  3,1(7)	Return address in ac 
												   >	2492:    JMP  7,-54(7)	Jump to main 
												   >	2493:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
tictactoe.mem tictactoe.mem.f21 differ: byte 1, line 1
tictactoe (MEM DIFF)
Var: board of array of type int [mem: Global loc: -1 size: 10] [line: 27]			   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 28]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: move returns type void [mem: Global loc: 0 size: -2] [line: 30]		   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: board of array of type int [mem: Global loc: -1 size: 10] [line: 27]
												   >	Sibling: 8  Var: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 28]
												   >	Sibling: 9  Func: move returns type void [mem: Global loc: 0 size: -2] [line: 30]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 31]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 31]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 32]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 32]
.   .   Child: 1  Assign: = of type int [line: 33]						   |	.   .   Child: 1  Assign: := of type int [line: 33]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 33]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 33]
.   .   .   Child: 1  Const 0 of type int [line: 33]							.   .   .   Child: 1  Const 0 of type int [line: 33]
.   .   Sibling: 1  While [line: 35]									.   .   Sibling: 1  While [line: 35]
.   .   .   Child: 0  Op: < of type bool [line: 35]							.   .   .   Child: 0  Op: < of type bool [line: 35]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 35]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 35]
.   .   .   .   Child: 1  Const 9 of type int [line: 35]						.   .   .   .   Child: 1  Const 9 of type int [line: 35]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 35]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 35]
.   .   .   .   Child: 1  If [line: 36]									.   .   .   .   Child: 1  If [line: 36]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 36]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 36]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 36]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 36]
.   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 36]					.   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 36]
.   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 36]					.   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 36]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 36]
.   .   .   .   .   .   Child: 1  Break [line: 37]							.   .   .   .   .   .   Child: 1  Break [line: 37]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 39]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 39]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 39]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 39]
.   .   Sibling: 2  If [line: 42]									.   .   Sibling: 2  If [line: 42]
.   .   .   Child: 0  Op: < of type bool [line: 42]							.   .   .   Child: 0  Op: < of type bool [line: 42]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 42]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 42]
.   .   .   .   Child: 1  Const 9 of type int [line: 42]						.   .   .   .   Child: 1  Const 9 of type int [line: 42]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 42]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 42]
.   .   .   .   Child: 1  Assign: = of type int [line: 43]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 43]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 43]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 43]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 43]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 43]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 43]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 43]
.   .   .   .   Sibling: 1  Assign: = of type bool [line: 44]					   |	.   .   .   .   Sibling: 1  Assign: := of type bool [line: 44]
.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:	.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:
.   .   .   .   .   Child: 1  Const true of type bool [line: 44]					.   .   .   .   .   Child: 1  Const true of type bool [line: 44]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 46]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 46]
.   .   .   .   Child: 1  Assign: = of type bool [line: 47]					   |	.   .   .   .   Child: 1  Assign: := of type bool [line: 47]
.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:	.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:
.   .   .   .   .   Child: 1  Const false of type bool [line: 47]					.   .   .   .   .   Child: 1  Const false of type bool [line: 47]
Sibling: 3  Func: win returns type bool [mem: Global loc: 0 size: -2] [line: 52]		   |	Sibling: 10  Func: win returns type bool [mem: Global loc: 0 size: -2] [line: 52]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 53]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 53]
.   .   Child: 1  If [line: 54]										.   .   Child: 1  If [line: 54]
.   .   .   Child: 0  Op: and of type bool [line: 58]							.   .   .   Child: 0  Op: and of type bool [line: 58]
.   .   .   .   Child: 0  Op: or of type bool [line: 56]						.   .   .   .   Child: 0  Op: or of type bool [line: 56]
.   .   .   .   .   Child: 0  Op: or of type bool [line: 55]						.   .   .   .   .   Child: 0  Op: or of type bool [line: 55]
.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 54]					.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 54]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 54]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 54]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 54]
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 54]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 54]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 54]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 54]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 54]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 54]
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 54]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 54]
.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 55]					.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 55]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 55]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 55]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 55]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 55]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 55]				.   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 55]
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 55]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 55]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 55]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 55]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 55]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 55]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 55]				.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 55]
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 55]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 55]
.   .   .   .   .   Child: 1  Op: and of type bool [line: 56]						.   .   .   .   .   Child: 1  Op: and of type bool [line: 56]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 56]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 56]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 56]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 56]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 56]				.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 56]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 56]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 56]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 56]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 56]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 56]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 56]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 56]				.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 56]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 56]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 56]
.   .   .   .   Child: 1  Op: == of type bool [line: 58]					   |	.   .   .   .   Child: 1  Op: = of type bool [line: 58]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 58]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 58]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 58]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 58]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 58]						.   .   .   .   .   Child: 1  Op: chsign of type int [line: 58]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 58]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 58]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 58]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 58]
.   .   .   .   Child: 1  Assign: = of type int [line: 59]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 59]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 59]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 59]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 59]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 59]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 59]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 59]
.   .   .   .   Sibling: 1  Assign: = of type bool [line: 60]					   |	.   .   .   .   Sibling: 1  Assign: := of type bool [line: 60]
.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:	.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:
.   .   .   .   .   Child: 1  Const false of type bool [line: 60]					.   .   .   .   .   Child: 1  Const false of type bool [line: 60]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 62]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 62]
.   .   .   .   Child: 1  If [line: 63]									.   .   .   .   Child: 1  If [line: 63]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 65]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 65]
.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 64]					.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 64]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 63]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 63]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 63]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 63]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 63]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 63]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 63]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 63]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 63]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 63]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 63]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 63]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 63]
.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 64]					.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 64]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 64]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 64]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 64]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 64]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 64]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 64]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 64]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 64]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 64]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 64]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 64]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 64]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 64]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 64]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 64]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 64]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 65]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 65]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 65]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 65]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 65]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 65]
.   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 65]					.   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 65]
.   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 65]				.   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 65]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 65]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 65]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 66]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 66]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 66]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 66]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 66]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 66]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 66]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 66]
.   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 67]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 67]
.   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1	.   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1
.   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 67]				.   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 67]
.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 69]				.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 69]
.   .   .   .   .   .   Child: 1  If [line: 70]								.   .   .   .   .   .   Child: 1  If [line: 70]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 73]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 73]
.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 72]				.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 72]
.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 71]				.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 71]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 70]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 70]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 70]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 70]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 70]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 70]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 70]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 70]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 71]			.   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 71]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 71]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 71]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 71]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 71]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 71]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 71]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 71]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 71]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 71]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 71]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 71]
.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 72]				.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 72]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 72]		   |	.   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 72]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 72]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 72]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 72]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 72]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 72]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 72]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 72]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 72]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 72]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 72]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 72]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 72]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 72]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 72]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 73]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 73]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 73]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 73]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 73]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 73]
.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 73]				.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 73]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 73]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 73]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 73]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 73]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 74]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 74]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 74]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 74]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 74]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 74]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 74]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 74]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 75]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 75]
.   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10	.   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10
.   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 75]			.   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 75]
.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 77]			.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 77]
.   .   .   .   .   .   .   .   Child: 1  If [line: 78]							.   .   .   .   .   .   .   .   Child: 1  If [line: 78]
.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 80]				.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 80]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 79]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 79]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 78]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 78]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 78]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 78]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 78]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 78]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 78]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 78]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 78]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 78]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 79]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 79]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 79]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 79]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 79]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 79]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 79]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 80]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 80]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 80]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 80]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 80]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 80]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 80]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 80]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 80]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 80]
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 80]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 80]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 81]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 81]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 81]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 81]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 81]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 81]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 81]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 81]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 82]		   |	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 82]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 82]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 82]
.   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 84]		.   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line: 84]
.   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 85]						.   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 85]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 89]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 88]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 88]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 87]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 87]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 86]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 86]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 87	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 87
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line:   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line:   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 88]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 88]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 88]   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 88]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 8	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 8
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 88]   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 88]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 8	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 8
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 89]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 89]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 89]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 89]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 89]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 89]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 89]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 90]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 90]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 90]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 90]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 90]
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 91]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 91]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem:	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem:
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 91	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [line: 91
.   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -2] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 94]					.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 94]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 96]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 96]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 95]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 95]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 96]   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 96]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 9	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 9
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [li	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 9   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 9	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 9
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of type bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of type bool [
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 101]			.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 101]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type boo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type boo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bo   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type b
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gamenotdone of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const false of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 109]		.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 109]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: Non	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: Non
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of t   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := o
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gameno	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: gameno
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const fals	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const fals
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: Non	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: Non
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 116]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 116]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assi   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assi
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   Sibling: 1  If [line: 134]									.   .   Sibling: 1  If [line: 134]
.   .   .   Child: 0  Op: != of type bool [line: 134]						   |	.   .   .   Child: 0  Op: >< of type bool [line: 134]
.   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 134	.   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 134
.   .   .   .   Child: 1  Const false of type bool [line: 134]						.   .   .   .   Child: 1  Const false of type bool [line: 134]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 134]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 134]
.   .   .   .   Child: 1  Return [line: 135]								.   .   .   .   Child: 1  Return [line: 135]
.   .   .   .   .   Child: 0  Const false of type bool [line: 135]					.   .   .   .   .   Child: 0  Const false of type bool [line: 135]
.   .   Sibling: 2  Return [line: 138]									.   .   Sibling: 2  Return [line: 138]
.   .   .   Child: 0  Const true of type bool [line: 138]						.   .   .   Child: 0  Const true of type bool [line: 138]
Sibling: 4  Func: blockplayer returns type bool [mem: Global loc: 0 size: -2] [line: 141]	   |	Sibling: 11  Func: blockplayer returns type bool [mem: Global loc: 0 size: -2] [line: 141]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 142]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 142]
.   .   Child: 0  Var: blocked of type bool [mem: Local loc: -2 size: 1] [line: 143]			.   .   Child: 0  Var: blocked of type bool [mem: Local loc: -2 size: 1] [line: 143]
.   .   Child: 1  Assign: = of type bool [line: 144]						   |	.   .   Child: 1  Assign: := of type bool [line: 144]
.   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 144]			.   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 144]
.   .   .   Child: 1  Const false of type bool [line: 144]						.   .   .   Child: 1  Const false of type bool [line: 144]
.   .   Sibling: 1  If [line: 146]									.   .   Sibling: 1  If [line: 146]
.   .   .   Child: 0  Op: and of type bool [line: 149]							.   .   .   Child: 0  Op: and of type bool [line: 149]
.   .   .   .   Child: 0  Op: or of type bool [line: 148]						.   .   .   .   Child: 0  Op: or of type bool [line: 148]
.   .   .   .   .   Child: 0  Op: or of type bool [line: 147]						.   .   .   .   .   Child: 0  Op: or of type bool [line: 147]
.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 146]					.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 146]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 146]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 146]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 146]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 146]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 146]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 146]
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 146]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 146]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 146]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 146]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 146]
.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 147]					.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 147]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 147]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 147]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 147]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 147]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 147]				.   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 147]
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 147]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 147]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 147]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 147]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 147]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 147]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 147]				.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 147]
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 147]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 147]
.   .   .   .   .   Child: 1  Op: and of type bool [line: 148]						.   .   .   .   .   Child: 1  Op: and of type bool [line: 148]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 148]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 148]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 148]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 148]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 148]				.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 148]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 148]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 148]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 148]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 148]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 148]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 148]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 148]				.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 148]
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 148]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 148]
.   .   .   .   Child: 1  Op: == of type bool [line: 149]					   |	.   .   .   .   Child: 1  Op: = of type bool [line: 149]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 149]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 149]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 149]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 149]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 149]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 149]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 149]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 149]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 149]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 149]
.   .   .   .   Child: 1  Assign: = of type int [line: 150]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 150]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 150]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 150]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 150]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 150]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 150]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 150]
.   .   .   .   Sibling: 1  Assign: = of type bool [line: 151]					   |	.   .   .   .   Sibling: 1  Assign: := of type bool [line: 151]
.   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 151]		.   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 151]
.   .   .   .   .   Child: 1  Const true of type bool [line: 151]					.   .   .   .   .   Child: 1  Const true of type bool [line: 151]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 153]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 153]
.   .   .   .   Child: 1  If [line: 154]								.   .   .   .   Child: 1  If [line: 154]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 156]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 156]
.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 155]					.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 155]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 154]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 154]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 154]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 154]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 154]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 154]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 154]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 154]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 154]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 154]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 154]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 154]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 154]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 154]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 154]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 154]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 154]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 154]
.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 155]					.   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 155]
.   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 155]			   |	.   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 155]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 155]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 155]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 155]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 155]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 155]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 155]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 155]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 155]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 155]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 155]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 155]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 155]
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 155]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 155]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 156]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 156]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 156]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 156]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 156]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 156]
.   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 156]				.   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 156]
.   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 156]				.   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 156]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 156]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 156]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 157]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 157]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 157]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 157]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 157]				.   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 157]
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 157]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 157]
.   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 158]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 158]
.   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [lin	.   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [lin
.   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 158]				.   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 158]
.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 160]				.   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 160]
.   .   .   .   .   .   Child: 1  If [line: 161]							.   .   .   .   .   .   Child: 1  If [line: 161]
.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 164]					.   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 164]
.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 163]				.   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 163]
.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 162]				.   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 162]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 161]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 161]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 161]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 161]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 161]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 161]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 161]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 161]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 162]			.   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 162]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 162]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 162]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 162]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 162]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 162]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 162]		   |	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 162]			.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [me
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 162]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 162]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 162]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 162]
.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 163]				.   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 163]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 163]		   |	.   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 163]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 163]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 163]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 163]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 163]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 163]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 163]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 163]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 163]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 163]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 163]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 163]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 163]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 163]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 163]
.   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 164]			   |	.   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 164]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 164]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 164]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 164]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 164]
.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 164]			.   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 164]
.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 164]			.   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 164]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 164]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 164]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 165]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 165]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 165]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 165]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global lo
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 165]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 165]
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 165]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 165]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 166]			   |	.   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 166]
.   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size:	.   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size:
.   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 166]			.   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 166]
.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 168]			.   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 168]
.   .   .   .   .   .   .   .   Child: 1  If [line: 169]						.   .   .   .   .   .   .   .   Child: 1  If [line: 169]
.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 171]				.   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 171]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 170]			.   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 170]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 169]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 169]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 169]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 169	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 169
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 169]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 169]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 169]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 169]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 169	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 169
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 169]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 169]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 170]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 170]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 170]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 170	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 170
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 170]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 170]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 170]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 170]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 170	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 170
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 170]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 170]
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 171]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 171]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 171]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 171]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 171]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 171]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 171]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 171]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 171]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 171]
.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 171]		.   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 171]
.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 172]		   |	.   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 172]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 172]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 172]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G	.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: G
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 172]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 172]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 172]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 172]
.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 173]		   |	.   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 173]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: 	.   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 173]		.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 173]
.   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 175]		.   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 175]
.   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 176]					.   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 176]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 180]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 180]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 179]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 179]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 178]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 178]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 177	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 177
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 17	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 17
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line:   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line:   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 179]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line: 179]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 179   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 179]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 179   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 179]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 7 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 180]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 180]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 180]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 180]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 180	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 180
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 180]	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [line: 180]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 180	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [line: 180
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 181]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 181]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 181]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 181]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 181	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 181
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 181]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 181]
.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 182]	   |	.   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 182]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Loc	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [mem: Loc
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 182	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 182
.   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line	.   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 185]				.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 185]
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 187]		.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line: 187]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 186	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [line: 186
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 4 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 5 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 0 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 6 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 187   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 187]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [li	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type int [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int [line: 1   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int [line: 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line:
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type bool [lin
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of type bool [
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type bool [l
.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -	.   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -
.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 192]			.   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 192]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bool [line
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [l	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type bool [l
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type boo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type boo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of type bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type bool [l   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type bool [li
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 1 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of type int    |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of type int
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type int 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: board of a
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 8 of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type in
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of type bo   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := of type b
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of typ	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocked of typ
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 200]		.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 200]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of type bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or of type
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: == of type   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = of type 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: chsign
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: Non	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [mem: Non
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: = of t   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign: := of 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: [ of t
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: bo
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 2 of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: = of   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assign: := o
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocke	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id: blocke
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Const true
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: Non	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 2  Compound [mem: Non
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 207]	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  If [line: 207]
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: and of
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: or
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Chil
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: ==   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op: = 
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Compound [
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Assign
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Op
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assi   |	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Sibling: 1  Assi
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Id
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co	.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Co
.   .   Sibling: 2  Return [line: 225]									.   .   Sibling: 2  Return [line: 225]
.   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 225]			.   .   .   Child: 0  Id: blocked of type bool [mem: Local loc: -2 size: 1] [line: 225]
Sibling: 5  Func: placey returns type void [mem: Global loc: 0 size: -2] [line: 228]		   |	Sibling: 12  Func: placey returns type void [mem: Global loc: 0 size: -2] [line: 228]
.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 229]						.   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 229]
.   .   Child: 1  If [line: 231]									.   .   Child: 1  If [line: 231]
.   .   .   Child: 0  Op: not of type bool [line: 231]							.   .   .   Child: 0  Op: not of type bool [line: 231]
.   .   .   .   Child: 0  Call: win of type bool [line: 231]						.   .   .   .   Child: 0  Call: win of type bool [line: 231]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 231]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 231]
.   .   .   .   Child: 1  If [line: 232]								.   .   .   .   Child: 1  If [line: 232]
.   .   .   .   .   Child: 0  Op: not of type bool [line: 232]						.   .   .   .   .   Child: 0  Op: not of type bool [line: 232]
.   .   .   .   .   .   Child: 0  Call: blockplayer of type bool [line: 232]				.   .   .   .   .   .   Child: 0  Call: blockplayer of type bool [line: 232]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 232]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -2] [line: 232]
.   .   .   .   .   .   Child: 1  Call: move of type void [line: 233]					.   .   .   .   .   .   Child: 1  Call: move of type void [line: 233]
Sibling: 6  Func: xingrid returns type bool [mem: Global loc: 0 size: -3] [line: 239]		   |	Sibling: 13  Func: xingrid returns type bool [mem: Global loc: 0 size: -3] [line: 239]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 239]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 239]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 240]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 240]
.   .   Child: 0  Var: retval of type bool [mem: Local loc: -3 size: 1] [line: 241]			.   .   Child: 0  Var: retval of type bool [mem: Local loc: -3 size: 1] [line: 241]
.   .   Child: 1  Assign: = of type bool [line: 242]						   |	.   .   Child: 1  Assign: := of type bool [line: 242]
.   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line: 242]			.   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line: 242]
.   .   .   Child: 1  Const false of type bool [line: 242]						.   .   .   Child: 1  Const false of type bool [line: 242]
.   .   Sibling: 1  If [line: 244]									.   .   Sibling: 1  If [line: 244]
.   .   .   Child: 0  Op: and of type bool [line: 244]							.   .   .   Child: 0  Op: and of type bool [line: 244]
.   .   .   .   Child: 0  Op: >= of type bool [line: 244]						.   .   .   .   Child: 0  Op: >= of type bool [line: 244]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 244]		.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 244]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 244]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 244]
.   .   .   .   Child: 1  Op: <= of type bool [line: 244]						.   .   .   .   Child: 1  Op: <= of type bool [line: 244]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 244]		.   .   .   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 244]
.   .   .   .   .   Child: 1  Const 8 of type int [line: 244]						.   .   .   .   .   Child: 1  Const 8 of type int [line: 244]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 244]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 244]
.   .   .   .   Child: 1  If [line: 245]								.   .   .   .   Child: 1  If [line: 245]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 245]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 245]
.   .   .   .   .   .   Child: 0  Op: != of type bool [line: 245]				   |	.   .   .   .   .   .   Child: 0  Op: >< of type bool [line: 245]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 245]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 245]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 245]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 245]
.   .   .   .   .   .   Child: 1  Op: != of type bool [line: 245]				   |	.   .   .   .   .   .   Child: 1  Op: >< of type bool [line: 245]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 245]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 245]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 245]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 245]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 245]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 245]
.   .   .   .   .   .   Child: 1  Assign: = of type int [line: 246]				   |	.   .   .   .   .   .   Child: 1  Assign: := of type int [line: 246]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 246]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 246]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li	.   .   .   .   .   .   .   .   Child: 1  Id: x of type int [mem: Parameter loc: -2 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 246]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 246]
.   .   .   .   .   .   Sibling: 1  Assign: = of type bool [line: 247]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type bool [line: 247]
.   .   .   .   .   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line	.   .   .   .   .   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line
.   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 247]				.   .   .   .   .   .   .   Child: 1  Const true of type bool [line: 247]
.   .   Sibling: 2  Return [line: 251]									.   .   Sibling: 2  Return [line: 251]
.   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line: 251]			.   .   .   Child: 0  Id: retval of type bool [mem: Local loc: -3 size: 1] [line: 251]
Sibling: 7  Func: printboard returns type void [mem: Global loc: 0 size: -2] [line: 254]	   |	Sibling: 14  Func: printboard returns type void [mem: Global loc: 0 size: -2] [line: 254]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 255]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 255]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 256]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 256]
.   .   Child: 1  Assign: = of type int [line: 257]						   |	.   .   Child: 1  Assign: := of type int [line: 257]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 257]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 257]
.   .   .   Child: 1  Const 0 of type int [line: 257]							.   .   .   Child: 1  Const 0 of type int [line: 257]
.   .   Sibling: 1  While [line: 259]									.   .   Sibling: 1  While [line: 259]
.   .   .   Child: 0  Op: < of type bool [line: 259]							.   .   .   Child: 0  Op: < of type bool [line: 259]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 259]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 259]
.   .   .   .   Child: 1  Const 9 of type int [line: 259]						.   .   .   .   Child: 1  Const 9 of type int [line: 259]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 259]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 259]
.   .   .   .   Child: 1  If [line: 260]								.   .   .   .   Child: 1  If [line: 260]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 260]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 260]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 260]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 260]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 260]	.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 260]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 260]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 260]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 260]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 260]
.   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 261]				.   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 261]
.   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 261]				.   .   .   .   .   .   .   Child: 0  Const true of type bool [line: 261]
.   .   .   .   .   Child: 2  If [line: 263]								.   .   .   .   .   Child: 2  If [line: 263]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 263]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 263]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 263]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 263]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 263]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 263]
.   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 263]			.   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 263]
.   .   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 264]				.   .   .   .   .   .   .   Child: 1  Call: outputb of type void [line: 264]
.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 264]				.   .   .   .   .   .   .   .   Child: 0  Const false of type bool [line: 264]
.   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 266]			.   .   .   .   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 266]
.   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 267]				.   .   .   .   .   .   .   Child: 1  Call: output of type void [line: 267]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   Sibling: 1  If [line: 269]								.   .   .   .   Sibling: 1  If [line: 269]
.   .   .   .   .   Child: 0  Op: or of type bool [line: 269]						.   .   .   .   .   Child: 0  Op: or of type bool [line: 269]
.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 269]					.   .   .   .   .   .   Child: 0  Op: or of type bool [line: 269]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 269]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 269]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 269]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 269]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 269]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 269]
.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 269]				.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 269]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 269]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 269]
.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 269]	.   .   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 269]
.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 269]					.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 269]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 269]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 269]
.   .   .   .   .   .   Child: 1  Call: outnl of type void [line: 270]					.   .   .   .   .   .   Child: 1  Call: outnl of type void [line: 270]
.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 272]						.   .   .   .   Sibling: 2  Assign: ++ of type int [line: 272]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 272]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 272]
Sibling: 8  Func: finished returns type bool [mem: Global loc: 0 size: -2] [line: 277]		   |	Sibling: 15  Func: finished returns type bool [mem: Global loc: 0 size: -2] [line: 277]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 278]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 278]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 279]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 279]
.   .   Child: 1  Assign: = of type int [line: 281]						   |	.   .   Child: 1  Assign: := of type int [line: 281]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 281]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 281]
.   .   .   Child: 1  Const 0 of type int [line: 281]							.   .   .   Child: 1  Const 0 of type int [line: 281]
.   .   Sibling: 1  If [line: 283]									.   .   Sibling: 1  If [line: 283]
.   .   .   Child: 0  Op: and of type bool [line: 283]							.   .   .   Child: 0  Op: and of type bool [line: 283]
.   .   .   .   Child: 0  Op: != of type bool [line: 283]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 283]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 283]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 283]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 283]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 283]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 283]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 283]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 283]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 283]
.   .   .   .   Child: 1  Op: or of type bool [line: 287]						.   .   .   .   Child: 1  Op: or of type bool [line: 287]
.   .   .   .   .   Child: 0  Op: or of type bool [line: 285]						.   .   .   .   .   Child: 0  Op: or of type bool [line: 285]
.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 284]					.   .   .   .   .   .   Child: 0  Op: and of type bool [line: 284]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 283]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 283]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 283]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 283]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 283]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 283]
.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 283]					.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 283]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 283]				.   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 283]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 284]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 284]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 284]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 284]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 284]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 284]
.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 284]					.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 284]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 284]				.   .   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 284]
.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 286]					.   .   .   .   .   .   Child: 1  Op: and of type bool [line: 286]
.   .   .   .   .   .   .   Child: 0  Op: == of type bool [line: 285]				   |	.   .   .   .   .   .   .   Child: 0  Op: = of type bool [line: 285]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 285]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 285]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 285]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 285]
.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 285]					.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 285]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 285]				.   .   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 285]
.   .   .   .   .   .   .   Child: 1  Op: == of type bool [line: 286]				   |	.   .   .   .   .   .   .   Child: 1  Op: = of type bool [line: 286]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 286]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 286]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 286]				.   .   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 286]
.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 286]					.   .   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 286]
.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -	.   .   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -
.   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 286]				.   .   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 286]
.   .   .   .   .   Child: 1  Op: and of type bool [line: 288]						.   .   .   .   .   Child: 1  Op: and of type bool [line: 288]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 287]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 287]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 287]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 287]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 287]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 287]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 287]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 287]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 287]				.   .   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 287]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 288]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 288]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 288]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 288]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 288]				.   .   .   .   .   .   .   .   Child: 1  Const 0 of type int [line: 288]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 288]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 288]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 288]				.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 288]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 288]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 288]
.   .   .   .   Child: 1  Return [line: 289]								.   .   .   .   Child: 1  Return [line: 289]
.   .   .   .   .   Child: 0  Const true of type bool [line: 289]					.   .   .   .   .   Child: 0  Const true of type bool [line: 289]
.   .   Sibling: 2  If [line: 292]									.   .   Sibling: 2  If [line: 292]
.   .   .   Child: 0  Op: and of type bool [line: 293]							.   .   .   Child: 0  Op: and of type bool [line: 293]
.   .   .   .   Child: 0  Op: != of type bool [line: 292]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 292]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 292]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 292]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 292]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 292]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 292]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 292]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 292]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 292]
.   .   .   .   Child: 1  Op: and of type bool [line: 293]						.   .   .   .   Child: 1  Op: and of type bool [line: 293]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 293]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 293]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 293]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 293]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 293]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 293]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 293]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 293]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 293]					.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 293]
.   .   .   .   .   Child: 1  Op: == of type bool [line: 293]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 293]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 293]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 293]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 293]					.   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 293]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 293]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 293]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 293]					.   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 293]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 293]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 293]
.   .   .   .   Child: 1  Return [line: 294]								.   .   .   .   Child: 1  Return [line: 294]
.   .   .   .   .   Child: 0  Const true of type bool [line: 294]					.   .   .   .   .   Child: 0  Const true of type bool [line: 294]
.   .   Sibling: 3  If [line: 297]									.   .   Sibling: 3  If [line: 297]
.   .   .   Child: 0  Op: and of type bool [line: 297]							.   .   .   Child: 0  Op: and of type bool [line: 297]
.   .   .   .   Child: 0  Op: != of type bool [line: 297]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 297]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 297]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 297]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 297]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 297]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 297]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 297]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 297]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 297]
.   .   .   .   Child: 1  Op: or of type bool [line: 299]						.   .   .   .   Child: 1  Op: or of type bool [line: 299]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 298]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 298]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 297]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 297]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 297]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 297]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 297]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 297]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 297]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 297]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 297]				.   .   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 297]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 298]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 298]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 298]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 298]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 298]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 298]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 298]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 298]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 298]				.   .   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 298]
.   .   .   .   .   Child: 1  Op: and of type bool [line: 300]						.   .   .   .   .   Child: 1  Op: and of type bool [line: 300]
.   .   .   .   .   .   Child: 0  Op: == of type bool [line: 299]				   |	.   .   .   .   .   .   Child: 0  Op: = of type bool [line: 299]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 299]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 299]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 299]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 299]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 299]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 299]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 299]				.   .   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 299]
.   .   .   .   .   .   Child: 1  Op: == of type bool [line: 300]				   |	.   .   .   .   .   .   Child: 1  Op: = of type bool [line: 300]
.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 300]					.   .   .   .   .   .   .   Child: 0  Op: [ of type int [line: 300]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 300]				.   .   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 300]
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 300]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 300]
.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si	.   .   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 si
.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 300]				.   .   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 300]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 300]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 300]
.   .   .   .   Child: 1  Return [line: 301]								.   .   .   .   Child: 1  Return [line: 301]
.   .   .   .   .   Child: 0  Const true of type bool [line: 301]					.   .   .   .   .   Child: 0  Const true of type bool [line: 301]
.   .   Sibling: 4  If [line: 304]									.   .   Sibling: 4  If [line: 304]
.   .   .   Child: 0  Op: and of type bool [line: 305]							.   .   .   Child: 0  Op: and of type bool [line: 305]
.   .   .   .   Child: 0  Op: != of type bool [line: 304]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 304]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 304]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 304]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 304]					.   .   .   .   .   .   Child: 1  Const 3 of type int [line: 304]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 304]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 304]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 304]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 304]
.   .   .   .   Child: 1  Op: and of type bool [line: 305]						.   .   .   .   Child: 1  Op: and of type bool [line: 305]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 305]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 305]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 305]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 305]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 305]					.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 305]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 305]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 305]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 305]					.   .   .   .   .   .   .   Child: 1  Const 4 of type int [line: 305]
.   .   .   .   .   Child: 1  Op: == of type bool [line: 305]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 305]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 305]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 305]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 305]					.   .   .   .   .   .   .   Child: 1  Const 3 of type int [line: 305]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 305]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 305]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 305]					.   .   .   .   .   .   .   Child: 1  Const 5 of type int [line: 305]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 305]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 305]
.   .   .   .   Child: 1  Return [line: 306]								.   .   .   .   Child: 1  Return [line: 306]
.   .   .   .   .   Child: 0  Const true of type bool [line: 306]					.   .   .   .   .   Child: 0  Const true of type bool [line: 306]
.   .   Sibling: 5  If [line: 309]									.   .   Sibling: 5  If [line: 309]
.   .   .   Child: 0  Op: and of type bool [line: 310]							.   .   .   Child: 0  Op: and of type bool [line: 310]
.   .   .   .   Child: 0  Op: != of type bool [line: 309]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 309]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 309]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 309]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 309]					.   .   .   .   .   .   Child: 1  Const 6 of type int [line: 309]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 309]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 309]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 309]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 309]
.   .   .   .   Child: 1  Op: and of type bool [line: 310]						.   .   .   .   Child: 1  Op: and of type bool [line: 310]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 310]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 310]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 310]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 310]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 310]					.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 310]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 310]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 310]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 310]					.   .   .   .   .   .   .   Child: 1  Const 7 of type int [line: 310]
.   .   .   .   .   Child: 1  Op: == of type bool [line: 310]					   |	.   .   .   .   .   Child: 1  Op: = of type bool [line: 310]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 310]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 310]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 310]					.   .   .   .   .   .   .   Child: 1  Const 6 of type int [line: 310]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 310]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 310]
.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 	.   .   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 
.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 310]					.   .   .   .   .   .   .   Child: 1  Const 8 of type int [line: 310]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 310]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 310]
.   .   .   .   Child: 1  Return [line: 311]								.   .   .   .   Child: 1  Return [line: 311]
.   .   .   .   .   Child: 0  Const true of type bool [line: 311]					.   .   .   .   .   Child: 0  Const true of type bool [line: 311]
.   .   Sibling: 6  While [line: 314]									.   .   Sibling: 6  While [line: 314]
.   .   .   Child: 0  Op: and of type bool [line: 314]							.   .   .   Child: 0  Op: and of type bool [line: 314]
.   .   .   .   Child: 0  Op: != of type bool [line: 314]					   |	.   .   .   .   Child: 0  Op: >< of type bool [line: 314]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 314]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 314]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 314]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 314]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 314]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 314]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 314]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 314]
.   .   .   .   Child: 1  Op: < of type bool [line: 314]						.   .   .   .   Child: 1  Op: < of type bool [line: 314]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 314]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 314]
.   .   .   .   .   Child: 1  Const 9 of type int [line: 314]						.   .   .   .   .   Child: 1  Const 9 of type int [line: 314]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 314]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 314]
.   .   .   .   Child: 1  Assign: ++ of type int [line: 315]						.   .   .   .   Child: 1  Assign: ++ of type int [line: 315]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 315]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 315]
.   .   Sibling: 7  If [line: 318]									.   .   Sibling: 7  If [line: 318]
.   .   .   Child: 0  Op: == of type bool [line: 318]						   |	.   .   .   Child: 0  Op: = of type bool [line: 318]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 318]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 318]
.   .   .   .   Child: 1  Const 9 of type int [line: 318]						.   .   .   .   Child: 1  Const 9 of type int [line: 318]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 318]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 318]
.   .   .   .   Child: 1  Return [line: 319]								.   .   .   .   Child: 1  Return [line: 319]
.   .   .   .   .   Child: 0  Const true of type bool [line: 319]					.   .   .   .   .   Child: 0  Const true of type bool [line: 319]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 321]					.   .   .   Child: 2  Compound [mem: None loc: 0 size: -3] [line: 321]
.   .   .   .   Child: 1  Return [line: 322]								.   .   .   .   Child: 1  Return [line: 322]
.   .   .   .   .   Child: 0  Const false of type bool [line: 322]					.   .   .   .   .   Child: 0  Const false of type bool [line: 322]
Sibling: 9  Func: playgame returns type void [mem: Global loc: 0 size: -2] [line: 326]		   |	Sibling: 16  Func: playgame returns type void [mem: Global loc: 0 size: -2] [line: 326]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 327]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 327]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 328]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 328]
.   .   Child: 1  Assign: = of type int [line: 329]						   |	.   .   Child: 1  Assign: := of type int [line: 329]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 329]			.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 329]
.   .   .   Child: 1  Const 9 of type int [line: 329]							.   .   .   Child: 1  Const 9 of type int [line: 329]
.   .   Sibling: 1  Call: outnl of type void [line: 331]						.   .   Sibling: 1  Call: outnl of type void [line: 331]
.   .   Sibling: 2  Call: printboard of type void [line: 332]						.   .   Sibling: 2  Call: printboard of type void [line: 332]
.   .   Sibling: 3  While [line: 334]									.   .   Sibling: 3  While [line: 334]
.   .   .   Child: 0  Op: and of type bool [line: 334]							.   .   .   Child: 0  Op: and of type bool [line: 334]
.   .   .   .   Child: 0  Op: not of type bool [line: 334]						.   .   .   .   Child: 0  Op: not of type bool [line: 334]
.   .   .   .   .   Child: 0  Call: finished of type bool [line: 334]					.   .   .   .   .   Child: 0  Call: finished of type bool [line: 334]
.   .   .   .   Child: 1  Op: == of type bool [line: 334]					   |	.   .   .   .   Child: 1  Op: = of type bool [line: 334]
.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:	.   .   .   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line:
.   .   .   .   .   Child: 1  Const true of type bool [line: 334]					.   .   .   .   .   Child: 1  Const true of type bool [line: 334]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 334]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 334]
.   .   .   .   Child: 1  Assign: = of type int [line: 335]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 335]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 335]		.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 335]
.   .   .   .   .   Child: 1  Call: input of type int [line: 335]					.   .   .   .   .   Child: 1  Call: input of type int [line: 335]
.   .   .   .   Sibling: 1  If [line: 337]								.   .   .   .   Sibling: 1  If [line: 337]
.   .   .   .   .   Child: 0  Op: and of type bool [line: 337]						.   .   .   .   .   Child: 0  Op: and of type bool [line: 337]
.   .   .   .   .   .   Child: 0  Call: xingrid of type bool [line: 337]				.   .   .   .   .   .   Child: 0  Call: xingrid of type bool [line: 337]
.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 337]	.   .   .   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 337]
.   .   .   .   .   .   Child: 1  Op: not of type bool [line: 337]					.   .   .   .   .   .   Child: 1  Op: not of type bool [line: 337]
.   .   .   .   .   .   .   Child: 0  Call: finished of type bool [line: 337]				.   .   .   .   .   .   .   Child: 0  Call: finished of type bool [line: 337]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 337]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 337]
.   .   .   .   .   .   Child: 1  Call: placey of type void [line: 338]					.   .   .   .   .   .   Child: 1  Call: placey of type void [line: 338]
.   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 339]				.   .   .   .   .   .   Sibling: 1  Call: outnl of type void [line: 339]
.   .   .   .   .   .   Sibling: 2  Call: printboard of type void [line: 340]				.   .   .   .   .   .   Sibling: 2  Call: printboard of type void [line: 340]
.   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 341]				.   .   .   .   .   .   Sibling: 3  Call: outnl of type void [line: 341]
Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 346]		   |	Sibling: 17  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 346]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 347]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 347]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 348]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 348]
.   .   Child: 1  Assign: = of type int [line: 349]						   |	.   .   Child: 1  Assign: := of type int [line: 349]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 349]			.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 349]
.   .   .   Child: 1  Const 0 of type int [line: 349]							.   .   .   Child: 1  Const 0 of type int [line: 349]
.   .   Sibling: 1  While [line: 351]									.   .   Sibling: 1  While [line: 351]
.   .   .   Child: 0  Op: < of type bool [line: 351]							.   .   .   Child: 0  Op: < of type bool [line: 351]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 351]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 351]
.   .   .   .   Child: 1  Const 9 of type int [line: 351]						.   .   .   .   Child: 1  Const 9 of type int [line: 351]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 351]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 351]
.   .   .   .   Child: 1  Assign: = of type int [line: 352]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 352]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 352]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 352]
.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 	.   .   .   .   .   .   Child: 0  Id: board of array of type int [mem: Global loc: -1 size: 10] 
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 352]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -2 size: 1] [line: 352]
.   .   .   .   .   Child: 1  Op: chsign of type int [line: 352]					.   .   .   .   .   Child: 1  Op: chsign of type int [line: 352]
.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 352]					.   .   .   .   .   .   Child: 0  Const 1 of type int [line: 352]
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 353]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 353]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 353]		.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 353]
.   .   Sibling: 2  Assign: = of type bool [line: 356]						   |	.   .   Sibling: 2  Assign: := of type bool [line: 356]
.   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 356]		.   .   .   Child: 0  Id: gamenotdone of type bool [mem: Global loc: -10 size: 1] [line: 356]
.   .   .   Child: 1  Const true of type bool [line: 356]						.   .   .   Child: 1  Const true of type bool [line: 356]
.   .   Sibling: 3  Call: playgame of type void [line: 357]						.   .   Sibling: 3  Call: playgame of type void [line: 357]
.   .   Sibling: 4  Call: outnl of type void [line: 359]						.   .   Sibling: 4  Call: outnl of type void [line: 359]
.   .   Sibling: 5  Call: printboard of type void [line: 360]						.   .   Sibling: 5  Call: printboard of type void [line: 360]
.   .   Sibling: 6  Call: outnl of type void [line: 361]						.   .   Sibling: 6  Call: outnl of type void [line: 361]
Offset for end of global space: -11									Offset for end of global space: -11
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
tictactoe.out ztmp23114.txt differ: byte 1, line 1
tictactoe (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/tictactoe.tm
Number of errors: 0										   |	0 1 2
------------------------------------								   |	3 4 5
Loading file: tictactoe.tm									   |	6 7 8
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 4 unknown.									   |	T F 2
ERROR: TM Command 6 unknown.									   |	3 4 5
ERROR: TM Command 3 unknown.									   |	6 7 8
												   >	entered: 4
												   >	T F 2
												   >	3 T 5
												   >	6 7 F
												   >	entered: 6
												   >	T F F
												   >	3 T 5
												   >	T 7 F
												   >	entered: 3
												   >	T F F
												   >	T T 5
												   >	T 7 F
Bye.													Bye.
====================================
FILE: tiny3.c-
-rw-------. 1 corg7983 domain_users  246 Nov 17 15:35 tiny3.c-
-rw-------. 1 corg7983 domain_users  249 Nov 17 15:35 tiny3.c-.f21
-rw-------. 1 corg7983 domain_users  246 Nov 17 15:35 tiny3.c-.f22
-rw-------. 1 corg7983 domain_users  146 Nov 17 15:35 tiny3.expected
-rw-------. 1 corg7983 domain_users 2404 Nov 22 12:27 tiny3.mem
-rw-------. 1 corg7983 domain_users  359 Nov 17 15:35 tiny3.mem.diffs
-rw-------. 1 corg7983 domain_users 3249 Nov 17 15:35 tiny3.mem.f21
-rw-------. 1 corg7983 domain_users  210 Nov 22 12:27 tiny3.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 tiny3.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 tiny3.tm.diffs
-rw-------. 1 corg7983 domain_users 5877 Nov 17 15:35 tiny3.tm.f21
TM CODE COMPARISON
tiny3 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  tiny3.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION wolf
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	 40:     LD  3,-2(1)	Load variable garion
												   >	 41:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 42:     LD  3,0(0)	Load variable g
												   >	* TOFF inc: -4
												   >	 43:     LD  4,-4(1)	Pop left into ac1 
												   >	 44:    ADD  3,4,3	Op + 
												   >	 45:    LDA  2,0(3)	Copy result to return register 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 49:    LDC  2,0(6)	Set return value to 0 
												   >	 50:     LD  3,-1(1)	Load return address 
												   >	 51:     LD  1,0(1)	Adjust fp 
												   >	 52:    JMP  7,0(3)	Return 
												   >	* END FUNCTION wolf
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION polgara
												   >	* TOFF set: -3
												   >	 53:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* RETURN
												   >	 54:     LD  3,-2(1)	Load variable silk
												   >	 55:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 56:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 57:     LD  4,-4(1)	Pop left into ac1 
												   >	 58:    ADD  3,4,3	Op + 
												   >	 59:    LDA  2,0(3)	Copy result to return register 
												   >	 60:     LD  3,-1(1)	Load return address 
												   >	 61:     LD  1,0(1)	Adjust fp 
												   >	 62:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 63:    LDC  2,0(6)	Set return value to 0 
												   >	 64:     LD  3,-1(1)	Load return address 
												   >	 65:     LD  1,0(1)	Adjust fp 
												   >	 66:    JMP  7,0(3)	Return 
												   >	* END FUNCTION polgara
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 67:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 68:    LDC  3,33(6)	Load integer constant 
												   >	 69:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	 70:    LDC  3,666(6)	Load integer constant 
												   >	 71:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL wolf
												   >	 72:     ST  1,-3(1)	Store fp in ghost frame for wolf
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	* CALL polgara
												   >	 73:     ST  1,-5(1)	Store fp in ghost frame for polgara
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	 74:     LD  3,-2(1)	Load variable x
												   >	 75:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end polgara
												   >	 76:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	 77:    LDA  3,1(7)	Return address in ac 
												   >	 78:    JMP  7,-26(7)	CALL polgara
												   >	 79:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end polgara
												   >	* TOFF set: -5
												   >	 80:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end wolf
												   >	 81:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 82:    LDA  3,1(7)	Return address in ac 
												   >	 83:    JMP  7,-45(7)	CALL wolf
												   >	 84:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end wolf
												   >	* TOFF set: -3
												   >	 85:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 86:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 87:     LD  3,-2(1)	Load variable x
												   >	 88:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 89:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-86(7)	CALL output
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 93:    LDC  2,0(6)	Set return value to 0 
												   >	 94:     LD  3,-1(1)	Load return address 
												   >	 95:     LD  1,0(1)	Adjust fp 
												   >	 96:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,96(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 97:    LDA  1,-1(0)	set first frame at end of globals 
												   >	 98:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 99:    LDA  3,1(7)	Return address in ac 
												   >	100:    JMP  7,-34(7)	Jump to main 
												   >	101:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
tiny3.mem tiny3.mem.f21 differ: byte 104, line 3
tiny3 (MEM DIFF)
WARNING(4): The variable 'w' seems not to be used.							WARNING(4): The variable 'w' seems not to be used.
WARNING(10): The variable 'p' seems not to be used.							WARNING(10): The variable 'p' seems not to be used.
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: wolf returns type int [mem: Global loc: 0 size: -3] [line: 2]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Func: wolf returns type int [mem: Global loc: 0 size: -3] [line: 2]
.   Child: 0  Parm: garion of type int [mem: Parameter loc: -2 size: 1] [line: 2]			.   Child: 0  Parm: garion of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 3]
.   .   Child: 0  Var: w of type int [mem: Local loc: -3 size: 1] [line: 4]				.   .   Child: 0  Var: w of type int [mem: Local loc: -3 size: 1] [line: 4]
.   .   Child: 1  Return [line: 5]									.   .   Child: 1  Return [line: 5]
.   .   .   Child: 0  Op: + of type int [line: 5]							.   .   .   Child: 0  Op: + of type int [line: 5]
.   .   .   .   Child: 0  Id: garion of type int [mem: Parameter loc: -2 size: 1] [line: 5]		.   .   .   .   Child: 0  Id: garion of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 5]			.   .   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 5]
Sibling: 2  Func: polgara returns type int [mem: Global loc: 0 size: -3] [line: 8]		   |	Sibling: 9  Func: polgara returns type int [mem: Global loc: 0 size: -3] [line: 8]
.   Child: 0  Parm: silk of type int [mem: Parameter loc: -2 size: 1] [line: 8]				.   Child: 0  Parm: silk of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 9]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 9]
.   .   Child: 0  Var: p of type int [mem: Local loc: -3 size: 1] [line: 10]				.   .   Child: 0  Var: p of type int [mem: Local loc: -3 size: 1] [line: 10]
.   .   Child: 1  Return [line: 11]									.   .   Child: 1  Return [line: 11]
.   .   .   Child: 0  Op: + of type int [line: 11]							.   .   .   Child: 0  Op: + of type int [line: 11]
.   .   .   .   Child: 0  Id: silk of type int [mem: Parameter loc: -2 size: 1] [line: 11]		.   .   .   .   Child: 0  Id: silk of type int [mem: Parameter loc: -2 size: 1] [line: 11]
.   .   .   .   Child: 1  Const 1 of type int [line: 11]						.   .   .   .   Child: 1  Const 1 of type int [line: 11]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 14]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 15]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 15]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 16]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 16]
.   .   Child: 1  Assign: = of type int [line: 17]						   |	.   .   Child: 1  Assign: := of type int [line: 17]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 17]
.   .   .   Child: 1  Const 33 of type int [line: 17]							.   .   .   Child: 1  Const 33 of type int [line: 17]
.   .   Sibling: 1  Assign: = of type int [line: 18]						   |	.   .   Sibling: 1  Assign: := of type int [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 18]
.   .   .   Child: 1  Const 666 of type int [line: 18]							.   .   .   Child: 1  Const 666 of type int [line: 18]
.   .   Sibling: 2  Assign: = of type int [line: 19]						   |	.   .   Sibling: 2  Assign: := of type int [line: 19]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   .   Child: 1  Call: wolf of type int [line: 19]							.   .   .   Child: 1  Call: wolf of type int [line: 19]
.   .   .   .   Child: 0  Call: polgara of type int [line: 19]						.   .   .   .   Child: 0  Call: polgara of type int [line: 19]
.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]			.   .   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 19]
.   .   Sibling: 3  Call: output of type void [line: 20]						.   .   Sibling: 3  Call: output of type void [line: 20]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 20]
Offset for end of global space: -1									Offset for end of global space: -1
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
tiny3.out ztmp23114.txt differ: byte 104, line 3
tiny3 (Output DIFF)
WARNING(4): The variable 'w' seems not to be used.							WARNING(4): The variable 'w' seems not to be used.
WARNING(10): The variable 'p' seems not to be used.							WARNING(10): The variable 'p' seems not to be used.
Number of warnings: 2										   |	Loading file: BroadTests/tiny3.tm
Number of errors: 0										   |	700
------------------------------------								   <
Loading file: tiny3.tm										   <
Bye.													Bye.
====================================
FILE: tiny.c-
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 tiny.c-
-rw-------. 1 corg7983 domain_users  147 Nov 17 15:35 tiny.c-.f21
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 tiny.c-.f22
-rw-------. 1 corg7983 domain_users   98 Nov 17 15:35 tiny.expected
-rw-------. 1 corg7983 domain_users 1299 Nov 22 12:27 tiny.mem
-rw-------. 1 corg7983 domain_users  236 Nov 17 15:35 tiny.mem.diffs
-rw-------. 1 corg7983 domain_users 2142 Nov 17 15:35 tiny.mem.f21
-rw-------. 1 corg7983 domain_users  163 Nov 22 12:27 tiny.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 tiny.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 tiny.tm.diffs
-rw-------. 1 corg7983 domain_users 4762 Nov 17 15:35 tiny.tm.f21
TM CODE COMPARISON
tiny (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  tiny.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION wolf
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* RETURN
												   >	 40:    LDC  3,42(6)	Load integer constant 
												   >	 41:    LDA  2,0(3)	Copy result to return register 
												   >	 42:     LD  3,-1(1)	Load return address 
												   >	 43:     LD  1,0(1)	Adjust fp 
												   >	 44:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 45:    LDC  2,0(6)	Set return value to 0 
												   >	 46:     LD  3,-1(1)	Load return address 
												   >	 47:     LD  1,0(1)	Adjust fp 
												   >	 48:    JMP  7,0(3)	Return 
												   >	* END FUNCTION wolf
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 49:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 50:    LDC  3,666(6)	Load integer constant 
												   >	 51:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL wolf
												   >	 52:     ST  1,-3(1)	Store fp in ghost frame for wolf
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 53:     LD  3,-2(1)	Load variable x
												   >	 54:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end wolf
												   >	 55:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-19(7)	CALL wolf
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end wolf
												   >	* TOFF set: -3
												   >	 59:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	* CALL output
												   >	 60:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 61:     LD  3,-2(1)	Load variable x
												   >	 62:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 63:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 64:    LDA  3,1(7)	Return address in ac 
												   >	 65:    JMP  7,-60(7)	CALL output
												   >	 66:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 67:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 68:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 69:    LDA  3,1(7)	Return address in ac 
												   >	 70:    JMP  7,-37(7)	CALL outnl
												   >	 71:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 72:    LDC  2,0(6)	Set return value to 0 
												   >	 73:     LD  3,-1(1)	Load return address 
												   >	 74:     LD  1,0(1)	Adjust fp 
												   >	 75:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,75(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 76:    LDA  1,0(0)	set first frame at end of globals 
												   >	 77:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 78:    LDA  3,1(7)	Return address in ac 
												   >	 79:    JMP  7,-31(7)	Jump to main 
												   >	 80:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
tiny.mem tiny.mem.f21 differ: byte 64, line 2
tiny (MEM DIFF)
WARNING(1): The parameter 'garion' seems not to be used.						WARNING(1): The parameter 'garion' seems not to be used.
Func: wolf returns type int [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: wolf returns type int [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: garion of type int [mem: Parameter loc: -2 size: 1] [line: 1]			.   Child: 0  Parm: garion of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 1  Return [line: 3]									.   .   Child: 1  Return [line: 3]
.   .   .   Child: 0  Const 42 of type int [line: 3]							.   .   .   Child: 0  Const 42 of type int [line: 3]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 7]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 8]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   Child: 1  Assign: = of type int [line: 9]						   |	.   .   Child: 1  Assign: := of type int [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 9]
.   .   .   Child: 1  Const 666 of type int [line: 9]							.   .   .   Child: 1  Const 666 of type int [line: 9]
.   .   Sibling: 1  Assign: = of type int [line: 10]						   |	.   .   Sibling: 1  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   Child: 1  Call: wolf of type int [line: 10]							.   .   .   Child: 1  Call: wolf of type int [line: 10]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   Sibling: 2  Call: output of type void [line: 11]						.   .   Sibling: 2  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   Sibling: 3  Call: outnl of type void [line: 12]							.   .   Sibling: 3  Call: outnl of type void [line: 12]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
tiny.out ztmp23114.txt differ: byte 58, line 2
tiny (Output DIFF)
WARNING(1): The parameter 'garion' seems not to be used.						WARNING(1): The parameter 'garion' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/tiny.tm
Number of errors: 0										   |	42
------------------------------------								   <
Loading file: tiny.tm										   <
Bye.													Bye.
====================================
FILE: toroman.c-
-rw-------. 1 corg7983 domain_users  1121 Nov 17 15:35 toroman.c-
-rw-------. 1 corg7983 domain_users  1134 Nov 17 15:35 toroman.c-.f21
-rw-------. 1 corg7983 domain_users  1121 Nov 17 15:35 toroman.c-.f22
-rw-------. 1 corg7983 domain_users   529 Nov 17 15:35 toroman.expected
-rw-------. 1 corg7983 domain_users   100 Nov 17 15:35 toroman.in
-rw-------. 1 corg7983 domain_users 11432 Nov 22 12:27 toroman.mem
-rw-------. 1 corg7983 domain_users  1907 Nov 17 15:35 toroman.mem.diffs
-rw-------. 1 corg7983 domain_users 12284 Nov 17 15:35 toroman.mem.f21
-rw-------. 1 corg7983 domain_users   944 Nov 22 12:27 toroman.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 toroman.tm
-rw-------. 1 corg7983 domain_users   280 Nov 17 15:35 toroman.tm.diffs
-rw-------. 1 corg7983 domain_users 15877 Nov 17 15:35 toroman.tm.f21
TM CODE COMPARISON
toroman (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  toroman.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION roman
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -149
												   >	 40:    LDC  3,13(6)	load size of array value
												   >	 41:     ST  3,-6(1)	save size of array value
												   >	 42:    LDC  3,26(6)	load size of array letters
												   >	 43:     ST  3,-20(1)	save size of array letters
												   >	  1:    LIT  "M CMD CDC XCL XLX IXV IVI "
												   >	 44:    LDA  3,-1(0)	Load address of char array 
												   >	 45:    LDA  4,-21(1)	address of lhs 
												   >	 46:     LD  5,1(3)	size of rhs 
												   >	 47:     LD  6,1(4)	size of lhs 
												   >	 48:    SWP  5,6,6	pick smallest size 
												   >	 49:    MOV  4,3,5	array op = 
												   >	 50:    LDC  3,100(6)	load size of array s
												   >	 51:     ST  3,-47(1)	save size of array s
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 52:    LDC  3,100(6)	Load integer constant 
												   >	 53:     ST  3,-3(1)	Store variable b
												   >	* EXPRESSION
												   >	 54:    LDC  3,0(6)	Load integer constant 
												   >	 55:     ST  3,-4(1)	Store variable j
												   >	 56:     ST  3,-149(1)	Push index 
												   >	* TOFF dec: -150
												   >	 57:    LDC  3,1000(6)	Load integer constant 
												   >	* TOFF inc: -149
												   >	 58:     LD  4,-149(1)	Pop index 
												   >	 59:    LDA  5,-7(1)	Load address of base of array value
												   >	 60:    SUB  5,5,4	Compute offset of value 
												   >	 61:     ST  3,0(5)	Store variable value
												   >	* TOFF set: -152
												   >	* FOR
												   >	 62:    LDC  3,0(6)	Load integer constant 
												   >	 63:     ST  3,-149(1)	save starting value in index variable 
												   >	 64:    LDC  3,3(6)	Load integer constant 
												   >	 65:     ST  3,-150(1)	save stop value 
												   >	 66:    LDC  3,1(6)	default increment by 1 
												   >	 67:     ST  3,-151(1)	save step value 
												   >	 68:     LD  4,-149(1)	loop index 
												   >	 69:     LD  5,-150(1)	stop value 
												   >	 70:     LD  3,-151(1)	step value 
												   >	 71:    SLT  3,4,5	Op < 
												   >	 72:    JNZ  3,1(7)	Jump to loop body 
												   >	* COMPOUND
												   >	* TOFF set: -152
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 74:     LD  3,-4(1)	load lhs variable j
												   >	 75:    LDA  3,1(3)	increment value of j
												   >	 76:     ST  3,-4(1)	Store variable j
												   >	 77:     ST  3,-152(1)	Push index 
												   >	* TOFF dec: -153
												   >	 78:    LDC  3,9(6)	Load integer constant 
												   >	 79:     ST  3,-153(1)	Push left side 
												   >	* TOFF dec: -154
												   >	 80:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -153
												   >	 81:     LD  4,-153(1)	Pop left into ac1 
												   >	 82:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -152
												   >	 83:     LD  4,-152(1)	Pop index 
												   >	 84:    LDA  5,-7(1)	Load address of base of array value
												   >	 85:    SUB  5,5,4	Compute offset of value 
												   >	 86:     ST  3,0(5)	Store variable value
												   >	* EXPRESSION
												   >	 87:     LD  3,-4(1)	load lhs variable j
												   >	 88:    LDA  3,1(3)	increment value of j
												   >	 89:     ST  3,-4(1)	Store variable j
												   >	 90:     ST  3,-152(1)	Push index 
												   >	* TOFF dec: -153
												   >	 91:    LDC  3,5(6)	Load integer constant 
												   >	 92:     ST  3,-153(1)	Push left side 
												   >	* TOFF dec: -154
												   >	 93:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -153
												   >	 94:     LD  4,-153(1)	Pop left into ac1 
												   >	 95:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -152
												   >	 96:     LD  4,-152(1)	Pop index 
												   >	 97:    LDA  5,-7(1)	Load address of base of array value
												   >	 98:    SUB  5,5,4	Compute offset of value 
												   >	 99:     ST  3,0(5)	Store variable value
												   >	* EXPRESSION
												   >	100:     LD  3,-4(1)	load lhs variable j
												   >	101:    LDA  3,1(3)	increment value of j
												   >	102:     ST  3,-4(1)	Store variable j
												   >	103:     ST  3,-152(1)	Push index 
												   >	* TOFF dec: -153
												   >	104:    LDC  3,4(6)	Load integer constant 
												   >	105:     ST  3,-153(1)	Push left side 
												   >	* TOFF dec: -154
												   >	106:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -153
												   >	107:     LD  4,-153(1)	Pop left into ac1 
												   >	108:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -152
												   >	109:     LD  4,-152(1)	Pop index 
												   >	110:    LDA  5,-7(1)	Load address of base of array value
												   >	111:    SUB  5,5,4	Compute offset of value 
												   >	112:     ST  3,0(5)	Store variable value
												   >	* EXPRESSION
												   >	113:     LD  3,-4(1)	load lhs variable j
												   >	114:    LDA  3,1(3)	increment value of j
												   >	115:     ST  3,-4(1)	Store variable j
												   >	116:     ST  3,-152(1)	Push index 
												   >	* TOFF dec: -153
												   >	117:     LD  3,-3(1)	Load variable b
												   >	* TOFF inc: -152
												   >	118:     LD  4,-152(1)	Pop index 
												   >	119:    LDA  5,-7(1)	Load address of base of array value
												   >	120:    SUB  5,5,4	Compute offset of value 
												   >	121:     ST  3,0(5)	Store variable value
												   >	* EXPRESSION
												   >	122:    LDC  3,10(6)	Load integer constant 
												   >	123:     LD  4,-3(1)	load lhs variable b
												   >	124:    DIV  3,4,3	op /= 
												   >	125:     ST  3,-3(1)	Store variable b
												   >	* TOFF set: -152
												   >	* END COMPOUND
												   >	* Bottom of loop increment and jump
												   >	126:     LD  3,-149(1)	Load index 
												   >	127:     LD  5,-151(1)	Load step 
												   >	128:    ADD  3,3,5	increment 
												   >	129:     ST  3,-149(1)	store back to index 
												   >	130:    JMP  7,-63(7)	go to beginning of loop 
												   >	 73:    JMP  7,57(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* EXPRESSION
												   >	131:    LDC  3,0(6)	Load integer constant 
												   >	132:     ST  3,-5(1)	Store variable i
												   >	* EXPRESSION
												   >	133:    LDC  3,0(6)	Load integer constant 
												   >	134:     ST  3,-148(1)	Store variable sloc
												   >	* WHILE
												   >	135:    LDA  3,-7(1)	Load address of base of array value
												   >	136:     ST  3,-152(1)	Push left side 
												   >	* TOFF dec: -153
												   >	137:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -152
												   >	138:     LD  4,-152(1)	Pop left into ac1 
												   >	139:    SUB  3,4,3	compute location from index 
												   >	140:     LD  3,0(3)	Load array element 
												   >	141:     ST  3,-152(1)	Push left side 
												   >	* TOFF dec: -153
												   >	142:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -152
												   >	143:     LD  4,-152(1)	Pop left into ac1 
												   >	144:    TGT  3,4,3	Op > 
												   >	145:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -149
												   >	* Compound Body
												   >	* WHILE
												   >	147:     LD  3,-2(1)	Load variable n
												   >	148:     ST  3,-149(1)	Push left side 
												   >	* TOFF dec: -150
												   >	149:    LDA  3,-7(1)	Load address of base of array value
												   >	150:     ST  3,-150(1)	Push left side 
												   >	* TOFF dec: -151
												   >	151:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -150
												   >	152:     LD  4,-150(1)	Pop left into ac1 
												   >	153:    SUB  3,4,3	compute location from index 
												   >	154:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -149
												   >	155:     LD  4,-149(1)	Pop left into ac1 
												   >	156:    TGE  3,4,3	Op >= 
												   >	157:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -149
												   >	* Compound Body
												   >	* EXPRESSION
												   >	159:    LDA  3,-7(1)	Load address of base of array value
												   >	160:     ST  3,-149(1)	Push left side 
												   >	* TOFF dec: -150
												   >	161:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -149
												   >	162:     LD  4,-149(1)	Pop left into ac1 
												   >	163:    SUB  3,4,3	compute location from index 
												   >	164:     LD  3,0(3)	Load array element 
												   >	165:     LD  4,-2(1)	load lhs variable n
												   >	166:    SUB  3,4,3	op -= 
												   >	167:     ST  3,-2(1)	Store variable n
												   >	* EXPRESSION
												   >	168:     LD  3,-148(1)	Load variable sloc
												   >	169:     ST  3,-149(1)	Push index 
												   >	* TOFF dec: -150
												   >	170:    LDA  3,-21(1)	Load address of base of array letters
												   >	171:     ST  3,-150(1)	Push left side 
												   >	* TOFF dec: -151
												   >	172:    LDC  3,2(6)	Load integer constant 
												   >	173:     ST  3,-151(1)	Push left side 
												   >	* TOFF dec: -152
												   >	174:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -151
												   >	175:     LD  4,-151(1)	Pop left into ac1 
												   >	176:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -150
												   >	177:     LD  4,-150(1)	Pop left into ac1 
												   >	178:    SUB  3,4,3	compute location from index 
												   >	179:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -149
												   >	180:     LD  4,-149(1)	Pop index 
												   >	181:    LDA  5,-48(1)	Load address of base of array s
												   >	182:    SUB  5,5,4	Compute offset of value 
												   >	183:     ST  3,0(5)	Store variable s
												   >	* EXPRESSION
												   >	184:     LD  3,-148(1)	load lhs variable sloc
												   >	185:    LDA  3,1(3)	increment value of sloc
												   >	186:     ST  3,-148(1)	Store variable sloc
												   >	* IF
												   >	187:    LDA  3,-21(1)	Load address of base of array letters
												   >	188:     ST  3,-149(1)	Push left side 
												   >	* TOFF dec: -150
												   >	189:    LDC  3,2(6)	Load integer constant 
												   >	190:     ST  3,-150(1)	Push left side 
												   >	* TOFF dec: -151
												   >	191:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -150
												   >	192:     LD  4,-150(1)	Pop left into ac1 
												   >	193:    MUL  3,4,3	Op * 
												   >	194:     ST  3,-150(1)	Push left side 
												   >	* TOFF dec: -151
												   >	195:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -150
												   >	196:     LD  4,-150(1)	Pop left into ac1 
												   >	197:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -149
												   >	198:     LD  4,-149(1)	Pop left into ac1 
												   >	199:    SUB  3,4,3	compute location from index 
												   >	200:     LD  3,0(3)	Load array element 
												   >	201:     ST  3,-149(1)	Push left side 
												   >	* TOFF dec: -150
												   >	202:    LDC  3,32(6)	Load char constant 
												   >	* TOFF inc: -149
												   >	203:     LD  4,-149(1)	Pop left into ac1 
												   >	204:    TNE  3,4,3	Op >< 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -149
												   >	* Compound Body
												   >	* EXPRESSION
												   >	206:     LD  3,-148(1)	Load variable sloc
												   >	207:     ST  3,-149(1)	Push index 
												   >	* TOFF dec: -150
												   >	208:    LDA  3,-21(1)	Load address of base of array letters
												   >	209:     ST  3,-150(1)	Push left side 
												   >	* TOFF dec: -151
												   >	210:    LDC  3,2(6)	Load integer constant 
												   >	211:     ST  3,-151(1)	Push left side 
												   >	* TOFF dec: -152
												   >	212:     LD  3,-5(1)	Load variable i
												   >	* TOFF inc: -151
												   >	213:     LD  4,-151(1)	Pop left into ac1 
												   >	214:    MUL  3,4,3	Op * 
												   >	215:     ST  3,-151(1)	Push left side 
												   >	* TOFF dec: -152
												   >	216:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -151
												   >	217:     LD  4,-151(1)	Pop left into ac1 
												   >	218:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -150
												   >	219:     LD  4,-150(1)	Pop left into ac1 
												   >	220:    SUB  3,4,3	compute location from index 
												   >	221:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -149
												   >	222:     LD  4,-149(1)	Pop index 
												   >	223:    LDA  5,-48(1)	Load address of base of array s
												   >	224:    SUB  5,5,4	Compute offset of value 
												   >	225:     ST  3,0(5)	Store variable s
												   >	* EXPRESSION
												   >	226:     LD  3,-148(1)	load lhs variable sloc
												   >	227:    LDA  3,1(3)	increment value of sloc
												   >	228:     ST  3,-148(1)	Store variable sloc
												   >	* TOFF set: -149
												   >	* END COMPOUND
												   >	205:    JZR  3,23(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* TOFF set: -149
												   >	* END COMPOUND
												   >	229:    JMP  7,-83(7)	go to beginning of loop 
												   >	158:    JMP  7,71(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	230:     LD  3,-5(1)	load lhs variable i
												   >	231:    LDA  3,1(3)	increment value of i
												   >	232:     ST  3,-5(1)	Store variable i
												   >	* TOFF set: -152
												   >	* END COMPOUND
												   >	233:    JMP  7,-99(7)	go to beginning of loop 
												   >	146:    JMP  7,87(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -152
												   >	* FOR
												   >	234:    LDC  3,0(6)	Load integer constant 
												   >	235:     ST  3,-149(1)	save starting value in index variable 
												   >	236:     LD  3,-148(1)	Load variable sloc
												   >	237:     ST  3,-150(1)	save stop value 
												   >	238:    LDC  3,1(6)	default increment by 1 
												   >	239:     ST  3,-151(1)	save step value 
												   >	240:     LD  4,-149(1)	loop index 
												   >	241:     LD  5,-150(1)	stop value 
												   >	242:     LD  3,-151(1)	step value 
												   >	243:    SLT  3,4,5	Op < 
												   >	244:    JNZ  3,1(7)	Jump to loop body 
												   >	* EXPRESSION
												   >	* CALL outputc
												   >	246:     ST  1,-152(1)	Store fp in ghost frame for outputc
												   >	* TOFF dec: -153
												   >	* TOFF dec: -154
												   >	* Param 1
												   >	247:    LDA  3,-48(1)	Load address of base of array s
												   >	248:     ST  3,-154(1)	Push left side 
												   >	* TOFF dec: -155
												   >	249:     LD  3,-149(1)	Load variable i
												   >	* TOFF inc: -154
												   >	250:     LD  4,-154(1)	Pop left into ac1 
												   >	251:    SUB  3,4,3	compute location from index 
												   >	252:     LD  3,0(3)	Load array element 
												   >	253:     ST  3,-154(1)	Push parameter 
												   >	* TOFF dec: -155
												   >	* Param end outputc
												   >	254:    LDA  1,-152(1)	Ghost frame becomes new active frame 
												   >	255:    LDA  3,1(7)	Return address in ac 
												   >	256:    JMP  7,-229(7)	CALL outputc
												   >	257:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputc
												   >	* TOFF set: -152
												   >	* Bottom of loop increment and jump
												   >	258:     LD  3,-149(1)	Load index 
												   >	259:     LD  5,-151(1)	Load step 
												   >	260:    ADD  3,3,5	increment 
												   >	261:     ST  3,-149(1)	store back to index 
												   >	262:    JMP  7,-23(7)	go to beginning of loop 
												   >	245:    JMP  7,17(7)	Jump past loop [backpatch] 
												   >	* END LOOP
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	263:    LDC  2,0(6)	Set return value to 0 
												   >	264:     LD  3,-1(1)	Load return address 
												   >	265:     LD  1,0(1)	Adjust fp 
												   >	266:    JMP  7,0(3)	Return 
												   >	* END FUNCTION roman
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	267:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* WHILE
												   >	268:    LDC  3,1(6)	Load Boolean constant 
												   >	269:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL input
												   >	271:     ST  1,-3(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end input
												   >	272:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	273:    LDA  3,1(7)	Return address in ac 
												   >	274:    JMP  7,-274(7)	CALL input
												   >	275:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -3
												   >	276:     ST  3,-2(1)	Store variable n
												   >	* IF
												   >	277:     LD  3,-2(1)	Load variable n
												   >	278:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	279:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	280:     LD  4,-3(1)	Pop left into ac1 
												   >	281:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* BREAK
												   >	283:    JMP  7,-14(7)	break 
												   >	282:    JZR  3,1(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL roman
												   >	284:     ST  1,-3(1)	Store fp in ghost frame for roman
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	285:     LD  3,-2(1)	Load variable n
												   >	286:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end roman
												   >	287:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	288:    LDA  3,1(7)	Return address in ac 
												   >	289:    JMP  7,-251(7)	CALL roman
												   >	290:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end roman
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	291:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	292:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	293:    LDA  3,1(7)	Return address in ac 
												   >	294:    JMP  7,-261(7)	CALL outnl
												   >	295:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	296:    JMP  7,-29(7)	go to beginning of loop 
												   >	270:    JMP  7,26(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	297:    LDC  2,0(6)	Set return value to 0 
												   >	298:     LD  3,-1(1)	Load return address 
												   >	299:     LD  1,0(1)	Adjust fp 
												   >	300:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,300(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	301:    LDA  1,-27(0)	set first frame at end of globals 
												   >	302:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	303:    LDA  3,1(7)	Return address in ac 
												   >	304:    JMP  7,-38(7)	Jump to main 
												   >	305:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
toroman.mem toroman.mem.f21 differ: byte 59, line 2
toroman (MEM DIFF)
WARNING(15): The variable 'i' seems not to be used.							WARNING(15): The variable 'i' seems not to be used.
Func: roman returns type void [mem: Global loc: 0 size: -3] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: roman returns type void [mem: Global loc: 0 size: -3] [line: 1]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 1]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 1]						.   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 1]
.   .   Child: 0  Var: b of type int [mem: Local loc: -3 size: 1] [line: 2]				.   .   Child: 0  Var: b of type int [mem: Local loc: -3 size: 1] [line: 2]
.   .   Sibling: 1  Var: j of type int [mem: Local loc: -4 size: 1] [line: 2]				.   .   Sibling: 1  Var: j of type int [mem: Local loc: -4 size: 1] [line: 2]
.   .   Sibling: 2  Var: i of type int [mem: Local loc: -5 size: 1] [line: 2]				.   .   Sibling: 2  Var: i of type int [mem: Local loc: -5 size: 1] [line: 2]
.   .   Sibling: 3  Var: value of array of type int [mem: Local loc: -7 size: 14] [line: 3]		.   .   Sibling: 3  Var: value of array of type int [mem: Local loc: -7 size: 14] [line: 3]
.   .   Sibling: 4  Var: letters of array of type char [mem: Local loc: -21 size: 27] [line: 4]		.   .   Sibling: 4  Var: letters of array of type char [mem: Local loc: -21 size: 27] [line: 4]
.   .   .   Child: 0  Const "M CMD CDC XCL XLX IXV IVI " of array of type char [mem: Global loc:	.   .   .   Child: 0  Const "M CMD CDC XCL XLX IXV IVI " of array of type char [mem: Global loc:
.   .   Sibling: 5  Var: s of array of type char [mem: Local loc: -48 size: 101] [line: 5]		.   .   Sibling: 5  Var: s of array of type char [mem: Local loc: -48 size: 101] [line: 5]
.   .   Sibling: 6  Var: sloc of type int [mem: Local loc: -148 size: 1] [line: 6]			.   .   Sibling: 6  Var: sloc of type int [mem: Local loc: -148 size: 1] [line: 6]
.   .   Child: 1  Assign: = of type int [line: 13]						   |	.   .   Child: 1  Assign: := of type int [line: 13]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 13]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 13]
.   .   .   Child: 1  Const 100 of type int [line: 13]							.   .   .   Child: 1  Const 100 of type int [line: 13]
.   .   Sibling: 1  Assign: = of type int [line: 14]						   |	.   .   Sibling: 1  Assign: := of type int [line: 14]
.   .   .   Child: 0  Op: [ of type int [line: 14]							.   .   .   Child: 0  Op: [ of type int [line: 14]
.   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [line: 14	.   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [line: 14
.   .   .   .   Child: 1  Assign: = of type int [line: 14]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 14]
.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 14]			.   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 14]
.   .   .   .   .   Child: 1  Const 0 of type int [line: 14]						.   .   .   .   .   Child: 1  Const 0 of type int [line: 14]
.   .   .   Child: 1  Const 1000 of type int [line: 14]							.   .   .   Child: 1  Const 1000 of type int [line: 14]
.   .   Sibling: 2  For [mem: None loc: 0 size: -150] [line: 15]				   |	.   .   Sibling: 2  For [mem: None loc: 0 size: -152] [line: 15]
.   .   .   Child: 0  Var: i of type int [mem: Local loc: -149 size: 1] [line: 15]			.   .   .   Child: 0  Var: i of type int [mem: Local loc: -149 size: 1] [line: 15]
.   .   .   Child: 1  Range [line: 15]									.   .   .   Child: 1  Range [line: 15]
.   .   .   .   Child: 0  Const 0 of type int [line: 15]						.   .   .   .   Child: 0  Const 0 of type int [line: 15]
.   .   .   .   Child: 1  Const 3 of type int [line: 15]						.   .   .   .   Child: 1  Const 3 of type int [line: 15]
.   .   .   Child: 2  Compound [mem: None loc: 0 size: -150] [line: 15]				   |	.   .   .   Child: 2  Compound [mem: None loc: 0 size: -152] [line: 15]
.   .   .   .   Child: 1  Assign: = of type int [line: 16]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 16]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 16]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [	.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 16]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 16]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 16]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 16]
.   .   .   .   .   Child: 1  Op: * of type int [line: 16]						.   .   .   .   .   Child: 1  Op: * of type int [line: 16]
.   .   .   .   .   .   Child: 0  Const 9 of type int [line: 16]					.   .   .   .   .   .   Child: 0  Const 9 of type int [line: 16]
.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 16]		.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 16]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 17]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 17]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 17]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [	.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 17]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 17]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 17]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 17]
.   .   .   .   .   Child: 1  Op: * of type int [line: 17]						.   .   .   .   .   Child: 1  Op: * of type int [line: 17]
.   .   .   .   .   .   Child: 0  Const 5 of type int [line: 17]					.   .   .   .   .   .   Child: 0  Const 5 of type int [line: 17]
.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]		.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 17]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 18]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 18]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 18]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [	.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 18]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 18]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 18]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 18]
.   .   .   .   .   Child: 1  Op: * of type int [line: 18]						.   .   .   .   .   Child: 1  Op: * of type int [line: 18]
.   .   .   .   .   .   Child: 0  Const 4 of type int [line: 18]					.   .   .   .   .   .   Child: 0  Const 4 of type int [line: 18]
.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 18]		.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 18]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 19]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 19]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 19]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [	.   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [
.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 19]					.   .   .   .   .   .   Child: 1  Assign: ++ of type int [line: 19]
.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 19]		.   .   .   .   .   .   .   Child: 0  Id: j of type int [mem: Local loc: -4 size: 1] [line: 19]
.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]			.   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   .   .   Sibling: 4  Assign: /= of type int [line: 20]						.   .   .   .   Sibling: 4  Assign: /= of type int [line: 20]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 20]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -3 size: 1] [line: 20]
.   .   .   .   .   Child: 1  Const 10 of type int [line: 20]						.   .   .   .   .   Child: 1  Const 10 of type int [line: 20]
.   .   Sibling: 3  Assign: = of type int [line: 23]						   |	.   .   Sibling: 3  Assign: := of type int [line: 23]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 23]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 23]
.   .   .   Child: 1  Const 0 of type int [line: 23]							.   .   .   Child: 1  Const 0 of type int [line: 23]
.   .   Sibling: 4  Assign: = of type int [line: 24]						   |	.   .   Sibling: 4  Assign: := of type int [line: 24]
.   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1] [line: 24]			.   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1] [line: 24]
.   .   .   Child: 1  Const 0 of type int [line: 24]							.   .   .   Child: 1  Const 0 of type int [line: 24]
.   .   Sibling: 5  While [line: 25]									.   .   Sibling: 5  While [line: 25]
.   .   .   Child: 0  Op: > of type bool [line: 25]							.   .   .   Child: 0  Op: > of type bool [line: 25]
.   .   .   .   Child: 0  Op: [ of type int [line: 25]							.   .   .   .   Child: 0  Op: [ of type int [line: 25]
.   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [line	.   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 14] [line
.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 25]			.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 25]
.   .   .   .   Child: 1  Const 0 of type int [line: 25]						.   .   .   .   Child: 1  Const 0 of type int [line: 25]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 25]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 25]
.   .   .   .   Child: 1  While [line: 26]								.   .   .   .   Child: 1  While [line: 26]
.   .   .   .   .   Child: 0  Op: >= of type bool [line: 26]						.   .   .   .   .   Child: 0  Op: >= of type bool [line: 26]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 26]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 26]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 26]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 26]
.   .   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 1	.   .   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 size: 1
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 26]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 26]
.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 26]				.   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 26]
.   .   .   .   .   .   Child: 1  Assign: -= of type int [line: 27]					.   .   .   .   .   .   Child: 1  Assign: -= of type int [line: 27]
.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 27]					.   .   .   .   .   .   .   Child: 1  Op: [ of type int [line: 27]
.   .   .   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 siz	.   .   .   .   .   .   .   .   Child: 0  Id: value of array of type int [mem: Local loc: -7 siz
.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 	.   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [line: 
.   .   .   .   .   .   Sibling: 1  Assign: = of type char [line: 28]				   |	.   .   .   .   .   .   Sibling: 1  Assign: := of type char [line: 28]
.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 28]					.   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 28]
.   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -48 size:	.   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -48 size:
.   .   .   .   .   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 size: 1] [l	.   .   .   .   .   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 size: 1] [l
.   .   .   .   .   .   .   Child: 1  Op: [ of type char [line: 28]					.   .   .   .   .   .   .   Child: 1  Op: [ of type char [line: 28]
.   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local loc: -21	.   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local loc: -21
.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 28]					.   .   .   .   .   .   .   .   Child: 1  Op: * of type int [line: 28]
.   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 28]				.   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 28]
.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [li	.   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size: 1] [li
.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 29]					.   .   .   .   .   .   Sibling: 2  Assign: ++ of type int [line: 29]
.   .   .   .   .   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1] [line:	.   .   .   .   .   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1] [line:
.   .   .   .   .   .   Sibling: 3  If [line: 30]							.   .   .   .   .   .   Sibling: 3  If [line: 30]
.   .   .   .   .   .   .   Child: 0  Op: != of type bool [line: 30]				   |	.   .   .   .   .   .   .   Child: 0  Op: >< of type bool [line: 30]
.   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 30]					.   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 30]
.   .   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local loc:	.   .   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local loc:
.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 30]				.   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 30]
.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 30]				.   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 30]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 30]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 30]
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size	.   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 size
.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 30]			.   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 30]
.   .   .   .   .   .   .   .   Child: 1  Const ' ' of type char [line: 30]				.   .   .   .   .   .   .   .   Child: 1  Const ' ' of type char [line: 30]
.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 30]			.   .   .   .   .   .   .   Child: 1  Compound [mem: None loc: 0 size: -149] [line: 30]
.   .   .   .   .   .   .   .   Child: 1  Assign: = of type char [line: 31]			   |	.   .   .   .   .   .   .   .   Child: 1  Assign: := of type char [line: 31]
.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 31]				.   .   .   .   .   .   .   .   .   Child: 0  Op: [ of type char [line: 31]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -
.   .   .   .   .   .   .   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 siz	.   .   .   .   .   .   .   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 siz
.   .   .   .   .   .   .   .   .   Child: 1  Op: [ of type char [line: 31]				.   .   .   .   .   .   .   .   .   Child: 1  Op: [ of type char [line: 31]
.   .   .   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local 	.   .   .   .   .   .   .   .   .   .   Child: 0  Id: letters of array of type char [mem: Local 
.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 31]				.   .   .   .   .   .   .   .   .   .   Child: 1  Op: + of type int [line: 31]
.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 31]			.   .   .   .   .   .   .   .   .   .   .   Child: 0  Op: * of type int [line: 31]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 31]		.   .   .   .   .   .   .   .   .   .   .   .   Child: 0  Const 2 of type int [line: 31]
.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 	.   .   .   .   .   .   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -5 
.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 31]			.   .   .   .   .   .   .   .   .   .   .   Child: 1  Const 1 of type int [line: 31]
.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 32]				.   .   .   .   .   .   .   .   Sibling: 1  Assign: ++ of type int [line: 32]
.   .   .   .   .   .   .   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1	.   .   .   .   .   .   .   .   .   Child: 0  Id: sloc of type int [mem: Local loc: -148 size: 1
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 35]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 35]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 35]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -5 size: 1] [line: 35]
.   .   Sibling: 6  For [mem: None loc: 0 size: -150] [line: 38]				   |	.   .   Sibling: 6  For [mem: None loc: 0 size: -152] [line: 38]
.   .   .   Child: 0  Var: i of type int [mem: Local loc: -149 size: 1] [line: 38]			.   .   .   Child: 0  Var: i of type int [mem: Local loc: -149 size: 1] [line: 38]
.   .   .   Child: 1  Range [line: 38]									.   .   .   Child: 1  Range [line: 38]
.   .   .   .   Child: 0  Const 0 of type int [line: 38]						.   .   .   .   Child: 0  Const 0 of type int [line: 38]
.   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 size: 1] [line: 38]		.   .   .   .   Child: 1  Id: sloc of type int [mem: Local loc: -148 size: 1] [line: 38]
.   .   .   Child: 2  Call: outputc of type void [line: 38]						.   .   .   Child: 2  Call: outputc of type void [line: 38]
.   .   .   .   Child: 0  Op: [ of type char [line: 38]							.   .   .   .   Child: 0  Op: [ of type char [line: 38]
.   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -48 size: 101] [line:	.   .   .   .   .   Child: 0  Id: s of array of type char [mem: Local loc: -48 size: 101] [line:
.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -149 size: 1] [line: 38]		.   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -149 size: 1] [line: 38]
Sibling: 1  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 41]		   |	Sibling: 8  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 41]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 41]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 41]
.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 42]				.   .   Child: 0  Var: n of type int [mem: Local loc: -2 size: 1] [line: 42]
.   .   Child: 1  While [line: 43]									.   .   Child: 1  While [line: 43]
.   .   .   Child: 0  Const true of type bool [line: 43]						.   .   .   Child: 0  Const true of type bool [line: 43]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 43]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 43]
.   .   .   .   Child: 1  Assign: = of type int [line: 44]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 44]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 44]			.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 44]
.   .   .   .   .   Child: 1  Call: input of type int [line: 44]					.   .   .   .   .   Child: 1  Call: input of type int [line: 44]
.   .   .   .   Sibling: 1  If [line: 45]								.   .   .   .   Sibling: 1  If [line: 45]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 45]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 45]
.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]		.   .   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 45]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 45]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 45]
.   .   .   .   .   Child: 1  Break [line: 45]								.   .   .   .   .   Child: 1  Break [line: 45]
.   .   .   .   Sibling: 2  Call: roman of type void [line: 46]						.   .   .   .   Sibling: 2  Call: roman of type void [line: 46]
.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 46]			.   .   .   .   .   Child: 0  Id: n of type int [mem: Local loc: -2 size: 1] [line: 46]
.   .   .   .   Sibling: 3  Call: outnl of type void [line: 47]						.   .   .   .   Sibling: 3  Call: outnl of type void [line: 47]
Offset for end of global space: -27									Offset for end of global space: -27
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
toroman.out ztmp23114.txt differ: byte 53, line 2
toroman (Output DIFF)
WARNING(15): The variable 'i' seems not to be used.							WARNING(15): The variable 'i' seems not to be used.
Number of warnings: 1										   |	Loading file: BroadTests/toroman.tm
Number of errors: 0										   |	entered: 1
------------------------------------								   |	I
Loading file: toroman.tm									   |	entered: 2
ERROR: TM Command 1 unknown.									   |	II
ERROR: TM Command 2 unknown.									   |	entered: 3
ERROR: TM Command 3 unknown.									   |	III
ERROR: TM Command 4 unknown.									   |	entered: 4
ERROR: TM Command 5 unknown.									   |	IV
ERROR: TM Command 6 unknown.									   |	entered: 5
ERROR: TM Command 7 unknown.									   |	V
ERROR: TM Command 8 unknown.									   |	entered: 6
ERROR: TM Command 9 unknown.									   |	VI
ERROR: TM Command 1 unknown.									   |	entered: 7
ERROR: TM Command 1 unknown.									   |	VII
ERROR: TM Command 1 unknown.									   |	entered: 8
ERROR: TM Command 1 unknown.									   |	VIII
ERROR: TM Command 1 unknown.									   |	entered: 9
ERROR: TM Command 1 unknown.									   |	IX
ERROR: TM Command 3 unknown.									   |	entered: 10
ERROR: TM Command 4 unknown.									   |	X
ERROR: TM Command 5 unknown.									   |	entered: 11
ERROR: TM Command 8 unknown.									   |	XI
ERROR: TM Command 9 unknown.									   |	entered: 12
ERROR: TM Command 1 unknown.									   |	XII
ERROR: TM Command 1 unknown.									   |	entered: 13
ERROR: TM Command 6 unknown.									   |	XIII
ERROR: TM Command 7 unknown.									   |	entered: 14
ERROR: TM Command 1 unknown.									   |	XIV
ERROR: TM Command 5 unknown.									   |	entered: 15
ERROR: TM Command 0 unknown.									   |	XV
												   >	entered: 33
												   >	XXXIII
												   >	entered: 44
												   >	XLIV
												   >	entered: 55
												   >	LV
												   >	entered: 88
												   >	LXXXVIII
												   >	entered: 99
												   >	XCIX
												   >	entered: 101
												   >	CI
												   >	entered: 104
												   >	CIV
												   >	entered: 666
												   >	DCLXVI
												   >	entered: 721
												   >	DCCXXI
												   >	entered: 1666
												   >	MDCLXVI
												   >	entered: 5000
												   >	MMMMM
												   >	entered: 0
Bye.													Bye.
====================================
FILE: unary.c-
-rw-------. 1 corg7983 domain_users   689 Nov 17 15:35 unary.c-
-rw-------. 1 corg7983 domain_users   694 Nov 17 15:35 unary.c-.f21
-rw-------. 1 corg7983 domain_users   689 Nov 17 15:35 unary.c-.f22
-rw-------. 1 corg7983 domain_users   195 Nov 17 15:35 unary.expected
-rw-------. 1 corg7983 domain_users  5892 Nov 22 12:27 unary.mem
-rw-------. 1 corg7983 domain_users   617 Nov 17 15:35 unary.mem.diffs
-rw-------. 1 corg7983 domain_users  6738 Nov 17 15:35 unary.mem.f21
-rw-------. 1 corg7983 domain_users   233 Nov 22 12:27 unary.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 unary.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 unary.tm.diffs
-rw-------. 1 corg7983 domain_users 12144 Nov 17 15:35 unary.tm.f21
TM CODE COMPARISON
unary (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  unary.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -18
												   >	 40:    LDC  3,7(6)	load size of array a
												   >	 41:     ST  3,-4(1)	save size of array a
												   >	 42:    LDC  3,5(6)	load size of array b
												   >	 43:     ST  3,-12(1)	save size of array b
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 44:    LDC  3,88(6)	Load integer constant 
												   >	 45:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 46:     LD  3,-2(1)	Load variable x
												   >	 47:     ST  3,-18(1)	Push left side 
												   >	* TOFF dec: -19
												   >	 48:    LDC  3,9(6)	Load integer constant 
												   >	* TOFF inc: -18
												   >	 49:     LD  4,-18(1)	Pop left into ac1 
												   >	 50:    SUB  3,4,3	Op - 
												   >	 51:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	 52:     LD  3,-2(1)	Load variable x
												   >	 53:    NEG  3,3,3	Op unary - 
												   >	 54:     ST  3,-3(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL output
												   >	 55:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 56:     LD  3,-2(1)	Load variable x
												   >	 57:    NEG  3,3,3	Op unary - 
												   >	 58:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 59:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 60:    LDA  3,1(7)	Return address in ac 
												   >	 61:    JMP  7,-56(7)	CALL output
												   >	 62:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 63:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 64:     LD  3,-3(1)	Load variable y
												   >	 65:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 66:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 67:    LDA  3,1(7)	Return address in ac 
												   >	 68:    JMP  7,-63(7)	CALL output
												   >	 69:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 70:     ST  1,-18(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param end outnl
												   >	 71:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 72:    LDA  3,1(7)	Return address in ac 
												   >	 73:    JMP  7,-40(7)	CALL outnl
												   >	 74:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 75:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 76:    LDC  3,3(6)	Load integer constant 
												   >	 77:    NEG  3,3,3	Op unary - 
												   >	 78:    NEG  3,3,3	Op unary - 
												   >	 79:     ST  3,-20(1)	Push left side 
												   >	* TOFF dec: -21
												   >	 80:    LDC  3,5(6)	Load integer constant 
												   >	 81:    NEG  3,3,3	Op unary - 
												   >	* TOFF inc: -20
												   >	 82:     LD  4,-20(1)	Pop left into ac1 
												   >	 83:    MUL  3,4,3	Op * 
												   >	 84:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 85:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-82(7)	CALL output
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	 89:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	 90:    LDC  3,3(6)	Load integer constant 
												   >	 91:    NEG  3,3,3	Op unary - 
												   >	 92:    NEG  3,3,3	Op unary - 
												   >	 93:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	 94:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	 95:    LDA  3,1(7)	Return address in ac 
												   >	 96:    JMP  7,-91(7)	CALL output
												   >	 97:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 98:     ST  1,-18(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param end outnl
												   >	 99:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	100:    LDA  3,1(7)	Return address in ac 
												   >	101:    JMP  7,-68(7)	CALL outnl
												   >	102:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -18
												   >	* COMPOUND
												   >	* TOFF set: -20
												   >	* Compound Body
												   >	* EXPRESSION
												   >	103:    LDC  3,1(6)	Load Boolean constant 
												   >	104:     ST  3,-18(1)	Store variable x
												   >	* EXPRESSION
												   >	105:     LD  3,-18(1)	Load variable x
												   >	106:    LDC  4,1(6)	Load 1 
												   >	107:    XOR  3,3,4	Op XOR to get logical not 
												   >	108:     ST  3,-19(1)	Store variable y
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	109:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	110:     LD  3,-18(1)	Load variable x
												   >	111:    LDC  4,1(6)	Load 1 
												   >	112:    XOR  3,3,4	Op XOR to get logical not 
												   >	113:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	114:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	115:    LDA  3,1(7)	Return address in ac 
												   >	116:    JMP  7,-100(7)	CALL outputb
												   >	117:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	118:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	119:     LD  3,-19(1)	Load variable y
												   >	120:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	121:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	122:    LDA  3,1(7)	Return address in ac 
												   >	123:    JMP  7,-107(7)	CALL outputb
												   >	124:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	125:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	126:     LD  3,-18(1)	Load variable x
												   >	127:    LDC  4,1(6)	Load 1 
												   >	128:    XOR  3,3,4	Op XOR to get logical not 
												   >	129:    LDC  4,1(6)	Load 1 
												   >	130:    XOR  3,3,4	Op XOR to get logical not 
												   >	131:     ST  3,-22(1)	Push left side 
												   >	* TOFF dec: -23
												   >	132:     LD  3,-19(1)	Load variable y
												   >	133:    LDC  4,1(6)	Load 1 
												   >	134:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -22
												   >	135:     LD  4,-22(1)	Pop left into ac1 
												   >	136:    AND  3,4,3	Op AND 
												   >	137:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	138:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	139:    LDA  3,1(7)	Return address in ac 
												   >	140:    JMP  7,-124(7)	CALL outputb
												   >	141:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	142:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	143:     LD  3,-18(1)	Load variable x
												   >	144:    LDC  4,1(6)	Load 1 
												   >	145:    XOR  3,3,4	Op XOR to get logical not 
												   >	146:    LDC  4,1(6)	Load 1 
												   >	147:    XOR  3,3,4	Op XOR to get logical not 
												   >	148:     ST  3,-22(1)	Push left side 
												   >	* TOFF dec: -23
												   >	149:     LD  3,-19(1)	Load variable y
												   >	150:    LDC  4,1(6)	Load 1 
												   >	151:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -22
												   >	152:     LD  4,-22(1)	Pop left into ac1 
												   >	153:     OR  3,4,3	Op OR 
												   >	154:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	155:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	156:    LDA  3,1(7)	Return address in ac 
												   >	157:    JMP  7,-141(7)	CALL outputb
												   >	158:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	159:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	160:     LD  3,-19(1)	Load variable y
												   >	161:    LDC  4,1(6)	Load 1 
												   >	162:    XOR  3,3,4	Op XOR to get logical not 
												   >	163:    LDC  4,1(6)	Load 1 
												   >	164:    XOR  3,3,4	Op XOR to get logical not 
												   >	165:     ST  3,-22(1)	Push left side 
												   >	* TOFF dec: -23
												   >	166:     LD  3,-18(1)	Load variable x
												   >	167:    LDC  4,1(6)	Load 1 
												   >	168:    XOR  3,3,4	Op XOR to get logical not 
												   >	* TOFF inc: -22
												   >	169:     LD  4,-22(1)	Pop left into ac1 
												   >	170:     OR  3,4,3	Op OR 
												   >	171:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	172:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-158(7)	CALL outputb
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outputb
												   >	176:     ST  1,-20(1)	Store fp in ghost frame for outputb
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param 1
												   >	177:     LD  3,-18(1)	Load variable x
												   >	178:    LDC  4,1(6)	Load 1 
												   >	179:    XOR  3,3,4	Op XOR to get logical not 
												   >	180:    LDC  4,1(6)	Load 1 
												   >	181:    XOR  3,3,4	Op XOR to get logical not 
												   >	182:     ST  3,-22(1)	Push parameter 
												   >	* TOFF dec: -23
												   >	* Param end outputb
												   >	183:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	184:    LDA  3,1(7)	Return address in ac 
												   >	185:    JMP  7,-169(7)	CALL outputb
												   >	186:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outputb
												   >	* TOFF set: -20
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	187:     ST  1,-20(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -21
												   >	* TOFF dec: -22
												   >	* Param end outnl
												   >	188:    LDA  1,-20(1)	Ghost frame becomes new active frame 
												   >	189:    LDA  3,1(7)	Return address in ac 
												   >	190:    JMP  7,-157(7)	CALL outnl
												   >	191:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -20
												   >	* TOFF set: -18
												   >	* END COMPOUND
												   >	* EXPRESSION
												   >	* CALL output
												   >	192:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	193:    LDA  3,-5(1)	Load address of base of array a
												   >	194:     LD  3,1(3)	Load array size 
												   >	195:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	196:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	197:    LDA  3,1(7)	Return address in ac 
												   >	198:    JMP  7,-193(7)	CALL output
												   >	199:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* EXPRESSION
												   >	* CALL output
												   >	200:     ST  1,-18(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -19
												   >	* TOFF dec: -20
												   >	* Param 1
												   >	201:    LDA  3,-13(1)	Load address of base of array b
												   >	202:     LD  3,1(3)	Load array size 
												   >	203:     ST  3,-20(1)	Push parameter 
												   >	* TOFF dec: -21
												   >	* Param end output
												   >	204:    LDA  1,-18(1)	Ghost frame becomes new active frame 
												   >	205:    LDA  3,1(7)	Return address in ac 
												   >	206:    JMP  7,-201(7)	CALL output
												   >	207:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -18
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	208:    LDC  2,0(6)	Set return value to 0 
												   >	209:     LD  3,-1(1)	Load return address 
												   >	210:     LD  1,0(1)	Adjust fp 
												   >	211:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,211(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	212:    LDA  1,0(0)	set first frame at end of globals 
												   >	213:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	214:    LDA  3,1(7)	Return address in ac 
												   >	215:    JMP  7,-177(7)	Jump to main 
												   >	216:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
unary.mem unary.mem.f21 differ: byte 133, line 3
unary (MEM DIFF)
WARNING(35): Variable 'a' may be uninitialized when used here.						WARNING(35): Variable 'a' may be uninitialized when used here.
WARNING(36): Variable 'b' may be uninitialized when used here.						WARNING(36): Variable 'b' may be uninitialized when used here.
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 4]
.   Child: 1  Compound [mem: None loc: 0 size: -18] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -18] [line: 5]
.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]				.   .   Child: 0  Var: x of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 7]				.   .   Sibling: 1  Var: y of type int [mem: Local loc: -3 size: 1] [line: 7]
.   .   Sibling: 2  Var: a of array of type bool [mem: Local loc: -5 size: 8] [line: 8]			.   .   Sibling: 2  Var: a of array of type bool [mem: Local loc: -5 size: 8] [line: 8]
.   .   Sibling: 3  Var: b of array of type bool [mem: Local loc: -13 size: 6] [line: 8]		.   .   Sibling: 3  Var: b of array of type bool [mem: Local loc: -13 size: 6] [line: 8]
.   .   Child: 1  Assign: = of type int [line: 10]						   |	.   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]				.   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 10]
.   .   .   Child: 1  Const 88 of type int [line: 10]							.   .   .   Child: 1  Const 88 of type int [line: 10]
.   .   Sibling: 1  Assign: = of type int [line: 11]						   |	.   .   Sibling: 1  Assign: := of type int [line: 11]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 11]
.   .   .   Child: 1  Op: - of type int [line: 11]							.   .   .   Child: 1  Op: - of type int [line: 11]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 11]
.   .   .   .   Child: 1  Const 9 of type int [line: 11]						.   .   .   .   Child: 1  Const 9 of type int [line: 11]
.   .   Sibling: 2  Assign: = of type int [line: 12]						   |	.   .   Sibling: 2  Assign: := of type int [line: 12]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 12]
.   .   .   Child: 1  Op: chsign of type int [line: 12]							.   .   .   Child: 1  Op: chsign of type int [line: 12]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   Sibling: 3  Call: output of type void [line: 13]						.   .   Sibling: 3  Call: output of type void [line: 13]
.   .   .   Child: 0  Op: chsign of type int [line: 13]							.   .   .   Child: 0  Op: chsign of type int [line: 13]
.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]			.   .   .   .   Child: 0  Id: x of type int [mem: Local loc: -2 size: 1] [line: 13]
.   .   Sibling: 4  Call: output of type void [line: 14]						.   .   Sibling: 4  Call: output of type void [line: 14]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   Sibling: 5  Call: outnl of type void [line: 15]							.   .   Sibling: 5  Call: outnl of type void [line: 15]
.   .   Sibling: 6  Call: output of type void [line: 17]						.   .   Sibling: 6  Call: output of type void [line: 17]
.   .   .   Child: 0  Op: * of type int [line: 17]							.   .   .   Child: 0  Op: * of type int [line: 17]
.   .   .   .   Child: 0  Op: chsign of type int [line: 17]						.   .   .   .   Child: 0  Op: chsign of type int [line: 17]
.   .   .   .   .   Child: 0  Op: chsign of type int [line: 17]						.   .   .   .   .   Child: 0  Op: chsign of type int [line: 17]
.   .   .   .   .   .   Child: 0  Const 3 of type int [line: 17]					.   .   .   .   .   .   Child: 0  Const 3 of type int [line: 17]
.   .   .   .   Child: 1  Op: chsign of type int [line: 17]						.   .   .   .   Child: 1  Op: chsign of type int [line: 17]
.   .   .   .   .   Child: 0  Const 5 of type int [line: 17]						.   .   .   .   .   Child: 0  Const 5 of type int [line: 17]
.   .   Sibling: 7  Call: output of type void [line: 18]						.   .   Sibling: 7  Call: output of type void [line: 18]
.   .   .   Child: 0  Op: chsign of type int [line: 18]							.   .   .   Child: 0  Op: chsign of type int [line: 18]
.   .   .   .   Child: 0  Op: chsign of type int [line: 18]						.   .   .   .   Child: 0  Op: chsign of type int [line: 18]
.   .   .   .   .   Child: 0  Const 3 of type int [line: 18]						.   .   .   .   .   Child: 0  Const 3 of type int [line: 18]
.   .   Sibling: 8  Call: outnl of type void [line: 19]							.   .   Sibling: 8  Call: outnl of type void [line: 19]
.   .   Sibling: 9  Compound [mem: None loc: 0 size: -20] [line: 21]					.   .   Sibling: 9  Compound [mem: None loc: 0 size: -20] [line: 21]
.   .   .   Child: 0  Var: x of type bool [mem: Local loc: -18 size: 1] [line: 21]			.   .   .   Child: 0  Var: x of type bool [mem: Local loc: -18 size: 1] [line: 21]
.   .   .   Sibling: 1  Var: y of type bool [mem: Local loc: -19 size: 1] [line: 22]			.   .   .   Sibling: 1  Var: y of type bool [mem: Local loc: -19 size: 1] [line: 22]
.   .   .   Child: 1  Assign: = of type bool [line: 24]						   |	.   .   .   Child: 1  Assign: := of type bool [line: 24]
.   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 24]			.   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 24]
.   .   .   .   Child: 1  Const true of type bool [line: 24]						.   .   .   .   Child: 1  Const true of type bool [line: 24]
.   .   .   Sibling: 1  Assign: = of type bool [line: 25]					   |	.   .   .   Sibling: 1  Assign: := of type bool [line: 25]
.   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 25]			.   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 25]
.   .   .   .   Child: 1  Op: not of type bool [line: 25]						.   .   .   .   Child: 1  Op: not of type bool [line: 25]
.   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 25]		.   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 25]
.   .   .   Sibling: 2  Call: outputb of type void [line: 26]						.   .   .   Sibling: 2  Call: outputb of type void [line: 26]
.   .   .   .   Child: 0  Op: not of type bool [line: 26]						.   .   .   .   Child: 0  Op: not of type bool [line: 26]
.   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 26]		.   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 26]
.   .   .   Sibling: 3  Call: outputb of type void [line: 27]						.   .   .   Sibling: 3  Call: outputb of type void [line: 27]
.   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 27]			.   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 27]
.   .   .   Sibling: 4  Call: outputb of type void [line: 28]						.   .   .   Sibling: 4  Call: outputb of type void [line: 28]
.   .   .   .   Child: 0  Op: and of type bool [line: 28]						.   .   .   .   Child: 0  Op: and of type bool [line: 28]
.   .   .   .   .   Child: 0  Op: not of type bool [line: 28]						.   .   .   .   .   Child: 0  Op: not of type bool [line: 28]
.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 28]					.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 28]
.   .   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 28	.   .   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 28
.   .   .   .   .   Child: 1  Op: not of type bool [line: 28]						.   .   .   .   .   Child: 1  Op: not of type bool [line: 28]
.   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 28]		.   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 28]
.   .   .   Sibling: 5  Call: outputb of type void [line: 29]						.   .   .   Sibling: 5  Call: outputb of type void [line: 29]
.   .   .   .   Child: 0  Op: or of type bool [line: 29]						.   .   .   .   Child: 0  Op: or of type bool [line: 29]
.   .   .   .   .   Child: 0  Op: not of type bool [line: 29]						.   .   .   .   .   Child: 0  Op: not of type bool [line: 29]
.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 29]					.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 29]
.   .   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 29	.   .   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 29
.   .   .   .   .   Child: 1  Op: not of type bool [line: 29]						.   .   .   .   .   Child: 1  Op: not of type bool [line: 29]
.   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 29]		.   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 29]
.   .   .   Sibling: 6  Call: outputb of type void [line: 30]						.   .   .   Sibling: 6  Call: outputb of type void [line: 30]
.   .   .   .   Child: 0  Op: or of type bool [line: 30]						.   .   .   .   Child: 0  Op: or of type bool [line: 30]
.   .   .   .   .   Child: 0  Op: not of type bool [line: 30]						.   .   .   .   .   Child: 0  Op: not of type bool [line: 30]
.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 30]					.   .   .   .   .   .   Child: 0  Op: not of type bool [line: 30]
.   .   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 30	.   .   .   .   .   .   .   Child: 0  Id: y of type bool [mem: Local loc: -19 size: 1] [line: 30
.   .   .   .   .   Child: 1  Op: not of type bool [line: 30]						.   .   .   .   .   Child: 1  Op: not of type bool [line: 30]
.   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 30]		.   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 30]
.   .   .   Sibling: 7  Call: outputb of type void [line: 31]						.   .   .   Sibling: 7  Call: outputb of type void [line: 31]
.   .   .   .   Child: 0  Op: not of type bool [line: 31]						.   .   .   .   Child: 0  Op: not of type bool [line: 31]
.   .   .   .   .   Child: 0  Op: not of type bool [line: 31]						.   .   .   .   .   Child: 0  Op: not of type bool [line: 31]
.   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 31]		.   .   .   .   .   .   Child: 0  Id: x of type bool [mem: Local loc: -18 size: 1] [line: 31]
.   .   .   Sibling: 8  Call: outnl of type void [line: 32]						.   .   .   Sibling: 8  Call: outnl of type void [line: 32]
.   .   Sibling: 10  Call: output of type void [line: 35]						.   .   Sibling: 10  Call: output of type void [line: 35]
.   .   .   Child: 0  Op: sizeof of type int [line: 35]							.   .   .   Child: 0  Op: sizeof of type int [line: 35]
.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -5 size: 8] [line: 35]		.   .   .   .   Child: 0  Id: a of array of type bool [mem: Local loc: -5 size: 8] [line: 35]
.   .   Sibling: 11  Call: output of type void [line: 36]						.   .   Sibling: 11  Call: output of type void [line: 36]
.   .   .   Child: 0  Op: sizeof of type int [line: 36]							.   .   .   Child: 0  Op: sizeof of type int [line: 36]
.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -13 size: 6] [line: 36]		.   .   .   .   Child: 0  Id: b of array of type bool [mem: Local loc: -13 size: 6] [line: 36]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 2											Number of warnings: 2
Number of errors: 0											Number of errors: 0
unary.out ztmp23114.txt differ: byte 127, line 3
unary (Output DIFF)
WARNING(35): Variable 'a' may be uninitialized when used here.						WARNING(35): Variable 'a' may be uninitialized when used here.
WARNING(36): Variable 'b' may be uninitialized when used here.						WARNING(36): Variable 'b' may be uninitialized when used here.
Number of warnings: 2										   |	Loading file: BroadTests/unary.tm
Number of errors: 0										   |	-88 -88
------------------------------------								   |	-15 3
Loading file: unary.tm										   |	F F T T F T
												   >	7 5
Bye.													Bye.
====================================
FILE: var2.c-
-rw-------. 1 corg7983 domain_users   423 Nov 17 15:35 var2.c-
-rw-------. 1 corg7983 domain_users   425 Nov 17 15:35 var2.c-.f21
-rw-------. 1 corg7983 domain_users   423 Nov 17 15:35 var2.c-.f22
-rw-------. 1 corg7983 domain_users    72 Nov 17 15:35 var2.expected
-rw-------. 1 corg7983 domain_users  3784 Nov 22 12:27 var2.mem
-rw-------. 1 corg7983 domain_users   242 Nov 17 15:35 var2.mem.diffs
-rw-------. 1 corg7983 domain_users  4628 Nov 17 15:35 var2.mem.f21
-rw-------. 1 corg7983 domain_users   106 Nov 22 12:27 var2.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 var2.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 var2.tm.diffs
-rw-------. 1 corg7983 domain_users 10935 Nov 17 15:35 var2.tm.f21
TM CODE COMPARISON
var2 (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  var2.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	 40:    LDC  3,222(6)	Load integer constant 
												   >	 41:     ST  3,-3(1)	Store variable y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 42:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 43:     LD  3,-2(1)	Load variable x
												   >	 44:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 45:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 46:    LDA  3,1(7)	Return address in ac 
												   >	 47:    JMP  7,-42(7)	CALL output
												   >	 48:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 49:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 50:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 51:    LDA  3,1(7)	Return address in ac 
												   >	 52:    JMP  7,-19(7)	CALL outnl
												   >	 53:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 54:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 55:     LD  3,-10(0)	Load variable z
												   >	 56:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 57:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 58:    LDA  3,1(7)	Return address in ac 
												   >	 59:    JMP  7,-54(7)	CALL output
												   >	 60:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 61:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 62:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 63:    LDA  3,1(7)	Return address in ac 
												   >	 64:    JMP  7,-31(7)	CALL outnl
												   >	 65:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 66:     LD  3,-3(1)	Load variable y
												   >	 67:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 68:     LD  3,0(0)	Load variable g
												   >	 69:     ST  3,-10(0)	Store variable z
												   >	* EXPRESSION
												   >	* CALL output
												   >	 70:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 71:     LD  3,-2(1)	Load variable x
												   >	 72:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 73:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 74:    LDA  3,1(7)	Return address in ac 
												   >	 75:    JMP  7,-70(7)	CALL output
												   >	 76:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 77:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 78:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 79:    LDA  3,1(7)	Return address in ac 
												   >	 80:    JMP  7,-47(7)	CALL outnl
												   >	 81:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 82:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 83:     LD  3,-10(0)	Load variable z
												   >	 84:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 85:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 86:    LDA  3,1(7)	Return address in ac 
												   >	 87:    JMP  7,-82(7)	CALL output
												   >	 88:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 89:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 90:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 91:    LDA  3,1(7)	Return address in ac 
												   >	 92:    JMP  7,-59(7)	CALL outnl
												   >	 93:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* RETURN
												   >	 94:     LD  3,-10(0)	Load variable z
												   >	 95:    LDA  2,0(3)	Copy result to return register 
												   >	 96:     LD  3,-1(1)	Load return address 
												   >	 97:     LD  1,0(1)	Adjust fp 
												   >	 98:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 99:    LDC  2,0(6)	Set return value to 0 
												   >	100:     LD  3,-1(1)	Load return address 
												   >	101:     LD  1,0(1)	Adjust fp 
												   >	102:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	103:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	104:    LDC  3,444(6)	Load integer constant 
												   >	105:     ST  3,-2(1)	Store variable m
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	106:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	107:    LDA  3,-2(0)	Load address of base of array h
												   >	108:     LD  3,1(3)	Load array size 
												   >	109:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	110:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	111:    LDA  3,1(7)	Return address in ac 
												   >	112:    JMP  7,-107(7)	CALL output
												   >	113:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	114:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	115:     LD  3,0(0)	Load variable g
												   >	116:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	117:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	118:    LDA  3,1(7)	Return address in ac 
												   >	119:    JMP  7,-114(7)	CALL output
												   >	120:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	121:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	122:     LD  3,-2(1)	Load variable m
												   >	123:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	124:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	125:    LDA  3,1(7)	Return address in ac 
												   >	126:    JMP  7,-121(7)	CALL output
												   >	127:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	128:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	129:     LD  3,-11(0)	Load variable z
												   >	130:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	131:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	132:    LDA  3,1(7)	Return address in ac 
												   >	133:    JMP  7,-128(7)	CALL output
												   >	134:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	135:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	136:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	137:    LDA  3,1(7)	Return address in ac 
												   >	138:    JMP  7,-105(7)	CALL outnl
												   >	139:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL dog
												   >	140:     ST  1,-3(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	141:     LD  3,-2(1)	Load variable m
												   >	142:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end dog
												   >	143:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	144:    LDA  3,1(7)	Return address in ac 
												   >	145:    JMP  7,-107(7)	CALL dog
												   >	146:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL output
												   >	147:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	148:     LD  3,-11(0)	Load variable z
												   >	149:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	150:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	151:    LDA  3,1(7)	Return address in ac 
												   >	152:    JMP  7,-147(7)	CALL output
												   >	153:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	154:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	155:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	156:    LDA  3,1(7)	Return address in ac 
												   >	157:    JMP  7,-124(7)	CALL outnl
												   >	158:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	159:    LDC  2,0(6)	Set return value to 0 
												   >	160:     LD  3,-1(1)	Load return address 
												   >	161:     LD  1,0(1)	Adjust fp 
												   >	162:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,162(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	163:    LDA  1,-12(0)	set first frame at end of globals 
												   >	164:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	165:    LDC  3,111(6)	Load integer constant 
												   >	166:     ST  3,-2(1)	Push left side 
												   >	* TOFF dec: -3
												   >	167:    LDC  3,22(6)	Load integer constant 
												   >	168:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	169:    LDC  3,33(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	170:     LD  4,-3(1)	Pop left into ac1 
												   >	171:    MUL  3,4,3	Op * 
												   >	* TOFF inc: -2
												   >	172:     LD  4,-2(1)	Pop left into ac1 
												   >	173:    ADD  3,4,3	Op + 
												   >	174:     ST  3,0(0)	Store variable g
												   >	175:    LDC  3,8(6)	load size of array h
												   >	176:     ST  3,-1(0)	save size of array h
												   >	177:    LDC  3,333(6)	Load integer constant 
												   >	178:     ST  3,-10(0)	Store variable z
												   >	179:    LDC  3,555(6)	Load integer constant 
												   >	180:     ST  3,-11(0)	Store variable z
												   >	* END INIT GLOBALS AND STATICS
												   >	181:    LDA  3,1(7)	Return address in ac 
												   >	182:    JMP  7,-80(7)	Jump to main 
												   >	183:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
var2.mem var2.mem.f21 differ: byte 1, line 1
var2 (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 2]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 2]
.   Child: 0  Op: + of type int [line: 2]								.   Child: 0  Op: + of type int [line: 2]
.   .   Child: 0  Const 111 of type int [line: 2]							.   .   Child: 0  Const 111 of type int [line: 2]
.   .   Child: 1  Op: * of type int [line: 2]								.   .   Child: 1  Op: * of type int [line: 2]
.   .   .   Child: 0  Const 22 of type int [line: 2]							.   .   .   Child: 0  Const 22 of type int [line: 2]
.   .   .   Child: 1  Const 33 of type int [line: 2]							.   .   .   Child: 1  Const 33 of type int [line: 2]
Sibling: 1  Var: h of array of type int [mem: Global loc: -2 size: 9] [line: 3]			   |	Sibling: 8  Var: h of array of type int [mem: Global loc: -2 size: 9] [line: 3]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 5]			   |	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 5]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 5]
.   .   Child: 0  Var: y of type int [mem: Local loc: -3 size: 1] [line: 6]				.   .   Child: 0  Var: y of type int [mem: Local loc: -3 size: 1] [line: 6]
.   .   .   Child: 0  Const 222 of type int [line: 6]							.   .   .   Child: 0  Const 222 of type int [line: 6]
.   .   Sibling: 1  Var: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 7]		.   .   Sibling: 1  Var: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 7]
.   .   .   Child: 0  Const 333 of type int [line: 7]							.   .   .   Child: 0  Const 333 of type int [line: 7]
.   .   Child: 1  Call: output of type void [line: 9]							.   .   Child: 1  Call: output of type void [line: 9]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 9]
.   .   Sibling: 1  Call: outnl of type void [line: 10]							.   .   Sibling: 1  Call: outnl of type void [line: 10]
.   .   Sibling: 2  Call: output of type void [line: 11]						.   .   Sibling: 2  Call: output of type void [line: 11]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 11]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 11]
.   .   Sibling: 3  Call: outnl of type void [line: 12]							.   .   Sibling: 3  Call: outnl of type void [line: 12]
.   .   Sibling: 4  Assign: = of type int [line: 14]						   |	.   .   Sibling: 4  Assign: := of type int [line: 14]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 14]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 14]
.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]				.   .   .   Child: 1  Id: y of type int [mem: Local loc: -3 size: 1] [line: 14]
.   .   Sibling: 5  Assign: = of type int [line: 15]						   |	.   .   Sibling: 5  Assign: := of type int [line: 15]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 15]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 15]
.   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]				.   .   .   Child: 1  Id: g of type int [mem: Global loc: 0 size: 1] [line: 15]
.   .   Sibling: 6  Call: output of type void [line: 17]						.   .   Sibling: 6  Call: output of type void [line: 17]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 17]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 17]
.   .   Sibling: 7  Call: outnl of type void [line: 18]							.   .   Sibling: 7  Call: outnl of type void [line: 18]
.   .   Sibling: 8  Call: output of type void [line: 19]						.   .   Sibling: 8  Call: output of type void [line: 19]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 19]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 19]
.   .   Sibling: 9  Call: outnl of type void [line: 20]							.   .   Sibling: 9  Call: outnl of type void [line: 20]
.   .   Sibling: 10  Return [line: 21]									.   .   Sibling: 10  Return [line: 21]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 21]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -10 size: 1] [line: 21]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 24]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 24]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 25]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 25]
.   .   Child: 0  Var: m of type int [mem: Local loc: -2 size: 1] [line: 26]				.   .   Child: 0  Var: m of type int [mem: Local loc: -2 size: 1] [line: 26]
.   .   .   Child: 0  Const 444 of type int [line: 26]							.   .   .   Child: 0  Const 444 of type int [line: 26]
.   .   Sibling: 1  Var: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 27]		.   .   Sibling: 1  Var: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 27]
.   .   .   Child: 0  Const 555 of type int [line: 27]							.   .   .   Child: 0  Const 555 of type int [line: 27]
.   .   Child: 1  Call: output of type void [line: 29]							.   .   Child: 1  Call: output of type void [line: 29]
.   .   .   Child: 0  Op: sizeof of type int [line: 29]							.   .   .   Child: 0  Op: sizeof of type int [line: 29]
.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 9] [line: 29]		.   .   .   .   Child: 0  Id: h of array of type int [mem: Global loc: -2 size: 9] [line: 29]
.   .   Sibling: 1  Call: output of type void [line: 30]						.   .   Sibling: 1  Call: output of type void [line: 30]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 30]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 30]
.   .   Sibling: 2  Call: output of type void [line: 31]						.   .   Sibling: 2  Call: output of type void [line: 31]
.   .   .   Child: 0  Id: m of type int [mem: Local loc: -2 size: 1] [line: 31]				.   .   .   Child: 0  Id: m of type int [mem: Local loc: -2 size: 1] [line: 31]
.   .   Sibling: 3  Call: output of type void [line: 32]						.   .   Sibling: 3  Call: output of type void [line: 32]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 32]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 32]
.   .   Sibling: 4  Call: outnl of type void [line: 33]							.   .   Sibling: 4  Call: outnl of type void [line: 33]
.   .   Sibling: 5  Call: dog of type int [line: 34]							.   .   Sibling: 5  Call: dog of type int [line: 34]
.   .   .   Child: 0  Id: m of type int [mem: Local loc: -2 size: 1] [line: 34]				.   .   .   Child: 0  Id: m of type int [mem: Local loc: -2 size: 1] [line: 34]
.   .   Sibling: 6  Call: output of type void [line: 35]						.   .   Sibling: 6  Call: output of type void [line: 35]
.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 35]		.   .   .   Child: 0  Id: z of static type int [mem: LocalStatic loc: -11 size: 1] [line: 35]
.   .   Sibling: 7  Call: outnl of type void [line: 36]							.   .   Sibling: 7  Call: outnl of type void [line: 36]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
var2.out ztmp23114.txt differ: byte 1, line 1
var2 (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/var2.tm
Number of errors: 0										   |	8 837 444 555
------------------------------------								   |	444
Loading file: var2.tm										   |	333
												   >	222
												   >	837
												   >	555
Bye.													Bye.
====================================
FILE: vararray.c-
-rw-------. 1 corg7983 domain_users   449 Nov 17 15:35 vararray.c-
-rw-------. 1 corg7983 domain_users   454 Nov 17 15:35 vararray.c-.f21
-rw-------. 1 corg7983 domain_users   449 Nov 17 15:35 vararray.c-.f22
-rw-------. 1 corg7983 domain_users   150 Nov 17 15:35 vararray.expected
-rw-------. 1 corg7983 domain_users  5545 Nov 22 12:27 vararray.mem
-rw-------. 1 corg7983 domain_users   601 Nov 17 15:35 vararray.mem.diffs
-rw-------. 1 corg7983 domain_users  6392 Nov 17 15:35 vararray.mem.f21
-rw-------. 1 corg7983 domain_users   173 Nov 22 12:27 vararray.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 vararray.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 vararray.tm.diffs
-rw-------. 1 corg7983 domain_users 13203 Nov 17 15:35 vararray.tm.f21
TM CODE COMPARISON
vararray (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  vararray.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -3
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load address of base of array q
												   >	 42:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	 43:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	 44:     LD  4,-5(1)	Pop left into ac1 
												   >	 45:    SUB  3,4,3	compute location from index 
												   >	 46:     LD  3,0(3)	Load array element 
												   >	 47:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 48:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 49:    LDA  3,1(7)	Return address in ac 
												   >	 50:    JMP  7,-45(7)	CALL output
												   >	 51:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 52:    LDC  2,0(6)	Set return value to 0 
												   >	 53:     LD  3,-1(1)	Load return address 
												   >	 54:     LD  1,0(1)	Adjust fp 
												   >	 55:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -3
												   >	 56:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -13
												   >	 57:    LDC  3,9(6)	load size of array y
												   >	 58:     ST  3,-3(1)	save size of array y
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 59:     ST  1,-13(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -14
												   >	* TOFF dec: -15
												   >	* Param 1
												   >	 60:     LD  3,-2(1)	Load address of base of array x
												   >	 61:     LD  3,1(3)	Load array size 
												   >	 62:     ST  3,-15(1)	Push parameter 
												   >	* TOFF dec: -16
												   >	* Param end output
												   >	 63:    LDA  1,-13(1)	Ghost frame becomes new active frame 
												   >	 64:    LDA  3,1(7)	Return address in ac 
												   >	 65:    JMP  7,-60(7)	CALL output
												   >	 66:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -13
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 67:     ST  1,-13(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -14
												   >	* TOFF dec: -15
												   >	* Param end outnl
												   >	 68:    LDA  1,-13(1)	Ghost frame becomes new active frame 
												   >	 69:    LDA  3,1(7)	Return address in ac 
												   >	 70:    JMP  7,-37(7)	CALL outnl
												   >	 71:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -13
												   >	* EXPRESSION
												   >	* CALL output
												   >	 72:     ST  1,-13(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -14
												   >	* TOFF dec: -15
												   >	* Param 1
												   >	 73:     LD  3,-2(1)	Load address of base of array x
												   >	 74:     ST  3,-15(1)	Push left side 
												   >	* TOFF dec: -16
												   >	 75:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -15
												   >	 76:     LD  4,-15(1)	Pop left into ac1 
												   >	 77:    SUB  3,4,3	compute location from index 
												   >	 78:     LD  3,0(3)	Load array element 
												   >	 79:     ST  3,-15(1)	Push parameter 
												   >	* TOFF dec: -16
												   >	* Param end output
												   >	 80:    LDA  1,-13(1)	Ghost frame becomes new active frame 
												   >	 81:    LDA  3,1(7)	Return address in ac 
												   >	 82:    JMP  7,-77(7)	CALL output
												   >	 83:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -13
												   >	* EXPRESSION
												   >	* CALL cat
												   >	 84:     ST  1,-13(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -14
												   >	* TOFF dec: -15
												   >	* Param 1
												   >	 85:     LD  3,-2(1)	Load address of base of array x
												   >	 86:     ST  3,-15(1)	Push parameter 
												   >	* TOFF dec: -16
												   >	* Param end cat
												   >	 87:    LDA  1,-13(1)	Ghost frame becomes new active frame 
												   >	 88:    LDA  3,1(7)	Return address in ac 
												   >	 89:    JMP  7,-51(7)	CALL cat
												   >	 90:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -13
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 91:     ST  1,-13(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -14
												   >	* TOFF dec: -15
												   >	* Param end outnl
												   >	 92:    LDA  1,-13(1)	Ghost frame becomes new active frame 
												   >	 93:    LDA  3,1(7)	Return address in ac 
												   >	 94:    JMP  7,-61(7)	CALL outnl
												   >	 95:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -13
												   >	* EXPRESSION
												   >	 96:    LDC  3,5(6)	Load integer constant 
												   >	 97:     ST  3,-13(1)	Push index 
												   >	* TOFF dec: -14
												   >	 98:    LDA  3,-4(1)	Load address of base of array y
												   >	 99:     ST  3,-14(1)	Push left side 
												   >	* TOFF dec: -15
												   >	100:    LDC  3,5(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	101:     LD  4,-14(1)	Pop left into ac1 
												   >	102:    SUB  3,4,3	compute location from index 
												   >	103:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -13
												   >	104:     LD  4,-13(1)	Pop index 
												   >	105:     LD  5,-2(1)	Load address of base of array x
												   >	106:    SUB  5,5,4	Compute offset of value 
												   >	107:     ST  3,0(5)	Store variable x
												   >	* EXPRESSION
												   >	108:    LDC  3,6(6)	Load integer constant 
												   >	109:     ST  3,-13(1)	Push index 
												   >	* TOFF dec: -14
												   >	110:    LDA  3,-1(0)	Load address of base of array g
												   >	111:     ST  3,-14(1)	Push left side 
												   >	* TOFF dec: -15
												   >	112:    LDC  3,6(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	113:     LD  4,-14(1)	Pop left into ac1 
												   >	114:    SUB  3,4,3	compute location from index 
												   >	115:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -13
												   >	116:     LD  4,-13(1)	Pop index 
												   >	117:    LDA  5,-14(0)	Load address of base of array z
												   >	118:    SUB  5,5,4	Compute offset of value 
												   >	119:     ST  3,0(5)	Store variable z
												   >	* RETURN
												   >	120:    LDA  3,-14(0)	Load address of base of array z
												   >	121:     ST  3,-13(1)	Push left side 
												   >	* TOFF dec: -14
												   >	122:    LDC  3,4(6)	Load integer constant 
												   >	* TOFF inc: -13
												   >	123:     LD  4,-13(1)	Pop left into ac1 
												   >	124:    SUB  3,4,3	compute location from index 
												   >	125:     LD  3,0(3)	Load array element 
												   >	126:    LDA  2,0(3)	Copy result to return register 
												   >	127:     LD  3,-1(1)	Load return address 
												   >	128:     LD  1,0(1)	Adjust fp 
												   >	129:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	130:    LDC  2,0(6)	Set return value to 0 
												   >	131:     LD  3,-1(1)	Load return address 
												   >	132:     LD  1,0(1)	Adjust fp 
												   >	133:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	134:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	135:    LDC  3,11(6)	load size of array m
												   >	136:     ST  3,-2(1)	save size of array m
												   >	* Compound Body
												   >	* EXPRESSION
												   >	137:    LDC  3,10(6)	Load integer constant 
												   >	138:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	139:    LDC  3,111(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	140:     LD  4,-14(1)	Pop index 
												   >	141:    LDA  5,-3(1)	Load address of base of array m
												   >	142:    SUB  5,5,4	Compute offset of value 
												   >	143:     ST  3,0(5)	Store variable m
												   >	* EXPRESSION
												   >	* CALL dog
												   >	144:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	145:    LDA  3,-3(1)	Load address of base of array m
												   >	146:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end dog
												   >	147:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	148:    LDA  3,1(7)	Return address in ac 
												   >	149:    JMP  7,-94(7)	CALL dog
												   >	150:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	151:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	152:    LDA  3,-3(1)	Load address of base of array m
												   >	153:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	154:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	155:     LD  4,-16(1)	Pop left into ac1 
												   >	156:    SUB  3,4,3	compute location from index 
												   >	157:     LD  3,0(3)	Load array element 
												   >	158:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	159:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	160:    LDA  3,1(7)	Return address in ac 
												   >	161:    JMP  7,-156(7)	CALL output
												   >	162:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	163:    LDC  3,10(6)	Load integer constant 
												   >	164:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	165:    LDC  3,222(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	166:     LD  4,-14(1)	Pop index 
												   >	167:    LDA  5,-1(0)	Load address of base of array g
												   >	168:    SUB  5,5,4	Compute offset of value 
												   >	169:     ST  3,0(5)	Store variable g
												   >	* EXPRESSION
												   >	* CALL dog
												   >	170:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	171:    LDA  3,-1(0)	Load address of base of array g
												   >	172:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end dog
												   >	173:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	174:    LDA  3,1(7)	Return address in ac 
												   >	175:    JMP  7,-120(7)	CALL dog
												   >	176:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	177:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	178:    LDA  3,-1(0)	Load address of base of array g
												   >	179:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	180:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	181:     LD  4,-16(1)	Pop left into ac1 
												   >	182:    SUB  3,4,3	compute location from index 
												   >	183:     LD  3,0(3)	Load array element 
												   >	184:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	185:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	186:    LDA  3,1(7)	Return address in ac 
												   >	187:    JMP  7,-182(7)	CALL output
												   >	188:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	189:    LDC  3,10(6)	Load integer constant 
												   >	190:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	191:    LDC  3,333(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	192:     LD  4,-14(1)	Pop index 
												   >	193:    LDA  5,-25(0)	Load address of base of array z
												   >	194:    SUB  5,5,4	Compute offset of value 
												   >	195:     ST  3,0(5)	Store variable z
												   >	* EXPRESSION
												   >	* CALL dog
												   >	196:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	197:    LDA  3,-25(0)	Load address of base of array z
												   >	198:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end dog
												   >	199:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	200:    LDA  3,1(7)	Return address in ac 
												   >	201:    JMP  7,-146(7)	CALL dog
												   >	202:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	203:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	204:    LDA  3,-25(0)	Load address of base of array z
												   >	205:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	206:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	207:     LD  4,-16(1)	Pop left into ac1 
												   >	208:    SUB  3,4,3	compute location from index 
												   >	209:     LD  3,0(3)	Load array element 
												   >	210:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	211:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	212:    LDA  3,1(7)	Return address in ac 
												   >	213:    JMP  7,-208(7)	CALL output
												   >	214:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	215:    LDC  2,0(6)	Set return value to 0 
												   >	216:     LD  3,-1(1)	Load return address 
												   >	217:     LD  1,0(1)	Adjust fp 
												   >	218:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,218(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	219:    LDA  1,-38(0)	set first frame at end of globals 
												   >	220:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	221:    LDC  3,12(6)	load size of array g
												   >	222:     ST  3,0(0)	save size of array g
												   >	223:    LDC  3,10(6)	load size of array z
												   >	224:     ST  3,-13(0)	save size of array z
												   >	225:    LDC  3,13(6)	load size of array z
												   >	226:     ST  3,-24(0)	save size of array z
												   >	* END INIT GLOBALS AND STATICS
												   >	227:    LDA  3,1(7)	Return address in ac 
												   >	228:    JMP  7,-95(7)	Jump to main 
												   >	229:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
vararray.mem vararray.mem.f21 differ: byte 64, line 2
vararray (MEM DIFF)
WARNING(15): Variable 'y' may be uninitialized when used here.						WARNING(15): Variable 'y' may be uninitialized when used here.
Var: g of array of type int [mem: Global loc: -1 size: 13] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 3]			   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of array of type int [mem: Global loc: -1 size: 13] [line: 1]
												   >	Sibling: 8  Func: cat returns type void [mem: Global loc: 0 size: -3] [line: 3]
.   Child: 0  Parm: q of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]			.   Child: 0  Parm: q of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 3]
.   .   Child: 1  Call: output of type void [line: 3]							.   .   Child: 1  Call: output of type void [line: 3]
.   .   .   Child: 0  Op: [ of type int [line: 3]							.   .   .   Child: 0  Op: [ of type int [line: 3]
.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]		.   .   .   .   Child: 0  Id: q of array of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   .   .   .   Child: 1  Const 10 of type int [line: 3]						.   .   .   .   Child: 1  Const 10 of type int [line: 3]
Sibling: 2  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 6]			   |	Sibling: 9  Func: dog returns type int [mem: Global loc: 0 size: -3] [line: 6]
.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]			.   Child: 0  Parm: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 6]
.   Child: 1  Compound [mem: None loc: 0 size: -13] [line: 6]						.   Child: 1  Compound [mem: None loc: 0 size: -13] [line: 6]
.   .   Child: 0  Var: y of array of type int [mem: Local loc: -4 size: 10] [line: 7]			.   .   Child: 0  Var: y of array of type int [mem: Local loc: -4 size: 10] [line: 7]
.   .   Sibling: 1  Var: z of static array of type int [mem: LocalStatic loc: -14 size: 11] [lin	.   .   Sibling: 1  Var: z of static array of type int [mem: LocalStatic loc: -14 size: 11] [lin
.   .   Child: 1  Call: output of type void [line: 10]							.   .   Child: 1  Call: output of type void [line: 10]
.   .   .   Child: 0  Op: sizeof of type int [line: 10]							.   .   .   Child: 0  Op: sizeof of type int [line: 10]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   .   Sibling: 1  Call: outnl of type void [line: 11]							.   .   Sibling: 1  Call: outnl of type void [line: 11]
.   .   Sibling: 2  Call: output of type void [line: 12]						.   .   Sibling: 2  Call: output of type void [line: 12]
.   .   .   Child: 0  Op: [ of type int [line: 12]							.   .   .   Child: 0  Op: [ of type int [line: 12]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 12]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 12]
.   .   .   .   Child: 1  Const 10 of type int [line: 12]						.   .   .   .   Child: 1  Const 10 of type int [line: 12]
.   .   Sibling: 3  Call: cat of type void [line: 13]							.   .   Sibling: 3  Call: cat of type void [line: 13]
.   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 13]		.   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 13]
.   .   Sibling: 4  Call: outnl of type void [line: 14]							.   .   Sibling: 4  Call: outnl of type void [line: 14]
.   .   Sibling: 5  Assign: = of type int [line: 15]						   |	.   .   Sibling: 5  Assign: := of type int [line: 15]
.   .   .   Child: 0  Op: [ of type int [line: 15]							.   .   .   Child: 0  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 15]	.   .   .   .   Child: 0  Id: x of array of type int [mem: Parameter loc: -2 size: 1] [line: 15]
.   .   .   .   Child: 1  Const 5 of type int [line: 15]						.   .   .   .   Child: 1  Const 5 of type int [line: 15]
.   .   .   Child: 1  Op: [ of type int [line: 15]							.   .   .   Child: 1  Op: [ of type int [line: 15]
.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -4 size: 10] [line: 15]		.   .   .   .   Child: 0  Id: y of array of type int [mem: Local loc: -4 size: 10] [line: 15]
.   .   .   .   Child: 1  Const 5 of type int [line: 15]						.   .   .   .   Child: 1  Const 5 of type int [line: 15]
.   .   Sibling: 6  Assign: = of type int [line: 16]						   |	.   .   Sibling: 6  Assign: := of type int [line: 16]
.   .   .   Child: 0  Op: [ of type int [line: 16]							.   .   .   Child: 0  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -14 size: 11]	.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -14 size: 11]
.   .   .   .   Child: 1  Const 6 of type int [line: 16]						.   .   .   .   Child: 1  Const 6 of type int [line: 16]
.   .   .   Child: 1  Op: [ of type int [line: 16]							.   .   .   Child: 1  Op: [ of type int [line: 16]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 16]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 16]
.   .   .   .   Child: 1  Const 6 of type int [line: 16]						.   .   .   .   Child: 1  Const 6 of type int [line: 16]
.   .   Sibling: 7  Return [line: 18]									.   .   Sibling: 7  Return [line: 18]
.   .   .   Child: 0  Op: [ of type int [line: 18]							.   .   .   Child: 0  Op: [ of type int [line: 18]
.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -14 size: 11]	.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -14 size: 11]
.   .   .   .   Child: 1  Const 4 of type int [line: 18]						.   .   .   .   Child: 1  Const 4 of type int [line: 18]
Sibling: 3  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 21]		   |	Sibling: 10  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 21]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 22]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 22]
.   .   Child: 0  Var: m of array of type int [mem: Local loc: -3 size: 12] [line: 23]			.   .   Child: 0  Var: m of array of type int [mem: Local loc: -3 size: 12] [line: 23]
.   .   Sibling: 1  Var: z of static array of type int [mem: LocalStatic loc: -25 size: 14] [lin	.   .   Sibling: 1  Var: z of static array of type int [mem: LocalStatic loc: -25 size: 14] [lin
.   .   Child: 1  Assign: = of type int [line: 26]						   |	.   .   Child: 1  Assign: := of type int [line: 26]
.   .   .   Child: 0  Op: [ of type int [line: 26]							.   .   .   Child: 0  Op: [ of type int [line: 26]
.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 26]		.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 26]
.   .   .   .   Child: 1  Const 10 of type int [line: 26]						.   .   .   .   Child: 1  Const 10 of type int [line: 26]
.   .   .   Child: 1  Const 111 of type int [line: 26]							.   .   .   Child: 1  Const 111 of type int [line: 26]
.   .   Sibling: 1  Call: dog of type int [line: 27]							.   .   Sibling: 1  Call: dog of type int [line: 27]
.   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 27]		.   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 27]
.   .   Sibling: 2  Call: output of type void [line: 28]						.   .   Sibling: 2  Call: output of type void [line: 28]
.   .   .   Child: 0  Op: [ of type int [line: 28]							.   .   .   Child: 0  Op: [ of type int [line: 28]
.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 28]		.   .   .   .   Child: 0  Id: m of array of type int [mem: Local loc: -3 size: 12] [line: 28]
.   .   .   .   Child: 1  Const 10 of type int [line: 28]						.   .   .   .   Child: 1  Const 10 of type int [line: 28]
.   .   Sibling: 3  Assign: = of type int [line: 30]						   |	.   .   Sibling: 3  Assign: := of type int [line: 30]
.   .   .   Child: 0  Op: [ of type int [line: 30]							.   .   .   Child: 0  Op: [ of type int [line: 30]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 30]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 30]
.   .   .   .   Child: 1  Const 10 of type int [line: 30]						.   .   .   .   Child: 1  Const 10 of type int [line: 30]
.   .   .   Child: 1  Const 222 of type int [line: 30]							.   .   .   Child: 1  Const 222 of type int [line: 30]
.   .   Sibling: 4  Call: dog of type int [line: 31]							.   .   Sibling: 4  Call: dog of type int [line: 31]
.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 31]		.   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 31]
.   .   Sibling: 5  Call: output of type void [line: 32]						.   .   Sibling: 5  Call: output of type void [line: 32]
.   .   .   Child: 0  Op: [ of type int [line: 32]							.   .   .   Child: 0  Op: [ of type int [line: 32]
.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 32]		.   .   .   .   Child: 0  Id: g of array of type int [mem: Global loc: -1 size: 13] [line: 32]
.   .   .   .   Child: 1  Const 10 of type int [line: 32]						.   .   .   .   Child: 1  Const 10 of type int [line: 32]
.   .   Sibling: 6  Assign: = of type int [line: 34]						   |	.   .   Sibling: 6  Assign: := of type int [line: 34]
.   .   .   Child: 0  Op: [ of type int [line: 34]							.   .   .   Child: 0  Op: [ of type int [line: 34]
.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14]	.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14]
.   .   .   .   Child: 1  Const 10 of type int [line: 34]						.   .   .   .   Child: 1  Const 10 of type int [line: 34]
.   .   .   Child: 1  Const 333 of type int [line: 34]							.   .   .   Child: 1  Const 333 of type int [line: 34]
.   .   Sibling: 7  Call: dog of type int [line: 35]							.   .   Sibling: 7  Call: dog of type int [line: 35]
.   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14] [li	.   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14] [li
.   .   Sibling: 8  Call: output of type void [line: 36]						.   .   Sibling: 8  Call: output of type void [line: 36]
.   .   .   Child: 0  Op: [ of type int [line: 36]							.   .   .   Child: 0  Op: [ of type int [line: 36]
.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14]	.   .   .   .   Child: 0  Id: z of static array of type int [mem: LocalStatic loc: -25 size: 14]
.   .   .   .   Child: 1  Const 10 of type int [line: 36]						.   .   .   .   Child: 1  Const 10 of type int [line: 36]
Offset for end of global space: -38									Offset for end of global space: -38
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
vararray.out ztmp23114.txt differ: byte 64, line 2
vararray (Output DIFF)
WARNING(15): Variable 'y' may be uninitialized when used here.						WARNING(15): Variable 'y' may be uninitialized when used here.
Number of warnings: 1										   |	Loading file: BroadTests/vararray.tm
Number of errors: 0										   |	11
------------------------------------								   |	111 111
Loading file: vararray.tm									   |	111 12
												   >	222 222
												   >	222 13
												   >	333 333
												   >	333
Bye.													Bye.
====================================
FILE: var.c-
-rw-------. 1 corg7983 domain_users   527 Nov 17 15:35 var.c-
-rw-------. 1 corg7983 domain_users   533 Nov 17 15:35 var.c-.f21
-rw-------. 1 corg7983 domain_users   527 Nov 17 15:35 var.c-.f22
-rw-------. 1 corg7983 domain_users    93 Nov 17 15:35 var.expected
-rw-------. 1 corg7983 domain_users  6434 Nov 22 12:27 var.mem
-rw-------. 1 corg7983 domain_users   722 Nov 17 15:35 var.mem.diffs
-rw-------. 1 corg7983 domain_users  7283 Nov 17 15:35 var.mem.f21
-rw-------. 1 corg7983 domain_users   105 Nov 22 12:27 var.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 var.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 var.tm.diffs
-rw-------. 1 corg7983 domain_users 16166 Nov 17 15:35 var.tm.f21
TM CODE COMPARISON
var (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  var.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load variable x
												   >	 42:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 43:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 47:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 48:     LD  3,-3(1)	Load address of base of array xa
												   >	 49:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 50:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 51:     LD  4,-6(1)	Pop left into ac1 
												   >	 52:    SUB  3,4,3	compute location from index 
												   >	 53:     LD  3,0(3)	Load array element 
												   >	 54:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 55:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-52(7)	CALL output
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 59:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 60:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-29(7)	CALL outnl
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 64:    LDC  2,0(6)	Set return value to 0 
												   >	 65:     LD  3,-1(1)	Load return address 
												   >	 66:     LD  1,0(1)	Adjust fp 
												   >	 67:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 68:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 69:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 70:     LD  3,-2(1)	Load variable x
												   >	 71:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 72:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-69(7)	CALL output
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 76:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 77:     LD  3,-3(1)	Load address of base of array xa
												   >	 78:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 79:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 80:     LD  4,-6(1)	Pop left into ac1 
												   >	 81:    SUB  3,4,3	compute location from index 
												   >	 82:     LD  3,0(3)	Load array element 
												   >	 83:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 84:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 85:    LDA  3,1(7)	Return address in ac 
												   >	 86:    JMP  7,-81(7)	CALL output
												   >	 87:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 88:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 89:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-58(7)	CALL outnl
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 93:    LDC  3,668(6)	Load integer constant 
												   >	 94:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 95:    LDC  3,1(6)	Load integer constant 
												   >	 96:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 97:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 98:     LD  4,-4(1)	Pop left into ac1 
												   >	 99:    ADD  3,4,3	Op + 
												   >	100:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	101:    LDC  3,669(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	102:     LD  4,-4(1)	Pop index 
												   >	103:     LD  5,-3(1)	Load address of base of array xa
												   >	104:    SUB  5,5,4	Compute offset of value 
												   >	105:     ST  3,0(5)	Store variable xa
												   >	* EXPRESSION
												   >	* CALL output
												   >	106:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	107:     LD  3,-2(1)	Load variable x
												   >	108:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	109:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-106(7)	CALL output
												   >	112:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	113:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	114:     LD  3,-3(1)	Load address of base of array xa
												   >	115:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	116:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	117:     LD  4,-6(1)	Pop left into ac1 
												   >	118:    SUB  3,4,3	compute location from index 
												   >	119:     LD  3,0(3)	Load array element 
												   >	120:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	121:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	122:    LDA  3,1(7)	Return address in ac 
												   >	123:    JMP  7,-118(7)	CALL output
												   >	124:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	125:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	126:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-95(7)	CALL outnl
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	130:    LDC  3,670(6)	Load integer constant 
												   >	131:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	132:    LDC  3,2(6)	Load integer constant 
												   >	133:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	134:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	135:     LD  4,-4(1)	Pop left into ac1 
												   >	136:    ADD  3,4,3	Op + 
												   >	137:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	138:    LDC  3,671(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	139:     LD  4,-4(1)	Pop index 
												   >	140:    LDA  5,-2(0)	Load address of base of array ga
												   >	141:    SUB  5,5,4	Compute offset of value 
												   >	142:     ST  3,0(5)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL output
												   >	143:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	144:     LD  3,0(0)	Load variable g
												   >	145:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	146:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	147:    LDA  3,1(7)	Return address in ac 
												   >	148:    JMP  7,-143(7)	CALL output
												   >	149:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	150:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	151:    LDA  3,-2(0)	Load address of base of array ga
												   >	152:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	153:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	154:     LD  4,-6(1)	Pop left into ac1 
												   >	155:    SUB  3,4,3	compute location from index 
												   >	156:     LD  3,0(3)	Load array element 
												   >	157:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	158:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	159:    LDA  3,1(7)	Return address in ac 
												   >	160:    JMP  7,-155(7)	CALL output
												   >	161:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	162:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	163:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	164:    LDA  3,1(7)	Return address in ac 
												   >	165:    JMP  7,-132(7)	CALL outnl
												   >	166:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL cat
												   >	167:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	168:     LD  3,-2(1)	Load variable x
												   >	169:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	170:     LD  3,-3(1)	Load address of base of array xa
												   >	171:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end cat
												   >	172:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-136(7)	CALL cat
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL cat
												   >	176:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	177:     LD  3,0(0)	Load variable g
												   >	178:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	179:    LDA  3,-2(0)	Load address of base of array ga
												   >	180:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end cat
												   >	181:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	182:    LDA  3,1(7)	Return address in ac 
												   >	183:    JMP  7,-145(7)	CALL cat
												   >	184:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	185:    LDC  2,0(6)	Set return value to 0 
												   >	186:     LD  3,-1(1)	Load return address 
												   >	187:     LD  1,0(1)	Adjust fp 
												   >	188:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	189:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	190:    LDC  3,10(6)	load size of array ya
												   >	191:     ST  3,-3(1)	save size of array ya
												   >	* Compound Body
												   >	* EXPRESSION
												   >	192:    LDC  3,666(6)	Load integer constant 
												   >	193:     ST  3,-2(1)	Store variable y
												   >	* EXPRESSION
												   >	194:    LDC  3,1(6)	Load integer constant 
												   >	195:     ST  3,-14(1)	Push left side 
												   >	* TOFF dec: -15
												   >	196:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	197:     LD  4,-14(1)	Pop left into ac1 
												   >	198:    ADD  3,4,3	Op + 
												   >	199:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	200:    LDC  3,667(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	201:     LD  4,-14(1)	Pop index 
												   >	202:    LDA  5,-4(1)	Load address of base of array ya
												   >	203:    SUB  5,5,4	Compute offset of value 
												   >	204:     ST  3,0(5)	Store variable ya
												   >	* EXPRESSION
												   >	* CALL output
												   >	205:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	206:     LD  3,-2(1)	Load variable y
												   >	207:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	208:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-205(7)	CALL output
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	212:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	213:    LDA  3,-4(1)	Load address of base of array ya
												   >	214:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	215:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	216:     LD  4,-16(1)	Pop left into ac1 
												   >	217:    SUB  3,4,3	compute location from index 
												   >	218:     LD  3,0(3)	Load array element 
												   >	219:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	220:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	221:    LDA  3,1(7)	Return address in ac 
												   >	222:    JMP  7,-217(7)	CALL output
												   >	223:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	224:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	225:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	226:    LDA  3,1(7)	Return address in ac 
												   >	227:    JMP  7,-194(7)	CALL outnl
												   >	228:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL dog
												   >	229:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	230:     LD  3,-2(1)	Load variable y
												   >	231:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param 2
												   >	232:    LDA  3,-4(1)	Load address of base of array ya
												   >	233:     ST  3,-17(1)	Push parameter 
												   >	* TOFF dec: -18
												   >	* Param end dog
												   >	234:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-169(7)	CALL dog
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	238:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	239:     LD  3,-2(1)	Load variable y
												   >	240:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	241:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	242:    LDA  3,1(7)	Return address in ac 
												   >	243:    JMP  7,-238(7)	CALL output
												   >	244:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	245:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	246:    LDA  3,-4(1)	Load address of base of array ya
												   >	247:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	248:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	249:     LD  4,-16(1)	Pop left into ac1 
												   >	250:    SUB  3,4,3	compute location from index 
												   >	251:     LD  3,0(3)	Load array element 
												   >	252:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	253:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	254:    LDA  3,1(7)	Return address in ac 
												   >	255:    JMP  7,-250(7)	CALL output
												   >	256:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	257:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	258:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	259:    LDA  3,1(7)	Return address in ac 
												   >	260:    JMP  7,-227(7)	CALL outnl
												   >	261:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	262:    LDC  2,0(6)	Set return value to 0 
												   >	263:     LD  3,-1(1)	Load return address 
												   >	264:     LD  1,0(1)	Adjust fp 
												   >	265:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,265(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	266:    LDA  1,-12(0)	set first frame at end of globals 
												   >	267:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	268:    LDC  3,10(6)	load size of array ga
												   >	269:     ST  3,-1(0)	save size of array ga
												   >	* END INIT GLOBALS AND STATICS
												   >	270:    LDA  3,1(7)	Return address in ac 
												   >	271:    JMP  7,-83(7)	Jump to main 
												   >	272:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
var.mem var.mem.f21 differ: byte 1, line 1
var (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: ga of array of type int [mem: Global loc: -2 size: 11] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: cat returns type void [mem: Global loc: 0 size: -4] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: ga of array of type int [mem: Global loc: -2 size: 11] [line: 1]
												   >	Sibling: 9  Func: cat returns type void [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]		.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 1  Call: output of type void [line: 5]							.   .   Child: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Call: output of type void [line: 6]							.   .   Sibling: 1  Call: output of type void [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 3 of type int [line: 6]							.   .   .   .   Child: 1  Const 3 of type int [line: 6]
.   .   Sibling: 2  Call: outnl of type void [line: 7]							.   .   Sibling: 2  Call: outnl of type void [line: 7]
Sibling: 3  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 10]		   |	Sibling: 10  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 10]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 10]		.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 11]
.   .   Child: 1  Call: output of type void [line: 12]							.   .   Child: 1  Call: output of type void [line: 12]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]
.   .   Sibling: 1  Call: output of type void [line: 13]						.   .   Sibling: 1  Call: output of type void [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 13	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 13
.   .   .   .   Child: 1  Const 3 of type int [line: 13]						.   .   .   .   Child: 1  Const 3 of type int [line: 13]
.   .   Sibling: 2  Call: outnl of type void [line: 14]							.   .   Sibling: 2  Call: outnl of type void [line: 14]
.   .   Sibling: 3  Assign: = of type int [line: 16]						   |	.   .   Sibling: 3  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]
.   .   .   Child: 1  Const 668 of type int [line: 16]							.   .   .   Child: 1  Const 668 of type int [line: 16]
.   .   Sibling: 4  Assign: = of type int [line: 17]						   |	.   .   Sibling: 4  Assign: := of type int [line: 17]
.   .   .   Child: 0  Op: [ of type int [line: 17]							.   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 17	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 17
.   .   .   .   Child: 1  Op: + of type int [line: 17]							.   .   .   .   Child: 1  Op: + of type int [line: 17]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 17]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 17]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 17]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 17]
.   .   .   Child: 1  Const 669 of type int [line: 17]							.   .   .   Child: 1  Const 669 of type int [line: 17]
.   .   Sibling: 5  Call: output of type void [line: 18]						.   .   Sibling: 5  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 18]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 18]
.   .   Sibling: 6  Call: output of type void [line: 19]						.   .   Sibling: 6  Call: output of type void [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 19	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 19
.   .   .   .   Child: 1  Const 3 of type int [line: 19]						.   .   .   .   Child: 1  Const 3 of type int [line: 19]
.   .   Sibling: 7  Call: outnl of type void [line: 20]							.   .   Sibling: 7  Call: outnl of type void [line: 20]
.   .   Sibling: 8  Assign: = of type int [line: 22]						   |	.   .   Sibling: 8  Assign: := of type int [line: 22]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 22]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 22]
.   .   .   Child: 1  Const 670 of type int [line: 22]							.   .   .   Child: 1  Const 670 of type int [line: 22]
.   .   Sibling: 9  Assign: = of type int [line: 23]						   |	.   .   Sibling: 9  Assign: := of type int [line: 23]
.   .   .   Child: 0  Op: [ of type int [line: 23]							.   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 23]		.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 23]
.   .   .   .   Child: 1  Op: + of type int [line: 23]							.   .   .   .   Child: 1  Op: + of type int [line: 23]
.   .   .   .   .   Child: 0  Const 2 of type int [line: 23]						.   .   .   .   .   Child: 0  Const 2 of type int [line: 23]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 23]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   Child: 1  Const 671 of type int [line: 23]							.   .   .   Child: 1  Const 671 of type int [line: 23]
.   .   Sibling: 10  Call: output of type void [line: 24]						.   .   Sibling: 10  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]
.   .   Sibling: 11  Call: output of type void [line: 25]						.   .   Sibling: 11  Call: output of type void [line: 25]
.   .   .   Child: 0  Op: [ of type int [line: 25]							.   .   .   Child: 0  Op: [ of type int [line: 25]
.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 25]		.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 25]
.   .   .   .   Child: 1  Const 3 of type int [line: 25]						.   .   .   .   Child: 1  Const 3 of type int [line: 25]
.   .   Sibling: 12  Call: outnl of type void [line: 26]						.   .   Sibling: 12  Call: outnl of type void [line: 26]
.   .   Sibling: 13  Call: cat of type void [line: 28]							.   .   Sibling: 13  Call: cat of type void [line: 28]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 28]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 28]
.   .   .   Sibling: 1  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 28]		.   .   .   Sibling: 1  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 28]
.   .   Sibling: 14  Call: cat of type void [line: 29]							.   .   Sibling: 14  Call: cat of type void [line: 29]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 29]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 29]
.   .   .   Sibling: 1  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 29]		.   .   .   Sibling: 1  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 29]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 32]		   |	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 32]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 33]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 33]
.   .   Child: 0  Var: y of type int [mem: Local loc: -2 size: 1] [line: 34]				.   .   Child: 0  Var: y of type int [mem: Local loc: -2 size: 1] [line: 34]
.   .   Sibling: 1  Var: ya of array of type int [mem: Local loc: -4 size: 11] [line: 34]		.   .   Sibling: 1  Var: ya of array of type int [mem: Local loc: -4 size: 11] [line: 34]
.   .   Child: 1  Assign: = of type int [line: 36]						   |	.   .   Child: 1  Assign: := of type int [line: 36]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 36]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 36]
.   .   .   Child: 1  Const 666 of type int [line: 36]							.   .   .   Child: 1  Const 666 of type int [line: 36]
.   .   Sibling: 1  Assign: = of type int [line: 37]						   |	.   .   Sibling: 1  Assign: := of type int [line: 37]
.   .   .   Child: 0  Op: [ of type int [line: 37]							.   .   .   Child: 0  Op: [ of type int [line: 37]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 37]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 37]
.   .   .   .   Child: 1  Op: + of type int [line: 37]							.   .   .   .   Child: 1  Op: + of type int [line: 37]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 37]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 37]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 37]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 37]
.   .   .   Child: 1  Const 667 of type int [line: 37]							.   .   .   Child: 1  Const 667 of type int [line: 37]
.   .   Sibling: 2  Call: output of type void [line: 38]						.   .   Sibling: 2  Call: output of type void [line: 38]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 38]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 38]
.   .   Sibling: 3  Call: output of type void [line: 39]						.   .   Sibling: 3  Call: output of type void [line: 39]
.   .   .   Child: 0  Op: [ of type int [line: 39]							.   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 39]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 39]
.   .   .   .   Child: 1  Const 3 of type int [line: 39]						.   .   .   .   Child: 1  Const 3 of type int [line: 39]
.   .   Sibling: 4  Call: outnl of type void [line: 40]							.   .   Sibling: 4  Call: outnl of type void [line: 40]
.   .   Sibling: 5  Call: dog of type void [line: 42]							.   .   Sibling: 5  Call: dog of type void [line: 42]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 42]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 42]
.   .   .   Sibling: 1  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 42]		.   .   .   Sibling: 1  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 42]
.   .   Sibling: 6  Call: output of type void [line: 44]						.   .   Sibling: 6  Call: output of type void [line: 44]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 44]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 44]
.   .   Sibling: 7  Call: output of type void [line: 45]						.   .   Sibling: 7  Call: output of type void [line: 45]
.   .   .   Child: 0  Op: [ of type int [line: 45]							.   .   .   Child: 0  Op: [ of type int [line: 45]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 45]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 45]
.   .   .   .   Child: 1  Const 3 of type int [line: 45]						.   .   .   .   Child: 1  Const 3 of type int [line: 45]
.   .   Sibling: 8  Call: outnl of type void [line: 46]							.   .   Sibling: 8  Call: outnl of type void [line: 46]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
var.out ztmp23114.txt differ: byte 1, line 1
var (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/var.tm
Number of errors: 0										   |	666 667
------------------------------------								   |	666 667
Loading file: var.tm										   |	668 669
												   >	670 671
												   >	668 669
												   >	670 671
												   >	666 669
Bye.													Bye.
====================================
FILE: varnovoid.c-
-rw-------. 1 corg7983 domain_users   527 Nov 17 15:35 varnovoid.c-
-rw-------. 1 corg7983 domain_users   533 Nov 17 15:35 varnovoid.c-.f21
-rw-------. 1 corg7983 domain_users   527 Nov 17 15:35 varnovoid.c-.f22
-rw-------. 1 corg7983 domain_users    99 Nov 17 15:35 varnovoid.expected
-rw-------. 1 corg7983 domain_users  6434 Nov 22 12:27 varnovoid.mem
-rw-------. 1 corg7983 domain_users   722 Nov 17 15:35 varnovoid.mem.diffs
-rw-------. 1 corg7983 domain_users  7283 Nov 17 15:35 varnovoid.mem.f21
-rw-------. 1 corg7983 domain_users   111 Nov 22 12:27 varnovoid.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 varnovoid.tm
-rw-------. 1 corg7983 domain_users   145 Nov 17 15:35 varnovoid.tm.diffs
-rw-------. 1 corg7983 domain_users 16172 Nov 17 15:35 varnovoid.tm.f21
TM CODE COMPARISON
varnovoid (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  varnovoid.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION cat
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 40:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 41:     LD  3,-2(1)	Load variable x
												   >	 42:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 43:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 44:    LDA  3,1(7)	Return address in ac 
												   >	 45:    JMP  7,-40(7)	CALL output
												   >	 46:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 47:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 48:     LD  3,-3(1)	Load address of base of array xa
												   >	 49:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 50:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 51:     LD  4,-6(1)	Pop left into ac1 
												   >	 52:    SUB  3,4,3	compute location from index 
												   >	 53:     LD  3,0(3)	Load array element 
												   >	 54:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 55:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 56:    LDA  3,1(7)	Return address in ac 
												   >	 57:    JMP  7,-52(7)	CALL output
												   >	 58:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 59:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 60:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 61:    LDA  3,1(7)	Return address in ac 
												   >	 62:    JMP  7,-29(7)	CALL outnl
												   >	 63:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 64:    LDC  2,0(6)	Set return value to 0 
												   >	 65:     LD  3,-1(1)	Load return address 
												   >	 66:     LD  1,0(1)	Adjust fp 
												   >	 67:    JMP  7,0(3)	Return 
												   >	* END FUNCTION cat
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION dog
												   >	* TOFF set: -4
												   >	 68:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -4
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 69:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 70:     LD  3,-2(1)	Load variable x
												   >	 71:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 72:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 73:    LDA  3,1(7)	Return address in ac 
												   >	 74:    JMP  7,-69(7)	CALL output
												   >	 75:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	 76:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	 77:     LD  3,-3(1)	Load address of base of array xa
												   >	 78:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 79:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 80:     LD  4,-6(1)	Pop left into ac1 
												   >	 81:    SUB  3,4,3	compute location from index 
												   >	 82:     LD  3,0(3)	Load array element 
												   >	 83:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	 84:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 85:    LDA  3,1(7)	Return address in ac 
												   >	 86:    JMP  7,-81(7)	CALL output
												   >	 87:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 88:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	 89:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	 90:    LDA  3,1(7)	Return address in ac 
												   >	 91:    JMP  7,-58(7)	CALL outnl
												   >	 92:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	 93:    LDC  3,668(6)	Load integer constant 
												   >	 94:     ST  3,-2(1)	Store variable x
												   >	* EXPRESSION
												   >	 95:    LDC  3,1(6)	Load integer constant 
												   >	 96:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	 97:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	 98:     LD  4,-4(1)	Pop left into ac1 
												   >	 99:    ADD  3,4,3	Op + 
												   >	100:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	101:    LDC  3,669(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	102:     LD  4,-4(1)	Pop index 
												   >	103:     LD  5,-3(1)	Load address of base of array xa
												   >	104:    SUB  5,5,4	Compute offset of value 
												   >	105:     ST  3,0(5)	Store variable xa
												   >	* EXPRESSION
												   >	* CALL output
												   >	106:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	107:     LD  3,-2(1)	Load variable x
												   >	108:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	109:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	110:    LDA  3,1(7)	Return address in ac 
												   >	111:    JMP  7,-106(7)	CALL output
												   >	112:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	113:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	114:     LD  3,-3(1)	Load address of base of array xa
												   >	115:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	116:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	117:     LD  4,-6(1)	Pop left into ac1 
												   >	118:    SUB  3,4,3	compute location from index 
												   >	119:     LD  3,0(3)	Load array element 
												   >	120:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	121:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	122:    LDA  3,1(7)	Return address in ac 
												   >	123:    JMP  7,-118(7)	CALL output
												   >	124:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	125:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	126:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	127:    LDA  3,1(7)	Return address in ac 
												   >	128:    JMP  7,-95(7)	CALL outnl
												   >	129:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	130:    LDC  3,670(6)	Load integer constant 
												   >	131:     ST  3,0(0)	Store variable g
												   >	* EXPRESSION
												   >	132:    LDC  3,2(6)	Load integer constant 
												   >	133:     ST  3,-4(1)	Push left side 
												   >	* TOFF dec: -5
												   >	134:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	135:     LD  4,-4(1)	Pop left into ac1 
												   >	136:    ADD  3,4,3	Op + 
												   >	137:     ST  3,-4(1)	Push index 
												   >	* TOFF dec: -5
												   >	138:    LDC  3,671(6)	Load integer constant 
												   >	* TOFF inc: -4
												   >	139:     LD  4,-4(1)	Pop index 
												   >	140:    LDA  5,-2(0)	Load address of base of array ga
												   >	141:    SUB  5,5,4	Compute offset of value 
												   >	142:     ST  3,0(5)	Store variable ga
												   >	* EXPRESSION
												   >	* CALL output
												   >	143:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	144:     LD  3,0(0)	Load variable g
												   >	145:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	146:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	147:    LDA  3,1(7)	Return address in ac 
												   >	148:    JMP  7,-143(7)	CALL output
												   >	149:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL output
												   >	150:     ST  1,-4(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	151:    LDA  3,-2(0)	Load address of base of array ga
												   >	152:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	153:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	154:     LD  4,-6(1)	Pop left into ac1 
												   >	155:    SUB  3,4,3	compute location from index 
												   >	156:     LD  3,0(3)	Load array element 
												   >	157:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param end output
												   >	158:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	159:    LDA  3,1(7)	Return address in ac 
												   >	160:    JMP  7,-155(7)	CALL output
												   >	161:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	162:     ST  1,-4(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param end outnl
												   >	163:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	164:    LDA  3,1(7)	Return address in ac 
												   >	165:    JMP  7,-132(7)	CALL outnl
												   >	166:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL cat
												   >	167:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	168:     LD  3,-2(1)	Load variable x
												   >	169:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	170:     LD  3,-3(1)	Load address of base of array xa
												   >	171:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end cat
												   >	172:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-136(7)	CALL cat
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* EXPRESSION
												   >	* CALL cat
												   >	176:     ST  1,-4(1)	Store fp in ghost frame for cat
												   >	* TOFF dec: -5
												   >	* TOFF dec: -6
												   >	* Param 1
												   >	177:     LD  3,0(0)	Load variable g
												   >	178:     ST  3,-6(1)	Push parameter 
												   >	* TOFF dec: -7
												   >	* Param 2
												   >	179:    LDA  3,-2(0)	Load address of base of array ga
												   >	180:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end cat
												   >	181:    LDA  1,-4(1)	Ghost frame becomes new active frame 
												   >	182:    LDA  3,1(7)	Return address in ac 
												   >	183:    JMP  7,-145(7)	CALL cat
												   >	184:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end cat
												   >	* TOFF set: -4
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	185:    LDC  2,0(6)	Set return value to 0 
												   >	186:     LD  3,-1(1)	Load return address 
												   >	187:     LD  1,0(1)	Adjust fp 
												   >	188:    JMP  7,0(3)	Return 
												   >	* END FUNCTION dog
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	189:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -14
												   >	190:    LDC  3,10(6)	load size of array ya
												   >	191:     ST  3,-3(1)	save size of array ya
												   >	* Compound Body
												   >	* EXPRESSION
												   >	192:    LDC  3,666(6)	Load integer constant 
												   >	193:     ST  3,-2(1)	Store variable y
												   >	* EXPRESSION
												   >	194:    LDC  3,1(6)	Load integer constant 
												   >	195:     ST  3,-14(1)	Push left side 
												   >	* TOFF dec: -15
												   >	196:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	197:     LD  4,-14(1)	Pop left into ac1 
												   >	198:    ADD  3,4,3	Op + 
												   >	199:     ST  3,-14(1)	Push index 
												   >	* TOFF dec: -15
												   >	200:    LDC  3,667(6)	Load integer constant 
												   >	* TOFF inc: -14
												   >	201:     LD  4,-14(1)	Pop index 
												   >	202:    LDA  5,-4(1)	Load address of base of array ya
												   >	203:    SUB  5,5,4	Compute offset of value 
												   >	204:     ST  3,0(5)	Store variable ya
												   >	* EXPRESSION
												   >	* CALL output
												   >	205:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	206:     LD  3,-2(1)	Load variable y
												   >	207:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	208:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	209:    LDA  3,1(7)	Return address in ac 
												   >	210:    JMP  7,-205(7)	CALL output
												   >	211:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	212:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	213:    LDA  3,-4(1)	Load address of base of array ya
												   >	214:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	215:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	216:     LD  4,-16(1)	Pop left into ac1 
												   >	217:    SUB  3,4,3	compute location from index 
												   >	218:     LD  3,0(3)	Load array element 
												   >	219:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	220:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	221:    LDA  3,1(7)	Return address in ac 
												   >	222:    JMP  7,-217(7)	CALL output
												   >	223:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	224:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	225:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	226:    LDA  3,1(7)	Return address in ac 
												   >	227:    JMP  7,-194(7)	CALL outnl
												   >	228:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL dog
												   >	229:     ST  1,-14(1)	Store fp in ghost frame for dog
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	230:     LD  3,-2(1)	Load variable y
												   >	231:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param 2
												   >	232:    LDA  3,-4(1)	Load address of base of array ya
												   >	233:     ST  3,-17(1)	Push parameter 
												   >	* TOFF dec: -18
												   >	* Param end dog
												   >	234:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	235:    LDA  3,1(7)	Return address in ac 
												   >	236:    JMP  7,-169(7)	CALL dog
												   >	237:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end dog
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	238:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	239:     LD  3,-2(1)	Load variable y
												   >	240:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	241:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	242:    LDA  3,1(7)	Return address in ac 
												   >	243:    JMP  7,-238(7)	CALL output
												   >	244:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL output
												   >	245:     ST  1,-14(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param 1
												   >	246:    LDA  3,-4(1)	Load address of base of array ya
												   >	247:     ST  3,-16(1)	Push left side 
												   >	* TOFF dec: -17
												   >	248:    LDC  3,3(6)	Load integer constant 
												   >	* TOFF inc: -16
												   >	249:     LD  4,-16(1)	Pop left into ac1 
												   >	250:    SUB  3,4,3	compute location from index 
												   >	251:     LD  3,0(3)	Load array element 
												   >	252:     ST  3,-16(1)	Push parameter 
												   >	* TOFF dec: -17
												   >	* Param end output
												   >	253:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	254:    LDA  3,1(7)	Return address in ac 
												   >	255:    JMP  7,-250(7)	CALL output
												   >	256:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -14
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	257:     ST  1,-14(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -15
												   >	* TOFF dec: -16
												   >	* Param end outnl
												   >	258:    LDA  1,-14(1)	Ghost frame becomes new active frame 
												   >	259:    LDA  3,1(7)	Return address in ac 
												   >	260:    JMP  7,-227(7)	CALL outnl
												   >	261:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -14
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	262:    LDC  2,0(6)	Set return value to 0 
												   >	263:     LD  3,-1(1)	Load return address 
												   >	264:     LD  1,0(1)	Adjust fp 
												   >	265:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,265(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	266:    LDA  1,-12(0)	set first frame at end of globals 
												   >	267:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	268:    LDC  3,10(6)	load size of array ga
												   >	269:     ST  3,-1(0)	save size of array ga
												   >	* END INIT GLOBALS AND STATICS
												   >	270:    LDA  3,1(7)	Return address in ac 
												   >	271:    JMP  7,-83(7)	Jump to main 
												   >	272:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
varnovoid.mem varnovoid.mem.f21 differ: byte 1, line 1
varnovoid (MEM DIFF)
Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]					   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
Sibling: 1  Var: ga of array of type int [mem: Global loc: -2 size: 11] [line: 1]		   |	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
Sibling: 2  Func: cat returns type void [mem: Global loc: 0 size: -4] [line: 3]			   |	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Var: g of type int [mem: Global loc: 0 size: 1] [line: 1]
												   >	Sibling: 8  Var: ga of array of type int [mem: Global loc: -2 size: 11] [line: 1]
												   >	Sibling: 9  Func: cat returns type void [mem: Global loc: 0 size: -4] [line: 3]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 3]
.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]		.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 3]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 4]
.   .   Child: 1  Call: output of type void [line: 5]							.   .   Child: 1  Call: output of type void [line: 5]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 5]
.   .   Sibling: 1  Call: output of type void [line: 6]							.   .   Sibling: 1  Call: output of type void [line: 6]
.   .   .   Child: 0  Op: [ of type int [line: 6]							.   .   .   Child: 0  Op: [ of type int [line: 6]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 3 of type int [line: 6]							.   .   .   .   Child: 1  Const 3 of type int [line: 6]
.   .   Sibling: 2  Call: outnl of type void [line: 7]							.   .   Sibling: 2  Call: outnl of type void [line: 7]
Sibling: 3  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 10]		   |	Sibling: 10  Func: dog returns type void [mem: Global loc: 0 size: -4] [line: 10]
.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]				.   Child: 0  Parm: x of type int [mem: Parameter loc: -2 size: 1] [line: 10]
.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 10]		.   Sibling: 1  Parm: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 10]
.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 11]						.   Child: 1  Compound [mem: None loc: 0 size: -4] [line: 11]
.   .   Child: 1  Call: output of type void [line: 12]							.   .   Child: 1  Call: output of type void [line: 12]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 12]
.   .   Sibling: 1  Call: output of type void [line: 13]						.   .   Sibling: 1  Call: output of type void [line: 13]
.   .   .   Child: 0  Op: [ of type int [line: 13]							.   .   .   Child: 0  Op: [ of type int [line: 13]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 13	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 13
.   .   .   .   Child: 1  Const 3 of type int [line: 13]						.   .   .   .   Child: 1  Const 3 of type int [line: 13]
.   .   Sibling: 2  Call: outnl of type void [line: 14]							.   .   Sibling: 2  Call: outnl of type void [line: 14]
.   .   Sibling: 3  Assign: = of type int [line: 16]						   |	.   .   Sibling: 3  Assign: := of type int [line: 16]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 16]
.   .   .   Child: 1  Const 668 of type int [line: 16]							.   .   .   Child: 1  Const 668 of type int [line: 16]
.   .   Sibling: 4  Assign: = of type int [line: 17]						   |	.   .   Sibling: 4  Assign: := of type int [line: 17]
.   .   .   Child: 0  Op: [ of type int [line: 17]							.   .   .   Child: 0  Op: [ of type int [line: 17]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 17	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 17
.   .   .   .   Child: 1  Op: + of type int [line: 17]							.   .   .   .   Child: 1  Op: + of type int [line: 17]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 17]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 17]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 17]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 17]
.   .   .   Child: 1  Const 669 of type int [line: 17]							.   .   .   Child: 1  Const 669 of type int [line: 17]
.   .   Sibling: 5  Call: output of type void [line: 18]						.   .   Sibling: 5  Call: output of type void [line: 18]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 18]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 18]
.   .   Sibling: 6  Call: output of type void [line: 19]						.   .   Sibling: 6  Call: output of type void [line: 19]
.   .   .   Child: 0  Op: [ of type int [line: 19]							.   .   .   Child: 0  Op: [ of type int [line: 19]
.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 19	.   .   .   .   Child: 0  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 19
.   .   .   .   Child: 1  Const 3 of type int [line: 19]						.   .   .   .   Child: 1  Const 3 of type int [line: 19]
.   .   Sibling: 7  Call: outnl of type void [line: 20]							.   .   Sibling: 7  Call: outnl of type void [line: 20]
.   .   Sibling: 8  Assign: = of type int [line: 22]						   |	.   .   Sibling: 8  Assign: := of type int [line: 22]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 22]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 22]
.   .   .   Child: 1  Const 670 of type int [line: 22]							.   .   .   Child: 1  Const 670 of type int [line: 22]
.   .   Sibling: 9  Assign: = of type int [line: 23]						   |	.   .   Sibling: 9  Assign: := of type int [line: 23]
.   .   .   Child: 0  Op: [ of type int [line: 23]							.   .   .   Child: 0  Op: [ of type int [line: 23]
.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 23]		.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 23]
.   .   .   .   Child: 1  Op: + of type int [line: 23]							.   .   .   .   Child: 1  Op: + of type int [line: 23]
.   .   .   .   .   Child: 0  Const 2 of type int [line: 23]						.   .   .   .   .   Child: 0  Const 2 of type int [line: 23]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 23]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 23]
.   .   .   Child: 1  Const 671 of type int [line: 23]							.   .   .   Child: 1  Const 671 of type int [line: 23]
.   .   Sibling: 10  Call: output of type void [line: 24]						.   .   Sibling: 10  Call: output of type void [line: 24]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 24]
.   .   Sibling: 11  Call: output of type void [line: 25]						.   .   Sibling: 11  Call: output of type void [line: 25]
.   .   .   Child: 0  Op: [ of type int [line: 25]							.   .   .   Child: 0  Op: [ of type int [line: 25]
.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 25]		.   .   .   .   Child: 0  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 25]
.   .   .   .   Child: 1  Const 3 of type int [line: 25]						.   .   .   .   Child: 1  Const 3 of type int [line: 25]
.   .   Sibling: 12  Call: outnl of type void [line: 26]						.   .   Sibling: 12  Call: outnl of type void [line: 26]
.   .   Sibling: 13  Call: cat of type void [line: 28]							.   .   Sibling: 13  Call: cat of type void [line: 28]
.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 28]			.   .   .   Child: 0  Id: x of type int [mem: Parameter loc: -2 size: 1] [line: 28]
.   .   .   Sibling: 1  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 28]		.   .   .   Sibling: 1  Id: xa of array of type int [mem: Parameter loc: -3 size: 1] [line: 28]
.   .   Sibling: 14  Call: cat of type void [line: 29]							.   .   Sibling: 14  Call: cat of type void [line: 29]
.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 29]				.   .   .   Child: 0  Id: g of type int [mem: Global loc: 0 size: 1] [line: 29]
.   .   .   Sibling: 1  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 29]		.   .   .   Sibling: 1  Id: ga of array of type int [mem: Global loc: -2 size: 11] [line: 29]
Sibling: 4  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 32]		   |	Sibling: 11  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 32]
.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 33]						.   Child: 1  Compound [mem: None loc: 0 size: -14] [line: 33]
.   .   Child: 0  Var: y of type int [mem: Local loc: -2 size: 1] [line: 34]				.   .   Child: 0  Var: y of type int [mem: Local loc: -2 size: 1] [line: 34]
.   .   Sibling: 1  Var: ya of array of type int [mem: Local loc: -4 size: 11] [line: 34]		.   .   Sibling: 1  Var: ya of array of type int [mem: Local loc: -4 size: 11] [line: 34]
.   .   Child: 1  Assign: = of type int [line: 36]						   |	.   .   Child: 1  Assign: := of type int [line: 36]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 36]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 36]
.   .   .   Child: 1  Const 666 of type int [line: 36]							.   .   .   Child: 1  Const 666 of type int [line: 36]
.   .   Sibling: 1  Assign: = of type int [line: 37]						   |	.   .   Sibling: 1  Assign: := of type int [line: 37]
.   .   .   Child: 0  Op: [ of type int [line: 37]							.   .   .   Child: 0  Op: [ of type int [line: 37]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 37]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 37]
.   .   .   .   Child: 1  Op: + of type int [line: 37]							.   .   .   .   Child: 1  Op: + of type int [line: 37]
.   .   .   .   .   Child: 0  Const 1 of type int [line: 37]						.   .   .   .   .   Child: 0  Const 1 of type int [line: 37]
.   .   .   .   .   Child: 1  Const 2 of type int [line: 37]						.   .   .   .   .   Child: 1  Const 2 of type int [line: 37]
.   .   .   Child: 1  Const 667 of type int [line: 37]							.   .   .   Child: 1  Const 667 of type int [line: 37]
.   .   Sibling: 2  Call: output of type void [line: 38]						.   .   Sibling: 2  Call: output of type void [line: 38]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 38]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 38]
.   .   Sibling: 3  Call: output of type void [line: 39]						.   .   Sibling: 3  Call: output of type void [line: 39]
.   .   .   Child: 0  Op: [ of type int [line: 39]							.   .   .   Child: 0  Op: [ of type int [line: 39]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 39]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 39]
.   .   .   .   Child: 1  Const 3 of type int [line: 39]						.   .   .   .   Child: 1  Const 3 of type int [line: 39]
.   .   Sibling: 4  Call: outnl of type void [line: 40]							.   .   Sibling: 4  Call: outnl of type void [line: 40]
.   .   Sibling: 5  Call: dog of type void [line: 42]							.   .   Sibling: 5  Call: dog of type void [line: 42]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 42]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 42]
.   .   .   Sibling: 1  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 42]		.   .   .   Sibling: 1  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 42]
.   .   Sibling: 6  Call: output of type void [line: 44]						.   .   Sibling: 6  Call: output of type void [line: 44]
.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 44]				.   .   .   Child: 0  Id: y of type int [mem: Local loc: -2 size: 1] [line: 44]
.   .   Sibling: 7  Call: output of type void [line: 45]						.   .   Sibling: 7  Call: output of type void [line: 45]
.   .   .   Child: 0  Op: [ of type int [line: 45]							.   .   .   Child: 0  Op: [ of type int [line: 45]
.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 45]		.   .   .   .   Child: 0  Id: ya of array of type int [mem: Local loc: -4 size: 11] [line: 45]
.   .   .   .   Child: 1  Const 3 of type int [line: 45]						.   .   .   .   Child: 1  Const 3 of type int [line: 45]
.   .   Sibling: 8  Call: outnl of type void [line: 46]							.   .   Sibling: 8  Call: outnl of type void [line: 46]
Offset for end of global space: -12									Offset for end of global space: -12
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
varnovoid.out ztmp23114.txt differ: byte 1, line 1
varnovoid (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/varnovoid.tm
Number of errors: 0										   |	666 667
------------------------------------								   |	666 667
Loading file: varnovoid.tm									   |	668 669
												   >	670 671
												   >	668 669
												   >	670 671
												   >	666 669
Bye.													Bye.
====================================
FILE: walsh.c-
-rw-------. 1 corg7983 domain_users  1445 Nov 17 15:35 walsh.c-
-rw-------. 1 corg7983 domain_users  1466 Nov 17 15:35 walsh.c-.f21
-rw-------. 1 corg7983 domain_users  1445 Nov 17 15:35 walsh.c-.f22
-rw-------. 1 corg7983 domain_users   573 Nov 17 15:35 walsh.expected
-rw-------. 1 corg7983 domain_users    92 Nov 17 15:35 walsh.in
-rw-------. 1 corg7983 domain_users 18813 Nov 22 12:27 walsh.mem
-rw-------. 1 corg7983 domain_users  3807 Nov 17 15:35 walsh.mem.diffs
-rw-------. 1 corg7983 domain_users 19678 Nov 17 15:35 walsh.mem.f21
-rw-------. 1 corg7983 domain_users   953 Nov 22 12:27 walsh.out
-rw-------. 1 corg7983 domain_users     0 Nov 22 12:27 walsh.tm
-rw-------. 1 corg7983 domain_users   413 Nov 17 15:35 walsh.tm.diffs
-rw-------. 1 corg7983 domain_users 24578 Nov 17 15:35 walsh.tm.f21
TM CODE COMPARISON
walsh (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  walsh.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION pow
												   >	* TOFF set: -4
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,1(6)	Load integer constant 
												   >	 41:     ST  3,-5(1)	Store variable ans
												   >	* EXPRESSION
												   >	 42:     LD  3,-2(1)	Load variable n
												   >	 43:     ST  3,-4(1)	Store variable sqr
												   >	* WHILE
												   >	 44:    LDC  3,1(6)	Load Boolean constant 
												   >	 45:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	 47:     LD  3,-3(1)	Load variable p
												   >	 48:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 49:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 50:     LD  4,-6(1)	Pop left into ac1 
												   >	 51:    MOD  3,4,3	Op % 
												   >	 52:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 53:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 54:     LD  4,-6(1)	Pop left into ac1 
												   >	 55:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* EXPRESSION
												   >	 57:     LD  3,-5(1)	Load variable ans
												   >	 58:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 59:     LD  3,-4(1)	Load variable sqr
												   >	* TOFF inc: -6
												   >	 60:     LD  4,-6(1)	Pop left into ac1 
												   >	 61:    MUL  3,4,3	Op * 
												   >	 62:     ST  3,-5(1)	Store variable ans
												   >	 56:    JZR  3,6(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 63:     LD  3,-3(1)	Load variable p
												   >	 64:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 65:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 66:     LD  4,-6(1)	Pop left into ac1 
												   >	 67:    DIV  3,4,3	Op / 
												   >	 68:     ST  3,-3(1)	Store variable p
												   >	* IF
												   >	 69:     LD  3,-3(1)	Load variable p
												   >	 70:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 71:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	 72:     LD  4,-6(1)	Pop left into ac1 
												   >	 73:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	 75:     LD  3,-5(1)	Load variable ans
												   >	 76:    LDA  2,0(3)	Copy result to return register 
												   >	 77:     LD  3,-1(1)	Load return address 
												   >	 78:     LD  1,0(1)	Adjust fp 
												   >	 79:    JMP  7,0(3)	Return 
												   >	 74:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	 80:     LD  3,-4(1)	Load variable sqr
												   >	 81:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 82:     LD  3,-4(1)	Load variable sqr
												   >	* TOFF inc: -6
												   >	 83:     LD  4,-6(1)	Pop left into ac1 
												   >	 84:    MUL  3,4,3	Op * 
												   >	 85:     ST  3,-4(1)	Store variable sqr
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	 86:    JMP  7,-43(7)	go to beginning of loop 
												   >	 46:    JMP  7,40(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 87:    LDC  2,0(6)	Set return value to 0 
												   >	 88:     LD  3,-1(1)	Load return address 
												   >	 89:     LD  1,0(1)	Adjust fp 
												   >	 90:    JMP  7,0(3)	Return 
												   >	* END FUNCTION pow
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION getFunc
												   >	* TOFF set: -3
												   >	 91:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* IF
												   >	* CALL input
												   >	 92:     ST  1,-6(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param end input
												   >	 93:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	 94:    LDA  3,1(7)	Return address in ac 
												   >	 95:    JMP  7,-95(7)	CALL input
												   >	 96:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -6
												   >	 97:     ST  3,-3(1)	Store variable numbits
												   >	 98:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	 99:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	100:     LD  4,-6(1)	Pop left into ac1 
												   >	101:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	103:    LDC  3,0(6)	Load integer constant 
												   >	104:    LDA  2,0(3)	Copy result to return register 
												   >	105:     LD  3,-1(1)	Load return address 
												   >	106:     LD  1,0(1)	Adjust fp 
												   >	107:    JMP  7,0(3)	Return 
												   >	102:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL pow
												   >	108:     ST  1,-6(1)	Store fp in ghost frame for pow
												   >	* TOFF dec: -7
												   >	* TOFF dec: -8
												   >	* Param 1
												   >	109:    LDC  3,2(6)	Load integer constant 
												   >	110:     ST  3,-8(1)	Push parameter 
												   >	* TOFF dec: -9
												   >	* Param 2
												   >	111:     LD  3,-3(1)	Load variable numbits
												   >	112:     ST  3,-9(1)	Push parameter 
												   >	* TOFF dec: -10
												   >	* Param end pow
												   >	113:    LDA  1,-6(1)	Ghost frame becomes new active frame 
												   >	114:    LDA  3,1(7)	Return address in ac 
												   >	115:    JMP  7,-77(7)	CALL pow
												   >	116:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pow
												   >	* TOFF set: -6
												   >	117:     ST  3,-5(1)	Store variable size
												   >	* EXPRESSION
												   >	118:    LDC  3,0(6)	Load integer constant 
												   >	119:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	120:     LD  3,-4(1)	Load variable i
												   >	121:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	122:     LD  3,-5(1)	Load variable size
												   >	* TOFF inc: -6
												   >	123:     LD  4,-6(1)	Pop left into ac1 
												   >	124:    TLT  3,4,3	Op < 
												   >	125:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -6
												   >	* Compound Body
												   >	* EXPRESSION
												   >	127:     LD  3,-4(1)	Load variable i
												   >	128:     ST  3,-6(1)	Push index 
												   >	* TOFF dec: -7
												   >	* CALL input
												   >	129:     ST  1,-7(1)	Store fp in ghost frame for input
												   >	* TOFF dec: -8
												   >	* TOFF dec: -9
												   >	* Param end input
												   >	130:    LDA  1,-7(1)	Ghost frame becomes new active frame 
												   >	131:    LDA  3,1(7)	Return address in ac 
												   >	132:    JMP  7,-132(7)	CALL input
												   >	133:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end input
												   >	* TOFF set: -7
												   >	* TOFF inc: -6
												   >	134:     LD  4,-6(1)	Pop index 
												   >	135:     LD  5,-2(1)	Load address of base of array f
												   >	136:    SUB  5,5,4	Compute offset of value 
												   >	137:     ST  3,0(5)	Store variable f
												   >	* EXPRESSION
												   >	138:     LD  3,-4(1)	Load variable i
												   >	139:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	140:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -6
												   >	141:     LD  4,-6(1)	Pop left into ac1 
												   >	142:    ADD  3,4,3	Op + 
												   >	143:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -6
												   >	* END COMPOUND
												   >	144:    JMP  7,-25(7)	go to beginning of loop 
												   >	126:    JMP  7,18(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	145:     LD  3,-3(1)	Load variable numbits
												   >	146:    LDA  2,0(3)	Copy result to return register 
												   >	147:     LD  3,-1(1)	Load return address 
												   >	148:     LD  1,0(1)	Adjust fp 
												   >	149:    JMP  7,0(3)	Return 
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	150:    LDC  2,0(6)	Set return value to 0 
												   >	151:     LD  3,-1(1)	Load return address 
												   >	152:     LD  1,0(1)	Adjust fp 
												   >	153:    JMP  7,0(3)	Return 
												   >	* END FUNCTION getFunc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION printFunc
												   >	* TOFF set: -4
												   >	154:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	155:    LDC  3,0(6)	Load integer constant 
												   >	156:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	157:     LD  3,-4(1)	Load variable i
												   >	158:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	159:     LD  3,-3(1)	Load variable size
												   >	* TOFF inc: -5
												   >	160:     LD  4,-5(1)	Pop left into ac1 
												   >	161:    TLT  3,4,3	Op < 
												   >	162:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	164:     ST  1,-5(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param 1
												   >	165:     LD  3,-2(1)	Load address of base of array f
												   >	166:     ST  3,-7(1)	Push left side 
												   >	* TOFF dec: -8
												   >	167:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -7
												   >	168:     LD  4,-7(1)	Pop left into ac1 
												   >	169:    SUB  3,4,3	compute location from index 
												   >	170:     LD  3,0(3)	Load array element 
												   >	171:     ST  3,-7(1)	Push parameter 
												   >	* TOFF dec: -8
												   >	* Param end output
												   >	172:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	173:    LDA  3,1(7)	Return address in ac 
												   >	174:    JMP  7,-169(7)	CALL output
												   >	175:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -5
												   >	* EXPRESSION
												   >	176:     LD  3,-4(1)	Load variable i
												   >	177:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	178:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -5
												   >	179:     LD  4,-5(1)	Pop left into ac1 
												   >	180:    ADD  3,4,3	Op + 
												   >	181:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	182:    JMP  7,-26(7)	go to beginning of loop 
												   >	163:    JMP  7,19(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	183:     ST  1,-5(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -6
												   >	* TOFF dec: -7
												   >	* Param end outnl
												   >	184:    LDA  1,-5(1)	Ghost frame becomes new active frame 
												   >	185:    LDA  3,1(7)	Return address in ac 
												   >	186:    JMP  7,-153(7)	CALL outnl
												   >	187:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -5
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	188:    LDC  2,0(6)	Set return value to 0 
												   >	189:     LD  3,-1(1)	Load return address 
												   >	190:     LD  1,0(1)	Adjust fp 
												   >	191:    JMP  7,0(3)	Return 
												   >	* END FUNCTION printFunc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION fwt
												   >	* TOFF set: -5
												   >	192:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	193:     LD  3,-4(1)	Load variable size
												   >	194:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	195:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	196:     LD  4,-8(1)	Pop left into ac1 
												   >	197:    DIV  3,4,3	Op / 
												   >	198:     ST  3,-4(1)	Store variable size
												   >	* IF
												   >	199:     LD  3,-4(1)	Load variable size
												   >	200:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	201:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	202:     LD  4,-8(1)	Pop left into ac1 
												   >	203:    TGT  3,4,3	Op > 
												   >	* THEN
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL fwt
												   >	205:     ST  1,-8(1)	Store fp in ghost frame for fwt
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	206:     LD  3,-2(1)	Load address of base of array w
												   >	207:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	208:     LD  3,-3(1)	Load variable start
												   >	209:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	210:     LD  3,-4(1)	Load variable size
												   >	211:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end fwt
												   >	212:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	213:    LDA  3,1(7)	Return address in ac 
												   >	214:    JMP  7,-23(7)	CALL fwt
												   >	215:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fwt
												   >	* TOFF set: -8
												   >	* EXPRESSION
												   >	* CALL fwt
												   >	216:     ST  1,-8(1)	Store fp in ghost frame for fwt
												   >	* TOFF dec: -9
												   >	* TOFF dec: -10
												   >	* Param 1
												   >	217:     LD  3,-2(1)	Load address of base of array w
												   >	218:     ST  3,-10(1)	Push parameter 
												   >	* TOFF dec: -11
												   >	* Param 2
												   >	219:     LD  3,-3(1)	Load variable start
												   >	220:     ST  3,-11(1)	Push left side 
												   >	* TOFF dec: -12
												   >	221:     LD  3,-4(1)	Load variable size
												   >	* TOFF inc: -11
												   >	222:     LD  4,-11(1)	Pop left into ac1 
												   >	223:    ADD  3,4,3	Op + 
												   >	224:     ST  3,-11(1)	Push parameter 
												   >	* TOFF dec: -12
												   >	* Param 3
												   >	225:     LD  3,-4(1)	Load variable size
												   >	226:     ST  3,-12(1)	Push parameter 
												   >	* TOFF dec: -13
												   >	* Param end fwt
												   >	227:    LDA  1,-8(1)	Ghost frame becomes new active frame 
												   >	228:    LDA  3,1(7)	Return address in ac 
												   >	229:    JMP  7,-38(7)	CALL fwt
												   >	230:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fwt
												   >	* TOFF set: -8
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	204:    JZR  3,26(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	231:     LD  3,-3(1)	Load variable start
												   >	232:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	233:     LD  3,-3(1)	Load variable start
												   >	234:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	235:     LD  3,-4(1)	Load variable size
												   >	* TOFF inc: -8
												   >	236:     LD  4,-8(1)	Pop left into ac1 
												   >	237:    ADD  3,4,3	Op + 
												   >	238:     ST  3,-6(1)	Store variable b
												   >	* WHILE
												   >	239:     LD  3,-5(1)	Load variable a
												   >	240:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	241:     LD  3,-3(1)	Load variable start
												   >	242:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	243:     LD  3,-4(1)	Load variable size
												   >	* TOFF inc: -9
												   >	244:     LD  4,-9(1)	Pop left into ac1 
												   >	245:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -8
												   >	246:     LD  4,-8(1)	Pop left into ac1 
												   >	247:    TLT  3,4,3	Op < 
												   >	248:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -8
												   >	* Compound Body
												   >	* EXPRESSION
												   >	250:     LD  3,-2(1)	Load address of base of array w
												   >	251:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	252:     LD  3,-5(1)	Load variable a
												   >	* TOFF inc: -8
												   >	253:     LD  4,-8(1)	Pop left into ac1 
												   >	254:    SUB  3,4,3	compute location from index 
												   >	255:     LD  3,0(3)	Load array element 
												   >	256:     ST  3,-7(1)	Store variable tmp
												   >	* EXPRESSION
												   >	257:     LD  3,-5(1)	Load variable a
												   >	258:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	259:     LD  3,-2(1)	Load address of base of array w
												   >	260:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	261:     LD  3,-5(1)	Load variable a
												   >	* TOFF inc: -9
												   >	262:     LD  4,-9(1)	Pop left into ac1 
												   >	263:    SUB  3,4,3	compute location from index 
												   >	264:     LD  3,0(3)	Load array element 
												   >	265:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	266:     LD  3,-2(1)	Load address of base of array w
												   >	267:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	268:     LD  3,-6(1)	Load variable b
												   >	* TOFF inc: -10
												   >	269:     LD  4,-10(1)	Pop left into ac1 
												   >	270:    SUB  3,4,3	compute location from index 
												   >	271:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -9
												   >	272:     LD  4,-9(1)	Pop left into ac1 
												   >	273:    ADD  3,4,3	Op + 
												   >	* TOFF inc: -8
												   >	274:     LD  4,-8(1)	Pop index 
												   >	275:     LD  5,-2(1)	Load address of base of array w
												   >	276:    SUB  5,5,4	Compute offset of value 
												   >	277:     ST  3,0(5)	Store variable w
												   >	* EXPRESSION
												   >	278:     LD  3,-6(1)	Load variable b
												   >	279:     ST  3,-8(1)	Push index 
												   >	* TOFF dec: -9
												   >	280:     LD  3,-7(1)	Load variable tmp
												   >	281:     ST  3,-9(1)	Push left side 
												   >	* TOFF dec: -10
												   >	282:     LD  3,-2(1)	Load address of base of array w
												   >	283:     ST  3,-10(1)	Push left side 
												   >	* TOFF dec: -11
												   >	284:     LD  3,-6(1)	Load variable b
												   >	* TOFF inc: -10
												   >	285:     LD  4,-10(1)	Pop left into ac1 
												   >	286:    SUB  3,4,3	compute location from index 
												   >	287:     LD  3,0(3)	Load array element 
												   >	* TOFF inc: -9
												   >	288:     LD  4,-9(1)	Pop left into ac1 
												   >	289:    SUB  3,4,3	Op - 
												   >	* TOFF inc: -8
												   >	290:     LD  4,-8(1)	Pop index 
												   >	291:     LD  5,-2(1)	Load address of base of array w
												   >	292:    SUB  5,5,4	Compute offset of value 
												   >	293:     ST  3,0(5)	Store variable w
												   >	* EXPRESSION
												   >	294:     LD  3,-5(1)	Load variable a
												   >	295:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	296:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	297:     LD  4,-8(1)	Pop left into ac1 
												   >	298:    ADD  3,4,3	Op + 
												   >	299:     ST  3,-5(1)	Store variable a
												   >	* EXPRESSION
												   >	300:     LD  3,-6(1)	Load variable b
												   >	301:     ST  3,-8(1)	Push left side 
												   >	* TOFF dec: -9
												   >	302:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -8
												   >	303:     LD  4,-8(1)	Pop left into ac1 
												   >	304:    ADD  3,4,3	Op + 
												   >	305:     ST  3,-6(1)	Store variable b
												   >	* TOFF set: -8
												   >	* END COMPOUND
												   >	306:    JMP  7,-68(7)	go to beginning of loop 
												   >	249:    JMP  7,57(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	307:    LDC  2,0(6)	Set return value to 0 
												   >	308:     LD  3,-1(1)	Load return address 
												   >	309:     LD  1,0(1)	Adjust fp 
												   >	310:    JMP  7,0(3)	Return 
												   >	* END FUNCTION fwt
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION div
												   >	* TOFF set: -4
												   >	311:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	312:    LDC  3,0(6)	Load integer constant 
												   >	313:     ST  3,-4(1)	Store variable i
												   >	* WHILE
												   >	314:     LD  3,-4(1)	Load variable i
												   >	315:     ST  3,-5(1)	Push left side 
												   >	* TOFF dec: -6
												   >	316:     LD  3,-3(1)	Load variable size
												   >	* TOFF inc: -5
												   >	317:     LD  4,-5(1)	Pop left into ac1 
												   >	318:    TLT  3,4,3	Op < 
												   >	319:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -5
												   >	* Compound Body
												   >	* EXPRESSION
												   >	321:     LD  3,-4(1)	Load variable i
												   >	322:     ST  3,-5(1)	Push index 
												   >	* TOFF dec: -6
												   >	323:     LD  3,-2(1)	Load address of base of array f
												   >	324:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	325:     LD  3,-4(1)	Load variable i
												   >	* TOFF inc: -6
												   >	326:     LD  4,-6(1)	Pop left into ac1 
												   >	327:    SUB  3,4,3	compute location from index 
												   >	328:     LD  3,0(3)	Load array element 
												   >	329:     ST  3,-6(1)	Push left side 
												   >	* TOFF dec: -7
												   >	330:     LD  3,-3(1)	Load variable size
												   >	* TOFF inc: -6
												   >	331:     LD  4,-6(1)	Pop left into ac1 
												   >	332:    DIV  3,4,3	Op / 
												   >	* TOFF inc: -5
												   >	333:     LD  4,-5(1)	Pop index 
												   >	334:     LD  5,-2(1)	Load address of base of array f
												   >	335:    SUB  5,5,4	Compute offset of value 
												   >	336:     ST  3,0(5)	Store variable f
												   >	* EXPRESSION
												   >	337:     LD  3,-4(1)	load lhs variable i
												   >	338:    LDA  3,1(3)	increment value of i
												   >	339:     ST  3,-4(1)	Store variable i
												   >	* TOFF set: -5
												   >	* END COMPOUND
												   >	340:    JMP  7,-27(7)	go to beginning of loop 
												   >	320:    JMP  7,20(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* TOFF set: -4
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	341:    LDC  2,0(6)	Set return value to 0 
												   >	342:     LD  3,-1(1)	Load return address 
												   >	343:     LD  1,0(1)	Adjust fp 
												   >	344:    JMP  7,0(3)	Return 
												   >	* END FUNCTION div
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	345:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -262
												   >	346:    LDC  3,256(6)	load size of array f
												   >	347:     ST  3,-2(1)	save size of array f
												   >	* Compound Body
												   >	* WHILE
												   >	348:    LDC  3,1(6)	Load Boolean constant 
												   >	349:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -262
												   >	* Compound Body
												   >	* IF
												   >	* CALL getFunc
												   >	351:     ST  1,-262(1)	Store fp in ghost frame for getFunc
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	352:    LDA  3,-3(1)	Load address of base of array f
												   >	353:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param end getFunc
												   >	354:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	355:    LDA  3,1(7)	Return address in ac 
												   >	356:    JMP  7,-266(7)	CALL getFunc
												   >	357:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end getFunc
												   >	* TOFF set: -262
												   >	358:     ST  3,-260(1)	Store variable numbits
												   >	359:     ST  3,-262(1)	Push left side 
												   >	* TOFF dec: -263
												   >	360:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -262
												   >	361:     LD  4,-262(1)	Pop left into ac1 
												   >	362:    TEQ  3,4,3	Op = 
												   >	* THEN
												   >	* RETURN
												   >	364:    LDC  3,0(6)	Load integer constant 
												   >	365:    LDA  2,0(3)	Copy result to return register 
												   >	366:     LD  3,-1(1)	Load return address 
												   >	367:     LD  1,0(1)	Adjust fp 
												   >	368:    JMP  7,0(3)	Return 
												   >	363:    JZR  3,5(7)	Jump around the THEN if false [backpatch] 
												   >	* END IF
												   >	* EXPRESSION
												   >	* CALL pow
												   >	369:     ST  1,-262(1)	Store fp in ghost frame for pow
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	370:    LDC  3,2(6)	Load integer constant 
												   >	371:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	372:     LD  3,-260(1)	Load variable numbits
												   >	373:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param end pow
												   >	374:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	375:    LDA  3,1(7)	Return address in ac 
												   >	376:    JMP  7,-338(7)	CALL pow
												   >	377:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end pow
												   >	* TOFF set: -262
												   >	378:     ST  3,-259(1)	Store variable size
												   >	* EXPRESSION
												   >	379:     LD  3,-259(1)	Load variable size
												   >	380:     ST  3,-262(1)	Push left side 
												   >	* TOFF dec: -263
												   >	381:    LDC  3,2(6)	Load integer constant 
												   >	* TOFF inc: -262
												   >	382:     LD  4,-262(1)	Pop left into ac1 
												   >	383:    DIV  3,4,3	Op / 
												   >	384:     ST  3,-261(1)	Store variable half
												   >	* EXPRESSION
												   >	* CALL fwt
												   >	385:     ST  1,-262(1)	Store fp in ghost frame for fwt
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	386:    LDA  3,-3(1)	Load address of base of array f
												   >	387:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	388:    LDC  3,0(6)	Load integer constant 
												   >	389:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param 3
												   >	390:     LD  3,-259(1)	Load variable size
												   >	391:     ST  3,-266(1)	Push parameter 
												   >	* TOFF dec: -267
												   >	* Param end fwt
												   >	392:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	393:    LDA  3,1(7)	Return address in ac 
												   >	394:    JMP  7,-203(7)	CALL fwt
												   >	395:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fwt
												   >	* TOFF set: -262
												   >	* EXPRESSION
												   >	* CALL printFunc
												   >	396:     ST  1,-262(1)	Store fp in ghost frame for printFunc
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	397:    LDA  3,-3(1)	Load address of base of array f
												   >	398:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	399:     LD  3,-259(1)	Load variable size
												   >	400:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param end printFunc
												   >	401:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	402:    LDA  3,1(7)	Return address in ac 
												   >	403:    JMP  7,-250(7)	CALL printFunc
												   >	404:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printFunc
												   >	* TOFF set: -262
												   >	* EXPRESSION
												   >	* CALL fwt
												   >	405:     ST  1,-262(1)	Store fp in ghost frame for fwt
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	406:    LDA  3,-3(1)	Load address of base of array f
												   >	407:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	408:    LDC  3,0(6)	Load integer constant 
												   >	409:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param 3
												   >	410:     LD  3,-259(1)	Load variable size
												   >	411:     ST  3,-266(1)	Push parameter 
												   >	* TOFF dec: -267
												   >	* Param end fwt
												   >	412:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	413:    LDA  3,1(7)	Return address in ac 
												   >	414:    JMP  7,-223(7)	CALL fwt
												   >	415:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end fwt
												   >	* TOFF set: -262
												   >	* EXPRESSION
												   >	* CALL div
												   >	416:     ST  1,-262(1)	Store fp in ghost frame for div
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	417:    LDA  3,-3(1)	Load address of base of array f
												   >	418:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	419:     LD  3,-259(1)	Load variable size
												   >	420:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param end div
												   >	421:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	422:    LDA  3,1(7)	Return address in ac 
												   >	423:    JMP  7,-113(7)	CALL div
												   >	424:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end div
												   >	* TOFF set: -262
												   >	* EXPRESSION
												   >	* CALL printFunc
												   >	425:     ST  1,-262(1)	Store fp in ghost frame for printFunc
												   >	* TOFF dec: -263
												   >	* TOFF dec: -264
												   >	* Param 1
												   >	426:    LDA  3,-3(1)	Load address of base of array f
												   >	427:     ST  3,-264(1)	Push parameter 
												   >	* TOFF dec: -265
												   >	* Param 2
												   >	428:     LD  3,-259(1)	Load variable size
												   >	429:     ST  3,-265(1)	Push parameter 
												   >	* TOFF dec: -266
												   >	* Param end printFunc
												   >	430:    LDA  1,-262(1)	Ghost frame becomes new active frame 
												   >	431:    LDA  3,1(7)	Return address in ac 
												   >	432:    JMP  7,-279(7)	CALL printFunc
												   >	433:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end printFunc
												   >	* TOFF set: -262
												   >	* TOFF set: -262
												   >	* END COMPOUND
												   >	434:    JMP  7,-87(7)	go to beginning of loop 
												   >	350:    JMP  7,84(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* RETURN
												   >	435:    LDC  3,0(6)	Load integer constant 
												   >	436:    LDA  2,0(3)	Copy result to return register 
												   >	437:     LD  3,-1(1)	Load return address 
												   >	438:     LD  1,0(1)	Adjust fp 
												   >	439:    JMP  7,0(3)	Return 
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	440:    LDC  2,0(6)	Set return value to 0 
												   >	441:     LD  3,-1(1)	Load return address 
												   >	442:     LD  1,0(1)	Adjust fp 
												   >	443:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,443(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	444:    LDA  1,0(0)	set first frame at end of globals 
												   >	445:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	446:    LDA  3,1(7)	Return address in ac 
												   >	447:    JMP  7,-103(7)	Jump to main 
												   >	448:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
walsh.mem walsh.mem.f21 differ: byte 70, line 2
walsh (MEM DIFF)
WARNING(88): Variable 'f' may be uninitialized when used here.						WARNING(88): Variable 'f' may be uninitialized when used here.
Func: pow returns type int [mem: Global loc: 0 size: -4] [line: 2]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: pow returns type int [mem: Global loc: 0 size: -4] [line: 2]
.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]				.   Child: 0  Parm: n of type int [mem: Parameter loc: -2 size: 1] [line: 2]
.   Sibling: 1  Parm: p of type int [mem: Parameter loc: -3 size: 1] [line: 2]				.   Sibling: 1  Parm: p of type int [mem: Parameter loc: -3 size: 1] [line: 2]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 3]
.   .   Child: 0  Var: sqr of type int [mem: Local loc: -4 size: 1] [line: 4]				.   .   Child: 0  Var: sqr of type int [mem: Local loc: -4 size: 1] [line: 4]
.   .   Sibling: 1  Var: ans of type int [mem: Local loc: -5 size: 1] [line: 5]				.   .   Sibling: 1  Var: ans of type int [mem: Local loc: -5 size: 1] [line: 5]
.   .   Child: 1  Assign: = of type int [line: 7]						   |	.   .   Child: 1  Assign: := of type int [line: 7]
.   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 7]			.   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 7]
.   .   .   Child: 1  Const 1 of type int [line: 7]							.   .   .   Child: 1  Const 1 of type int [line: 7]
.   .   Sibling: 1  Assign: = of type int [line: 8]						   |	.   .   Sibling: 1  Assign: := of type int [line: 8]
.   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 8]			.   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 8]
.   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 8]			.   .   .   Child: 1  Id: n of type int [mem: Parameter loc: -2 size: 1] [line: 8]
.   .   Sibling: 2  While [line: 9]									.   .   Sibling: 2  While [line: 9]
.   .   .   Child: 0  Const true of type bool [line: 9]							.   .   .   Child: 0  Const true of type bool [line: 9]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 9]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 9]
.   .   .   .   Child: 1  If [line: 10]									.   .   .   .   Child: 1  If [line: 10]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 10]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 10]
.   .   .   .   .   .   Child: 0  Op: % of type int [line: 10]						.   .   .   .   .   .   Child: 0  Op: % of type int [line: 10]
.   .   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 10]					.   .   .   .   .   .   .   Child: 1  Const 2 of type int [line: 10]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 10]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 10]
.   .   .   .   .   Child: 1  Assign: = of type int [line: 10]					   |	.   .   .   .   .   Child: 1  Assign: := of type int [line: 10]
.   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 10]		.   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 10]
.   .   .   .   .   .   Child: 1  Op: * of type int [line: 10]						.   .   .   .   .   .   Child: 1  Op: * of type int [line: 10]
.   .   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 10	.   .   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 10
.   .   .   .   .   .   .   Child: 1  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 10	.   .   .   .   .   .   .   Child: 1  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 10
.   .   .   .   Sibling: 1  Assign: = of type int [line: 11]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 11]
.   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 11]		.   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   .   .   .   .   Child: 1  Op: / of type int [line: 11]						.   .   .   .   .   Child: 1  Op: / of type int [line: 11]
.   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 11]		.   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 11]
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 11]
.   .   .   .   Sibling: 2  If [line: 12]								.   .   .   .   Sibling: 2  If [line: 12]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 12]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 12]
.   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 12]		.   .   .   .   .   .   Child: 0  Id: p of type int [mem: Parameter loc: -3 size: 1] [line: 12]
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 12]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 12]
.   .   .   .   .   Child: 1  Return [line: 12]								.   .   .   .   .   Child: 1  Return [line: 12]
.   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 12]		.   .   .   .   .   .   Child: 0  Id: ans of type int [mem: Local loc: -5 size: 1] [line: 12]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 13]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 13]
.   .   .   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   Child: 1  Op: * of type int [line: 13]						.   .   .   .   .   Child: 1  Op: * of type int [line: 13]
.   .   .   .   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   .   Child: 0  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]
.   .   .   .   .   .   Child: 1  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]		.   .   .   .   .   .   Child: 1  Id: sqr of type int [mem: Local loc: -4 size: 1] [line: 13]
Sibling: 1  Func: getFunc returns type int [mem: Global loc: 0 size: -3] [line: 17]		   |	Sibling: 8  Func: getFunc returns type int [mem: Global loc: 0 size: -3] [line: 17]
.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 17]			.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 17]
.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 18]						.   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 18]
.   .   Child: 0  Var: numbits of type int [mem: Local loc: -3 size: 1] [line: 19]			.   .   Child: 0  Var: numbits of type int [mem: Local loc: -3 size: 1] [line: 19]
.   .   Sibling: 1  Var: i of type int [mem: Local loc: -4 size: 1] [line: 20]				.   .   Sibling: 1  Var: i of type int [mem: Local loc: -4 size: 1] [line: 20]
.   .   Sibling: 2  Var: size of type int [mem: Local loc: -5 size: 1] [line: 21]			.   .   Sibling: 2  Var: size of type int [mem: Local loc: -5 size: 1] [line: 21]
.   .   Child: 1  If [line: 23]										.   .   Child: 1  If [line: 23]
.   .   .   Child: 0  Op: == of type bool [line: 23]						   |	.   .   .   Child: 0  Op: = of type bool [line: 23]
.   .   .   .   Child: 0  Assign: = of type int [line: 23]					   |	.   .   .   .   Child: 0  Assign: := of type int [line: 23]
.   .   .   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 23]		.   .   .   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 23]
.   .   .   .   .   Child: 1  Call: input of type int [line: 23]					.   .   .   .   .   Child: 1  Call: input of type int [line: 23]
.   .   .   .   Child: 1  Const 0 of type int [line: 23]						.   .   .   .   Child: 1  Const 0 of type int [line: 23]
.   .   .   Child: 1  Return [line: 23]									.   .   .   Child: 1  Return [line: 23]
.   .   .   .   Child: 0  Const 0 of type int [line: 23]						.   .   .   .   Child: 0  Const 0 of type int [line: 23]
.   .   Sibling: 1  Assign: = of type int [line: 24]						   |	.   .   Sibling: 1  Assign: := of type int [line: 24]
.   .   .   Child: 0  Id: size of type int [mem: Local loc: -5 size: 1] [line: 24]			.   .   .   Child: 0  Id: size of type int [mem: Local loc: -5 size: 1] [line: 24]
.   .   .   Child: 1  Call: pow of type int [line: 24]							.   .   .   Child: 1  Call: pow of type int [line: 24]
.   .   .   .   Child: 0  Const 2 of type int [line: 24]						.   .   .   .   Child: 0  Const 2 of type int [line: 24]
.   .   .   .   Sibling: 1  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 24]		.   .   .   .   Sibling: 1  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 24]
.   .   Sibling: 2  Assign: = of type int [line: 25]						   |	.   .   Sibling: 2  Assign: := of type int [line: 25]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 25]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 25]
.   .   .   Child: 1  Const 0 of type int [line: 25]							.   .   .   Child: 1  Const 0 of type int [line: 25]
.   .   Sibling: 3  While [line: 26]									.   .   Sibling: 3  While [line: 26]
.   .   .   Child: 0  Op: < of type bool [line: 26]							.   .   .   Child: 0  Op: < of type bool [line: 26]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 26]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 26]
.   .   .   .   Child: 1  Id: size of type int [mem: Local loc: -5 size: 1] [line: 26]			.   .   .   .   Child: 1  Id: size of type int [mem: Local loc: -5 size: 1] [line: 26]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 26]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -6] [line: 26]
.   .   .   .   Child: 1  Assign: = of type int [line: 27]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 27]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 27]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 27]
.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 27]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 27]
.   .   .   .   .   Child: 1  Call: input of type int [line: 27]					.   .   .   .   .   Child: 1  Call: input of type int [line: 27]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 28]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 28]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]
.   .   .   .   .   Child: 1  Op: + of type int [line: 28]						.   .   .   .   .   Child: 1  Op: + of type int [line: 28]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 28]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 28]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 28]
.   .   Sibling: 4  Return [line: 31]									.   .   Sibling: 4  Return [line: 31]
.   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 31]			.   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -3 size: 1] [line: 31]
Sibling: 2  Func: printFunc returns type void [mem: Global loc: 0 size: -4] [line: 34]		   |	Sibling: 9  Func: printFunc returns type void [mem: Global loc: 0 size: -4] [line: 34]
.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 34]			.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 34]
.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 34]			.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 34]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 35]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 35]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 36]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 36]
.   .   Child: 1  Assign: = of type int [line: 38]						   |	.   .   Child: 1  Assign: := of type int [line: 38]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 38]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 38]
.   .   .   Child: 1  Const 0 of type int [line: 38]							.   .   .   Child: 1  Const 0 of type int [line: 38]
.   .   Sibling: 1  While [line: 39]									.   .   Sibling: 1  While [line: 39]
.   .   .   Child: 0  Op: < of type bool [line: 39]							.   .   .   Child: 0  Op: < of type bool [line: 39]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 39]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 39]
.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 39]		.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 39]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 39]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 39]
.   .   .   .   Child: 1  Call: output of type void [line: 40]						.   .   .   .   Child: 1  Call: output of type void [line: 40]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 40]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 40]
.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 40]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 40]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 41]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 41]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 41]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 41]
.   .   .   .   .   Child: 1  Op: + of type int [line: 41]						.   .   .   .   .   Child: 1  Op: + of type int [line: 41]
.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 41]		.   .   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 41]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 41]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 41]
.   .   Sibling: 2  Call: outnl of type void [line: 43]							.   .   Sibling: 2  Call: outnl of type void [line: 43]
Sibling: 3  Func: fwt returns type void [mem: Global loc: 0 size: -5] [line: 47]		   |	Sibling: 10  Func: fwt returns type void [mem: Global loc: 0 size: -5] [line: 47]
.   Child: 0  Parm: w of array of type int [mem: Parameter loc: -2 size: 1] [line: 47]			.   Child: 0  Parm: w of array of type int [mem: Parameter loc: -2 size: 1] [line: 47]
.   Sibling: 1  Parm: start of type int [mem: Parameter loc: -3 size: 1] [line: 47]			.   Sibling: 1  Parm: start of type int [mem: Parameter loc: -3 size: 1] [line: 47]
.   Sibling: 2  Parm: size of type int [mem: Parameter loc: -4 size: 1] [line: 47]			.   Sibling: 2  Parm: size of type int [mem: Parameter loc: -4 size: 1] [line: 47]
.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 48]						.   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 48]
.   .   Child: 0  Var: a of type int [mem: Local loc: -5 size: 1] [line: 49]				.   .   Child: 0  Var: a of type int [mem: Local loc: -5 size: 1] [line: 49]
.   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 49]				.   .   Sibling: 1  Var: b of type int [mem: Local loc: -6 size: 1] [line: 49]
.   .   Sibling: 2  Var: tmp of type int [mem: Local loc: -7 size: 1] [line: 49]			.   .   Sibling: 2  Var: tmp of type int [mem: Local loc: -7 size: 1] [line: 49]
.   .   Child: 1  Assign: = of type int [line: 51]						   |	.   .   Child: 1  Assign: := of type int [line: 51]
.   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 51]			.   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 51]
.   .   .   Child: 1  Op: / of type int [line: 51]							.   .   .   Child: 1  Op: / of type int [line: 51]
.   .   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 51]		.   .   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 51]
.   .   .   .   Child: 1  Const 2 of type int [line: 51]						.   .   .   .   Child: 1  Const 2 of type int [line: 51]
.   .   Sibling: 1  If [line: 52]									.   .   Sibling: 1  If [line: 52]
.   .   .   Child: 0  Op: > of type bool [line: 52]							.   .   .   Child: 0  Op: > of type bool [line: 52]
.   .   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 52]		.   .   .   .   Child: 0  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 52]
.   .   .   .   Child: 1  Const 1 of type int [line: 52]						.   .   .   .   Child: 1  Const 1 of type int [line: 52]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 52]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 52]
.   .   .   .   Child: 1  Call: fwt of type void [line: 53]						.   .   .   .   Child: 1  Call: fwt of type void [line: 53]
.   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   Sibling: 1  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 53	.   .   .   .   .   Sibling: 1  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 53
.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 53]	.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 53]
.   .   .   .   Sibling: 1  Call: fwt of type void [line: 54]						.   .   .   .   Sibling: 1  Call: fwt of type void [line: 54]
.   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [line:	.   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [line:
.   .   .   .   .   Sibling: 1  Op: + of type int [line: 54]						.   .   .   .   .   Sibling: 1  Op: + of type int [line: 54]
.   .   .   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 	.   .   .   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 
.   .   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 5	.   .   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 5
.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 54]	.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 54]
.   .   Sibling: 2  Assign: = of type int [line: 57]						   |	.   .   Sibling: 2  Assign: := of type int [line: 57]
.   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 57]				.   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 57]
.   .   .   Child: 1  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 57]			.   .   .   Child: 1  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 57]
.   .   Sibling: 3  Assign: = of type int [line: 58]						   |	.   .   Sibling: 3  Assign: := of type int [line: 58]
.   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 58]				.   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 58]
.   .   .   Child: 1  Op: + of type int [line: 58]							.   .   .   Child: 1  Op: + of type int [line: 58]
.   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 58]		.   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 58]
.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 58]		.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 58]
.   .   Sibling: 4  While [line: 59]									.   .   Sibling: 4  While [line: 59]
.   .   .   Child: 0  Op: < of type bool [line: 59]							.   .   .   Child: 0  Op: < of type bool [line: 59]
.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 59]			.   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 59]
.   .   .   .   Child: 1  Op: + of type int [line: 59]							.   .   .   .   Child: 1  Op: + of type int [line: 59]
.   .   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 59]		.   .   .   .   .   Child: 0  Id: start of type int [mem: Parameter loc: -3 size: 1] [line: 59]
.   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 59]		.   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -4 size: 1] [line: 59]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 59]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -8] [line: 59]
.   .   .   .   Child: 1  Assign: = of type int [line: 60]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 60]
.   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -7 size: 1] [line: 60]		.   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -7 size: 1] [line: 60]
.   .   .   .   .   Child: 1  Op: [ of type int [line: 60]						.   .   .   .   .   Child: 1  Op: [ of type int [line: 60]
.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 60]		.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 60]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 61]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 61]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 61]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 61]
.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 61]		.   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 61]
.   .   .   .   .   Child: 1  Op: + of type int [line: 61]						.   .   .   .   .   Child: 1  Op: + of type int [line: 61]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 61]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 61]
.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 61]		.   .   .   .   .   .   .   Child: 1  Id: a of type int [mem: Local loc: -5 size: 1] [line: 61]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 61]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 61]
.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 61]		.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 61]
.   .   .   .   Sibling: 2  Assign: = of type int [line: 62]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 62]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 62]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 62]
.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 62]		.   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 62]
.   .   .   .   .   Child: 1  Op: - of type int [line: 62]						.   .   .   .   .   Child: 1  Op: - of type int [line: 62]
.   .   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -7 size: 1] [line: 62]		.   .   .   .   .   .   Child: 0  Id: tmp of type int [mem: Local loc: -7 size: 1] [line: 62]
.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 62]						.   .   .   .   .   .   Child: 1  Op: [ of type int [line: 62]
.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: w of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 62]		.   .   .   .   .   .   .   Child: 1  Id: b of type int [mem: Local loc: -6 size: 1] [line: 62]
.   .   .   .   Sibling: 3  Assign: = of type int [line: 63]					   |	.   .   .   .   Sibling: 3  Assign: := of type int [line: 63]
.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 63]			.   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 63]
.   .   .   .   .   Child: 1  Op: + of type int [line: 63]						.   .   .   .   .   Child: 1  Op: + of type int [line: 63]
.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 63]		.   .   .   .   .   .   Child: 0  Id: a of type int [mem: Local loc: -5 size: 1] [line: 63]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 63]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 63]
.   .   .   .   Sibling: 4  Assign: = of type int [line: 64]					   |	.   .   .   .   Sibling: 4  Assign: := of type int [line: 64]
.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 64]			.   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 64]
.   .   .   .   .   Child: 1  Op: + of type int [line: 64]						.   .   .   .   .   Child: 1  Op: + of type int [line: 64]
.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 64]		.   .   .   .   .   .   Child: 0  Id: b of type int [mem: Local loc: -6 size: 1] [line: 64]
.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 64]					.   .   .   .   .   .   Child: 1  Const 1 of type int [line: 64]
Sibling: 4  Func: div returns type void [mem: Global loc: 0 size: -4] [line: 68]		   |	Sibling: 11  Func: div returns type void [mem: Global loc: 0 size: -4] [line: 68]
.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 68]			.   Child: 0  Parm: f of array of type int [mem: Parameter loc: -2 size: 1] [line: 68]
.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 68]			.   Sibling: 1  Parm: size of type int [mem: Parameter loc: -3 size: 1] [line: 68]
.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 69]						.   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 69]
.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 70]				.   .   Child: 0  Var: i of type int [mem: Local loc: -4 size: 1] [line: 70]
.   .   Child: 1  Assign: = of type int [line: 72]						   |	.   .   Child: 1  Assign: := of type int [line: 72]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 72]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 72]
.   .   .   Child: 1  Const 0 of type int [line: 72]							.   .   .   Child: 1  Const 0 of type int [line: 72]
.   .   Sibling: 1  While [line: 73]									.   .   Sibling: 1  While [line: 73]
.   .   .   Child: 0  Op: < of type bool [line: 73]							.   .   .   Child: 0  Op: < of type bool [line: 73]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 73]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 73]
.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 73]		.   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 73]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 73]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -5] [line: 73]
.   .   .   .   Child: 1  Assign: = of type int [line: 74]					   |	.   .   .   .   Child: 1  Assign: := of type int [line: 74]
.   .   .   .   .   Child: 0  Op: [ of type int [line: 74]						.   .   .   .   .   Child: 0  Op: [ of type int [line: 74]
.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l	.   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1] [l
.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 74]		.   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 74]
.   .   .   .   .   Child: 1  Op: / of type int [line: 74]						.   .   .   .   .   Child: 1  Op: / of type int [line: 74]
.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 74]						.   .   .   .   .   .   Child: 0  Op: [ of type int [line: 74]
.   .   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1	.   .   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Parameter loc: -2 size: 1
.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 74]		.   .   .   .   .   .   .   Child: 1  Id: i of type int [mem: Local loc: -4 size: 1] [line: 74]
.   .   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 7	.   .   .   .   .   .   Child: 1  Id: size of type int [mem: Parameter loc: -3 size: 1] [line: 7
.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 75]						.   .   .   .   Sibling: 1  Assign: ++ of type int [line: 75]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 75]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -4 size: 1] [line: 75]
Sibling: 5  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 79]		   |	Sibling: 12  Func: main returns type int [mem: Global loc: 0 size: -2] [line: 79]
.   Child: 1  Compound [mem: None loc: 0 size: -262] [line: 80]						.   Child: 1  Compound [mem: None loc: 0 size: -262] [line: 80]
.   .   Child: 0  Var: f of array of type int [mem: Local loc: -3 size: 257] [line: 81]			.   .   Child: 0  Var: f of array of type int [mem: Local loc: -3 size: 257] [line: 81]
.   .   Sibling: 1  Var: size of type int [mem: Local loc: -259 size: 1] [line: 83]			.   .   Sibling: 1  Var: size of type int [mem: Local loc: -259 size: 1] [line: 83]
.   .   Sibling: 2  Var: numbits of type int [mem: Local loc: -260 size: 1] [line: 84]			.   .   Sibling: 2  Var: numbits of type int [mem: Local loc: -260 size: 1] [line: 84]
.   .   Sibling: 3  Var: half of type int [mem: Local loc: -261 size: 1] [line: 85]			.   .   Sibling: 3  Var: half of type int [mem: Local loc: -261 size: 1] [line: 85]
.   .   Child: 1  While [line: 87]									.   .   Child: 1  While [line: 87]
.   .   .   Child: 0  Const true of type bool [line: 87]						.   .   .   Child: 0  Const true of type bool [line: 87]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -262] [line: 87]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -262] [line: 87]
.   .   .   .   Child: 1  If [line: 88]									.   .   .   .   Child: 1  If [line: 88]
.   .   .   .   .   Child: 0  Op: == of type bool [line: 88]					   |	.   .   .   .   .   Child: 0  Op: = of type bool [line: 88]
.   .   .   .   .   .   Child: 0  Assign: = of type int [line: 88]				   |	.   .   .   .   .   .   Child: 0  Assign: := of type int [line: 88]
.   .   .   .   .   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -260 size: 1] [li	.   .   .   .   .   .   .   Child: 0  Id: numbits of type int [mem: Local loc: -260 size: 1] [li
.   .   .   .   .   .   .   Child: 1  Call: getFunc of type int [line: 88]				.   .   .   .   .   .   .   Child: 1  Call: getFunc of type int [line: 88]
.   .   .   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 2	.   .   .   .   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 2
.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 88]					.   .   .   .   .   .   Child: 1  Const 0 of type int [line: 88]
.   .   .   .   .   Child: 1  Return [line: 88]								.   .   .   .   .   Child: 1  Return [line: 88]
.   .   .   .   .   .   Child: 0  Const 0 of type int [line: 88]					.   .   .   .   .   .   Child: 0  Const 0 of type int [line: 88]
.   .   .   .   Sibling: 1  Assign: = of type int [line: 89]					   |	.   .   .   .   Sibling: 1  Assign: := of type int [line: 89]
.   .   .   .   .   Child: 0  Id: size of type int [mem: Local loc: -259 size: 1] [line: 89]		.   .   .   .   .   Child: 0  Id: size of type int [mem: Local loc: -259 size: 1] [line: 89]
.   .   .   .   .   Child: 1  Call: pow of type int [line: 89]						.   .   .   .   .   Child: 1  Call: pow of type int [line: 89]
.   .   .   .   .   .   Child: 0  Const 2 of type int [line: 89]					.   .   .   .   .   .   Child: 0  Const 2 of type int [line: 89]
.   .   .   .   .   .   Sibling: 1  Id: numbits of type int [mem: Local loc: -260 size: 1] [line	.   .   .   .   .   .   Sibling: 1  Id: numbits of type int [mem: Local loc: -260 size: 1] [line
.   .   .   .   Sibling: 2  Assign: = of type int [line: 90]					   |	.   .   .   .   Sibling: 2  Assign: := of type int [line: 90]
.   .   .   .   .   Child: 0  Id: half of type int [mem: Local loc: -261 size: 1] [line: 90]		.   .   .   .   .   Child: 0  Id: half of type int [mem: Local loc: -261 size: 1] [line: 90]
.   .   .   .   .   Child: 1  Op: / of type int [line: 90]						.   .   .   .   .   Child: 1  Op: / of type int [line: 90]
.   .   .   .   .   .   Child: 0  Id: size of type int [mem: Local loc: -259 size: 1] [line: 90]	.   .   .   .   .   .   Child: 0  Id: size of type int [mem: Local loc: -259 size: 1] [line: 90]
.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 90]					.   .   .   .   .   .   Child: 1  Const 2 of type int [line: 90]
.   .   .   .   Sibling: 3  Call: fwt of type void [line: 92]						.   .   .   .   Sibling: 3  Call: fwt of type void [line: 92]
.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9	.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9
.   .   .   .   .   Sibling: 1  Const 0 of type int [line: 92]						.   .   .   .   .   Sibling: 1  Const 0 of type int [line: 92]
.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Local loc: -259 size: 1] [line: 92]		.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Local loc: -259 size: 1] [line: 92]
.   .   .   .   Sibling: 4  Call: printFunc of type void [line: 93]					.   .   .   .   Sibling: 4  Call: printFunc of type void [line: 93]
.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9	.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9
.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 93]		.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 93]
.   .   .   .   Sibling: 5  Call: fwt of type void [line: 95]						.   .   .   .   Sibling: 5  Call: fwt of type void [line: 95]
.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9	.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9
.   .   .   .   .   Sibling: 1  Const 0 of type int [line: 95]						.   .   .   .   .   Sibling: 1  Const 0 of type int [line: 95]
.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Local loc: -259 size: 1] [line: 95]		.   .   .   .   .   Sibling: 2  Id: size of type int [mem: Local loc: -259 size: 1] [line: 95]
.   .   .   .   Sibling: 6  Call: div of type void [line: 96]						.   .   .   .   Sibling: 6  Call: div of type void [line: 96]
.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9	.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9
.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 96]		.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 96]
.   .   .   .   Sibling: 7  Call: printFunc of type void [line: 97]					.   .   .   .   Sibling: 7  Call: printFunc of type void [line: 97]
.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9	.   .   .   .   .   Child: 0  Id: f of array of type int [mem: Local loc: -3 size: 257] [line: 9
.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 97]		.   .   .   .   .   Sibling: 1  Id: size of type int [mem: Local loc: -259 size: 1] [line: 97]
.   .   Sibling: 1  Return [line: 99]									.   .   Sibling: 1  Return [line: 99]
.   .   .   Child: 0  Const 0 of type int [line: 99]							.   .   .   Child: 0  Const 0 of type int [line: 99]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 1											Number of warnings: 1
Number of errors: 0											Number of errors: 0
walsh.out ztmp23114.txt differ: byte 64, line 2
walsh (Output DIFF)
WARNING(88): Variable 'f' may be uninitialized when used here.						WARNING(88): Variable 'f' may be uninitialized when used here.
Number of warnings: 1										   |	Loading file: BroadTests/walsh.tm
Number of errors: 0										   |	entered: 4
------------------------------------								   |	entered: 1
Loading file: walsh.tm										   |	entered: 4
ERROR: TM Command 4 unknown.									   |	entered: 9
ERROR: TM Command 1 unknown.									   |	entered: 16
ERROR: TM Command 4 unknown.									   |	entered: 25
ERROR: TM Command 9 unknown.									   |	entered: 36
ERROR: TM Command 1 unknown.									   |	entered: 49
ERROR: TM Command 2 unknown.									   |	entered: 64
ERROR: TM Command 3 unknown.									   |	entered: 81
ERROR: TM Command 4 unknown.									   |	entered: 100
ERROR: TM Command 6 unknown.									   |	entered: 121
ERROR: TM Command 8 unknown.									   |	entered: 144
ERROR: TM Command 1 unknown.									   |	entered: 169
ERROR: TM Command 1 unknown.									   |	entered: 196
ERROR: TM Command 1 unknown.									   |	entered: 225
ERROR: TM Command 1 unknown.									   |	entered: 256
ERROR: TM Command 1 unknown.									   |	1496 -136 -272 16 -544 32 64 0 -1088 64 128 0 256 0 0 0
ERROR: TM Command 2 unknown.									   |	1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256
ERROR: TM Command 2 unknown.									   |	entered: 3
ERROR: TM Command 3 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 16
ERROR: TM Command 1 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	entered: 0
ERROR: TM Command 0 unknown.									   |	16 -16 16 -16 16 -16 16 -16
ERROR: TM Command 0 unknown.									   |	0 16 0 0 0 0 0 0
												   >	entered: 0
Bye.													Bye.
====================================
FILE: while.c-
-rw-------. 1 corg7983 domain_users  144 Nov 17 15:35 while.c-
-rw-------. 1 corg7983 domain_users  146 Nov 17 15:35 while.c-.f21
-rw-------. 1 corg7983 domain_users  144 Nov 17 15:35 while.c-.f22
-rw-------. 1 corg7983 domain_users   63 Nov 17 15:35 while.expected
-rw-------. 1 corg7983 domain_users 1823 Nov 22 12:27 while.mem
-rw-------. 1 corg7983 domain_users  240 Nov 17 15:35 while.mem.diffs
-rw-------. 1 corg7983 domain_users 2666 Nov 17 15:35 while.mem.f21
-rw-------. 1 corg7983 domain_users  107 Nov 22 12:27 while.out
-rw-------. 1 corg7983 domain_users    0 Nov 22 12:27 while.tm
-rw-------. 1 corg7983 domain_users  145 Nov 17 15:35 while.tm.diffs
-rw-------. 1 corg7983 domain_users 5332 Nov 17 15:35 while.tm.f21
TM CODE COMPARISON
while (tm code DIFF)
												   >	* C- compiler version C-S21
												   >	* Built: Apr 18, 2021 (toffset telemetry)
												   >	* Author: Robert B. Heckendorn
												   >	* File compiled:  while.c-
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION input
												   >	  1:     ST  3,-1(1)	Store return address 
												   >	  2:     IN  2,2,2	Grab int input 
												   >	  3:     LD  3,-1(1)	Load return address 
												   >	  4:     LD  1,0(1)	Adjust fp 
												   >	  5:    JMP  7,0(3)	Return 
												   >	* END FUNCTION input
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION output
												   >	  6:     ST  3,-1(1)	Store return address 
												   >	  7:     LD  3,-2(1)	Load parameter 
												   >	  8:    OUT  3,3,3	Output integer 
												   >	  9:     LD  3,-1(1)	Load return address 
												   >	 10:     LD  1,0(1)	Adjust fp 
												   >	 11:    JMP  7,0(3)	Return 
												   >	* END FUNCTION output
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputb
												   >	 12:     ST  3,-1(1)	Store return address 
												   >	 13:    INB  2,2,2	Grab bool input 
												   >	 14:     LD  3,-1(1)	Load return address 
												   >	 15:     LD  1,0(1)	Adjust fp 
												   >	 16:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputb
												   >	 17:     ST  3,-1(1)	Store return address 
												   >	 18:     LD  3,-2(1)	Load parameter 
												   >	 19:   OUTB  3,3,3	Output bool 
												   >	 20:     LD  3,-1(1)	Load return address 
												   >	 21:     LD  1,0(1)	Adjust fp 
												   >	 22:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputb
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION inputc
												   >	 23:     ST  3,-1(1)	Store return address 
												   >	 24:    INC  2,2,2	Grab char input 
												   >	 25:     LD  3,-1(1)	Load return address 
												   >	 26:     LD  1,0(1)	Adjust fp 
												   >	 27:    JMP  7,0(3)	Return 
												   >	* END FUNCTION inputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outputc
												   >	 28:     ST  3,-1(1)	Store return address 
												   >	 29:     LD  3,-2(1)	Load parameter 
												   >	 30:   OUTC  3,3,3	Output char 
												   >	 31:     LD  3,-1(1)	Load return address 
												   >	 32:     LD  1,0(1)	Adjust fp 
												   >	 33:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outputc
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION outnl
												   >	 34:     ST  3,-1(1)	Store return address 
												   >	 35:  OUTNL  3,3,3	Output a newline 
												   >	 36:     LD  3,-1(1)	Load return address 
												   >	 37:     LD  1,0(1)	Adjust fp 
												   >	 38:    JMP  7,0(3)	Return 
												   >	* END FUNCTION outnl
												   >	* 
												   >	* ** ** ** ** ** ** ** ** ** ** ** **
												   >	* FUNCTION main
												   >	* TOFF set: -2
												   >	 39:     ST  3,-1(1)	Store return address 
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	 40:    LDC  3,10(6)	Load integer constant 
												   >	 41:     ST  3,-2(1)	Store variable i
												   >	* WHILE
												   >	 42:     LD  3,-2(1)	Load variable i
												   >	 43:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 44:    LDC  3,0(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 45:     LD  4,-3(1)	Pop left into ac1 
												   >	 46:    TGT  3,4,3	Op > 
												   >	 47:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* COMPOUND
												   >	* TOFF set: -3
												   >	* Compound Body
												   >	* EXPRESSION
												   >	* CALL output
												   >	 49:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 50:     LD  3,-2(1)	Load variable i
												   >	 51:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 52:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 53:    LDA  3,1(7)	Return address in ac 
												   >	 54:    JMP  7,-49(7)	CALL output
												   >	 55:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* EXPRESSION
												   >	 56:     LD  3,-2(1)	load lhs variable i
												   >	 57:    LDA  3,-1(3)	decrement value of i
												   >	 58:     ST  3,-2(1)	Store variable i
												   >	* TOFF set: -3
												   >	* END COMPOUND
												   >	 59:    JMP  7,-18(7)	go to beginning of loop 
												   >	 48:    JMP  7,11(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL outnl
												   >	 60:     ST  1,-3(1)	Store fp in ghost frame for outnl
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param end outnl
												   >	 61:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 62:    LDA  3,1(7)	Return address in ac 
												   >	 63:    JMP  7,-30(7)	CALL outnl
												   >	 64:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end outnl
												   >	* TOFF set: -3
												   >	* WHILE
												   >	 65:     LD  3,-2(1)	Load variable i
												   >	 66:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 67:    LDC  3,10(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 68:     LD  4,-3(1)	Pop left into ac1 
												   >	 69:    TLT  3,4,3	Op < 
												   >	 70:    JNZ  3,1(7)	Jump to while part 
												   >	* DO
												   >	* EXPRESSION
												   >	 72:     LD  3,-2(1)	Load variable i
												   >	 73:     ST  3,-3(1)	Push left side 
												   >	* TOFF dec: -4
												   >	 74:    LDC  3,1(6)	Load integer constant 
												   >	* TOFF inc: -3
												   >	 75:     LD  4,-3(1)	Pop left into ac1 
												   >	 76:    ADD  3,4,3	Op + 
												   >	 77:     ST  3,-2(1)	Store variable i
												   >	 78:    JMP  7,-14(7)	go to beginning of loop 
												   >	 71:    JMP  7,7(7)	Jump past loop [backpatch] 
												   >	* END WHILE
												   >	* EXPRESSION
												   >	* CALL output
												   >	 79:     ST  1,-3(1)	Store fp in ghost frame for output
												   >	* TOFF dec: -4
												   >	* TOFF dec: -5
												   >	* Param 1
												   >	 80:     LD  3,-2(1)	Load variable i
												   >	 81:     ST  3,-5(1)	Push parameter 
												   >	* TOFF dec: -6
												   >	* Param end output
												   >	 82:    LDA  1,-3(1)	Ghost frame becomes new active frame 
												   >	 83:    LDA  3,1(7)	Return address in ac 
												   >	 84:    JMP  7,-79(7)	CALL output
												   >	 85:    LDA  3,0(2)	Save the result in ac 
												   >	* Call end output
												   >	* TOFF set: -3
												   >	* TOFF set: -2
												   >	* END COMPOUND
												   >	* Add standard closing in case there is no return statement
												   >	 86:    LDC  2,0(6)	Set return value to 0 
												   >	 87:     LD  3,-1(1)	Load return address 
												   >	 88:     LD  1,0(1)	Adjust fp 
												   >	 89:    JMP  7,0(3)	Return 
												   >	* END FUNCTION main
												   >	  0:    JMP  7,89(7)	Jump to init [backpatch] 
												   >	* INIT
												   >	 90:    LDA  1,0(0)	set first frame at end of globals 
												   >	 91:     ST  1,0(1)	store old fp (point to self) 
												   >	* INIT GLOBALS AND STATICS
												   >	* END INIT GLOBALS AND STATICS
												   >	 92:    LDA  3,1(7)	Return address in ac 
												   >	 93:    JMP  7,-55(7)	Jump to main 
												   >	 94:   HALT  0,0,0	DONE! 
												   >	* END INIT
MEM COMPARISON
while.mem while.mem.f21 differ: byte 7, line 1
while (MEM DIFF)
Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]				   |	Func: input returns type int [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 1  Func: output returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type int [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 2  Func: inputb returns type bool [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 3  Func: outputb returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type bool [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 4  Func: inputc returns type char [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 5  Func: outputc returns type void [mem: Global loc: 0 size: -3] [line: -1]
												   >	.   Child: 0  Parm: *dummy* of type char [mem: Parameter loc: -2 size: 1] [line: -1]
												   >	Sibling: 6  Func: outnl returns type void [mem: Global loc: 0 size: -2] [line: -1]
												   >	Sibling: 7  Func: main returns type void [mem: Global loc: 0 size: -2] [line: 1]
.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]						.   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 2]
.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]				.   .   Child: 0  Var: i of type int [mem: Local loc: -2 size: 1] [line: 3]
.   .   Child: 1  Assign: = of type int [line: 5]						   |	.   .   Child: 1  Assign: := of type int [line: 5]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 5]
.   .   .   Child: 1  Const 10 of type int [line: 5]							.   .   .   Child: 1  Const 10 of type int [line: 5]
.   .   Sibling: 1  While [line: 6]									.   .   Sibling: 1  While [line: 6]
.   .   .   Child: 0  Op: > of type bool [line: 6]							.   .   .   Child: 0  Op: > of type bool [line: 6]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 6]
.   .   .   .   Child: 1  Const 0 of type int [line: 6]							.   .   .   .   Child: 1  Const 0 of type int [line: 6]
.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 6]					.   .   .   Child: 1  Compound [mem: None loc: 0 size: -3] [line: 6]
.   .   .   .   Child: 1  Call: output of type void [line: 7]						.   .   .   .   Child: 1  Call: output of type void [line: 7]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 7]
.   .   .   .   Sibling: 1  Assign: -- of type int [line: 8]						.   .   .   .   Sibling: 1  Assign: -- of type int [line: 8]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 8]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 8]
.   .   Sibling: 2  Call: outnl of type void [line: 10]							.   .   Sibling: 2  Call: outnl of type void [line: 10]
.   .   Sibling: 3  While [line: 12]									.   .   Sibling: 3  While [line: 12]
.   .   .   Child: 0  Op: < of type bool [line: 12]							.   .   .   Child: 0  Op: < of type bool [line: 12]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   .   Child: 1  Const 10 of type int [line: 12]						.   .   .   .   Child: 1  Const 10 of type int [line: 12]
.   .   .   Child: 1  Assign: = of type int [line: 12]						   |	.   .   .   Child: 1  Assign: := of type int [line: 12]
.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]			.   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   .   Child: 1  Op: + of type int [line: 12]							.   .   .   .   Child: 1  Op: + of type int [line: 12]
.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]			.   .   .   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 12]
.   .   .   .   .   Child: 1  Const 1 of type int [line: 12]						.   .   .   .   .   Child: 1  Const 1 of type int [line: 12]
.   .   Sibling: 4  Call: output of type void [line: 13]						.   .   Sibling: 4  Call: output of type void [line: 13]
.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 13]				.   .   .   Child: 0  Id: i of type int [mem: Local loc: -2 size: 1] [line: 13]
Offset for end of global space: 0									Offset for end of global space: 0
Number of warnings: 0											Number of warnings: 0
Number of errors: 0											Number of errors: 0
while.out ztmp23114.txt differ: byte 1, line 1
while (Output DIFF)
Number of warnings: 0										   |	Loading file: BroadTests/while.tm
Number of errors: 0										   |	10 9 8 7 6 5 4 3 2 1
------------------------------------								   |	10
Loading file: while.tm										   <
Bye.													Bye.
